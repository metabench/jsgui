(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){

},{}],2:[function(require,module,exports){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('is-array')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50
Buffer.poolSize = 8192 // not used by this implementation

var kMaxLength = 0x3fffffff
var rootParent = {}

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Note:
 *
 * - Implementation must support adding new properties to `Uint8Array` instances.
 *   Firefox 4-29 lacked support, fixed in Firefox 30+.
 *   See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *  - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *  - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *    incorrect length in some situations.
 *
 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they will
 * get the Object implementation, which is slower but will work correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = (function () {
  try {
    var buf = new ArrayBuffer(0)
    var arr = new Uint8Array(buf)
    arr.foo = function () { return 42 }
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        new Uint8Array(1).subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
})()

/**
 * Class: Buffer
 * =============
 *
 * The Buffer constructor returns instances of `Uint8Array` that are augmented
 * with function properties for all the node `Buffer` API functions. We use
 * `Uint8Array` so that square bracket notation works as expected -- it returns
 * a single octet.
 *
 * By augmenting the instances, we can avoid modifying the `Uint8Array`
 * prototype.
 */
function Buffer (subject, encoding, noZero) {
  if (!(this instanceof Buffer))
    return new Buffer(subject, encoding, noZero)

  var type = typeof subject

  // Find the length
  var length
  if (type === 'number') {
    length = +subject
  } else if (type === 'string') {
    length = Buffer.byteLength(subject, encoding)
  } else if (type === 'object' && subject !== null) { // assume object is array-like
    if (subject.type === 'Buffer' && isArray(subject.data))
      subject = subject.data
    length = +subject.length
  } else {
    throw new TypeError('must start with number, buffer, array or string')
  }

  if (length > kMaxLength)
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
      'size: 0x' + kMaxLength.toString(16) + ' bytes')

  if (length < 0)
    length = 0
  else
    length >>>= 0 // Coerce to uint32.

  var self = this
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Preferred: Return an augmented `Uint8Array` instance for best performance
    /*eslint-disable consistent-this */
    self = Buffer._augment(new Uint8Array(length))
    /*eslint-enable consistent-this */
  } else {
    // Fallback: Return THIS instance of Buffer (created by `new`)
    self.length = length
    self._isBuffer = true
  }

  var i
  if (Buffer.TYPED_ARRAY_SUPPORT && typeof subject.byteLength === 'number') {
    // Speed optimization -- use set if we're copying from a typed array
    self._set(subject)
  } else if (isArrayish(subject)) {
    // Treat array-ish objects as a byte array
    if (Buffer.isBuffer(subject)) {
      for (i = 0; i < length; i++)
        self[i] = subject.readUInt8(i)
    } else {
      for (i = 0; i < length; i++)
        self[i] = ((subject[i] % 256) + 256) % 256
    }
  } else if (type === 'string') {
    self.write(subject, 0, encoding)
  } else if (type === 'number' && !Buffer.TYPED_ARRAY_SUPPORT && !noZero) {
    for (i = 0; i < length; i++) {
      self[i] = 0
    }
  }

  if (length > 0 && length <= Buffer.poolSize)
    self.parent = rootParent

  return self
}

function SlowBuffer (subject, encoding, noZero) {
  if (!(this instanceof SlowBuffer))
    return new SlowBuffer(subject, encoding, noZero)

  var buf = new Buffer(subject, encoding, noZero)
  delete buf.parent
  return buf
}

Buffer.isBuffer = function (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b))
    throw new TypeError('Arguments must be Buffers')

  if (a === b) return 0

  var x = a.length
  var y = b.length
  for (var i = 0, len = Math.min(x, y); i < len && a[i] === b[i]; i++) {}
  if (i !== len) {
    x = a[i]
    y = b[i]
  }
  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'raw':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function (list, totalLength) {
  if (!isArray(list)) throw new TypeError('Usage: Buffer.concat(list[, length])')

  if (list.length === 0) {
    return new Buffer(0)
  } else if (list.length === 1) {
    return list[0]
  }

  var i
  if (totalLength === undefined) {
    totalLength = 0
    for (i = 0; i < list.length; i++) {
      totalLength += list[i].length
    }
  }

  var buf = new Buffer(totalLength)
  var pos = 0
  for (i = 0; i < list.length; i++) {
    var item = list[i]
    item.copy(buf, pos)
    pos += item.length
  }
  return buf
}

Buffer.byteLength = function (str, encoding) {
  var ret
  str = str + ''
  switch (encoding || 'utf8') {
    case 'ascii':
    case 'binary':
    case 'raw':
      ret = str.length
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = str.length * 2
      break
    case 'hex':
      ret = str.length >>> 1
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8ToBytes(str).length
      break
    case 'base64':
      ret = base64ToBytes(str).length
      break
    default:
      ret = str.length
  }
  return ret
}

// pre-set for values that may exist in the future
Buffer.prototype.length = undefined
Buffer.prototype.parent = undefined

// toString(encoding, start=0, end=buffer.length)
Buffer.prototype.toString = function (encoding, start, end) {
  var loweredCase = false

  start = start >>> 0
  end = end === undefined || end === Infinity ? this.length : end >>> 0

  if (!encoding) encoding = 'utf8'
  if (start < 0) start = 0
  if (end > this.length) end = this.length
  if (end <= start) return ''

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'binary':
        return binarySlice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase)
          throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.equals = function (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max)
      str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return 0
  return Buffer.compare(this, b)
}

// `get` will be removed in Node 0.13+
Buffer.prototype.get = function (offset) {
  console.log('.get() is deprecated. Access using array indexes instead.')
  return this.readUInt8(offset)
}

// `set` will be removed in Node 0.13+
Buffer.prototype.set = function (v, offset) {
  console.log('.set() is deprecated. Access using array indexes instead.')
  return this.writeUInt8(v, offset)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new Error('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; i++) {
    var byte = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(byte)) throw new Error('Invalid hex string')
    buf[offset + i] = byte
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  var charsWritten = blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
  return charsWritten
}

function asciiWrite (buf, string, offset, length) {
  var charsWritten = blitBuffer(asciiToBytes(string), buf, offset, length)
  return charsWritten
}

function binaryWrite (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  var charsWritten = blitBuffer(base64ToBytes(string), buf, offset, length)
  return charsWritten
}

function utf16leWrite (buf, string, offset, length) {
  var charsWritten = blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
  return charsWritten
}

Buffer.prototype.write = function (string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length
      length = undefined
    }
  } else {  // legacy
    var swap = encoding
    encoding = offset
    offset = length
    length = swap
  }

  offset = Number(offset) || 0

  if (length < 0 || offset < 0 || offset > this.length)
    throw new RangeError('attempt to write outside buffer bounds')

  var remaining = this.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase()

  var ret
  switch (encoding) {
    case 'hex':
      ret = hexWrite(this, string, offset, length)
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8Write(this, string, offset, length)
      break
    case 'ascii':
      ret = asciiWrite(this, string, offset, length)
      break
    case 'binary':
      ret = binaryWrite(this, string, offset, length)
      break
    case 'base64':
      ret = base64Write(this, string, offset, length)
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = utf16leWrite(this, string, offset, length)
      break
    default:
      throw new TypeError('Unknown encoding: ' + encoding)
  }
  return ret
}

Buffer.prototype.toJSON = function () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  var res = ''
  var tmp = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    if (buf[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i])
      tmp = ''
    } else {
      tmp += '%' + buf[i].toString(16)
    }
  }

  return res + decodeUtf8Char(tmp)
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function binarySlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; i++) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0)
      start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0)
      end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start)
    end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = Buffer._augment(this.subarray(start, end))
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined, true)
    for (var i = 0; i < sliceLen; i++) {
      newBuf[i] = this[i + start]
    }
  }

  if (newBuf.length)
    newBuf.parent = this.parent || this

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0)
    throw new RangeError('offset is not uint')
  if (offset + ext > length)
    throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert)
    checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100))
    val += this[offset + i] * mul

  return val
}

Buffer.prototype.readUIntBE = function (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert)
    checkOffset(offset, byteLength, this.length)

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100))
    val += this[offset + --byteLength] * mul

  return val
}

Buffer.prototype.readUInt8 = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
      ((this[offset + 1] << 16) |
      (this[offset + 2] << 8) |
      this[offset + 3])
}

Buffer.prototype.readIntLE = function (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert)
    checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100))
    val += this[offset + i] * mul
  mul *= 0x80

  if (val >= mul)
    val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert)
    checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100))
    val += this[offset + --i] * mul
  mul *= 0x80

  if (val >= mul)
    val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80))
    return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)

  return (this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16) |
      (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
      (this[offset + 1] << 16) |
      (this[offset + 2] << 8) |
      (this[offset + 3])
}

Buffer.prototype.readFloatLE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('value is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('index out of range')
}

Buffer.prototype.writeUIntLE = function (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert)
    checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100))
    this[offset + i] = (value / mul) >>> 0 & 0xFF

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert)
    checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100))
    this[offset + i] = (value / mul) >>> 0 & 0xFF

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = value
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
  } else objectWriteUInt16(this, value, offset, true)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = value
  } else objectWriteUInt16(this, value, offset, false)
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = value
  } else objectWriteUInt32(this, value, offset, true)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = value
  } else objectWriteUInt32(this, value, offset, false)
  return offset + 4
}

Buffer.prototype.writeIntLE = function (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkInt(this,
             value,
             offset,
             byteLength,
             Math.pow(2, 8 * byteLength - 1) - 1,
             -Math.pow(2, 8 * byteLength - 1))
  }

  var i = 0
  var mul = 1
  var sub = value < 0 ? 1 : 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100))
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkInt(this,
             value,
             offset,
             byteLength,
             Math.pow(2, 8 * byteLength - 1) - 1,
             -Math.pow(2, 8 * byteLength - 1))
  }

  var i = byteLength - 1
  var mul = 1
  var sub = value < 0 ? 1 : 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100))
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = value
  return offset + 1
}

Buffer.prototype.writeInt16LE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
  } else objectWriteUInt16(this, value, offset, true)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = value
  } else objectWriteUInt16(this, value, offset, false)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else objectWriteUInt32(this, value, offset, true)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = value
  } else objectWriteUInt32(this, value, offset, false)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (value > max || value < min) throw new RangeError('value is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('index out of range')
  if (offset < 0) throw new RangeError('index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert)
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert)
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function (target, target_start, start, end) {
  var self = this // source

  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (target_start >= target.length) target_start = target.length
  if (!target_start) target_start = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || self.length === 0) return 0

  // Fatal error conditions
  if (target_start < 0)
    throw new RangeError('targetStart out of bounds')
  if (start < 0 || start >= self.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length)
    end = this.length
  if (target.length - target_start < end - start)
    end = target.length - target_start + start

  var len = end - start

  if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < len; i++) {
      target[i + target_start] = this[i + start]
    }
  } else {
    target._set(this.subarray(start, start + len), target_start)
  }

  return len
}

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function (value, start, end) {
  if (!value) value = 0
  if (!start) start = 0
  if (!end) end = this.length

  if (end < start) throw new RangeError('end < start')

  // Fill 0 bytes; we're done
  if (end === start) return
  if (this.length === 0) return

  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')
  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')

  var i
  if (typeof value === 'number') {
    for (i = start; i < end; i++) {
      this[i] = value
    }
  } else {
    var bytes = utf8ToBytes(value.toString())
    var len = bytes.length
    for (i = start; i < end; i++) {
      this[i] = bytes[i % len]
    }
  }

  return this
}

/**
 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
 */
Buffer.prototype.toArrayBuffer = function () {
  if (typeof Uint8Array !== 'undefined') {
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      return (new Buffer(this)).buffer
    } else {
      var buf = new Uint8Array(this.length)
      for (var i = 0, len = buf.length; i < len; i += 1) {
        buf[i] = this[i]
      }
      return buf.buffer
    }
  } else {
    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')
  }
}

// HELPER FUNCTIONS
// ================

var BP = Buffer.prototype

/**
 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
 */
Buffer._augment = function (arr) {
  arr.constructor = Buffer
  arr._isBuffer = true

  // save reference to original Uint8Array get/set methods before overwriting
  arr._get = arr.get
  arr._set = arr.set

  // deprecated, will be removed in node 0.13+
  arr.get = BP.get
  arr.set = BP.set

  arr.write = BP.write
  arr.toString = BP.toString
  arr.toLocaleString = BP.toString
  arr.toJSON = BP.toJSON
  arr.equals = BP.equals
  arr.compare = BP.compare
  arr.copy = BP.copy
  arr.slice = BP.slice
  arr.readUIntLE = BP.readUIntLE
  arr.readUIntBE = BP.readUIntBE
  arr.readUInt8 = BP.readUInt8
  arr.readUInt16LE = BP.readUInt16LE
  arr.readUInt16BE = BP.readUInt16BE
  arr.readUInt32LE = BP.readUInt32LE
  arr.readUInt32BE = BP.readUInt32BE
  arr.readIntLE = BP.readIntLE
  arr.readIntBE = BP.readIntBE
  arr.readInt8 = BP.readInt8
  arr.readInt16LE = BP.readInt16LE
  arr.readInt16BE = BP.readInt16BE
  arr.readInt32LE = BP.readInt32LE
  arr.readInt32BE = BP.readInt32BE
  arr.readFloatLE = BP.readFloatLE
  arr.readFloatBE = BP.readFloatBE
  arr.readDoubleLE = BP.readDoubleLE
  arr.readDoubleBE = BP.readDoubleBE
  arr.writeUInt8 = BP.writeUInt8
  arr.writeUIntLE = BP.writeUIntLE
  arr.writeUIntBE = BP.writeUIntBE
  arr.writeUInt16LE = BP.writeUInt16LE
  arr.writeUInt16BE = BP.writeUInt16BE
  arr.writeUInt32LE = BP.writeUInt32LE
  arr.writeUInt32BE = BP.writeUInt32BE
  arr.writeIntLE = BP.writeIntLE
  arr.writeIntBE = BP.writeIntBE
  arr.writeInt8 = BP.writeInt8
  arr.writeInt16LE = BP.writeInt16LE
  arr.writeInt16BE = BP.writeInt16BE
  arr.writeInt32LE = BP.writeInt32LE
  arr.writeInt32BE = BP.writeInt32BE
  arr.writeFloatLE = BP.writeFloatLE
  arr.writeFloatBE = BP.writeFloatBE
  arr.writeDoubleLE = BP.writeDoubleLE
  arr.writeDoubleBE = BP.writeDoubleBE
  arr.fill = BP.fill
  arr.inspect = BP.inspect
  arr.toArrayBuffer = BP.toArrayBuffer

  return arr
}

var INVALID_BASE64_RE = /[^+\/0-9A-z\-]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function isArrayish (subject) {
  return isArray(subject) || Buffer.isBuffer(subject) ||
      subject && typeof subject === 'object' &&
      typeof subject.length === 'number'
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []
  var i = 0

  for (; i < length; i++) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (leadSurrogate) {
        // 2 leads in a row
        if (codePoint < 0xDC00) {
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          leadSurrogate = codePoint
          continue
        } else {
          // valid surrogate pair
          codePoint = leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00 | 0x10000
          leadSurrogate = null
        }
      } else {
        // no lead yet

        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else {
          // valid lead
          leadSurrogate = codePoint
          continue
        }
      }
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
      leadSurrogate = null
    }

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x200000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; i++) {
    if ((i + offset >= dst.length) || (i >= src.length))
      break
    dst[i + offset] = src[i]
  }
  return i
}

function decodeUtf8Char (str) {
  try {
    return decodeURIComponent(str)
  } catch (err) {
    return String.fromCharCode(0xFFFD) // UTF 8 invalid char
  }
}

},{"base64-js":3,"ieee754":4,"is-array":5}],3:[function(require,module,exports){
var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

;(function (exports) {
	'use strict';

  var Arr = (typeof Uint8Array !== 'undefined')
    ? Uint8Array
    : Array

	var PLUS   = '+'.charCodeAt(0)
	var SLASH  = '/'.charCodeAt(0)
	var NUMBER = '0'.charCodeAt(0)
	var LOWER  = 'a'.charCodeAt(0)
	var UPPER  = 'A'.charCodeAt(0)
	var PLUS_URL_SAFE = '-'.charCodeAt(0)
	var SLASH_URL_SAFE = '_'.charCodeAt(0)

	function decode (elt) {
		var code = elt.charCodeAt(0)
		if (code === PLUS ||
		    code === PLUS_URL_SAFE)
			return 62 // '+'
		if (code === SLASH ||
		    code === SLASH_URL_SAFE)
			return 63 // '/'
		if (code < NUMBER)
			return -1 //no match
		if (code < NUMBER + 10)
			return code - NUMBER + 26 + 26
		if (code < UPPER + 26)
			return code - UPPER
		if (code < LOWER + 26)
			return code - LOWER + 26
	}

	function b64ToByteArray (b64) {
		var i, j, l, tmp, placeHolders, arr

		if (b64.length % 4 > 0) {
			throw new Error('Invalid string. Length must be a multiple of 4')
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		var len = b64.length
		placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

		// base64 is 4/3 + up to two characters of the original data
		arr = new Arr(b64.length * 3 / 4 - placeHolders)

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length

		var L = 0

		function push (v) {
			arr[L++] = v
		}

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
			push((tmp & 0xFF0000) >> 16)
			push((tmp & 0xFF00) >> 8)
			push(tmp & 0xFF)
		}

		if (placeHolders === 2) {
			tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
			push(tmp & 0xFF)
		} else if (placeHolders === 1) {
			tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
			push((tmp >> 8) & 0xFF)
			push(tmp & 0xFF)
		}

		return arr
	}

	function uint8ToBase64 (uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length

		function encode (num) {
			return lookup.charAt(num)
		}

		function tripletToBase64 (num) {
			return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
		}

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
			output += tripletToBase64(temp)
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1]
				output += encode(temp >> 2)
				output += encode((temp << 4) & 0x3F)
				output += '=='
				break
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
				output += encode(temp >> 10)
				output += encode((temp >> 4) & 0x3F)
				output += encode((temp << 2) & 0x3F)
				output += '='
				break
		}

		return output
	}

	exports.toByteArray = b64ToByteArray
	exports.fromByteArray = uint8ToBase64
}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))

},{}],4:[function(require,module,exports){
exports.read = function(buffer, offset, isLE, mLen, nBytes) {
  var e, m,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      nBits = -7,
      i = isLE ? (nBytes - 1) : 0,
      d = isLE ? -1 : 1,
      s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity);
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
      i = isLE ? 0 : (nBytes - 1),
      d = isLE ? 1 : -1,
      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);

  buffer[offset + i - d] |= s * 128;
};

},{}],5:[function(require,module,exports){

/**
 * isArray
 */

var isArray = Array.isArray;

/**
 * toString
 */

var str = Object.prototype.toString;

/**
 * Whether or not the given `val`
 * is an array.
 *
 * example:
 *
 *        isArray([]);
 *        // > true
 *        isArray(arguments);
 *        // > false
 *        isArray('');
 *        // > false
 *
 * @param {mixed} val
 * @return {bool}
 */

module.exports = isArray || function (val) {
  return !! val && '[object Array]' == str.call(val);
};

},{}],6:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      }
      throw TypeError('Uncaught, unspecified "error" event.');
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        len = arguments.length;
        args = new Array(len - 1);
        for (i = 1; i < len; i++)
          args[i - 1] = arguments[i];
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    len = arguments.length;
    args = new Array(len - 1);
    for (i = 1; i < len; i++)
      args[i - 1] = arguments[i];

    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    var m;
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.listenerCount = function(emitter, type) {
  var ret;
  if (!emitter._events || !emitter._events[type])
    ret = 0;
  else if (isFunction(emitter._events[type]))
    ret = 1;
  else
    ret = emitter._events[type].length;
  return ret;
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],7:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],8:[function(require,module,exports){
module.exports = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};

},{}],9:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;

function drainQueue() {
    if (draining) {
        return;
    }
    draining = true;
    var currentQueue;
    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        var i = -1;
        while (++i < len) {
            currentQueue[i]();
        }
        len = queue.length;
    }
    draining = false;
}
process.nextTick = function (fun) {
    queue.push(fun);
    if (!draining) {
        setTimeout(drainQueue, 0);
    }
};

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],10:[function(require,module,exports){
module.exports = require("./lib/_stream_duplex.js")

},{"./lib/_stream_duplex.js":11}],11:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

module.exports = Duplex;

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) keys.push(key);
  return keys;
}
/*</replacement>*/


/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var Readable = require('./_stream_readable');
var Writable = require('./_stream_writable');

util.inherits(Duplex, Readable);

forEach(objectKeys(Writable.prototype), function(method) {
  if (!Duplex.prototype[method])
    Duplex.prototype[method] = Writable.prototype[method];
});

function Duplex(options) {
  if (!(this instanceof Duplex))
    return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false)
    this.readable = false;

  if (options && options.writable === false)
    this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false)
    this.allowHalfOpen = false;

  this.once('end', onend);
}

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended)
    return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  process.nextTick(this.end.bind(this));
}

function forEach (xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

}).call(this,require('_process'))

},{"./_stream_readable":13,"./_stream_writable":15,"_process":9,"core-util-is":16,"inherits":7}],12:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

module.exports = PassThrough;

var Transform = require('./_stream_transform');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough))
    return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function(chunk, encoding, cb) {
  cb(null, chunk);
};

},{"./_stream_transform":14,"core-util-is":16,"inherits":7}],13:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Readable;

/*<replacement>*/
var isArray = require('isarray');
/*</replacement>*/


/*<replacement>*/
var Buffer = require('buffer').Buffer;
/*</replacement>*/

Readable.ReadableState = ReadableState;

var EE = require('events').EventEmitter;

/*<replacement>*/
if (!EE.listenerCount) EE.listenerCount = function(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

var Stream = require('stream');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var StringDecoder;


/*<replacement>*/
var debug = require('util');
if (debug && debug.debuglog) {
  debug = debug.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/


util.inherits(Readable, Stream);

function ReadableState(options, stream) {
  var Duplex = require('./_stream_duplex');

  options = options || {};

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var defaultHwm = options.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;

  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;

  this.buffer = [];
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;


  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (stream instanceof Duplex)
    this.objectMode = this.objectMode || !!options.readableObjectMode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // when piping, we only care about 'readable' events that happen
  // after read()ing all the bytes and not getting any pushback.
  this.ranOut = false;

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder)
      StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  var Duplex = require('./_stream_duplex');

  if (!(this instanceof Readable))
    return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  Stream.call(this);
}

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function(chunk, encoding) {
  var state = this._readableState;

  if (util.isString(chunk) && !state.objectMode) {
    encoding = encoding || state.defaultEncoding;
    if (encoding !== state.encoding) {
      chunk = new Buffer(chunk, encoding);
      encoding = '';
    }
  }

  return readableAddChunk(this, state, chunk, encoding, false);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function(chunk) {
  var state = this._readableState;
  return readableAddChunk(this, state, chunk, '', true);
};

function readableAddChunk(stream, state, chunk, encoding, addToFront) {
  var er = chunkInvalid(state, chunk);
  if (er) {
    stream.emit('error', er);
  } else if (util.isNullOrUndefined(chunk)) {
    state.reading = false;
    if (!state.ended)
      onEofChunk(stream, state);
  } else if (state.objectMode || chunk && chunk.length > 0) {
    if (state.ended && !addToFront) {
      var e = new Error('stream.push() after EOF');
      stream.emit('error', e);
    } else if (state.endEmitted && addToFront) {
      var e = new Error('stream.unshift() after end event');
      stream.emit('error', e);
    } else {
      if (state.decoder && !addToFront && !encoding)
        chunk = state.decoder.write(chunk);

      if (!addToFront)
        state.reading = false;

      // if we want the data now, just emit it.
      if (state.flowing && state.length === 0 && !state.sync) {
        stream.emit('data', chunk);
        stream.read(0);
      } else {
        // update the buffer info.
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);

        if (state.needReadable)
          emitReadable(stream);
      }

      maybeReadMore(stream, state);
    }
  } else if (!addToFront) {
    state.reading = false;
  }

  return needMoreData(state);
}



// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended &&
         (state.needReadable ||
          state.length < state.highWaterMark ||
          state.length === 0);
}

// backwards compatibility.
Readable.prototype.setEncoding = function(enc) {
  if (!StringDecoder)
    StringDecoder = require('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 128MB
var MAX_HWM = 0x800000;
function roundUpToNextPowerOf2(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2
    n--;
    for (var p = 1; p < 32; p <<= 1) n |= n >> p;
    n++;
  }
  return n;
}

function howMuchToRead(n, state) {
  if (state.length === 0 && state.ended)
    return 0;

  if (state.objectMode)
    return n === 0 ? 0 : 1;

  if (isNaN(n) || util.isNull(n)) {
    // only flow one buffer at a time
    if (state.flowing && state.buffer.length)
      return state.buffer[0].length;
    else
      return state.length;
  }

  if (n <= 0)
    return 0;

  // If we're asking for more than the target buffer level,
  // then raise the water mark.  Bump up to the next highest
  // power of 2, to prevent increasing it excessively in tiny
  // amounts.
  if (n > state.highWaterMark)
    state.highWaterMark = roundUpToNextPowerOf2(n);

  // don't have that much.  return null, unless we've ended.
  if (n > state.length) {
    if (!state.ended) {
      state.needReadable = true;
      return 0;
    } else
      return state.length;
  }

  return n;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function(n) {
  debug('read', n);
  var state = this._readableState;
  var nOrig = n;

  if (!util.isNumber(n) || n > 0)
    state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 &&
      state.needReadable &&
      (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended)
      endReadable(this);
    else
      emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0)
      endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  }

  if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0)
      state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
  }

  // If _read pushed data synchronously, then `reading` will be false,
  // and we need to re-evaluate how much data we can return to the user.
  if (doRead && !state.reading)
    n = howMuchToRead(nOrig, state);

  var ret;
  if (n > 0)
    ret = fromList(n, state);
  else
    ret = null;

  if (util.isNull(ret)) {
    state.needReadable = true;
    n = 0;
  }

  state.length -= n;

  // If we have nothing in the buffer, then we want to know
  // as soon as we *do* get something into the buffer.
  if (state.length === 0 && !state.ended)
    state.needReadable = true;

  // If we tried to read() past the EOF, then emit end on the next tick.
  if (nOrig !== n && state.ended && state.length === 0)
    endReadable(this);

  if (!util.isNull(ret))
    this.emit('data', ret);

  return ret;
};

function chunkInvalid(state, chunk) {
  var er = null;
  if (!util.isBuffer(chunk) &&
      !util.isString(chunk) &&
      !util.isNullOrUndefined(chunk) &&
      !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}


function onEofChunk(stream, state) {
  if (state.decoder && !state.ended) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync)
      process.nextTick(function() {
        emitReadable_(stream);
      });
    else
      emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}


// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    process.nextTick(function() {
      maybeReadMore_(stream, state);
    });
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended &&
         state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;
    else
      len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function(n) {
  this.emit('error', new Error('not implemented'));
};

Readable.prototype.pipe = function(dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&
              dest !== process.stdout &&
              dest !== process.stderr;

  var endFn = doEnd ? onend : cleanup;
  if (state.endEmitted)
    process.nextTick(endFn);
  else
    src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable) {
    debug('onunpipe');
    if (readable === src) {
      cleanup();
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', cleanup);
    src.removeListener('data', ondata);

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain &&
        (!dest._writableState || dest._writableState.needDrain))
      ondrain();
  }

  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    var ret = dest.write(chunk);
    if (false === ret) {
      debug('false write response, pause',
            src._readableState.awaitDrain);
      src._readableState.awaitDrain++;
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EE.listenerCount(dest, 'error') === 0)
      dest.emit('error', er);
  }
  // This is a brutally ugly hack to make sure that our error handler
  // is attached before any userland ones.  NEVER DO THIS.
  if (!dest._events || !dest._events.error)
    dest.on('error', onerror);
  else if (isArray(dest._events.error))
    dest._events.error.unshift(onerror);
  else
    dest._events.error = [onerror, dest._events.error];



  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function() {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain)
      state.awaitDrain--;
    if (state.awaitDrain === 0 && EE.listenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}


Readable.prototype.unpipe = function(dest) {
  var state = this._readableState;

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0)
    return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes)
      return this;

    if (!dest)
      dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest)
      dest.emit('unpipe', this);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++)
      dests[i].emit('unpipe', this);
    return this;
  }

  // try to find the right one.
  var i = indexOf(state.pipes, dest);
  if (i === -1)
    return this;

  state.pipes.splice(i, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1)
    state.pipes = state.pipes[0];

  dest.emit('unpipe', this);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function(ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  // If listening to data, and it has not explicitly been paused,
  // then call resume to start the flow of data on the next tick.
  if (ev === 'data' && false !== this._readableState.flowing) {
    this.resume();
  }

  if (ev === 'readable' && this.readable) {
    var state = this._readableState;
    if (!state.readableListening) {
      state.readableListening = true;
      state.emittedReadable = false;
      state.needReadable = true;
      if (!state.reading) {
        var self = this;
        process.nextTick(function() {
          debug('readable nexttick read 0');
          self.read(0);
        });
      } else if (state.length) {
        emitReadable(this, state);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function() {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    if (!state.reading) {
      debug('resume read 0');
      this.read(0);
    }
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    process.nextTick(function() {
      resume_(stream, state);
    });
  }
}

function resume_(stream, state) {
  state.resumeScheduled = false;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading)
    stream.read(0);
}

Readable.prototype.pause = function() {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  if (state.flowing) {
    do {
      var chunk = stream.read();
    } while (null !== chunk && state.flowing);
  }
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function(stream) {
  var state = this._readableState;
  var paused = false;

  var self = this;
  stream.on('end', function() {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length)
        self.push(chunk);
    }

    self.push(null);
  });

  stream.on('data', function(chunk) {
    debug('wrapped data');
    if (state.decoder)
      chunk = state.decoder.write(chunk);
    if (!chunk || !state.objectMode && !chunk.length)
      return;

    var ret = self.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (util.isFunction(stream[i]) && util.isUndefined(this[i])) {
      this[i] = function(method) { return function() {
        return stream[method].apply(stream, arguments);
      }}(i);
    }
  }

  // proxy certain important events.
  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
  forEach(events, function(ev) {
    stream.on(ev, self.emit.bind(self, ev));
  });

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  self._read = function(n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return self;
};



// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
function fromList(n, state) {
  var list = state.buffer;
  var length = state.length;
  var stringMode = !!state.decoder;
  var objectMode = !!state.objectMode;
  var ret;

  // nothing in the list, definitely empty.
  if (list.length === 0)
    return null;

  if (length === 0)
    ret = null;
  else if (objectMode)
    ret = list.shift();
  else if (!n || n >= length) {
    // read it all, truncate the array.
    if (stringMode)
      ret = list.join('');
    else
      ret = Buffer.concat(list, length);
    list.length = 0;
  } else {
    // read just some of it.
    if (n < list[0].length) {
      // just take a part of the first list item.
      // slice is the same for buffers and strings.
      var buf = list[0];
      ret = buf.slice(0, n);
      list[0] = buf.slice(n);
    } else if (n === list[0].length) {
      // first list is a perfect match
      ret = list.shift();
    } else {
      // complex case.
      // we have enough to cover it, but it spans past the first buffer.
      if (stringMode)
        ret = '';
      else
        ret = new Buffer(n);

      var c = 0;
      for (var i = 0, l = list.length; i < l && c < n; i++) {
        var buf = list[0];
        var cpy = Math.min(n - c, buf.length);

        if (stringMode)
          ret += buf.slice(0, cpy);
        else
          buf.copy(ret, c, 0, cpy);

        if (cpy < buf.length)
          list[0] = buf.slice(cpy);
        else
          list.shift();

        c += cpy;
      }
    }
  }

  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0)
    throw new Error('endReadable called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    process.nextTick(function() {
      // Check that we didn't get one last unshift.
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit('end');
      }
    });
  }
}

function forEach (xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

function indexOf (xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}

}).call(this,require('_process'))

},{"./_stream_duplex":11,"_process":9,"buffer":2,"core-util-is":16,"events":6,"inherits":7,"isarray":8,"stream":21,"string_decoder/":22,"util":1}],14:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

module.exports = Transform;

var Duplex = require('./_stream_duplex');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(Transform, Duplex);


function TransformState(options, stream) {
  this.afterTransform = function(er, data) {
    return afterTransform(stream, er, data);
  };

  this.needTransform = false;
  this.transforming = false;
  this.writecb = null;
  this.writechunk = null;
}

function afterTransform(stream, er, data) {
  var ts = stream._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb)
    return stream.emit('error', new Error('no writecb in Transform class'));

  ts.writechunk = null;
  ts.writecb = null;

  if (!util.isNullOrUndefined(data))
    stream.push(data);

  if (cb)
    cb(er);

  var rs = stream._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    stream._read(rs.highWaterMark);
  }
}


function Transform(options) {
  if (!(this instanceof Transform))
    return new Transform(options);

  Duplex.call(this, options);

  this._transformState = new TransformState(options, this);

  // when the writable side finishes, then flush out anything remaining.
  var stream = this;

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  this.once('prefinish', function() {
    if (util.isFunction(this._flush))
      this._flush(function(er) {
        done(stream, er);
      });
    else
      done(stream);
  });
}

Transform.prototype.push = function(chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function(chunk, encoding, cb) {
  throw new Error('not implemented');
};

Transform.prototype._write = function(chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform ||
        rs.needReadable ||
        rs.length < rs.highWaterMark)
      this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function(n) {
  var ts = this._transformState;

  if (!util.isNull(ts.writechunk) && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};


function done(stream, er) {
  if (er)
    return stream.emit('error', er);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  var ws = stream._writableState;
  var ts = stream._transformState;

  if (ws.length)
    throw new Error('calling transform done when ws.length != 0');

  if (ts.transforming)
    throw new Error('calling transform done when still transforming');

  return stream.push(null);
}

},{"./_stream_duplex":11,"core-util-is":16,"inherits":7}],15:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, cb), and it'll handle all
// the drain event emission and buffering.

module.exports = Writable;

/*<replacement>*/
var Buffer = require('buffer').Buffer;
/*</replacement>*/

Writable.WritableState = WritableState;


/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var Stream = require('stream');

util.inherits(Writable, Stream);

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
}

function WritableState(options, stream) {
  var Duplex = require('./_stream_duplex');

  options = options || {};

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var defaultHwm = options.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (stream instanceof Duplex)
    this.objectMode = this.objectMode || !!options.writableObjectMode;

  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;

  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function(er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.buffer = [];

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;
}

function Writable(options) {
  var Duplex = require('./_stream_duplex');

  // Writable ctor is applied to Duplexes, though they're not
  // instanceof Writable, they're instanceof Readable.
  if (!(this instanceof Writable) && !(this instanceof Duplex))
    return new Writable(options);

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function() {
  this.emit('error', new Error('Cannot pipe. Not readable.'));
};


function writeAfterEnd(stream, state, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  process.nextTick(function() {
    cb(er);
  });
}

// If we get something that is not a buffer, string, null, or undefined,
// and we're not in objectMode, then that's an error.
// Otherwise stream chunks are all considered to be of length=1, and the
// watermarks determine how many objects to keep in the buffer, rather than
// how many bytes or characters.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  if (!util.isBuffer(chunk) &&
      !util.isString(chunk) &&
      !util.isNullOrUndefined(chunk) &&
      !state.objectMode) {
    var er = new TypeError('Invalid non-string/buffer chunk');
    stream.emit('error', er);
    process.nextTick(function() {
      cb(er);
    });
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function(chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  if (util.isFunction(encoding)) {
    cb = encoding;
    encoding = null;
  }

  if (util.isBuffer(chunk))
    encoding = 'buffer';
  else if (!encoding)
    encoding = state.defaultEncoding;

  if (!util.isFunction(cb))
    cb = function() {};

  if (state.ended)
    writeAfterEnd(this, state, cb);
  else if (validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function() {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function() {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing &&
        !state.corked &&
        !state.finished &&
        !state.bufferProcessing &&
        state.buffer.length)
      clearBuffer(this, state);
  }
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode &&
      state.decodeStrings !== false &&
      util.isString(chunk)) {
    chunk = new Buffer(chunk, encoding);
  }
  return chunk;
}

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, chunk, encoding, cb) {
  chunk = decodeChunk(state, chunk, encoding);
  if (util.isBuffer(chunk))
    encoding = 'buffer';
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret)
    state.needDrain = true;

  if (state.writing || state.corked)
    state.buffer.push(new WriteReq(chunk, encoding, cb));
  else
    doWrite(stream, state, false, len, chunk, encoding, cb);

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev)
    stream._writev(chunk, state.onwrite);
  else
    stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  if (sync)
    process.nextTick(function() {
      state.pendingcb--;
      cb(er);
    });
  else {
    state.pendingcb--;
    cb(er);
  }

  stream._writableState.errorEmitted = true;
  stream.emit('error', er);
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er)
    onwriteError(stream, state, sync, er, cb);
  else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(stream, state);

    if (!finished &&
        !state.corked &&
        !state.bufferProcessing &&
        state.buffer.length) {
      clearBuffer(stream, state);
    }

    if (sync) {
      process.nextTick(function() {
        afterWrite(stream, state, finished, cb);
      });
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished)
    onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}


// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;

  if (stream._writev && state.buffer.length > 1) {
    // Fast case, write everything using _writev()
    var cbs = [];
    for (var c = 0; c < state.buffer.length; c++)
      cbs.push(state.buffer[c].callback);

    // count the one we are adding, as well.
    // TODO(isaacs) clean this up
    state.pendingcb++;
    doWrite(stream, state, true, state.length, state.buffer, '', function(err) {
      for (var i = 0; i < cbs.length; i++) {
        state.pendingcb--;
        cbs[i](err);
      }
    });

    // Clear buffer
    state.buffer = [];
  } else {
    // Slow case, write chunks one-by-one
    for (var c = 0; c < state.buffer.length; c++) {
      var entry = state.buffer[c];
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);

      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        c++;
        break;
      }
    }

    if (c < state.buffer.length)
      state.buffer = state.buffer.slice(c);
    else
      state.buffer.length = 0;
  }

  state.bufferProcessing = false;
}

Writable.prototype._write = function(chunk, encoding, cb) {
  cb(new Error('not implemented'));

};

Writable.prototype._writev = null;

Writable.prototype.end = function(chunk, encoding, cb) {
  var state = this._writableState;

  if (util.isFunction(chunk)) {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (util.isFunction(encoding)) {
    cb = encoding;
    encoding = null;
  }

  if (!util.isNullOrUndefined(chunk))
    this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished)
    endWritable(this, state, cb);
};


function needFinish(stream, state) {
  return (state.ending &&
          state.length === 0 &&
          !state.finished &&
          !state.writing);
}

function prefinish(stream, state) {
  if (!state.prefinished) {
    state.prefinished = true;
    stream.emit('prefinish');
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(stream, state);
  if (need) {
    if (state.pendingcb === 0) {
      prefinish(stream, state);
      state.finished = true;
      stream.emit('finish');
    } else
      prefinish(stream, state);
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished)
      process.nextTick(cb);
    else
      stream.once('finish', cb);
  }
  state.ended = true;
}

}).call(this,require('_process'))

},{"./_stream_duplex":11,"_process":9,"buffer":2,"core-util-is":16,"inherits":7,"stream":21}],16:[function(require,module,exports){
(function (Buffer){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

function isBuffer(arg) {
  return Buffer.isBuffer(arg);
}
exports.isBuffer = isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}
}).call(this,require("buffer").Buffer)

},{"buffer":2}],17:[function(require,module,exports){
module.exports = require("./lib/_stream_passthrough.js")

},{"./lib/_stream_passthrough.js":12}],18:[function(require,module,exports){
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = require('stream');
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');

},{"./lib/_stream_duplex.js":11,"./lib/_stream_passthrough.js":12,"./lib/_stream_readable.js":13,"./lib/_stream_transform.js":14,"./lib/_stream_writable.js":15,"stream":21}],19:[function(require,module,exports){
module.exports = require("./lib/_stream_transform.js")

},{"./lib/_stream_transform.js":14}],20:[function(require,module,exports){
module.exports = require("./lib/_stream_writable.js")

},{"./lib/_stream_writable.js":15}],21:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = require('events').EventEmitter;
var inherits = require('inherits');

inherits(Stream, EE);
Stream.Readable = require('readable-stream/readable.js');
Stream.Writable = require('readable-stream/writable.js');
Stream.Duplex = require('readable-stream/duplex.js');
Stream.Transform = require('readable-stream/transform.js');
Stream.PassThrough = require('readable-stream/passthrough.js');

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};

},{"events":6,"inherits":7,"readable-stream/duplex.js":10,"readable-stream/passthrough.js":17,"readable-stream/readable.js":18,"readable-stream/transform.js":19,"readable-stream/writable.js":20}],22:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var Buffer = require('buffer').Buffer;

var isBufferEncoding = Buffer.isEncoding
  || function(encoding) {
       switch (encoding && encoding.toLowerCase()) {
         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
         default: return false;
       }
     }


function assertEncoding(encoding) {
  if (encoding && !isBufferEncoding(encoding)) {
    throw new Error('Unknown encoding: ' + encoding);
  }
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters. CESU-8 is handled as part of the UTF-8 encoding.
//
// @TODO Handling all encodings inside a single object makes it very difficult
// to reason about this code, so it should be split up in the future.
// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
// points as used by CESU-8.
var StringDecoder = exports.StringDecoder = function(encoding) {
  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
  assertEncoding(encoding);
  switch (this.encoding) {
    case 'utf8':
      // CESU-8 represents each of Surrogate Pair by 3-bytes
      this.surrogateSize = 3;
      break;
    case 'ucs2':
    case 'utf16le':
      // UTF-16 represents each of Surrogate Pair by 2-bytes
      this.surrogateSize = 2;
      this.detectIncompleteChar = utf16DetectIncompleteChar;
      break;
    case 'base64':
      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
      this.surrogateSize = 3;
      this.detectIncompleteChar = base64DetectIncompleteChar;
      break;
    default:
      this.write = passThroughWrite;
      return;
  }

  // Enough space to store all bytes of a single character. UTF-8 needs 4
  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
  this.charBuffer = new Buffer(6);
  // Number of bytes received for the current incomplete multi-byte character.
  this.charReceived = 0;
  // Number of bytes expected for the current incomplete multi-byte character.
  this.charLength = 0;
};


// write decodes the given buffer and returns it as JS string that is
// guaranteed to not contain any partial multi-byte characters. Any partial
// character found at the end of the buffer is buffered up, and will be
// returned when calling write again with the remaining bytes.
//
// Note: Converting a Buffer containing an orphan surrogate to a String
// currently works, but converting a String to a Buffer (via `new Buffer`, or
// Buffer#write) will replace incomplete surrogates with the unicode
// replacement character. See https://codereview.chromium.org/121173009/ .
StringDecoder.prototype.write = function(buffer) {
  var charStr = '';
  // if our last write ended with an incomplete multibyte character
  while (this.charLength) {
    // determine how many remaining bytes this buffer has to offer for this char
    var available = (buffer.length >= this.charLength - this.charReceived) ?
        this.charLength - this.charReceived :
        buffer.length;

    // add the new bytes to the char buffer
    buffer.copy(this.charBuffer, this.charReceived, 0, available);
    this.charReceived += available;

    if (this.charReceived < this.charLength) {
      // still not enough chars in this buffer? wait for more ...
      return '';
    }

    // remove bytes belonging to the current character from the buffer
    buffer = buffer.slice(available, buffer.length);

    // get the character that was split
    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
    var charCode = charStr.charCodeAt(charStr.length - 1);
    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
      this.charLength += this.surrogateSize;
      charStr = '';
      continue;
    }
    this.charReceived = this.charLength = 0;

    // if there are no more bytes in this buffer, just emit our char
    if (buffer.length === 0) {
      return charStr;
    }
    break;
  }

  // determine and set charLength / charReceived
  this.detectIncompleteChar(buffer);

  var end = buffer.length;
  if (this.charLength) {
    // buffer the incomplete character bytes we got
    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
    end -= this.charReceived;
  }

  charStr += buffer.toString(this.encoding, 0, end);

  var end = charStr.length - 1;
  var charCode = charStr.charCodeAt(end);
  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
    var size = this.surrogateSize;
    this.charLength += size;
    this.charReceived += size;
    this.charBuffer.copy(this.charBuffer, size, 0, size);
    buffer.copy(this.charBuffer, 0, 0, size);
    return charStr.substring(0, end);
  }

  // or just emit the charStr
  return charStr;
};

// detectIncompleteChar determines if there is an incomplete UTF-8 character at
// the end of the given buffer. If so, it sets this.charLength to the byte
// length that character, and sets this.charReceived to the number of bytes
// that are available for this character.
StringDecoder.prototype.detectIncompleteChar = function(buffer) {
  // determine how many bytes we have to check at the end of this buffer
  var i = (buffer.length >= 3) ? 3 : buffer.length;

  // Figure out if one of the last i bytes of our buffer announces an
  // incomplete char.
  for (; i > 0; i--) {
    var c = buffer[buffer.length - i];

    // See http://en.wikipedia.org/wiki/UTF-8#Description

    // 110XXXXX
    if (i == 1 && c >> 5 == 0x06) {
      this.charLength = 2;
      break;
    }

    // 1110XXXX
    if (i <= 2 && c >> 4 == 0x0E) {
      this.charLength = 3;
      break;
    }

    // 11110XXX
    if (i <= 3 && c >> 3 == 0x1E) {
      this.charLength = 4;
      break;
    }
  }
  this.charReceived = i;
};

StringDecoder.prototype.end = function(buffer) {
  var res = '';
  if (buffer && buffer.length)
    res = this.write(buffer);

  if (this.charReceived) {
    var cr = this.charReceived;
    var buf = this.charBuffer;
    var enc = this.encoding;
    res += buf.slice(0, cr).toString(enc);
  }

  return res;
};

function passThroughWrite(buffer) {
  return buffer.toString(this.encoding);
}

function utf16DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 2;
  this.charLength = this.charReceived ? 2 : 0;
}

function base64DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 3;
  this.charLength = this.charReceived ? 3 : 0;
}

},{"buffer":2}],23:[function(require,module,exports){

var jsgui = require('../../../../../js/web/jsgui-html-client');
var Client_Page_Context = require('../../../../../js/web/client-page-context');
//var Toggle_Button = require('../../../../../js/web/controls/advanced/toggle-button');
//var Start_Stop_Toggle_Button = require('../../../../../js/web/controls/advanced/start-stop-toggle-button');

var each = jsgui.each, stringify = jsgui.stringify;

var pc = new Client_Page_Context({
    'document': document
});

//pc.update_Controls('toggle_button', Toggle_Button);
//pc.update_Controls('start_stop_toggle_button', Start_Stop_Toggle_Button);


window.onload = function() {
    console.log('pre activate');

    jsgui.activate(pc);


}

},{"../../../../../js/web/client-page-context":43,"../../../../../js/web/jsgui-html-client":46}],24:[function(require,module,exports){
/*

if (typeof define !== 'function') {
    var define = require('amdefine')(module);
}


define(["./jsgui-lang-essentials", "./jsgui-data-structures", "./data-object", "./constraint"], function(jsgui, Data_Structures, Data_Object, Constraint) {

*/

var jsgui = require('./jsgui-lang-essentials');
var Data_Structures = require('./jsgui-data-structures');
var Data_Object = require('./data-object');
var Constraint = require('./constraint');

	// Collection... use sligntly more than essentials?
	// Likely to use the Data_Object class here.
	
	// Don't want this stuff growing much more in size
	//  There will be more features, should add them sparingly
	//   Maybe a more advanced layer... really for the server side or the most in-depth applications.
	//   Will want some kind of later loading, the later loading system in the core layer.
	
	// Don't think this needs much more code at the moment.
	//  It's got fairly large.
	//  It should be a very useful part of the system.
	
	// Global collection reference...
	//  want it so that a collection can reference another collection, so that every item gets put into this collection
	//   also gets put into the global collection. Will check unique conflicts as well... but the global collection could have different things to index on
	
	// Restricting objects in collection by data type.
	
	// Collection can operate a lot like a normal object anyway now. It can hold objects indexed by name, just like a normal map.
	//  However, the name property is now intrinsic to that object as well as something that gets indexed.
	
	// Need to deal with attached fields, like this:
	// {'attached': {'meta': 'name'}}

	var j = jsgui;
	var Class = j.Class;
	var each = j.each;
	var is_array = j.is_array;
	var is_dom_node = j.is_dom_node;
	var is_ctrl = j.is_ctrl;
	var extend = j.extend;
	var clone = j.clone;
	var x_clones = j.x_clones;
	var get_truth_map_from_arr = j.get_truth_map_from_arr;
	var get_map_from_arr = j.get_map_from_arr;
	var arr_like_to_arr = j.arr_like_to_arr;
	var tof = j.tof;
	var is_defined = j.is_defined;
	var stringify = j.stringify;
	var functional_polymorphism = j.functional_polymorphism;
	var fp = j.fp;
	var arrayify = j.arrayify;
	var mapify = j.mapify;
	var are_equal = j.are_equal;
	var get_item_sig = j.get_item_sig;
	var set_vals = j.set_vals;
	var truth = j.truth;
	var trim_sig_brackets = j.trim_sig_brackets;
	var iterate_ancestor_classes = j.iterate_ancestor_classes;
	var is_constructor_fn = j.is_constructor_fn;
	
	var is_arr_of_strs = j.is_arr_of_strs;
	var is_arr_of_arrs = j.is_arr_of_arrs;
	 
	var Sorted_KVS = Data_Structures.Sorted_KVS;
	var dobj = Data_Object.dobj;
	
	var input_processors = j.input_processors;
	var Data_Value = Data_Object.Data_Value;
	
	
	var constraint_from_obj = Constraint.from_obj;
	var native_constructor_tof = jsgui.native_constructor_tof;
	// Definitiely will help the website to power quite a few things.
	//  Having a really nice website of my own will definitely help.
	
	// Will have examples in different categories, such as data tools
	//  May make some kind of database available and viewable in a read-only form, then this would be usable for queries that are done by the users of my system.
	//  This would be good for demonstrating some front-end visualization code.
	
	// Will be nice to allow users / subscribers to manage some of their own data.
	
	
	// Upgrade to the Data_Object set_field...
	//  Will be able to process array of constructor function, meaning a collection of that type.
	
	var Collection_Index = Class.extend({
		'init' : function(spec) {
			// Could do some initialization here?
			//console.log('init Collection_Index');
			//console.log('spec.fields ' + stringify(spec.fields));
			if (is_defined(spec.fields)) {
				this.fields = spec.fields;
				
				// and if it is an array, save an alphabetically ordered copy.
				
				if (tof(spec.fields) == 'array') {
					// Not sure we can sort object fields by name like this?
					//  It seems to work?

                    // Fields in alphabetic order...
                    //  However, there will be the capability for nested fields, and intrinsic property references.



					this.alphabetic_fields = clone(spec.fields).sort();
				}

				// the fields held by the Collection_Index.
				//  some fields may represent fields on attached items.
				//   looks like there won't be anything to do on this simple field assignment?



				// this index will be quicker for matching.
			}
			
			this.__type = 'collection_index';
			
		},
		'add_object' : function(obj) {
			var tobj = tof(obj);

			//console.log('add_object Collection_Index');
			//console.log('***** tobj ' + tobj);

			if (tobj == 'array') {

				// check that all of the items can be added before adding any of
				// them???
				// or better to add them sequentially, because there could be
				// conflicts within the items themselves.
				// though, could check that first, but makes the code more
				// complex.
				// could do this by creating a parallel index with the same
				// properties, and have that load the data first.
				var that = this;
				each(obj, function(i, v) {
					that.add_object(v);
				});

			} else if (tobj == 'data_object') {
				//console.log('adding data_object');

				// chack if we can add it.

				//if (this.can_add_object(obj)) {
				// not doing uniqueness checking here.
				
					this.unsafe_add_object(obj);
				//}

				// then need to add the thing!

			}

		}

	// add_object
	// remove_object
	// iterate through objects...
	// default could be an array?
	// ?? get_object(key)

	// Index the whole collection... used when the index is created.

	// get_object(key, key)
	// get_object([keys])

	});

	// Ordered_Dict?

	var BPD_Collection_Index = Collection_Index.extend({
		'init' : function(spec) {
			// indexed with both the b+ tree and the dict.

		}
	})

	// Ordered collection index

	// Dict collection index

	// Ordered_Dict collection index - has both ordered and dict capabilities.
	// More space required, faster get operations through the dict.

	// Full_Text collection index?
	// This will be the most complicated to do. Would make data structures like
	// the Trie.
	// Could have that pluggable for more advanced data structures.

	// Dict, Ordered, and Full_Text seem like good index types.
	// Not saying how Ordered and Full_Text will be implemented.
	// Is it possible / easy for an index to be both full-text and ordered?

	// Could possibly even rate time complexity for each operation.
	// So program could even determine - we have 30,000 records, better download
	// a more efficient index.

	// Dict as the default index?

	// have dict_index(property_name) function?
	// sets up the index. di(pn, false) could remove it.

	// Seems good to separate these things out a lot.
	// Having it so that the index engines could get upgraded.

	// Would be worth approaching this in a very modular way, so that the data
	// structures could all be tested and optimized separately.
	// Swapped as well, as more advanced ones get written.

	//var index_key_separator = '*.oOo.*';
	
	var index_key_separator = ',';
	//  comma should work OK? Maybe not when reading out the values and knowing what they are from the key,
	//  but should be fine for comparisons and ordering
	
	// The trouble is, this could get written about!
	// Is there a way around using such a separator?
	// Not sure about more dict indexes at each level.
	// May not be a problem because we will be searching in the right indexes
	// anyway.

	// Attached fields... these will get indexed too.
	//  However, we won't have that much of an interface or abstraction for dealing with attached objects.
	//  They are simple object[attachmentName].

	// So in a collection, we want to be able to index attached fields.
	//  When querying them, we need to use a notation that indicated we are querying attached fields.
	//   It seems like they should be in the same index structure though.

	// Perhaps need to extend the indexes a bit to cover attached fields specifically in some places.

	// More thought about attached fields seems important.






	var Ordered_Collection_Index = Collection_Index.extend({
		'init': function(spec) {
			this._super(spec);
			// which field(s) get indexed?
			//this.fields = spec.fields;
			this.index_type = 'ordered';

		}

	// this will probably refer to the B+ implementation. need to wrap it
	// concisely.

	})

	// not so sure about this fn.
	var get_fields_key = function(fields) {
		var tf = tof(fields);
		if (tf == 'array') {
			return fields.join(index_key_separator);
		} else if (tf == 'string') {
			return fields;
		}
	}

    // We maybe need tests to do with adding Data_Objects to Collections, and seeing that they are automatically indexed.
    //  Currently having a problem accessing an Abstract Postgres Table through the Collection of tables.

    // Some unit tests to cover similar cases would help.

	var get_obj_fields_key = function(obj, fields) {
        //console.log('');
		//console.log('get_obj_fields_key');

		//var stack = new Error().stack
		//console.log( stack )

        //console.log('get_obj_fields_key obj', obj);
        //console.log('get_obj_fields_key stringify obj', stringify(obj));
        //console.log('tof obj', tof(obj));

		var tFields = tof(fields);

        //console.log('fields ' + stringify(fields));
		//console.log('tFields ' + tFields);

        // An attached field?
        //  So it's one object attached to another.

        //throw 'stop';
		if (tFields == 'string') {
			fields = [fields];
		}
		
		// var first = true;
		var arr_res = [];
		each(fields, function(i, field_definition) {

			// may check if it is a string or can be stringified.
			// maybe should call functions to get a string result too.

			// maybe will look at obj._ for the field value.
			// or use the get function.
			
			//console.log('field_name ' + stringify(field_name));


			var tFieldDef = tof(field_definition);
            //console.log('tFieldDef', tFieldDef);
			
			if (tFieldDef == 'array') {
				

				// gets more complicated with the array.
				//  commas will do fine for now.
				
				//var res = field_name.join(',');
				//console.log('res ' + res);
				//arr_res.push('[' + field_name.join(', ') + ']');
				//return res;
				arr_res.push(stringify(field_definition));
				
			} else if (tFieldDef == 'string') {

				// But for objects, we are getting potentially attached field values.




				//console.log('field_name ' + field_name);
                //console.log('field_definition', field_definition);
				var field_val = obj.get(field_definition);

                // Need to upgrade the object so it looks at intrinsic nested properties.

                //console.log('tof obj', tof(obj));
                //console.log('obj', stringify(obj));
                //console.log('obj', obj);

				//console.log('field_val ' + field_val);
                //console.log('tof field_val ' + tof(field_val));

               // throw 'stop';

                if (field_val) {
                    if (field_val.value) field_val = field_val.value();
                    arr_res.push(field_val);
                }




                //throw 'stop';

			} else if (tFieldDef == 'object') {
				//console.log('have an object fieldName, well its not really a simple field name it seems, could be an attached object\'s field.');

				// the key in the index is the value?
				//  is that what an index is in terms of key and value?

				// need a way of iterating through the attached fields?
				//  or deal with one level of attachment at this time?

                // 17/06/2014 - I'm needing this, and noticing that it's somewhat already been done.



				if (field_definition.attached) {
					// it will only be one attached item.
					var attachedObjName;
					var attachedObjFieldName;
					var c = 0;
					each(field_definition.attached, function(i, v) {
						attachedObjName = i;
						attachedObjFieldName = v;
						c++;
					})
					//console.log('c ' + c);
					if (c != 1) {
						throw 'unexpected number of items in attached definition';
					} else {
						var attachedObj = obj[attachedObjName];
						//console.log('attachedObj ' + stringify(attachedObj));
						var res = attachedObj.get(attachedObjFieldName);
						arr_res.push(res);
					}
				}


				//throw 'stop';

			}
			// object...


			// var field_val = obj[field_name];
		})

        var res = arr_res.join(index_key_separator);
        //console.log('get_obj_fields_key res', res);
		return res;
	}

	// Function to get the first or nth?

	
	
	var Sorted_Collection_Index = Collection_Index.extend({
		'init': function(spec) {
			this._super(spec);
			
			//this.fields = spec.fields;
			
			// the fields, sorted by name alphabetically
			//   could be done by Collection_Index
			this.index_type = 'sorted';
			
			// have something about its implementation?
			// could get that from the Sorted_KVS.
			//  Maybe as a function that applies to the type... getting more info about what underlying data structure it is using and the
			//   efficiency of various operations (high efficiency for sorted indexes)
			
			//this.unique_mode = true;
			
			// Can use the Sorted KVS. The fact it's using a tree is not very relevant here.
			
			this.sorted_kvs = new Sorted_KVS(12);
			
		},
		'each': function(callback) {
			return this.sorted_kvs.each(callback);
		},
		
		// this is not a constraint.
		
		/*
		'can_add_object': function(obj) {
			var fields_key = get_obj_fields_key(obj, this.fields);
			
			var count_with_fields_key = this.sorted_kvs.key_count(fields_key);
			
			// The collection index won't be operating unique mode.
			//  It will be a collection constraint, that makes reference to the index.
			
			// Have done a really large amount on this codebase.
			//  Need to do a fair bit more...
			//  Need to have it fully operating with constraints.
			
			// Then something relatively simple, set up with constraints and maybe some data, could be used to create the populated database
			
			// Quite a bit more to do on the general/back-end code.
			//  Then it won't be so hard to populate a few nice components with some text & images.
			
			
			
			
			
			//if (count_with_fields_key > 0) {
			//	if (this.unique_mode) return false;
				
			//}
			return true;
		},
		*/
		
		'unsafe_add_object': function(obj) {
			
			// if the object is just a string?
			//  object needs to be in a data_object though.
			//  that Data_Object can have a set type.
			//console.log('Sorted_Collection_Index unsafe_add_object');
			//console.log('Sorted_Collection_Index uao obj ' + stringify(obj));
			
			// but do we have the object's position/numerical index within the collection?
			
			// The fields key...
			//  The field's key?

			//console.log('this.fields ' + stringify(this.fields));


			// what is this function?
			//  gets a string
			//  gets the key for the object's values within this index's fields?

			// so that fields key would need to produce a string that allows the fields in the object
			//  to be indexed



			var fields_key = get_obj_fields_key(obj, this.fields);



			//console.log('this.fields ' + stringify(this.fields));
			//console.log('fields_key ' + stringify(fields_key));

			// so, we add it to the index.


			//throw ('5) stop');
			this.sorted_kvs.put(fields_key, obj);
			// so far, so good.

		},
		
		// get for one object?
		//  or find? Want flexibility where possible, so may provide arrays.
		
		'get': fp(function(a, sig) {
			//console.log('Sorted_Collection_Index get');
			// will be providing a key, or part of a key
			//  uses the prefix search.
			//console.log('sig ' + sig);
			
			if (sig == '[s]') {
				var search_term = a[0];
				//console.log('search_term ' + search_term);
				var kvps = this.sorted_kvs.get(search_term);
				//console.log('kvps ' + stringify(kvps));
				return kvps;
			}
			
			if (tof(a[0]) == 'array') {
				//throw ('stopping for array');
				var search_term = a[0].join(',');
				//console.log('search_term ' + search_term);
				//var keys = this.sorted_kvs.keys();
				//console.log('keys ' + stringify(keys));
				var kvps = this.sorted_kvs.get(search_term);
				//console.log('kvps ' + stringify(kvps));
				// should return keys and values
				return kvps;
			}
			
		}),
		'has': fp(function(a, sig) {
			if (sig == '[s]') {
				return (this.sorted_kvs.key_count() > 0);
			}
		}),
		'remove': function(obj) {
			// depends on what type of object the collection is holding too.
			//  When initialized as Collection(String).
			//   Has a collection data type constraint.
			//   The collection will still have items indexed.
			
			// So when a string item is added, it needs to get indexed. I'll trace that.
			
			var fields_key;
			if (tof(obj) == 'string') {
				fields_key = obj;
			} else {
				fields_key = get_obj_fields_key(obj, this.fields);
			}
			this.sorted_kvs.out(fields_key);
		}
		
		// when getting... do we have the fields?
	});
	
	// Map rather than dict?
	var Dict_Collection_Index = Collection_Index.extend({
		'init': function(spec) {
			this._super(spec);
			// which field(s) get indexed?
			//this.fields = spec.fields;
			this.index_type = 'dict';
			// also could do more than one field at once.
			// however, this one is no good for doing a search where the first
			// field in the multi-field index is specified but no others
			this.dict = {};
			// this should assume items are unique for the moment.
			// perhaps the Dict_Collection_Index could operate in unique_mode =
			// false as well.
			this.unique_mode = true;
		},

		'can_add_object' : function(obj) {
			// true / false?
			// won't have the error message.
			// perhaps another function could reveal the problem if asked.
			// this would be used for detecting if an object will be OK in a
			// number of different indexes before adding it to the collection.
			var fields_key = get_obj_fields_key(obj, this.fields);
			// is there already an object there? Different object?
			// same object?

			// Want to raise the right exception.
			var existing_obj = this.dict[fields_key];
			//console.log('existing_obj ' + existing_obj);
			if (is_defined(existing_obj)) {
				if (this.unique_mode === true) {

					// if (is_defined(existing_obj.__id) &&
					// is_defined(obj.__id)) {
					// if (existing_obj.__id === obj.__id) {
					// throw 'The same item (identified by ID) is already in the
					// collection, unique fields clash';
					//		
					// } else {
					// throw 'Unique fields clash';
					// }
					// }
					return false;
				}
			}
			return true;
		},

		'unsafe_add_object' : (function(obj) {

            //console.log('Dict_Collection_Index unsafe_add_object');
			//console.log('DICT unsafe_add_object');
			// it's currently unsafe to stringify some objects.
			//console.log('unsafe_add_object ' + stringify(obj));
			// should have a can_add_object function too,
			// possibly an unsafe_add function that does not do checking.
			// If something can't be added to one index, we don't want it added
			// to any of them.
			var fields_key = get_obj_fields_key(obj, this.fields);
			// won't be (directly) adding array objects to the collection.
			// will be adding collections to collections though.
			// console.log('tof(obj) ' + tof(obj));
			// console.log('Dict_Collection_Index add_object');
			// is this index doing multiple fields?
			// console.log('fields ' + stringify(this.fields));
			// for one field, no separator.
			this.dict[fields_key] = obj;
			// get the fields key from the field values.
			// this.dict[fields_key]

		}),
		'get': fp(function(a, sig) {
			// [s]
			// just one value, searching the index based on that value.
			
			// This one won't have the layer / wrapper for multiple values stored at one key (yet).
			
			// That would be a decent way of doing an index.
			//  The B+ tree would insert the multiple identical keys anyway.
			if (a.l == 1 && tof(a[0]) == 'string') {
				return this.dict[a[0]];
			}
			// array of values - will need to group them together and search the
			// index.
		})

	// some kind of search or retrieval function.
	// 'get' I think for this index.

	})

	// A whole system for collection indexes.
	// Maybe it should be in the collection class?
	// But maybe not if it encapsulates a fair bit of functionality and has a
	// simple enough API.

	// May make sense to keep the indexing system in one place.

	// Ensure there are various indexes...

	// May have both b+ and dict index at once?
	// Combined index? Like the KSVS?
	// Want the indexes to be fast and easy to set up primarily
	// Make it easy to use a b+ tree alongside a dict in indexing.

	// The the specific indexes...

	// Will add objects to them, and be able to do searches / get by key.

	// Want an index that is both b+ and dict.
	// Dict is used for the object retrieval from key
	// The b+ tree is used to ensure the correct order.

	// Collection always has items in an array...?
	// That array implementation could possibly change.
	// However, I think it will be OK for the moment.

	// Add and remove different types of index.
	// Possibly say what sort of index is needed...
	// Then the indexes could have different internal implementations
	//  

	// We may want to expand this in various ways.

	// Has a collection of indexes?
	// With them indexed?
	// In this situation, I think we need to do the indexing within the index
	// system on a lower level... a bit more code.
	// This indexing system will be used in a fair few places.
	// May wish to build on this (maybe separate module)
	// with a disconnected / async index system.
	// can make use of asyncronous data structures. These could be across a
	// network.

	// Collections will have different kinds of constraints to Data_Objects
	//  Though a collection constraint could be that field constraints are required.
	//  Data models defined using this system will then be more easily translated to DB and RDM formats.
	//   Could use these constraints here in JavaScript for checking before putting into an object database
	//   Can also use them in generating the SQL database and its CRUD functions.
	//    Likely to want to continue working on the parser. Being able to parse a variety of languages would prove very useful.
	//     It would also help for them to be integrated with the data model and JavaScript system I am using here.
	//     Being able to graphically illustrate what could go at any point in a document would be very useful...
	//      it would know what the objects are, and help / helpful windows could display information ready to be clicked on or tapped in order
	//      to add that text of function call. Would be nice to have an iPad next to the keyboard to tap things and view info interactively.
	//      Could easily be connected to an address over the LAN, I do think a Local_MB_Node system running in node.js could enhance people's
	//       experience as they use the website. 
	
	// For the moment, the single client is what matters.
	
	// As well as the index system, are the collection_constraints
	// These are different to field_constraints.
	// One collection_constrint will be applying field_constraints
	
	
	// When a collection is given a field constraint, it's a constraint that applies to the fields of all objects in the collection.
	
	// Not a Data_Object?
	//  It would probably be safe to make this a Data_Object.
	//  Making this Index_System use some lower level mechanisms for indexing. The index is not available here, this is used to implement indexing.
	
	// This kind of is the index index. Not so sure about a more complex index index inside this.
	//  Can put a few of the operations in functions to encapsulate index search.
	
	// Maybe don't create the index system if there is nothing to do.

	var Collection_Index_System = Class.extend({
		
		// I am now going to extend this so that it also can use B+ trees.
		//  B+ trees may be advantageous to use in many cases over dicts, but will likely be slower and use more memory, though will
		//  also provide prefix search and ordering functionality in addition to the dict index.
		
		
		'init' : function(spec) {

			// This could keep track of the primary_unique_index for get
			// operations.

			this.collection = spec.collection;

			// This should do a fair few things...
			// A new index can be added

			// New index created? Makes the index go and collect the
			// data by iterating through the array.

			// Will this System class make the CollectionIndexes all
			// work together smoothly in the Collection code?

			// The system will need to keep track of the indexes, kind
			// of provide an index to them.

			// Will this be tasked with carrying out the queries?
			// We have the indexes, we so we have access to the results.

			// The query planner or executer could go in this part.
			// Just need to make it so that collections do get indexed
			// OK, some separation of concerns may help.

			// This could really be in the Collection.

			// Could hook this up to listen for any item being added (or
			// removed) from the collection?
			// Or just have the collection notify it - not sure right
			// now.

			// This could expose an easier API.
			// Could also have a function that gets the index based on
			// which fields, and which index type.

			// Then with everything indexed within this system, it may
			// not be too hard to have this system carry out the
			// searches.

			// However, the searches could get a bit more complex...
			// searching non-indexed data.
			// Or sort, various functions.

			// Perhaps it will just be in the collection...
			// Or there could be an Index_System_Searcher object.
			// That would help encapsulate the functionality, have the
			// code express what it is doing at the same time.
			// So when a search query is given, it is the searcher that
			// queries the index system, finds out what indexes to use,
			// gets those indexes, then prepares the result.
			// It will know what final stages may be necessary to carry
			// out the query specified.

			// this.indexes = [];
			// just stored in an array?

			// or have them in some kind of object matrix?

			// a collection of indexes and then an index of them?

			// a reference to the primary index - the one that is used
			// when processing 'get' requests.

			// index types? dict, ordered_string, full_text?
			// 3 index types with defined capabilities...
			// could put in a full text index, with the full text index
			// API clearly defined.
			// then it would be a job to write some compressed dynamic
			// suffix tree JavaScript code.
			// that data structure would be interesting when run in a
			// distributed fashion, could have it as though very large
			// blocks of memory are available.

			// indexes by field...
			// indexes with multiple fields.

			// field object
			// single index
			// object containing indexes with nested indexes

			// index_map['last_name'].index_map['first_name'].indexes_by_type['dict']
			// one way of being able to get the indexes for a particular
			// field, of a particular type.
			// Think this is an OK way to store a map of the various
			// indexes that are used.
			// What about getting all indexes? Should we store them in
			// an array?
			// Not so sure for the moment, could iterate over these
			// indexes, and add and remove them without too much trouble
			// in this format.

			// get_indexes_by_type_by_fields(arr_field_names)
			// then those indexes are referred to by the type of index
			// (not the data structure used).
			// Though 'dict' works as a hash under the JS dict.

			// may be a little verbose specifying some indexes.
			// however, want a very functional index of indexes.
			// with the possibility of different types of indexes being
			// used.
			// being able to run relatively simple dict indexes on
			// collections for 'get' operations seems like a good plan.
			// have that within a flexible system that allows different
			// index types.

			// has a dict index (lookup / unique key) (could be set to
			// allow multiple items, so that all items at key get
			// returned)
			// or ordered_string? (allows multiple items more easily)
			// or full_text?

			// could get different implementations of these various
			// indexes.
			// for full text, could make a relatively simple tree index.
			// and could also experiment with some optimized full text
			// indexes. The unit testing would be useful for making
			// these indexes, and having a simple one could work
			// very well for testing and comparison.

			// Could have a data structures project where different ones
			// could be made.
			// Not so sure that the client in a web app would need this?
			// Searching would probably be done on the server.
			// However, these data structures could lead to server
			// implementations.

			// index_map['last_name'].indexes['dict']
			// and keeping track of the primary unique index.
			
			// There could be one index that is considered the primary_unique_index.
			//  Maybe determine the primary unique field?
			
			
			
			this.index_map = {};
			//  the indexes stored in the index map.
			//  may require searching at times.
			
			
		},

		// respond to events in the DataObjects / values stored within the collection.
		//  the normal system of propagating events up to the parents / ancestors?
		//  

		'notify_insertion': function(pos) {
			// need to code this.
			//  don't think its relevant for controls, which is what I'm working on right now.

			//console.log('TODO collection-index notify_insertion');
			return false;
		},
		
		
		'clear' : function() {
			this.index_map = {};
		},

		// re-index a whole collection / array...

		// add index by type by fields.

		// and set it as the primary index?
		// want to do that for quick retrieval with get operations.

		// Or set things as being a primary / unique field that will
		// work with get operations.
		// The indexing system is a little complex, but it won't take up
		// too much code when it's in place in the build.
		// Just a few hundred bytes I think.

		// Supporting get operations will make the Collection quite
		// useful.
		// Want it so that collections easily fit into place in code in
		// various situations.
		// Will often be defining which fields in an object are unique
		// Corresponding to unique columns / column constraints in a
		// database.

		// Want to make a nice IDE website, and use that to develop
		// version 2.
		// Saving database resources...
		// Likely to be storing classes and functions within the
		// database. Will be able to build them into modules.

		// Is a complicated way of going about things to have something
		// indexed with a dict...
		// But will save on code used in various objects. Some
		// complexity to be handled by the collection.
		// Will remove clutter from code that should be doing something
		// else apart from indexing a field.

		// Will get some examples with data working, then will get some
		// abstract postgres objects holding their objects using
		// Collection.
		// The Abstract Postgres code will be very clear, and easy
		// access to the objects will be provided.

		// Possibly will index a function matrix using multiple fields
		// in an index?
		// Will take time and effort to improve the collection, but then
		// it will be usable to store more things.
		// Ordering will not matter in many situations.
		// Will be able to sort a collection too, probably to keep it
		// sorted too.

		// Different implementation for get_by_position possible rather
		// than using array?
		// Perhaps these normal collections won't be so good for dealing
		// with large amounts of data, with the array operations.
		// Could maybe make a collection that does not use an array for
		// internal storage.
		// Right now, keeping track of the position in the array is
		// important.
		// Could perhaps make a B+ tree where items know their position.

		// search implies possibly returning multiple records.
		// we should know there won't be multiple records when searching
		// using a unique field / unique field combination.

		// could have 'get'?
		// a way of testing if things are stored in a unique index
		// system?

		// a non-unique dict system where new dicts get created at each
		// level?

		// get_by.
		//  will get by an indexed property.
		
		// get is fairly simple... need to have the index doing searches too.
		
		// also want to search the index system for indexes that are for various fields, but in any order.
		//  These indexes can be used to implement uniqueness constraints even if the order of keys does not match.
		//  Having this deal with some more complicated indexing patterns should make for a very powerful collection component.
		
		
		
		'search_for_index_with_fields': fp(function(a, sig) {
			// will be consulting the alphabetical list of fields.
			//  also, index could be indexed with its alphabetical list of fields.
			
			// scope for optimization through improved index index
			//  alphabetically sorted KVS of alphabetically sorted index fields.
			//  This is the kind of thing that will make this a good system!

			// Perhaps need different naming for attached fields?
			//  Need to be able to tell them apart from a list of fields.

			// an attached field:
			// ['attached', 'meta', 'name']
			//  could get confused with an array of three string field names.

			// '/.meta.name'
			//  /. could be convenient syntax for this, so we indicate that a field has been added that is
			//   an attached field.

			
			//console.log('search_for_index_with_fields ' + sig);
			//console.log('a ' + stringify(a));
			
			if (sig == '[s]') {
				return this.search_for_index_with_fields([a[0]]);
			}
			if (sig == '[a]') {
				
				// check the index in alphabetical order - any index with the right fields will do.
				
				//  may have option to continue search for the index with them matching in the right order.
				
				// could check for that one first.

				// OK, but to identify this is one field?
				//  Perhaps the whole field name as a string is better?

				
				//console.log('a[0] ' + stringify(a[0]));
				
				//var sorted_
				var idx = this.get_index_starting(a[0]);
				//console.log('idx', idx);
				return idx;
				
			}
			// how about looking through the indexes in this function?

			if (sig == '[o]') {
				var res;
				var matching_count = 0;

				this.iterate_indexes(function(index, stop) {
				
					
					
					//console.log('iterate_indexes index ' + index);
					//console.log('iterate_indexes index.fields ' + stringify(index.fields));
					//console.log('iterate_indexes index.fields ' + stringify(index.fields));
					//console.log('fields ' + stringify(fields));
					// compare the two arrays
					
					var i_fields = index.fields;
					if (tof(i_fields) == 'string') i_fields = [i_fields];
					
					//console.log('a[0] ' + stringify(a[0]));
					//console.log('i_fields ' + stringify(i_fields));

					var ae = are_equal([a[0]], i_fields);
					

					if (ae) {
						//matching_indexes.push(index);
						res = index;
						matching_count ++;
						//console.log('res ' + res);
						//return res;
					}
					
					//console.log('ae ' + ae);
					
					
					
					//throw ('iterate_indexes stop');
				});
				if (matching_count > 1) {
					throw 'unexpected matching_count > 1';
				} else {
					if (matching_count == 1) {
						return res;

					}
				}

			}
			
			
			
			
		}),
		
		
		// calling this find now.
		//  shorter, more positive sounding.
		'find': fp(function(a, sig) {
			
			// we can't really do search at the moment.
			//  21/06/2012, now we can. Good B+ implementation now in there.
			//  it looks like we can now... but maybe it's using 'get'.
			
			// however, do want full-text search.
			
			// will be doing searches with = or prefixes ok.
			
			//  (not all that well)
			// at a later stage we will have full-text search on indexes
			//  will search a lower case version of the text.
			
			// I think a trie will suffice for this functionality.
			//  Will do more experiments on this.
			//  May have an index of words and word occurrances within a collection.
			//   That would be a decent indexing system.
			//   Could also go for the full text index that could be more powerful and flexible.
			//   May want to be careful about setting word boundary search rules.
			
			// that could be done using a trie, prexix tree, suffix tree, suffix array, compressed dynamic suffix array, or other data structure.
			
			
			// can search one field for a name / value pair.
			//console.log('Collection_Index_System search sig: ' + sig);
			// searching multiple fields - multiple name value pairs.

			// nvp: [s,?]

			// do we have any indexes that cover all fields?
			// could do merging based on the results of more than one
			// index.

			// devising the search strategy becomes a bit more complex
			// when dealing with more than one index, being asked to
			// search by more than one field.

			// the indexing system does not hold all data anyway.
			// it won't be able to do all searches.

			// perhaps it should be queried to see what fields it does
			// index by before doing a search.
			// after doing a search with an index, may need to then
			// search through other fields without using the index.

			// searching by things in the order of the indexes
			// searching in other order, would be nice if it can consult
			// the right index.
			
			// var found = coll_presidents.find([['name', 'Franklin Pierce'], ['party', 'Republican']]);
			
			//console.log('Collection_Index_System find sig ' + sig);
			//console.log('a.l ' + a.l);

			if (sig == '[o]') {
				var objQuery = a[0];
				//console.log('objQuery ' + stringify(objQuery));

				//console.log('this.index_map ' + stringify(this.index_map));
				// so maybe if there is no index map we return false.
				//  not sure about indexed sub-items.

				//  may leave that for the moment.
				//   I'm sure it will be useful though.
				//    Perhaps they could be found through indexes in their own collections, so it's not down
				//     to the indexing system to find them apart from point them to the right item where it can.

				// Object query
				// ------------

				// Are we looking for a field that is indexed?
				//  Are we specifying multiple fields?

				// Dealing with searching for a single item with a query seems like a good case to handle.
				//  Other logic can deal with other cases.

				// indexes

				var indexes = this.indexes();

				// can't stringify the indexes.



				//console.log('t indexes ' + tof(indexes));
				//console.log('indexes.length ' + indexes.length);

				// then for each index, we see which fields it is...
				var map_single_field_indexes_by_field = {};
				each(indexes, function(i, v) {
					if (v.fields.length == 1) {
						//console.log('tof v.fields[0] ' + tof(v.fields[0]));

						var field = v.fields[0];
						var tField = tof(field);

						if (tField == 'string') {
							map_single_field_indexes_by_field[field] = v;
						}

						
					}
					//console.log('v.fields ' + stringify(v.fields));
				});

				// OK, so we see what it's indexed by.
				//  We also need to use the index to find the items by the object key.

				// {key: value}

				// Will need to look through the properties of the object given to this.
				var c = 0;
				var keys = [];

				each(objQuery, function(key, value) {
					//console.log('key ' + key);
					//console.log('value ' + value);
					c++;
					keys.push(key);
				});
				//console.log('c ' + c);

				if (keys.length == 1) {
					var index = map_single_field_indexes_by_field[keys[0]];

					if (index) {
						var res = index.get(objQuery[keys[0]]);
						//console.log('res ' + stringify(res));
						return res;
					} else {
						//throw 'no index found';

						return false;
					}

					
				}
				// we see which 


				// Want to search any indexes that match. May need to look through different sets if we are searching
				//  for more than one thing?




				throw 'stop';


				//console.log('Collection_Index_System search does not handle object query.');
				//  not yet? that will be a field name type thing, can look for fields on an attached
				//   object.
				//throw 'stop';
				return false;
			}



			if (sig == '[a]') {
				
				// .find('Donald Tsang < name < Jamie Oliver')
				// .find('Jamie Oliver > name > Donald Tsang') // in reverse order - it could notice that a > b and do the DESC query.
				
				//.find()
				
				// We could do a bit of interpretation on what is being looked for.
				//  There could be a search expression here.
				//  At the moment the search expression is just the field value, without the field name
				
				// '[indexed_field_value] = Jamie Oliver'
				// '= Jamie Oliver'
				// 'Jamie Oliver'
				
				// Index parsing for the queries should be useful.
				//  Also want things able to be done not in strings...
				//   Don't want to fall into the 'SQL Trap' of creating a string representation dynamically only to have to parse it again.
				
				// .find(['Donald Tsang', '<', 'name', '<', 'Jamie Oliver'])
				
				// the default will be <=
				// .find(['Donald Tsang', '<=', 'name', '<=', 'Jamie Oliver'])
				//                           ==
				// .find(['Donald Tsang', 'name', 'Jamie Oliver'])
				
				// .find({
				//    'name': ['Donald Tsang', 'Jamie Oliver'] // not saying inclusive or exclusive, could be inclusive by default
				//    'name': [['Donald Tsang', false], ['Jamie Oliver', false]] // exclusive
				//     exclusive(str) -> [str, false]
				//  Will need to do more specifying and testing for non-string values in indexes.
				//   Getting numerical indexes right with the comparison function would be nice.
				//    stores the number as a string... but stores it in numerical order.
				//     Would probably be best to parse it to a number for the comparison.
				//      Could try with numeric keys directly - they could work with comparisons.
				// })
				
				//  slightly odd syntax, but it makes sense.
				//   having the 'name' field in the middle... does make sense.
				//  expresses the operands - as if it has been parsed, the next stage.
				// searching for this one value.
				// not all indexes... need to have a default index.
				// primary index?
				//  may be spacifying the name of the field in many cases.
				//  this will be most useful when only one index is set up.
				//console.log('Index System find a[0] ' + stringify(a[0]));
				// primary index?
				//  may be the case when there is only one index.
				//  may specify primary indexes at other times.
				
				var indexes = [];
				
				this.iterate_indexes(function(finding_index) {
					//console.log('finding_index ' + finding_index);
					indexes.push(finding_index);
				});
				//throw('stop');
				//console.log('indexes.length ' + indexes.length);
				//console.log('this.index_map ' + stringify(this.index_map));
				
				// So, asking each index for the answer?
				
				//console.log('indexes.length ' + indexes.length);
				//console.log('a[0] ' + stringify(a[0]));
				
				var search_fields = [];
				var search_values = [];
				
				
				
				each(a[0], function(i, v) {
					//console.log('v ' + stringify(v));
					
				
					search_fields.push(v[0]);
					search_values.push(v[1]);
				});
				
				//console.log('search_fields ' + stringify(search_fields));
				
				/*
				
				if (indexes.length > 0) {
					
					// search for the right index.
					
					
					
					// consult the first index.
					
					var res = indexes[0].get(a[0]);
					
					//if (res.length == 1) {
					//	return res;
					//}
					//console.log('item ' + stringify(item));
					
					return res;
					
				}
				*/
				var equal_indices = [];
				//console.log('indexes ' + stringify(indexes));
				
				each(indexes, function(i, idx) {
					var idx_fields = idx.fields;
					//console.log('idx_fields ' + stringify(idx_fields));
					
					if (idx_fields.length >= search_fields.length) {
						// get the first part of the idx_fields
						
						// if it is an array...
						var idx_fields_to_check;
						if (tof(idx_fields) == 'array') {
							idx_fields_to_check = idx_fields.slice(0, search_fields.length);
						} else {
							idx_fields_to_check = [idx_fields];
						}
						
						
						
						
						//console.log('idx_fields_to_check ' + stringify(idx_fields_to_check));
						
						if (are_equal(idx_fields_to_check, search_fields)) {
							//console.log('they are equal');
							
							equal_indices.push(idx);
							
						}
						
					}
					
					//if (is_equal(idx_fields, search_fields))
					
					
				});
				
				//console.log('equal_indices.length ' + equal_indices.length);
				//return equal_indices[0];
				
				if (equal_indices.length > 0) {
					// use that index
					
					// will give that index two values to look for, in an array
					
					// will also do some testing with non-string values, and indexing them at some point.
					//  may do some lower level work in the B+ tree to get this right.
					
					var idx = equal_indices[0];
					//console.log('idx ' + stringify(idx));
					
					var res_indices_get = equal_indices[0].get(search_values);
					
					//console.log('res_indices_get ' + stringify(res_indices_get));
					
					return res_indices_get;
					
					
					
				}
				
				
			}
			
			/*
			if (sig == '[s]') {
				// it's searching for an index with a single field. Easy if there is just one of them found.
				
				// then split that string, it could be separated by commas.
				//  what about split with ', '?
				//  could have a new split function that maybe uses regexes to split like that?
				//  split, removing whitespace after commas.
				//  would go in util / essentials.
				
				var field_str = a[0];
				
				if (field_str.indexOf(',') > -1) {
					throw ('Multiple fields search through a string not yet implemented.');
				}
				var res = [];
				
				this.iterate_indexes(function(index) {
					if (index.fields.length == 1) {
						//res.push()
						if (index.fields[0] == field_str) {
							res.push(index);
						}
					}
				})
				if (res.length <= 1) return res[0];
				return res;
			}
			*/
			if (sig == '[o,s]') {
				// an object which represents the field.
				//  May need to read / understand that object.
				//   however, it could have been put into the index as a JSON field.
				//    so it will get recorded in the index under that string name.
				var fieldDef = a[0];
				//var strField = stringify(fieldDef);
				//console.log('strField ' + strField);

				// will search through and retrieve from the index (system)

				// can put in the object to the search.
				//  will it get stringified later?
				//   this needs to be used as a key for a string field though.
				var index = this.search_for_index_with_fields(fieldDef);
				//var index = this.search_for_index_with_fields(strField);
				//  may consult different indexes / look for them in a specific order when doing a lookup operation.
				//console.log('index ' + stringify(index));
				if (index) {
					//console.log('a[1] ' + stringify(a[1]));
					var res = index.get(a[1]);
				}
				//console.log('res ' + stringify(res));
				return res;
				//throw 'stop';


			}


			// That looks like multiple fields specified.
			if (a.l == 2 && tof(a[0]) == 'array') {
				//console.log('sig ' + sig);
				//console.log('4) a ' + stringify(a));
				//var index = this.search_for_index_with_fields(stringify(a[0]));
					
				// put them in an array to indicate they are one field?

				var index = this.search_for_index_with_fields([a[0]]);

				//  may consult different indexes / look for them in a specific order when doing a lookup operation.
				//console.log('index ' + stringify(index));
				if (index) {
					//console.log('a[1] ' + stringify(a[1]));
					var res = index.get(a[1]);
				}
				//console.log('res ' + stringify(res));
				return res;
			}

			if (a.l == 2 && tof(a[0]) == 'string') {
				// it's a single name-value pair.
				// is it?
				
				//console.log('sig ' + sig);
				//console.log('a ' + stringify(a));
				
				
				// search for the single index.
				// just use a dict index for the moment.
				// searching a dict is a 'get' operation.
				// maybe we need to search a full text index only?
				// the b+ index can do the prefix search, which is a
				// start.
				// more general searches, such as with a regex? becomes
				// more complex.

				
				//console.log('this.index_map ' + stringify(this.index_map));
				
				//var index = this.index_map[a[0]]['indexes_by_type']['dict'];
				
				// use a get_index function for this.
				var index = this.search_for_index_with_fields(a[0]);
				
				
				//  may consult different indexes / look for them in a specific order when doing a lookup operation.
				//console.log('index ' + index);
				//console.log('index ' + stringify(index));

				// then we search the index?
				// what API to lookup the value with the key?

				// return a search of the index.
				// a dict index... should maybe have 'get' rather than
				// search.
				//console.log('a[1] ' + a[1]);
				
				if (index) {
					var res = index.get(a[1]);
					//console.log('res ' + stringify(res));
					//console.log('a[1] ' + a[1]);
					//console.log('sig ' + sig);
				}
				
				//console.log('res ' + stringify(res));
				return res;
			}
		}),

		// This is going to be replaced with the system of constraints.
		//  There is the index
		//  Then there is the unique constraint
		//  Then it is the primary key, or similar to it, will be a field/column or a combination of them that gets used extensively in the
		//   database.
		
		// This will need to be tested fairly thoroughly, then it will be documented on the website.
		//  I think the website will have quite a lot of documentation, and I'll be able to modify it using a CMS.
		
		// Some documentation will be generated from the code.
		//  Will be able to edit API reference documents, they'll be viewable using a nice interface.
		// I think that could help take-up of this library quite considerably.
		//  That will be quite a big project.
		//  I think quite a lot of material about this, and JavaScript programming will go on my site.
		//  It would be good to have an active discussion forum as well.
		// The demos area, consultancy area, Web development work - getting back to people with a quote.
		//  It may be possible to put together good sites, quickly, for not all that much.
		// Could be recruiting contractors on that site. Would be a good interface with the programming community.
		//  Could possibly have a chat service, but answering people's questions quickly, or directing them to the forum, may be a useful thing to do.
		
		// I think this system would be a very solid technological basis for the site.
		//  Would be paticularly good for having other processes running that keep up-to-date backups.
		//  Also interested in connecting the web server with other MetaBench nodes that happen to be on and running.
		
		
		// There is no such thing as the primary unique index.
		//  There is the 'constraints' system.
		
		/*
		
		'primary_unique_index': fp(function(a, sig) {
			// just a string - the field name
			// dicts serve uniqueness checking well, though other data structures can do that too.
			
			//console.log('primary_unique_index sig ' + sig);
			
			if (sig == '[s]') {
				// ensuring there is that unique index, with that field
				// as the key.
				var field_name = a[0];
				// get the index for that field.
				// not sure it will already exist.

				// however, may want to first look to see if there are
				// any indexes for that field.
				// ensuring the dict index is the right way of doing
				// things for the moment.
				// will later do more development of the indexing system
				// so that other types of index can be used as a unique
				// index.
				// and so that the dict index can be used as a
				// non-unique index.
				//this._primary_unique_index = 
				this.ensure_index(field_name, 'dict');
			}
			if (sig = '[]') {
				//console.log('this._primary_unique_index ' + this._primary_unique_index);
				return this._primary_unique_index;
			}

		}),
		*/
		
		
		'get_index_starting': function(fields) {
			// will be starting with just one field?...
			//  get indexes starting...
			
			//console.log('get_index_starting ' + stringify(fields));
			
			if (tof(fields) == 'string') {
				fields = [fields];
			}
			//console.log('get_index_starting fields ' + stringify(fields));
			// go through all indexes, looking for the index which has got the right match.
			//  what about consulting an index of indexes?
			//  this could be done later, really won't be many indexes to search through.
			
			// look at the index map... get the fields as a string which will get used in the index lookup?
			//  want to be looking at all indexes at the moment.
			
			
			// want the stop function in iterate_indexes
			
			var matching_indexes = [];
			
			this.iterate_indexes(function(index, stop) {
				
				
				
				//console.log('iterate_indexes index ' + index);
				//console.log('iterate_indexes index.fields ' + stringify(index.fields));
				//console.log('fields ' + stringify(fields));
				// compare the two arrays
				
				var i_fields = index.fields;
				if (tof(i_fields) == 'string') i_fields = [i_fields];
				
				var ae = are_equal(fields, i_fields);
				
				if (ae) {
					matching_indexes.push(index);
				}
				
				//console.log('ae ' + ae);
				
				
				
				//throw ('iterate_indexes stop');
			});
			
			//console.log('matching_indexes.length ' + matching_indexes.length);
			
			if (matching_indexes.length > 1) {
				throw 'get_index_starting, more than 1 matching index found. Needs implementation';
				// May return the best match
				//  The best match could be found through an index.
				
				
			} else {
				return matching_indexes[0];
			}
			
			
		},
		
		
		'ensure_index': fp(function(a, sig) {
			// index may be given as the field(s)
			// single string field, or an array of fields.

			// index type as well...
			// we could have a default index type.

			// could try some benchmarks later on, judge difference
			// between b+ index and the dict index for retriveing
			// values.
			// dict will probably be much faster in JS because it uses
			// native code behind it, probably with a good string
			// hashing algorithm.

			// fields, index_type
			// field, index_type

			// and ensuring a unique index too?
			// perhaps the 'dict' index is unique.
			// could choose to operate the indexes on 'unique mode' or
			// not.

			// Want it easier to create a new index with the code.
			//  May have unsafe_add_index, or just be clearer about what code is used.
			
			// may ensure a single index.
			
			// may be given an array of strings.
			//   if so, it is a single index.
			
			
			//console.log('ensure_index sig ' + sig);
			
			if (a.l == 1 && is_arr_of_strs(a[0])) {
				// not specifying the type of index here.
				//  it is assumed to be the sorted (B+) index.
				
				
				// want to see if there is an existing index.
				
				/// hmmmm not sure... 
				
				var new_index_spec = a[0];
				//console.log('new_index_spec ' + stringify(new_index_spec));
				
				//throw('stop');
				// then create the actual (sorted) index.
				
				// will manually put this into the index map.
				//  may keep the index map, it's detailed, but also have a field_index_index where it points to the relevant index.
				//  may make other more direct objects in the index_system to refer to indexes.
				
				var sci = new Sorted_Collection_Index({
					'fields': new_index_spec
				});
				// then populate the index.
				
				// can add_object with an array to the index.
				sci.add_object(this.collection._arr);
				
				// then add the index into the index_system.
				
				// perhaps the map could be done in a heirachy like in nested?
				//  will have some code that is a bit complex and single-purpose here.
				//   it will be supporting the collection and index system.
				
				// May create light collection and data_object components. May have been better earlier, but then would have made things more complex too, this has been
				//  OK for developing.
				
				
				
				// not so sure about having the single field name?
				//  but they could be indexed here by their string fields key
				
				// this.index_map[field_name]['indexes_by_type'][index_type] = idx;
				
				//  could have the field names in sequence in the index - a little like the nested system.
				//  that would allow searching the index when looking sequentially for an index for fields.
				
				// though the sorted KVS with prefix search could actually help retrieve the index here.
				//  That would possibly be a useful data structure
				
				
				// The index map is already pretty unwieldy, perhaps it can be imprved.
				//  I think a specialized index index will be what is needed in a bit. At least there won't need to be so much specialized indexing code.
				//  Some kind of specialised code to power the indexing engine makes a lot of sense.
				
				// Will use the map and the fields_key for the moment.
				
				var fields_key = get_fields_key(new_index_spec);
				//console.log('2) fields_key ' + fields_key);
				
				this.index_map[fields_key] = this.index_map[fields_key] || {};
				this.index_map[fields_key]['indexes_by_type'] = this.index_map[fields_key]['indexes_by_type'] || {};
				this.index_map[fields_key]['indexes_by_type']['sorted'] = sci;
				
				return sci;
				
				//throw('4) stop');
				
			}
			
			// maybe change this interface.
			if (a.l == 2) {
				if (tof(a[1]) == 'string') {
					var index_type = a[1];
					if (tof(a[0]) == 'array') {
						var fields = a[0];
						
						return this.ensure_index[a[0]];
						
					}
					
					// what about when there are multiple fields to index.
					//  could try indexing president's party affiliations too.
					
					
					if (tof(a[0]) == 'string') {
						var field_name = a[0];

						// ensure a dict index...
						// think we will have to run through the types
						// sequentially here.

						// if (index_type == 'dict') {
						// see if there is a dict index already for that
						// field.

						// }

						// see if there is an existing index for that
						// field.

						var e_idx = this.get_index_by_type_by_fields([ field_name ], index_type);
						if (!is_defined(e_idx)) {
							// need to create the index.

							// should probably start it up with the
							// existing dataset.

							var idx = new Dict_Collection_Index({
								'fields' : [ field_name ]
							});
							// then want to load all the data in the
							// collection into the index.

							// Need to put the index in the index map.
							// Will do some ll_set or ll_ensure code to
							// make this shorter.
							this.index_map[field_name] = this.index_map[field_name] || {};
							this.index_map[field_name]['indexes_by_type'] = this.index_map[field_name]['indexes_by_type'] || {};
							this.index_map[field_name]['indexes_by_type'][index_type] = idx;
							
							// a dict of indexes, ordered by the field names of the index (comma separated), with an array of indexes that
							//  satisfy that combination of fields.
							// would be fast to search that array for particular fields - search all with that combination,
							//  then search for the fields in the particular order.
							
							// Sorted_KVS
							// .indexes_by_alphabetic_fields
							//  a prefix search on this could quickly get the required index
							// It would indeed be a fast way to get the index.
							//  Collection is getting quite big... it will be nice to get it back down to only a few KB.
							//  I wonder if the framework will wind up being quite hefty?
							//   Seems like a LOT of comments here. I think the collection itself, with the index system and data types etc, could be
							//   fairly small, a few K when wrapped up with other things.
							
							// I do want to provide an impressively small library, perhaps it will be around 30-40K?
							//  Once I have got a decent system, I can do refactoring and building.
							
							// I think an automated compilation / build process will be very useful.
							//  This one will put more things as local variables.
							//  Some object-oriented functions may be re-written as non-oo so that they work in the local scope, getting called from the local scope.
							//  Will also build up string names for strings that get used - can compress things a fair bit that way.
							//   With various compression means, it should be possible to get this down to a very small size.
							
							// The automatic linking (var removal) will prove useful when building this.
							//  Having this on the server, with an interface for producing builds will be useful.
							
							
							// a sorted KVS for storing the indexes by alphabetical fields...
							//  that would be nice for retrieving all of the indexes with a given alphabetical fields key.
							
							// Will take some more testing and checking to get the various things that are needed working.
							//  Am looking forward to creating the abstract rdb model, then translating that to an abstract Postgres model,
							//   then persisting that abstract Postgres model to a Postgres database.
							// All this middleware will make for some very convenient interfaces eventually.
							//  Having the data structure infrastructure to support them will help a lot.
							
							// as well as mapping it by type, and just one field name...
							//  need to have it indexing by the alphabetically sorted list of fields.
							// I think these things will take some more examples and testing, will test things with multiple indices as well.
							
							// Ordered indexes
							//  May be able to get them ordered by one of the sorted indexes.
							
							// Iterate through it, or get records, or get keys
							//  Will want to index the indexes with their fields stored alphabetically.
							//  this will matter when there are multiple fields in the indexes.
							
							
							
							
							

							// have made add_object into
							// unsafe_add_object that does not do
							// checking.
							// perhaps that unsafe method could be a
							// private function???

							// console.log('this.collection._arr ' )

							idx.add_object(this.collection._arr);

							// need to access the collection's array.
						}
					}
				}
			}
		}),



		// seems like the best way to index the indexes.
		// by field, then by index type.
		//  Would be good to have a clearer name / description of this function.

		'set_index_by_type_by_fields': function(index, arr_fields, index_type) {
			// In the Collection_Index_System

			//console.log('set_index_by_type_by_fields');
			// the fields for the index... possibly restricted to named fields, and do that check.
			//  make disabling some checks optional. Could also remove them at the build stage.
			
			// needs to go through the indexed fields
			// will create the dict maps saying which fields are getting
			// indexed.

			// Automatically indexing by automatically generated IDs?
			// That seems uncertain.

			// arr_fields ["attached", "meta", "name"] - that looks like one field.
			//  want a way of specifying a field is attached in some way.
			//  

			//console.log('index ' + stringify(index));
			//console.log('arr_fields ' + stringify(arr_fields));
			//console.log('index_type ' + stringify(index_type));

			
			// hmmm indexing by multiple fields.
			//  making a multi-level index map object.

			var c = 0, l = arr_fields.length;
			var i = this;
			//console.log('l ' + l);
			
			while (c < l) {
				var field = arr_fields[c];

				var tField = tof(field);
				//console.log('tField ' + tField);
				//throw 'stop';
				if (tField == 'string') {
					if (!i.index_map[field]) {
						i.index_map[field] = {};
					};
					i = i.index_map[field];
				} else {
					//console.log('tField ' + tField);
					// The field could be given as an array.

					// if it's an attached field...
					//  probably best to index it as an attached field.

					// object fields...
					//  need to be careful about adding these indexes for attached objects' fields.
					//  it needs to register so that when objects are added, the relevant indexes are
					//  notified, and know to check the attached object field.

					if (tField == 'object') {
						//console.log('is object');
						//console.log('field ' + stringify(field));

						// processing attached fields here?

						var fieldStr = stringify(field);
						if (!i.index_map[fieldStr]) {
							i.index_map[fieldStr] = {};
						};
						i = i.index_map[fieldStr];


						// Then would need something for when the object is added.

						//throw 'stop';

					}



					if (tField == 'array') {
						// record it in the index as a stringified array.
						//  that would be an attached field.
						//   attached(fieldName) would look neater, but not be JSON.

						var fieldStr = stringify(field);
						if (!i.index_map[fieldStr]) {
							i.index_map[fieldStr] = {};
						};
						i = i.index_map[fieldStr];




					}


					// Could set it by the name of the field even if it's attached?
					//  Or the attachment becomes part of the name?
					//  I think fields referring to attachments could make sense.
					//   Need to keep this consistant however.
					//console.log('field ' + stringify(field));

					// if the field is an array, such as ['attached', attachedObjName, attachedObjField]
					// an attached field.







					//throw '3) stop';
				}


				
				c++;
			}
			i['indexes_by_type'] = i['indexes_by_type'] || {};
			i['indexes_by_type'][index_type] = index;
		},
		
		// may just be called index() in the collection, but more in-depth name here.
		'set_index' : function(index) {
			this.set_index_by_type_by_fields(index, index.fields, index.index_type);
		},

		'get_index_by_type_by_fields': function(arr_fields, index_type) {
			// needs to go through the fields, moving through the
			// indexes.
			var c = 0, l = arr_fields.length;
			var i = this;
			while (c < l) {
				i = i.index_map[arr_fields[c]];

				c++;
			}
			// perhaps the index has not been defined.
			if (i) {
				var index = i['indexes_by_type'][index_type];
			}

			// could there be multiple indexes of the same index type?
			// possibly could make it hold indexes with different
			// engines / data structures... but I don't think that's
			// necessary.
			// but not sure the index exists...

			return index;

		},
		
		'indexes': fp(function(a, sig) {
			if (a.l == 0) {
				var res = [];
				this.iterate_indexes(function(index) {
					res.push(index);
				});
				return res;
			} else {
				throw 'Setting indexes not supported here (yet)';
			}
		}),

		// with 'stop' function in callback
		'iterate_indexes': function(index_callback) {

			//console.log('ii');
			
			// recursive function inside to do the iteration.
			//console.log('beginning index iteration. this.index_map: ' + stringify(this.index_map));
			// the index map needs to be updated when indexes are added.

			// will be used when adding an object to the indexes.
			// also when removing object from indexes.

			// stop in this code... a bit more complex.
			
			var iterate_level = function(level) {
				each(level, function(i, v, stop1) {
					//console.log('i ' + i);
					//console.log('v ' + stringify(v));

					// i is the field name.

					var ibt = v['indexes_by_type'];
					if (ibt) {
						each(ibt, function(i2, v2, stop2) {
							// is an index, I think.
							
							var full_stop = function() {
								stop2();
								stop1();
							}
							index_callback(v2, full_stop);
						});
					}

				})

				// each(level['indexes_by_type'], function(i, v) {
				// console.log('v ' + stringify(v));
				// each(v, function(index_type, index) {
				// index_callback(index);
				// })

				// });

			}
			//console.log('this.index_map ' + stringify(this.index_map));
			iterate_level(this.index_map);

		},

		// this will be checking it against constraints instead.
		/// depricated... will be removed.
		'_____can_add_object': function(obj) {
			// think we just check for single objects right now

			var tobj = tof(obj);
			//console.log('can_add_object tobj ' + tobj);

			if (tobj == 'data_object') {
				// go through the indexes to see if all the indexes can
				// add it.
				
				// does it match the acceptance criteria?
				/*
				if (this._accepts) {
					// check whether the obj matches this._accepts
					
					// ._accepts as constraints / a Data_Object as constraints?
					//  a Data_Object with its fields set as constraints?
					//  or would the fields be fine by themselves?
					
					// want a function to test a Data_Object against fields
					
					// the indexing system does not do the acceptance test for data validation, only checking it's not conflicting.
					
					console.log('this._accepts ' + this._accepts);
					
					
				}
				*/
				
				var can_add = true;

				this.iterate_indexes(function(index) {
					// a problem iterating the indexes.

					//console.log('*ii index ' + stringify(index));

					// when adding an object to an index, it could raise
					// an error.
					// may be best to check all indexes first to see if
					// the object will be addable.

					// index.add_object(obj);

					var index_can_add = index.can_add_object(obj);

					//console.log('index_can_add ' + index_can_add);

					if (!index_can_add) {
						can_add = false;
						// break from iteration, like is possible in
						// jQuery?
					}

				});

				return can_add;

			} else {
				return false;
				
			}

		},

		'add_object': function(obj) {
			//console.log('Index System add_object ' + stringify(obj));
			return this.unsafe_add_object(obj);
			/*
			
			if (this.can_add_object(obj)) {
				return this.unsafe_add_object(obj);
			} else {
				throw 'Can\'t add object. Check unique key collisions.';
			}
			*/
		},

		
		// The index no longer will have a problem with multiple items with the same key being added.
		//  It's the uniqueness constraints which may have something to say about it. They would consult the indexes.
		
		'unsafe_add_object': function(obj) {

            //console.log('Collection_Index_System unsafe_add_object');
			// NOT adds an index.
			// should add an object to all indexes.
			// a way to iterate through all indexes?
			// maybe they won't be stored in a normal array.
			//console.log('Collection_Index_System unsafe_add_object ' + stringify(obj));
			//console.log('obj.meta ' + jsgui.stringify(obj.meta));

			// The object may have attached objects.
			//  There could be attached metadata, but we want a general way for indexing (fields on)
			//   attached data.

			// It will still get put into the object index, but the index will have to be set up to
			//  deal with attached fields properly.

			// These are not subfields... there may not be any more than just metadata.
			//  meta seems most applicable to the Resource system, and get and set will be useful
			//  methods for interacting with the resource itself. The name could possibly be available
			//   through non-meta, but that could possibly have security / reliability issues.

			this.iterate_indexes(function(index) {
				// a problem iterating the indexes.
				// It seems like the indexes were not set up.
				//console.log('2) ii index ' + stringify(index));
				// when adding an object to an index, it could raise an
				// error.
				// may be best to check all indexes first to see if the
				// object will be addable.
				index.unsafe_add_object(obj);
			});

		},
		
		
		'remove': function(obj) {
			// was remove_object
			
			// need to locate the object.
			// it may be in all indexes.
			
			// tell all indexes to remove that object, if they have it.
			
			this.iterate_indexes(function(index) {
				index.remove(obj);
				
			});
			// remove it from the sorted_kvs.
		},
		// This is going to be changed to collection_constraints
		'accepts': fp(function(a, sig) {
			// may be expressed in terms of a Data_Object
			if (sig == '[D]') {
				// we set the acceptance criteria to the Data_Object. Every object that gets potentially added to this gets checked against
				//  the Data_Object's check acceptance criteria method (though this may call other, non-oo methods)
				this._accepts = a[0];
				// could check all existing items against acceptance criteria (first)?
				
			}
			// if it's an object, could save that object? test against that?
			
			if (sig == '[o]') {
				throw 'Map object as acceptance criteria not yet supported in Collection';
				
			}
		})
		
		/*
		'clear' : function() {

		}
		*/
		
		// a function to get the appropriate index for the given fields.
		//  check if it has such an index?

	// ensure index by type and rows.

	});

	var Collection_Index = {
		'System': Collection_Index_System,
		'Sorted': Sorted_Collection_Index
	}

	//return Collection_Index;
module.exports = Collection_Index;

//});

},{"./constraint":26,"./data-object":28,"./jsgui-data-structures":35,"./jsgui-lang-essentials":37}],25:[function(require,module,exports){

/* * @module core/collection */

/*
if (typeof define !== 'function') {
    var define = require('amdefine')(module);
}

define(["./jsgui-lang-essentials", "./jsgui-data-structures", "./data-object", "./data-object-fields-collection", "./constraint",
	"./collection-index"],
	*/

var jsgui = require('./jsgui-lang-essentials');
var Data_Structures = require('./jsgui-data-structures');
var Data_Value = require('./data-value');
var Data_Object = require('./data-object');
var Data_Object_Field_Collection = require('./data-object-fields-collection');
var Constraint = require('./constraint');
var Collection_Index = require('./collection-index');
//

//function(jsgui, Data_Structures, Data_Object, Data_Object_Field_Collection, Constraint, Collection_Index) {

// Collection... use sligntly more than essentials?
var Collection_Index_System = Collection_Index.System;
var Sorted_Collection_Index = Collection_Index.Sorted;

var j = jsgui;
var Class = j.Class;
var each = j.each;
var eac = j.eac;
var is_array = j.is_array;
var is_dom_node = j.is_dom_node;
var is_ctrl = j.is_ctrl;
var extend = j.extend;
var clone = j.clone;
var x_clones = j.x_clones;
var get_truth_map_from_arr = j.get_truth_map_from_arr;
var get_map_from_arr = j.get_map_from_arr;
var arr_like_to_arr = j.arr_like_to_arr;
var tof = j.tof;
var is_defined = j.is_defined;
var stringify = j.stringify;
var functional_polymorphism = j.functional_polymorphism;
var fp = j.fp;
var arrayify = j.arrayify;
var mapify = j.mapify;
var are_equal = j.are_equal;
var get_item_sig = j.get_item_sig;
var set_vals = j.set_vals;
var truth = j.truth;
var trim_sig_brackets = j.trim_sig_brackets;
var iterate_ancestor_classes = j.iterate_ancestor_classes;
var is_constructor_fn = j.is_constructor_fn;

var is_arr_of_strs = j.is_arr_of_strs;
var is_arr_of_arrs = j.is_arr_of_arrs;

var Sorted_KVS = Data_Structures.Sorted_KVS;
var dobj = Data_Object.dobj;

var input_processors = j.input_processors;

var constraint_from_obj = Constraint.from_obj;
var native_constructor_tof = jsgui.native_constructor_tof;

var dop = Data_Object.prototype;

// wrap the old set_field function
var old_set_field = dop.set_field;

var new_set_field = fp(function(a, sig) {
    // some polymorphic cases which are not checked by the old one.
    if (sig == '[s,[f]]') {
        // It's a constraint / field that is a collection.
        //  The collection actually gets created, _.field_name set to be that collection.

        //console.log('new_set_field sig ' + sig);

        // then create the data type constraint...
        //  the data type for that field is a collection, and that collection has a given type that it accepts.
        var field_name = a[0];
        //console.log('field_name ' + field_name);
        var dt_constructor = a[1][0];

        //console.log('dt_constructor ' + dt_constructor);

        var coll = new Collection(dt_constructor);
        coll._data_type_constraint = new Constraint.Collection_Data_Type(dt_constructor);
        this.set(field_name, coll);

        //throw '12) new_set_field stop';
    } else {
        old_set_field.apply(this, a);
    }
});

dop.set_field = new_set_field;

/**
* @param obj
* @param query
*/
var obj_matches_query_obj = function(obj, query) {
    //console.log('obj_matches_query_obj');
    //console.log('obj ' + stringify(obj));
    //console.log('query ' + stringify(query));

    var matches = true;
    each(query, function(fieldName, fieldDef) {
        var tfd = tof(fieldDef);
        //console.log('fieldName ' + fieldName);
        //console.log('tfd ' + tfd);

        if (tfd == 'string' || tfd == 'boolean' || tfd == 'number') {
            matches = matches && obj[fieldName] === fieldDef;
            //if (!matches) stop();
        } else {
            throw 'need more work on more complex queries for collection find, iterative search'
        }
    })
    return matches;
}


// In the definition of a control's extension, we may include a 'data_type'.
//  That will translate to a _data_type_constraint being applied to all collections
//   of that defined type.
//  constraint(D);

// May need to make a new extend function to handle 'data_type' being specified at the top
//  level of the definition, similar to 'fields'.

// May add some parameters into extend, so that this will accept a function that processes
//  this value upon initialization.

// 28-Dec-2013
//  This lacks insert_at. That seems like an important part of a collection.
//  Maybe not important with various indexing systems, but important for basic usage.
//   Like inserting a control into another control's contents as the first.


/*
 * @constructor
 */

/**
* A module representing a collection.
* @exports core/collection
*/
var Collection = Data_Object.extend({

    'init': function(spec, arr_values) {
        //console.log('Collection init');
        //console.log('spec ' + stringify(spec))
        spec = spec || {};
        // Probably should act differently for an abstract collection.
        this.__type = 'collection';
        if (spec.abstract === true) {
            //console.log('init abstract collection');

            // An abstract collection does no have an index system - though maybe has got abstract indexes?
            // We may initialise it using a constructor for another function.
            //  eg Collection(Table)

            // In this case hold the item type.
            //  It is a constraint.
            //  Any objects in the collection must be an instanceOf the type given.


            // Just meaning it is a collection of a certain type.
            //  Fields will get declared in the abstract, eg when defining a Database class, it has tables as a field.

            // Will do this as the collection having a data type constraint.

            var tspec = tof(spec);
            if (tspec === 'function') {
                this.constraint(spec);
            }



            // Abstract collection of type.

            // Will not have an actual index system in abstract mode.

        } else {
            this._relationships = this._relationships || {};
            this._arr_idx = 0;
            this._arr = [];

            // Maybe some collections don't need indexing?
            this.index_system = new Collection_Index_System({
                // The collection index system could have different default ways of indexing items.
                //  Each item that gets indexed could get indexed in a different way.
                'collection' : this
            });

            var spec = spec || {};

            if (tof(spec) == 'array') {
                spec = {
                    'load_array': spec
                };
            } else {
                if (tof(spec) == 'function') {
                    if (spec.abstract === true) {
                        //throw 'Collection with abstract spec function';

                        this._abstract = true;
                    } else {

                        if (is_constructor_fn(spec)) {

                            var chained_fields = Data_Object.get_chained_fields(spec);

                            var chained_fields_list = Data_Object.chained_fields_to_fields_list(chained_fields);

                            //console.log('***** chained_fields_list ' + stringify(chained_fields_list));

                            var index_field_names = [], field_name, field_text;
                            each(chained_fields_list, function(i, v) {
                                field_name = v[0];
                                field_text = v[1];

                                var isIndexed = field_text.indexOf('indexed') > -1;
                                var isUnique = field_text.indexOf('unique') > -1

                                if (isIndexed || isUnique) {
                                    index_field_names.push([field_name]);
                                }
                            });

                            // So, that does it :)
                            var old_spec = spec;
                            spec = {
                                'constraint': spec
                            };

                            if (old_spec == String) {
                                spec.index_by = 'value';
                            }

                            if (index_field_names.length > 0) {
                                spec.index_by = index_field_names;
                            }

                        }

                    }

                } else if (tof(spec) == 'string') {
                    // May be like with the constraint above.
                    // still need to set up the constructor function.

                    var map_native_constructors = {
                        'array': Array,
                        'boolean': Boolean,
                        'number': Number,
                        'string': String,
                        'object': Object
                    }

                    var nc = map_native_constructors[spec];

                    if (nc) {
                        spec = {
                            'constraint': nc
                        };
                        if (nc == String) {
                            spec.index_by = 'value';
                        }
                    }
                }
            }

            if (is_defined(spec.items)) {
                spec.load_array = spec.load_array || spec.items;
            }
            if (arr_values) {
                console.log('load arr_values ------------');
                spec.load_array = arr_values;
            }

            // keeping these things below the expected public interface.
            if (is_defined(spec.accepts)) {
                this._accepts = spec.accepts;
            }


            if (jsgui.__data_id_method == 'init') {
                // but maybe there will always be a context. May save download size on client too.
                if (this._context) {
                    this.__id = this._context.new_id(this.__type_name || this.__type);
                    this._context.map_objects[this.__id] = this;
                } else {
                    // don't think we want a whole bunch of objects mapped like this....
                    //  IDs will be very useful when they are controls... but maybe not always needed.

                    //this.__id = new_collection_id();
                    //map_jsgui_ids[this.__id] = this;
                }

            }

            if (!this.__type) {


            }
        }


        this._super(spec);
    },

    // maybe use fp, and otherwise apply with the same params and context.

   /**
    * @func
    * @param value
    */
    'set': function(value) {
        // get the tof(value)
        var tval = tof(value);

        //console.log('tval ' + tval);
        //throw('stop');
        var that = this;
        if (tval == 'data_object') {
            this.clear();
            return this.push(value);
        } else if (tval == 'array') {
            // for an array... clear, then add each.

            this.clear();
            // Not sure about making a new collection here... but maybe we could get it defined as a normal point.

            // But we could make a DataValue for the points.
            //  Could specify that points are stored as Data_Values.
            //   Maybe fixed length of 2.

            each(value, function(i, v) {
                that.push(v);
            });

        } else {
            if (tval == 'collection') {
                // need to reindex - though could have optimization that checks to see if the indexes are the same...
                throw 'stop';
                this.clear();
                value.each(function(i, v) {
                    that.push(v);
                })

            } else {
                return this._super(value);
            }


        }

    },

   /**
    * @func
    */
    'clear': function() {
        this._arr_idx = 0;
        this._arr = [];

        this.index_system = new Collection_Index_System({
            // The collection index system could have different default ways of indexing items.
            //  Each item that gets indexed could get indexed in a different way.
            'collection' : this
        });

        this.trigger('change', {
            'type': 'clear'
        })
    },

   /**
    * @func
    */
    'stringify': function() {
        var res = [];
        if (this._abstract) {
            // then we can hopefully get the datatype name

            // if it's abstract we detect it, otherwise it should be in there.
            var ncto = native_constructor_tof(this._type_constructor);

            res.push('~Collection(')
            if (ncto) {
                res.push(ncto);
            } else {

            }
            res.push(')');

        } else {
            res.push('Collection(');
            //console.log('obj._arr ' + stringify(obj._arr));

            var first = true;
            this.each(function(i, v) {
                if (!first) {
                    res.push(', ');
                } else {
                    first = false;
                }
                res.push(stringify(v));

            })

            res.push(')');
        }
        return res.join('');
    },

   /**
    * @func
    */
    'toString': function() {
        return stringify(this._arr);

    },

   /**
    * @func
    */
    'toObject': function() {
        var res = [];
        this.each(function(i, v) {
            res.push(v.toObject());
        });
        return res;
    },

   /**
    * @func
    * @param ...
    */
    'each' : fp(function(a, sig) {
        // was callback, context
        // ever given the context?

        if (sig == '[f]') {
            return each(this._arr, a[0]);
        } else {

            if (sig == '[X,f]') {
                // X for index

                // we use the order of the index.
                //  possibly we can iterate using the index itself, maybe with that same callback.

                var index = a[0];
                var callback = a[1];
                return index.each(callback);

            } else {
                if (a.l == 2) {
                    return each(this._arr, a[0], a[1]);
                }
            }
        }
    }),

    'eac' : fp(function(a, sig) {
        // was callback, context
        // ever given the context?

        if (sig == '[f]') {
            return eac(this._arr, a[0]);
        } else {

            if (sig == '[X,f]') {
                // X for index

                // we use the order of the index.
                //  possibly we can iterate using the index itself, maybe with that same callback.

                var index = a[0];
                var callback = a[1];
                return index.eac(callback);

            } else {
                if (a.l == 2) {
                    return eac(this._arr, a[0], a[1]);
                }
            }
        }
    }),


   /**
    * @func
    */
    '_id' : function() {
        // gets the id.


        if (this._context) {
            this.__id = this._context.new_id(this.__type_name || this.__type);
        } else {
            if (!is_defined(this.__id)) {

                // get a temporary id from somewhere?
                //  but the collection should really have a context...
                //  or without a context, the collection is its own context?

                // Won't go setting the ID for the moment.

                //this.__id = new_collection_id();
            }
        }
        return this.__id;

    },


   /**
    * @func
    */
    'length': function() {
        return this._arr.length;
    },


   /**
    * @func
    * @param ...
    */
    'find': fp(function(a, sig) {


        // var found = coll_presidents.find([['name', 'Franklin Pierce'], ['party', 'Republican']]);

        // it can be an array of fields.
        //console.log('collection find ' + sig);
        //console.log('a ' + stringify(a));
        if (a.l == 1) {

            // Make it so that index_system handles object queries...
            //  field: value

            var index_system_find_res = this.index_system.find(a[0]);
            //console.log('index_system_find_res ' + index_system_find_res);

            // How to know if these have been indexed or not.
            //  Perhaps the index system will only do certain queries.
            //  index_system.can_find would help.
            if (index_system_find_res === false) {
                // let's do the search ourself.
                // need to go through every object to see if it matches the search query.
                // Though the results may be better returned as a collection.
                var foundItems = [];
                each(this, function(index, item) {
                    //console.log('index ' + index);
                    //console.log('item ' + stringify(item));


                    // check each data item for the match.
                    throw 'stop';
                })
            } else {
                return index_system_find_res;
            }
            // if there is only one index in the system then the search will be simple.
        }

        // [o,s]
        //  finding a string value that's been specified using an object.
        //   It may indicate an attached field.
        //   We'll still be asking the index_system to find it.
        //   Need to be sure that [o,s] fields get indexed properly, and other indexes who's fields
        //    are specified by an object.
        //   {fieldName: {}} equivalent to 'fieldName'
        //    this will allow extended information to be added.
        //   We will be aware of what we are indexing, such as attached field names.
        //    Code when the index gets created
        //    Code when an item gets added to that index.
        //     Will need to check attached objects.

        if (sig == '[o,s]') {
            return this.index_system.find(a[0], a[1]);
        }

        //




        // and if looking for more than one thing...
        if (sig == '[s,s]') {
            return this.index_system.find(a[0], a[1]);
        }
        if (sig == '[a,s]') {
            return this.index_system.find(a[0], a[1]);
        }
        if (sig == '[s,o]') {
            var propertyName = a[0];
            var query = a[1];
            //console.log('propertyName ' + propertyName);
            //console.log('query ' + stringify(query));
            // Maybe return a Collection, not an array.
            // don't consult the index system.
            var foundItems = [];
            // for each object we need to go deeper into the fields.
            each(this, function(index, item) {
                //console.log('index ' + index);
                //console.log('item ' + stringify(item));

                //var matches = item.match(query);

                var itemProperty = item.get(propertyName);
                //console.log('itemProperty ' + stringify(itemProperty));

                //console.log('tof(itemProperty) ' + tof(itemProperty));
                var tip = tof(itemProperty);

                if (tip == 'array') {
                    // possibly should be a collection
                    each(itemProperty, function(i, v) {
                        //console.log('v ' + stringify(v));
                        var matches = obj_matches_query_obj(v, query);
                        //console.log('matches ' + matches);

                        if (matches) {
                            foundItems.push(v);
                        }
                    })
                }
                // check each data item for the match.
                //throw '!stop';
            })
            return new Collection(foundItems);
        }
    }),
    // get seems like the way to get unique values.


   /**
    * @func
    * @param ...
    */
    'get' : fp(function(a, sig, _super) {




        // integer... return the item from the collection.
        //console.log('collection get sig ' + sig);
        if (sig == '[n]' || sig == '[i]') {
            return this._arr[a[0]];
        }

        // getting by it's unique index?
        //  this may again refer to getting a property.

        if (sig == '[s]') {

            var ix_sys = this.index_system;
            var res;
            if (ix_sys) {
                //console.log('ix_sys', ix_sys);
                var pui = ix_sys._primary_unique_index;
                res = pui.get(a[0])[0];
            }

            if (res) {
                return res;
            }



            // Works differently when getting from an indexed collection.
            //  Need to look into the index_system
            //  there may be a primary_unique_index




            return Data_Object.prototype.get.apply(this, a);

        }
        // may take multiple params, specifying the fields in the
        // unique index.

    }),


    // insert_before could be useful.
    //  In some HTML controls want to insert one control before another one.


    // Will a control always know what position it's in?

   /**
    * @func
    * @param ...
    */
    'insert': function(item, pos) {
        // use array splice...
        //  then modify the index somehow.
        //  perhaps add 1 to each item's position past that point.
        //  may mean n operations on the index.
        //   some kind of offset tree could be useful for fast changes and keeping accurate lookups.

        this._arr.splice(pos, 0, item);

        // index system notify_insertion
        //  so the index system can make the adjustments to the other items.


        // then call the change event.
        //  and have event details saying an item i has been inserted at position p.
        //   for controls, that should be enough to render that control and put it onto the screen
        //   if the context is active.

        this.index_system.notify_insertion(pos);


        this.trigger('change', {
            'name': 'insert',
            'item': item,
            'pos': pos
        });




    },

    // may have efficiencies for adding and removing multiple items at once.
    //  can be sorted for insertion into index with more rapid algorithmic time.

   /**
    * @func
    * @param ...
    */
    'remove': fp(function(a, sig) {
        var that = this;

        //console.log('sig ' + sig);
        //throw 'stop';

        if (sig == '[n]') {

            var own_id = this._id();

            // remove the item at that position.

            var pos = a[0];
            var item = this._arr[pos];

            var o_item = item;
            //console.log('*');
            //console.log('item ' + stringify(item));

            var spliced_pos = pos;
            this._arr.splice(pos, 1);
            this._arr_idx--;
            var length = this._arr.length;
            while (pos < length) {

                // reassign the stored position of the item

                var item = this._arr[pos];

                item.relationships[own_id] = [that, pos];
                //console.log('');
                //console.log('item._parents[own_id] ' + stringify(item._parents[own_id]));
                pos++;
            }

            // need to remove that item from the index system as well.

            this.index_system.remove(o_item);
            // but is it no longer actually there?
            //  seems to be gone now.

            var e = {
                'target': this,
                'item': item,
                'position': spliced_pos
            }

            this.raise_event(that, 'remove', e);
        }

        // and if we are removing by a string key...

        if (sig == '[s]') {
            var key = a[0];

            // get the object...

            var obj = this.index_system.find([['value', key]]);

            //console.log('obj ' + stringify(obj));
            //console.log('tof(obj) ' + tof(obj));
            //throw 'stop'

            // and get the position within the parent.

            var my_id = this.__id;
            //console.log('my_id ' + my_id);
            //throw 'stop';

            var item_pos_within_this = obj[0]._relationships[my_id];
            //console.log('item_pos_within_this ' + item_pos_within_this);
            //throw 'stop';

            this.index_system.remove(key);
            this._arr.splice(item_pos_within_this, 1);

            // then adjust the positions downwards for each item afterwards.



            for (var c = item_pos_within_this, l = this._arr.length; c < l; c++) {
                //console.log('c ' + c);
                var item = this._arr[c];
                item._relationships[my_id]--;
            }

            var e = {
                'target': this,
                'item': obj[0],
                'position': item_pos_within_this
            }

            this.raise_event(that, 'remove', e);

        }

    }),

   /**
    * @func
    * @param obj_key
    */
    'has': function(obj_key) {
        // will operate differently depending on how the collection is being used.
        //console.log('this._data_type_constraint ' + stringify(this._data_type_constraint));
        if (this._data_type_constraint) {
            //console.log('this._data_type_constraint.data_type_constructor ' + stringify(this._data_type_constraint.data_type_constructor));
            if (this._data_type_constraint.data_type_constructor) {
                if(this._data_type_constraint.data_type_constructor === String) {
                    // collection of strings - does it have that string?
                    //console.log('this.index_system ' + stringify(this.index_system));
                    var found = this.index_system.find('value', obj_key);
                    //console.log('found ' + stringify(found));
                    //throw 'stop';
                    //return !!found;
                    return found.length > 0;
                }
            }
        }
    },

    // Set still operates as it does from the Data_Object.

    // Unique index being replaced with a constraint, and it also makes the index when the constraint is put in place if the index is not already there.


   /**
    * @func
    * @param ...
    */
    'get_index': fp(function(a, sig) {
        if (sig == '[s]') {
            return this.index_system.search(a[0]);
        }

    }),

    // has_index may be useful... perhaps this should be changed to index_by?
    //  other people may think this means it has an index (int) and returns that.

    // just need to be very clear about what this function does, could have an index_by function too.

    //

    // renamed index(), was index_by()

    // 'index' is actually going to be setting up constraints.
    //  // dealing with a layer of constraints may make sense, but it should probably be exposing the indexes.

    // Don't want to change the syntax, and make developers have to type 'Constraint' all the time, but I think that Constraints is the right
    //  way of expressing the underlying system, partly to aid transitions to databases, and its proven to be a flexible (inflexible) model.

   /**
    * @func
    * @param field
    */
    'find_unique_constraint': function(field) {
        // can be one field, or an array.

        // Perhaps the order of the fields here should be rearranged to alphabetical?
        //  In a constraint, the order of the fields should not matter - except it would set up an index using the order of the fields specified.
        //  the constraint could have the fields rearranged in alphabetical order.

        // There will be a bit of code bloat in some lower level components because they are not using Data_Object and Constraint classes themselves.
        //  Finding the right constraint out of the existing constraints is necessary when potentially adding a new constraint.
        //  Constraints having an alphabetically sorted list of fields?
        //  It is as though we can't use unique constraint code for this where otherwise it could have been used.

        // fields in alphabetical order...

        // want to be able to break out of each loops as well.
        //  posibly (i, v, break) and call the break function?

        var item = null;

        if (tof(field) == 'array') {

        } else if (tof(field) == 'string'){
            // it's just one string.
            each(this._unique_constraints, function(i, v, stop) {
                // does it match the field?
                if (v.fields === field) {
                    item = v;
                    stop();
                }
            })
        }
        //console.log('item ' + item);
        return item;
    },

    // The constraints will also be available, but they will likely make for a less user-friendly interface than fields.


   /**
    * @func
    * @param ...
    */
    'fields': fp(function(a, sig) {

        //console.log('Collection fields sig ' + sig);
        //console.log('Collection fields a ' + stringify(a));
        var that = this;
        // this will refer to the fields of the data_object_constraint.

        if (sig == '[o]') {
            // use a field definition constraint
            //  (a different way of doing the constraint, using json-like object, not using a Data_Object constructor.

            each(a[0], function(i, v) {
                that.set_field(i, v);
            });

            // set the constraints

            that.constraint(a[0]);

        } else {
            if (!this._data_object_constraint) {
                this._data_object_constraint = Constraint.from_obj(new Data_Object());
            }
            var doc = this._data_object_constraint;

            if (a.l == 0) {
                return doc.data_object.fc.get();
            }
            // if given an array, set the fields.

            //console.log('a.l ' + a.l);

            if (a.l == 1 && tof(a[0] == 'array')) {
                //console.log('array 1');
                return doc.data_object.fc.set(a[0]);
            }
        }


    }),

    // Getting quite in depth with generality and polymorphism here.
    //
    //  Perhaps there should be a _fields object.
    //  So far we have used constraints - there will be field constraints when fields are specified.
    //   Maybe it makes sense... a 'field' may correspond with indexes as well.

    // May be the fields from the prototype, as well as fields that have been added.

   /**
    * @func
    * @param ...
    */
    'set_field': fp(function(a, sig) {
        //console.log('set_field');
        // sets a field?
        //  maybe 'set' is a better word because it would overwrite existing fields.

        // will be able to add an individual field
        //  name and field type as string...
        var that = this;
        // we may have a data_def_constraint?
        //var that = this;

        // Fields get created using constraints.


        // Constraint from a new Data_Object?
        //  Not sure of the need of this.
        var doc = that._data_object_constraint = that._data_object_constraint || Constraint.from_obj(new Data_Object());


        //var doc = that._data_object_constraint ||
        //console.log('doc ' + stringify(doc));



        //console.log('set_field sig ' + sig);
        //console.log('set_field a ' + stringify(a));

        // Setting a field on a collection...
        //  Setting a constrinat?


        //if (doc) {
            if(a.l == 2 && tof(a[0]) == 'string') {
                doc.data_object.fc = doc.data_object.fc || new Data_Object_Field_Collection();

                // May need to set up indexing on the fields as well.


                return doc.data_object.fc.set(a[0], a[1]);
            }
        //}


    }),


   /**
    * @func
    * @param ...
    */
    'remove_field': fp(function(a, sig) {
        var doc = this._data_object_constraint;

        if (doc) {
            if (sig == '[s]') {
                return doc.data_object.fc.out(a[0]);
            }
        }


    }),
    // A constraint may reference an index.
    // It may need to create the index if it does not already exist.

    // Give a data type to give a type constraint.

   /**
    * @func
    */
    'get_data_type_constraint': function() {
        // there may just be one ._data_type_constraint.
        //  not having all the constraints listed together.

        return this._data_type_constraint;


    },

   /**
    * @func
    * @param ...
    */
    'constraint': fp(function(a, sig) {
        if (sig == '[]') {
            // Get all of the constraints.

            // if no constraints, return null.
            var res = null;

            if (this._data_type_constraint) {
                res = {
                    'data_type': this._data_type_constraint
                }
            }
            if (this._data_object_constraint) {
                res = res || {};
                res.data_object = this._data_object_constraint;
            }
            if (this._data_def_constraint) {
                res = res || {};
                res.data_def = this._data_def_constraint;
            }
            return res;
        }

        if (sig == '[o]') {
            this._data_def_constraint = new Constraint.Collection_Data_Def(a[0]);
        }

        if (sig == '[f]') {
            if (a[0] === Number) {
                //var cdtc = new Constraint.Collection_Data_Type(a[0]);
                this._data_type_constraint = new Constraint.Collection_Data_Type(a[0]);
                return this._data_type_constraint;
            }
            if (a[0] === String) {
                //var cdtc = new Constraint.Collection_Data_Type(String);
                this._data_type_constraint = new Constraint.Collection_Data_Type(a[0]);
                //console.log('this._data_type_constraint ' + this._data_type_constraint);
                return this._data_type_constraint;
            } else if (is_constructor_fn(a[0])) {

                //console.log('is_constructor_fn ');
                var data_type_constructor = a[0];
                // set up the data type constraint.
                //  can have a Type_Constraint on a collection... each object in the collection must satisfy that type.
                //   different to having it satisfy a particular data_object's constraints.
                var dtc = this._data_type_constraint;
                if (dtc) {
                    var cdtc = this._data_type_constraint.data_type_constructor;
                    if (cdtc && cdtc === data_type_constructor) {
                        //console.log('returning dtc');
                        return dtc;
                    }
                }
                this._data_type_constraint = new Constraint.Collection_Data_Type(data_type_constructor);
                //console.log('this._data_type_constraint ' + this._data_type_constraint);
                return this._data_type_constraint;
                // have a look at the existing data_type_constraint

            }
        }
        // ['unique', 'isbn-13']
        // ['unique', ['school_id', 'school_assigned_student_id']]

        // will need to ensure there is an index for that set of fields.

        // is it an array?
        //  could be an array of different constraints

        if (sig == '[D]') {
            var constraint = constraint_from_obj(a[0]);
            this._data_object_constraint = constraint;
        }
        if (sig == '[[s,s]]') {
            // A single constraint, with one string parameter (probably its field)

            var constraint_def = a[0];
            var constraint = constraint_from_obj(constraint_def);

            var c_type = constraint._constraint_type;
            //console.log('c_type ' + c_type);

            if (c_type == 'unique') {
                // ensure it has that unique constraint.
                //  this will mean going through all unique constraints, or checking its own index of them
                //  may have a bit of optimization here, but not using collections to implement this.
                //  collections will be used in many other things though. Will be useful for representing data models as well.

                // unique constraints,
                // NOT NULL,
                // Relationship
                // Check

                // The relationship constraints, when set up, will assist in creating the data models that accuratly model those relationships.
                // check if it already has that unique constraint.
                this._unique_constraints = this._unique_constraints || [];
                // get the index...
                // index_system.find_indexes_with_fields
                // get_unique_constraint?
                // find_unique_constraint(fields)
                //  that will be a function that does the specific search for an existing unique constraint with those fields.
                //  returns false if not found.
                // will use find_unique_constraint to see if there are already matching unique constraints.
                var field_name = constraint_def[1];
                //console.log('field_name ' + field_name);
                var existing_unique_constraint = this.find_unique_constraint(field_name);
                //console.log('existing_unique_constraint ' + existing_unique_constraint);

                if (existing_unique_constraint) {
                    return existing_unique_constraint;
                } else {

                    // look to see if there is an index that supports the constraint.
                    //  does not have to be a sorted index, necessarily.

                    // let's get an index, with those fields.

                    // it may be worth having the fields of various indexes sorted by name automatically.
                    //  would be useful for quick algorithmic comparison of which fields they are indexing.

                    // The optimal one would be the index in the same order, but failing that, an index with the fields in a different order can be used.
                    //  The order on the constraints does not matter so much, but it is nice to preserve whichever order the user specified initially.
                    // This will take more time and effort... but not a massive amount before the system is ready to be used.

                    // I think I should get my site running so it can host discussion about the system.
                    //  Having documentation on my site would be very good. It would be nice to measure the traffic and interest.

                    // There will be some features about doing some specific things.
                }
            }
        }
    }),

    // also could be expressed as a constraint and then the index is automatically put in place.
    // However, when an index is set, it's not setting a unique constraint automatically.

    // basically ensure_index for the moment.
    //  however, will also return the index, and with no params will get all indexes.
    //  will have nice syntax with ensuring multiple indexes at once.

    // Should possibly present nicer syntax to MongoDB with a wrapper.
    //  May have some different data wiring / connection options.
    // Likely to be best to do a lot in the abstract so changes can be viewed before being made.

   /**
    * @func
    * @param fields
    */
    'get_unique_constraint': function(fields) {
        if (tof(fields) == 'string') fields = [fields];
        each(this._unique_constraints, function(i, unique_constraint) {
            var uc_fields = unique_constraint.fields;
            //console.log('uc_fields ' + stringify(uc_fields));

            if (are_equal(uc_fields, fields)) return unique_constraint;
        });
    },

   /**
    * @func
    * @param ...
    */
    'unique': fp(function(a, sig) {
        var that = this;
        //console.log('a[0] ' + stringify(a[0]));

        if (sig == '[s]') {
            return this.unique([a[0]]);
        }
        if (tof(a[0]) == 'array') {
            if (is_arr_of_arrs(a[0])) {
                //console.log('is_arr_of_arrs');
            }
            if (is_arr_of_strs(a[0])) {
                var existing_uc = this.get_unique_constraint(a[0]);
                if (existing_uc) return existing_uc;
                var new_uc = new Constraint.Unique({
                    'fields': a[0]
                });
                this._unique_constraints = this._unique_constraints || [];
                this._unique_constraints.push(new_uc);
                var idx = this.index(a[0]);
                //console.log('');
                //console.log('idx ' + stringify(idx));
            }
        }
    }),

    // indexes
    //  will get all the indexes... may set a particular index? Or replace the indexes?

   /**
    * @func
    * @param ...
    */
    'indexes': fp(function(a, sig) {
        if (a.l == 0) {
            // get all indexes.
            // will look at the index system, and get the indexes from that.
            var index_system = this.index_system;
            //console.log('index_system ' + index_system);
            var indexes = index_system.indexes();
            return indexes;
        }
    }),
    // index_by - it sounds nice, reads well in code / samples.
    //  may just use the index() method, but that could call index_by to make things a bit clearer.


   /**
    * @func
    * @param ...
    */
    'index_by': fp(function(a, sig) {
        var that = this;
        //console.log('index_by a ' + stringify(a));
        //console.log('a.l ' + a.l);
        //console.log('index_by sig ' + sig);
        //console.log('a', a);
        //throw('stop');
        //console.log('tof(a[0]) ' + tof(a[0]));
        //if (a.l == 1 && tof(a[0]) == 'array') {
        if (sig == '[a]') {
            console.log('a[0] ' + stringify(a[0]));

            if (is_arr_of_strs(a[0])) {
                // then it's a single index.
                //console.log('is_arr_of_strs ' + stringify(a[0]));
                var relevant_index = this.index_system.get_index_starting(a[0]);
                //console.log('relevant_index ' + relevant_index);
                if (relevant_index) {
                    return relevant_index;

                } else {
                    var index_spec = a[0];
                    var new_index = this.index_system.ensure_index(index_spec);
                    return new_index;
                }
            }
            // If it's an array of arrays... it's an array of indexes.
            if (is_arr_of_arrs(a[0])) {
                // deal with each of them in turn.
                //console.log('it is_arr_of_arrs');
                each(a[0], function(i, specified_index) {
                    that.index(specified_index);
                });
            }
        }

        // otherwise, we'll be taking a map of what to index and what type of index to use there.

        // get the index, based on that name?
        if (sig == '[s]') {

            // Tell the index to sort itself based on that value.



            return that.index({
                'sorted': [[a[0]]]
            });
        }

        if (sig == '[o]') {
            //console.log('object sig');

            var index_map = a[0];
            //console.log('index_map ' + stringify(index_map));

            each(index_map, function(index_type, index_definition) {

                //console.log('index_definition', index_definition);
                //console.log('index_type ' + index_type);
                if (index_type == 'sorted') {
                    // set up the individual index of the specified type.

                    //if (index_type == 'sorted') {
                    //console.log('index_definition ' + stringify(index_definition));
                    if (tof(index_definition) == 'array') {
                        // is it an array of strings? then it is the fields?
                        // is it an array of arrays?
                        if (is_arr_of_arrs(index_definition)) {
                            // each index, each field in the index
                            var indexes = [];



                            each(index_definition, function(i, individual_index_fields) {
                                // then will have a bunch of fields
                                //console.log('individual_index_fields ' + stringify(individual_index_fields));

                                // Setting the fields of a Collection_Index...
                                //  need to be careful when the field is an attached object.
                                //   may use JSON notation for the attachement.
                                //   likely to disallow quotes and (square) brackets in field names.



                                // Make it so Sorted_Collection_Index can handle attached objects.
                                //  fields set like [{"attached": {"meta": "name"}}]
                                //  where a field is specified as an object,

                                // So the index gets created.
                                //  It has those fields...
                                //   where to they get made within the Sorted_Collection_Index constructor?

                                //console.log('individual_index_fields', individual_index_fields);


                                var index = new Sorted_Collection_Index({
                                    'fields' : individual_index_fields
                                });

                                // These collection indexes should have a 'get' function.

                                that.index_system.set_index(index);
                                indexes.push(index);

                            });

                            //console.log('indexes', indexes);

                            that.index_system._primary_unique_index = indexes[0];
                            return indexes[0];
                        }
                        if (is_arr_of_strs(index_definition)) {
                            // one index, with fields
                        }

                    }

                    //}
                }
            })
        }
    }),

   /**
    * @func
    * @param ...
    */
    'index': fp(function(a, sig) {

        if (a.l == 1) {
            return this.index_by(a[0]);
        }


    }),


   /**
    * @func
    * @param obj
    */
    'test_object_against_constraints': function(obj) {
        // will do the test for the various constraints
        //console.log('test_object_against_constraints');
        //var res_test_data_object_constraint =
        //console.log('this._type_constructor ' + this._type_constructor);
        //console.log('this._data_object_constraint ' + stringify(this._data_object_constraint));
        //console.log('this._data_type_constraint ' + stringify(this._data_type_constraint));

        //console.log('obj ' + stringify(obj));
        // Could also have a constructor type - can check instance of

        if (this._type_constructor) {
            if (!obj instanceof this._type_constructor) return false;
        }

        if (this._data_object_constraint) {
            // not sure why this will have a _data_object_constraint in various cases.
            //console.log('this._data_object_constraint', this._data_object_constraint);

            if (!this._data_object_constraint.match(obj)) return false;
        }

        if (this._data_type_constraint) {
            // test against that constraint
            if (!this._data_type_constraint.match(obj)) return false;
        }

        var that = this;

        var res = true;
        each(this._unique_constraints, function(i, unique_constraint) {
            //console.log('unique_constraint ' + stringify(unique_constraint));
            // then test against that unique constraint.

            // get the fields of the constraint, then try to get a record with those fields

            var uc_fields = unique_constraint.fields;
            //console.log('uc_fields ' + stringify(uc_fields));

            // then attempt to 'get', using these fields.
            //  performing a record count would be more efficient though.
            //  'has' search, returns boolean

            var find_params = [];
            each(uc_fields, function(i, field_name) {
                // get the value

                var field_value = obj.get(field_name);
                find_params.push([field_name, field_value]);

            });
            //console.log('find_params ' + stringify(find_params));

            var found = that.find(find_params);
            //console.log('found ' + stringify(found));

            if (found && found.length > 0) {
                res = false;
            }
        });
        return res;
    },


   /**
    * @func
    * @param value
    */

    // Sometimes wrap a normal JS obj as a Data_Value, Data_Object or Collection?



    'push': function(value) {

        var tv = tof(value);
        //console.log('1) collection push value: ' + stringify(value));
        //console.log('--------------------')
        //console.log('push tv ' + tv);

        if (tv == 'object') {

            var dtc = this._data_type_constraint;
            //  but we can have an object definition constraint?
            //  is that a type of data_type_constraint?
            //console.log('dtc ' + dtc);

            if (dtc) {
                var dtcon = dtc.data_type_constructor;
                //console.log('dtcon ' + dtcon);
                value = new dtcon(value);
            } else {
                var ddc = this._data_def_constraint;
                //console.log('ddc ' + stringify(ddc));

                // need to see if it matches the constraint.
                //console.log('value ' + stringify(value));
                // Will need something recursive to see if something matches a data_def.
                //  in the data_def_constrint code.
                var match = true;
                if (ddc) match = ddc.match(value);
                //console.log('match ' + match);

                if (!match) {
                    throw 'Does not match data_def constraint';
                } else {
                    // need to create a new data_object with that data_def?
                    //  or could set the fields?
                    //  Fields could respond to data_def.
                    //   But data_def could encompass more than just fields.

                    // And a Data_Object could have a data_def_constraint too.
                    //  That would also set its fields.

                    // Will just set the fields with the data_def for now???
                    //value = dobj(value);
                    // Would be better to make an enhanced_data_object here

                    //value = new
                    //console.log('* value ' + stringify(value));
                    if (ddc) {
                        value = dobj(value, ddc.data_def);
                    } else {
                        value = dobj(value);
                    }
                    //console.log('value ' + stringify(value));
                    // set its constraints...
                    value.constraints(ddc);
                    // Using the collection data definition constraint, should be able to set the inner constaint of the
                    //  data_object. May just use the same object rather than cloning it.
                }

                //value = dobj(value);
            }
            tv = tof(value);
            //console.log('tv ' + tv);
            //console.log('value ' + value);
        }

        //console.log('collection push tv: ' + tv);
        //console.log('2) collection push value: ' + stringify(value));
        // so, a data_item gets added at this._arr_idx

        // also need to be add a collection to the collection.
        //  that will be a lot like with Data_Object.
        //   There can't really be full automatic indexing here.

        if (tv == 'collection') {
            //console.log('1) pre test_object_against_constraints');
            var constraints_test_res = this.test_object_against_constraints(value);
            //console.log('constraints_test_res ' + constraints_test_res);
            if (constraints_test_res) {
                this.index_system.unsafe_add_object(value);
                var pos = this._arr.length;
                this._arr.push(value);

                // but does this have a context?
                //  A content collection should have the same context as the control it's in.
                value.parent(this, pos);

                var e = {
                    'target': this,
                    'item': value,
                    'position': pos,
                    'type': 'insert'
                }
                //console.log('adding collection to collection event being raised');
                // raise a change event.
                //  have a change type, like add or insert.

                //this.raise_event('add', e);
                this.raise_event('change', e);

                this._arr_idx++;
            } else {
                var stack = new Error().stack
                //console.log( stack );
                throw('Collection constraint(s) not satisfied');
            }
        }
        if (tv == 'data_object' || tv == 'control') {

            //console.log('pre constraints test');
            //console.log('2) pre test_object_against_constraints');
            var constraints_test_res = this.test_object_against_constraints(value);
            //console.log('post constraints test');
            // the uniqueness test is an important one too.
            //  when a unique constraint is set up, the index should be created.
            //console.log('constraints_test_res ' + constraints_test_res);
            // would be testing against a unique constraint.
            //  can test to see if a new object would violate a collection constraint?
            //console.log('constraints_test_res ' + constraints_test_res);
            if (constraints_test_res) {

                //console.log('pre unsafe_add_object value', stringify(value));

                //console.log('pre this.index_system.unsafe_add_object');

                this.index_system.unsafe_add_object(value);

                //console.log('post this.index_system.unsafe_add_object');
                // gets added to the index... but is its position within this collection stored too?
                //console.log('post unsafe_add_object');
                // Things do get a bit complicated with needing the positions within the collection to do various things.
                // Don't want to rely on it always being stored in the indexes though.

                var pos = this._arr.length;
                this._arr.push(value);
                // the position within the parent / the parent's array.
                //console.log('pos ' + pos);
                var e = {
                    'target': this,
                    'item': value,
                    'position': pos,
                    'type': 'insert'
                }
                //value._relationships[this._id()] = this._arr_idx;
                //console.log('adding data_object to collection event being raised');
                // this, and the position it's going to.


                // Should set the parent and the position within the parent.
                //  __index perhaps?

                value.parent(this, pos);

                // item can have multiple parents... that should be possible.
                //console.log('pre raise add event');

                // This bit is taking a while.
                //  Not sure why!!! Has to do with objects being put in a large collection probably.
                //  Too many things, in the wrong context, getting notified.
                //console.log('pre collection raise change event');

                this.raise_event('change', e);
                // raise event being called, but not fired as expected???

                //console.log('post raise change event');


                //console.log('post raise add event');
                // accessed using a 'parent' array / mini-collection?
                // mini-collection, handling collections without the bells and whistles?
                //  or collections with some things disabled?

                // value.parent(this)

                // location within parent...
                //  should probably / possibly make this clearer in code?
                //  not so sure that the position tracking will work all the times.
                //  may be best to separate the position, or give it some kind of variable name.
                // will do more work and testing on this later.
                this._arr_idx++;
            } else {
                var stack = new Error().stack
                //console.log( stack );
                throw('Collection constraint(s) not satisfied');
            }
            // check if the index system can add the object.
        }

        if (tv == 'array') {
            // wrap it or not? could put it in another collection.
            //  will that be useful for a function's parameters?
            //  that would maintain the whole system with the wrapper and relationships.
            // I think we do that... turn it into a new collection and put it in there.
            //  Will get for some more complex behaviours, but they could prove pretty useful.
            // Could make a copyleft licence wrapper - any code that runs it needs to be wrapped by that function.
            // for the moment, I think we create a new collection wrapper to hold the array.
            // need to basically add an array object to the collection, but have it wrapped.

            //var coll = new Collection(value);
            //return this.push(coll);
            return this.push(new Collection(value));
        }

        if (tv == 'string' || tv == 'number') {

            //console.log('tv ' + tv);
            // still need to check if it matched the collection constraint(s).
            //console.log('3) pre test_object_against_constraints');



            var constraints_test_res = this.test_object_against_constraints(value);
            //console.log('constraints_test_res ' + constraints_test_res);
            if (constraints_test_res) {
                var dv = new Data_Value({'value': value});
                //console.log('dv ' + stringify(dv));
                var pos = this._arr.length;
                // Should not need a context or ID just to be put in place.
                this._arr.push(dv);
                var e = {
                    'target': this,
                    'item': dv,
                    'position': pos,
                    'type': 'insert'
                }
                this.raise_event('change', e);

                if (tv == 'string') {
                    // indexing the value
                    this.index_system.unsafe_add_object(dv);
                }
            } else {
                console.trace();
                throw('wrong data type');
            }
        }
        //this._arr_idx++;
        return value;
    },


   /**
    * @func
    * @param value
    */
    //'add': function(value) {
    //    return this.push(value);
    //},


   /**
    * @func
    * @param arr
    */
    'load_array': function(arr) {
        var that = this;
        //console.log('load_array arr ' + stringify(arr));
        // there could be a data type that this is expecting... a constraint?
        //  could have a data type constructor.
        // so, if the item given is not a Data_Object, we can try making the Data_Object, and putting it in place.
        var dtc = this._data_type_constraint;
        //console.log('dtc ' + dtc);

        // May also need to change ID values on the objects?
        //  Create clones of the objects with different ID values?

        // Be able to accept items being pushed that will have IDs changed?

        // Should have a data_type_constructor with typed collections.



        if (dtc) {
            // is a Collection_Data_Type_Constraint
            var data_type_constructor = dtc.data_type_constructor;
            //console.log('data_type_constructor ' + data_type_constructor);

            /*
            each(arr, function(i, v) {
                that.push(v);
            });
            */
            for (var c = 0, l = arr.length; c < l; c++) {
                that.push(arr[c]);
            }


        } else {
            /*
            each(arr, function(i, v) {

                that.push(v);
            });
            */
            for (var c = 0, l = arr.length; c < l; c++) {
                that.push(arr[c]);
            }
        }
        this.raise_event('load');
    },


   /**
    * polymorphic version
    * @name values
    * @func
    * @param {string} parm1 - param description
    * @memberof module:core/collection
    * @inner
    */

   /**
    * @func
    * @param ...
    * @variation 2
    */
    'values': fp(function(a, sig) {
        if (a.l == 0) {
            return this._arr;
        } else {
            var stack = new Error().stack;
            //console.log(stack);
            //console.log('');
            //console.log('sig ' + sig);
            // should be setting the values.
            throw 'not yet implemented';
        }
    }),


   /**
    * @func
    */
    'value': function() {
        var res = [];
        this.each(function(i, v) {
            if (typeof v.value == 'function') {
                //res[i] = v.value();
                res.push(v.value());
            } else {
                res.push(v);
            }

        });
        return res;
    }

    // insert_at seems very important.



    // all the collection's values
    // values() will get or set all the values.

// Could use a (new) extension of Data_Object.extend.
//  We want it so that we can specify a 'data_object' when defining a class, and this
//   sets up a ._data_object_constraint using .constraint(D)
//    though we are giving it a Data_Object subclass constructor.





});

var p = Collection.prototype;
p.add = p.push;


/**
 * @function
 * @static
 */
Collection.extend = function() {
    var a = arguments;
    var args = [a[0]];
    // call Data_Object.extend with another function for post-initialization?

    if (a[0].data_object) {
        //console.log('extending a Collection with .data_object');
        args.push(function() {
            // post-init function to get called after the init function.

            this.constraint(a[0].data_object);
        })
        //throw 'stop';
    }
    // execute a post-init function in order to set the constraint in some circumstances?
    //var args = [a[0]]


    var res = Data_Object.extend.apply(this, args);


    return res;

}

module.exports = Collection;

	//return Collection;
//});

},{"./collection-index":24,"./constraint":26,"./data-object":28,"./data-object-fields-collection":27,"./data-value":29,"./jsgui-data-structures":35,"./jsgui-lang-essentials":37}],26:[function(require,module,exports){
/*

if (typeof define !== 'function') {
    var define = require('amdefine')(module);
}


define(["./jsgui-lang-essentials"], function(jsgui) {
	
    */
    var jsgui = require('./jsgui-lang-essentials');

    /**
    * Constraints module.
    *
    *  #####  Classes hierarchy:
    *
    * &nbsp;&nbsp;&nbsp;      {@link module:core/constraint.Constraint|Constraint} <br />
    * &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;       <mark>  {@link module:core/constraint.Data_Object_Constraint|Data_Object_Constraint} </mark><br />
    * &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;         {@link module:core/constraint.Data_Object_Def_Constraint|Data_Object_Def_Constraint} <strong>Data_Object_Def_Constraint</strong> <br />
    * &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;         {@link module:core/constraint.Field_Constraint|Field_Constraint}  <br />
    * &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;            {@link module:core/constraint.Not_Null_Constraint|Not_Null_Constraint} <strong>Not_Null</strong> <br />
    * &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;            {@link module:core/constraint.Field_Data_Type_Constraint|Field_Data_Type_Constraint} <strong>Field_Data_Type</strong> <br />
    * &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;               {@link module:core/constraint.Text_Constraint|Text_Constraint} <br />
    * &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;               {@link module:core/constraint.Guid_Constraint|Guid_Constraint} <strong>Guid</strong> <br />
    * &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;               {@link module:core/constraint.Number_Constraint|Number_Constraint} <br />
    * &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;                  {@link module:core/constraint.Int_Constraint|Int_Constraint} <br />
    * &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;         {@link module:core/constraint.Collection_Constraint|Collection_Constraint} <br />
    * &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;            {@link module:core/constraint.Collection_Data_Def_Constraint|Collection_Data_Def_Constraint} <strong>Collection_Data_Def</strong> <br />
    * &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;            {@link module:core/constraint.Collection_Data_Type_Constraint|Collection_Data_Type_Constraint} <strong>Collection_Data_Type</strong> <br />
    * &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;            {@link module:core/constraint.Unique_Constraint|Unique_Constraint} <strong>Unique</strong> <br />
    *
    * @module core/constraint
    * @exports Constraint
    */



	// This will define some constraint items.
	//  Not so sure about adding more things to the jsgui namespace, perhaps best just to provide the Constraint object
	
	
	// Constraint won't be or use a Data_Object...
	//  There may be some code that will make use of Data_Object interfaces, not sure.
	//  Mainly, this will be for validating JavaScript values against each other for use in the Data_Object, Collection, and other things.
	
	// Having this so it does not use a lot of other references will be helpful in keeping things modular,
	//  and quickly being able to use some validation code without too much supporting it.
	


	var j = jsgui;
	var Class = j.Class;
	var each = j.each;
	var is_array = j.is_array;
	var is_dom_node = j.is_dom_node;
	var is_ctrl = j.is_ctrl;
	var extend = j.extend;
	var clone = j.clone;
	var x_clones = j.x_clones;
	var get_truth_map_from_arr = j.get_truth_map_from_arr;
	var get_map_from_arr = j.get_map_from_arr;
	var arr_like_to_arr = j.arr_like_to_arr;
	var tof = j.tof;
	var is_defined = j.is_defined;
	var stringify = j.stringify;
	var functional_polymorphism = j.functional_polymorphism;
	var fp = j.fp;
	var arrayify = j.arrayify;
	var mapify = j.mapify;
	var are_equal = j.are_equal;
	var get_item_sig = j.get_item_sig;
	var set_vals = j.set_vals;
	var truth = j.truth;
	var trim_sig_brackets = j.trim_sig_brackets;
	var ll_set = j.ll_set;
	var ll_get = j.ll_get;
	var is_constructor_fn = j.is_constructor_fn;
	
	// Data Types are also similar to constraints.
	//  They are being used in the nested system with HTML.
	//  For the moment, I want to constinue to develop the Constraints system.
	//   They will be using something similar to Data_Type specifications for putting together the more compliacted constraints.
	
	// For the moment, these constraints will be used in preparation of mapping to a database (not nested, so far)
	//  At a later stage they will then be adapted further for the nested requirements of HTML correction and interpretation.
	
	// Perhaps the constraints, like for RGB, would be useful when putting things in a DB.
	//  Not sure how much of the translation would be done in the DB layer, but it could be done in JavaScript, with the database accepting
	//   less flexible data.
	
	// However, more flexibility and polymorphism in the database could be developed.
	//  We already have a bit, but it's not parsing RGB values. Not that keen on getting into the SQL coding, but there could
	//   be various functions that are made, library functions, that get put in.
	
	
	// I also think the whole system could run as a JavaScript file, but also have a huge declarative JSON section when a large application is running on the
	//  server.
	//  Not sure.
	
	// For the moment, this will be unifying what has been done on Data_Objects and nested objects, and serving as a general basis
	//  for RDB and other DB abstractions, and schemas.
	// Could be very useful for validating XML schemas, for example.
	
	// Some constraints that apply to collections may not apply to database tables.
	//  An example is if a collection needs to have 1 or more element. In a DB there can be an empty table, but some collections may specify it needs
	//   one or more object to be valid (but not to exist, necessarily?)
	
	// Getting these working, then mapping over to databases is quite a bit of code.
	//  Will be a useful basis for translating to abstract RBB
	
	// I think an abstract RDB set of classes would be quite useful.
	
	// Postgres RDB classes could inherit from many of them, for example.
	
	// There would also be a function to translate from generic RDB classes to Postgres ones.
	//  And to translate back too.
	
	// Then the Postgres classes are used to generate code, and functions that manipulate those tables / objects in the DB, which generate code
	
	// Advanced ORM is one of the things that this system really needs. It's going to be obtaining data and data models from other systems.
	//  Possibly would be run to quickly interoperate / import and export data to / from existing systems.
	// Could possibly have extra (very user friendly) modules operating over a legacy database application.
	//  Could do very specific things, as required for new functionality. Would then be in a position for the jsgui/metabench system
	//  to be fully activated and replace a legacy system, either keeping the existing database, or having exported and mirrored everything,
	//   could switch to Mongo or other DB designed by / using the application, or continue mirroring changes.
	
	// The whole middleware side of things will make integration tasks very quick.
	//  The Resource system and interface will be used for much of this.
	
	
	
	
	// Constraints could apply to various different things.
	//  Generally they will apply to a value.
	//  They will be testable against values to see where those values do or do not comply with the constraints.
	//  Not sure if it would be worth using this system to test against XML schemas. It could make sense. Perhaps the system for testing the XML
	//   schemas would be using this, perhaps it would even directly be this but with the correct options set.
	
	// This could get quite large, so this will really be a core constraint tester.
	//  It will be part of the core, but not the essentials. They will be useful for other programs in various places, and will be really small when
	//  compressed. In this case, I'll have a larger core. There will be builds / distributions available for clients.
	// Some will have client-side shims built in, like an IE6-7 build perhaps.
	
    /**
    * Creates the Constraint.
    * @constructor
    * @classdesc Base class for the constraints.
    * @memberof module:core/constraint
    */
    
	var Constraint = Class.extend({
		'init': function(spec) {
			// if the spec is a string, then parse the string.
			
			// it may make reference to various data types.
			//  text, restricted or unrestricted length
			//  ints, numbers, etc
			//  various tests will be carried out, beyond tof.
			
			if (tof(spec) == 'string') {
				
			}
			
			// A constraint can be / contain multiple other constraints.
			//  Maybe it should have that logic inside it, and these other constraints can be particular ones.
			
			// Code execution path... may be important getting that working before long, but now it does seem that specifying and
			//  validating these various types in JavaScript seems like an important thing to do.
			
			// 
			
			
		}
	// 'matches'
		
	
	})


    /**
    * Returns true if the `obj` value matches the `constraint` definition.
    * @func
    * @param {object} obj - object to check
    * @param {string} constraint - constraint definition
    * @memberof module:core/constraint
    * @example
    * obj_matches_constraint(1, "int") ==> true
    * obj_matches_constraint("1", "int") ==> false
    * obj_matches_constraint("1", "text(3)") ==> true
    */
	var obj_matches_constraint = function (obj, constraint) {
		//console.log('obj_matches_constraint ');
		//throw('stop');
		
		if (tof(constraint) == 'string') {
			constraint = constraint_from_str(constraint);
			
			return constraint.match(obj);
		}
		
	}


    /**
    * Creates the data object constraint.
    * @constructor
    * @classdesc <mark>the class does nothing, and not public.</mark>.
    * @memberof module:core/constraint
    */
    // Data_Object_Constraint

    // Or include this in Data_Object?
    // May be best to make its own module as we should not require Data_Object here?



    //var Data_Object = require('./data-object');

	var Data_Object_Constraint = Constraint.extend({
	    'init': function (spec) {
	        this.__data_type = 'data_object_constraint';
	    },
        'match': function(obj) {

            // Don't have Data_Object here??, as Data_Object is used by this
            //var res = obj instanceof Data_Object.constructor;

            var res = tof(obj) == 'data_object';
            //console.log('res', res);
            return (res);
        }
	});




	var Data_Object_Def_Constraint = Constraint.extend({

	    /** 
        * @classdesc Data object definition constraint.
        * @constructs module:core/constraint.Data_Object_Def_Constraint 
        * @param {object} spec - data definition
        * 
        */
		'init': function(spec) {
		    this.__data_type = 'data_object_def_constraint';
		    //
		    if (tof(spec) === 'object') {
		        this.data_def = spec;
		    }
		},

	    /**
        * Returns `true` if the `value` matches the constraint.
        * @param {object} value - object to check
        * @memberof module:core/constraint.Data_Object_Def_Constraint
        * @instance
        * @example
        * var c = new Constraint.Data_Object_Def_Constraint({ name: "string", age: "number" });
        * c.match({ name: "John", age: 25 })  ==> true
        * c.match({ name: "John", age: "25" })  ==> false
        * c.match({ name: "John" })  ==> false
        */
		'match': function (value) {
			// value must be an object?
			var that = this;

			var tv = tof(value);
			if (tv == 'object') {
				//console.log('value ' + stringify(value));

				// need to see if the value matches the items in the data_def.
				var allMatch = true;

				each(this.data_def, function(field_name, field_def, stop) {
					var match = object_matches_def(value[field_name], field_def);
					//console.log('match ' + match);

					allMatch = allMatch && match;
					if (!allMatch) stop();
				});
				return allMatch;
				//throw 'stop';
			}
            //
			return false;
		} 
	});



	// Data_Object_Def_Constraint
	//  Though putting them in as individual field constraints may make sense...
	//   But the field constraints sound more like constraints on individual fields. Useful to validate a particular field,
	//    but the object validation may work differently.

	
	var Field_Constraint = Constraint.extend({

	    /** 
        * @classdesc Field constraint base class. The class is private.
        * @constructs module:core/constraint.Field_Constraint 
        * 
        */
	    'init': function (spec) {
			// if the spec is a string, then parse the string.
			
			// it may make reference to various data types.
			//  text, restricted or unrestricted length
			//  ints, numbers, etc
			//  various tests will be carried out, beyond tof.
			
			this.__data_type = 'field_constraint';
			
			//if (tof(spec) == 'string') {
				
			//}
			
			// A constraint can be / contain multiple other constraints.
			//  Maybe it should have that logic inside it, and these other constraints can be particular ones.
			
			// Code execution path... may be important getting that working before long, but now it does seem that specifying and
			//  validating these various types in JavaScript seems like an important thing to do.
			
			// 
			
			
		}
	// 'matches'
		
	
	})
	



	// A Data_Object_Constraint could help

	// Data_Object_Def_Constraint
	//  A single constraint, with the definition of various fields given concisely.
	//   This could have better performance as it's not instatiating as many objects to carry out the constraints.
	//    But it may be a problem with having different ways of doing the same things.

	// Defining fields in more detail may make sense, using Field objects.
	//  They make sense for DBs

	// But for object definitions, it may be useful to just jave the simplest form of input - they could be translated to
	//  the field system. We may have two ways of modifying the same data, and have them working together well.
	
	
	// Field constraints,
	//  Will translate to data types, and possibly further checks / validation that is done in the DB layer on input
	
	// Will 
	
	
	// Collection constraints
	//  These will translate to table constraints
	
	
	// data_type_constraint
	// field_data_type_constraint
	
	//  not null is not (really) a data type constraint.
	//  same with some check constraints. Does not seem like a very definite boundary though.
	
	var Field_Data_Type_Constraint = Field_Constraint.extend({

	    /** 
        * @classdesc Typed field constraint base class. 
        *
        * The class public name is <strong>Field_Data_Type</strong> (e.g. `new Constraint.Field_Data_Type()`).
        * @constructs module:core/constraint.Field_Data_Type_Constraint 
        * 
        */
	    'init': function (spec) {
			
			// also hold the data type itself.
			
			
			
			this._super(spec);
		}
	});
	
	
	
	var Text_Constraint = Field_Data_Type_Constraint.extend({

	    /** 
        * The constructor is private. Use from_obj() or {@link module:core/constraint.from_str|from_str()} to create this constraint.
        * @classdesc Text field constraint: checks value type (string) and possibly max length.
        * @constructs module:core/constraint.Text_Constraint 
        * @param {object} spec - constraint properties: `{}` or `{length: maxlength}`
        * 
        */
	    'init': function (spec) {
			// if the spec is a string, then parse the string.
			
			// it may make reference to various data types.
			//  text, restricted or unrestricted length
			//  ints, numbers, etc
			//  various tests will be carried out, beyond tof.
			
			//if (tof(spec) == 'string') {
			//	
			//}

			this._super(spec);
			if (is_defined(spec.length)) {
				this.length = spec.length;
			}
			
			// A constraint can be / contain multiple other constraints.
			//  Maybe it should have that logic inside it, and these other constraints can be particular ones.
			
			// Code execution path... may be important getting that working before long, but now it does seem that specifying and
			//  validating these various types in JavaScript seems like an important thing to do.
			
			// 
			
			
	    },

	    /**
        * Returns `true` if the `value` matches the constraint.
        * @param {*} value - value to check
        * @memberof module:core/constraint.Text_Constraint
        * @instance
        * @example
        * var c = Constraint.from_obj("text(3)");
        * c.match("123")  ==> true
        * c.match(123)  ==> false
        * c.match("1234")  ==> false
        *
        * var c = Constraint.from_obj("text");
        * c.match("1234567890")  ==> true
        */
	    'match': function (v) {
		    if (is_defined(this.length)) {
		        return (tof(v) == 'string' && v.length <= this.length);
		    } else {
		        return (tof(v) == 'string');
		    }
	    },

	    /**
        * Returns the constraint information object. The object can be following:
        * - `["text", length]` - if the constraint contains a maxlength restriction
        * - `"text"` - if the constraint does not contains a maxlength restriction
        * @memberof module:core/constraint.Text_Constraint
        * @instance
        * @example
        * var c = Constraint.from_obj("text(3)");
        * c.to_info_obj()  ==> ["text", 3]
        *
        * var c = Constraint.from_obj("text");
        * c.to_info_obj()  ==> "text"
        */
	    'to_info_obj': function () {
			if (is_defined(this.length)) {
				return ['text', this.length];
			} else {
				return 'text';
			}
			
			
		}
	// 'matches'
		
	})
	
	var Not_Null_Constraint = Field_Constraint.extend({
		
	    /** 
        * @classdesc "Not null" constraint: checks a value to be not null. 
        *
        * The class public name is <strong>Not_Null</strong> (e.g. `new Constraint.Not_Null()`).
        * @constructs module:core/constraint.Not_Null_Constraint 
        */
	    'init': function (spec) {
			// if the spec is a string, then parse the string.
			this._super(spec);
			
			
	    },

	    /**
        * Returns `true` if the `value` matches the constraint (i.e. value != undefined && value != null).
        * @param {*} value - value to check
        * @memberof module:core/constraint.Not_Null_Constraint
        * @instance
        * @example
        * var c = new Constraint.Not_Null();
        * c.match("123")  ==> true
        * c.match(null)  ==> false
        */
	    'match': function (v) {
			return is_defined(v) && v != null;
		}
	});
	
	// Objects that represent the data types themselves?
	//  Probably not going to use classes for that, just JS objects like arrays, maps.
	
	var Guid_Constraint =  Field_Data_Type_Constraint.extend({

	    /** 
        * @classdesc GUID field constraint: checks a value to a GUID string (e.g. `"{86DCA9A5-31AC-4F20-B552-4D1503D0D11C}"`). 
        *
        * The class public name is <strong>Guid</strong> (e.g. `new Constraint.Guid()`).
        * @constructs module:core/constraint.Guid_Constraint 
        */
	    'init': function (spec) {
			// if the spec is a string, then parse the string.
			this._super(spec);
			
			
	    },

	    /**
        * Returns `true` if the `value` matches the constraint (i.e. value is a GUID string).
        * @param {*} value - value to check
        * @memberof module:core/constraint.Guid_Constraint
        * @instance
        * @example
        * var c = new Constraint.Guid();
        * c.match("{86DCA9A5-31AC-4F20-B552-4D1503D0D11C}")  ==> true
        * c.match("86DCA9A5-31AC-4F20-B552-4D1503D0D11C")  ==> false
        */

	    'match': function (v) {
			//return tof(v) == 'number';
			
			// string of a given length...
			
			//  this will really be for translating to Mongo or SQL Server or other DB GUID types.
			
		    // "{86DCA9A5-31AC-4F20-B552-4D1503D0D11C}"
		    if (tof(v) === "string") {
		        var reg = /^{[A-Fa-f0-9]{8}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{12}}$/;
		        return reg.test(v);
            }
            //
		    return false;
			
	    },

	    /**
        * Returns the constraint information object (i.e. "guid" string).
        * @memberof module:core/constraint.Guid_Constraint
        * @instance
        * @example
        * var c = Constraint.from_obj("guid");
        * c.to_info_obj()  ==> "guid"
        */
	    'to_info_obj': function () {
			return 'guid';
		}
		
	})
	
	
	var Number_Constraint = Field_Data_Type_Constraint.extend({

	    /** 
        * The constructor is private. Use from_obj() or {@link module:core/constraint.from_str|from_str()} to create this constraint.
        * @classdesc Number field constraint: checks value to be a number.
        * @constructs module:core/constraint.Number_Constraint 
        */
	    'init': function (spec) {
			// if the spec is a string, then parse the string.
			this._super(spec);
	    },

	    /**
        * Returns `true` if the `value` matches the constraint (i.e. value is a number).
        * @param {*} value - value to check
        * @memberof module:core/constraint.Number_Constraint
        * @instance
        * @example
        * var c = Constraint.from_obj("number");
        * c.match(1)  ==> true
        * c.match("1")  ==> false
        */
	    'match': function (v) {
			return tof(v) == 'number';
		},

	    /**
        * Returns the constraint information object (i.e. "number" string).
        * @memberof module:core/constraint.Number_Constraint
        * @instance
        * @example
        * var c = Constraint.from_obj("number");
        * c.to_info_obj()  ==> "number"
        */
		'to_info_obj': function () {
			return 'number';
		}
		
	})
	
	var Int_Constraint = Number_Constraint.extend({

	    /** 
        * The constructor is private. Use from_obj() or {@link module:core/constraint.from_str|from_str()} to create this constraint.
        * @classdesc Int field constraint: checks value to be an integer number.
        * @constructs module:core/constraint.Int_Constraint 
        */
	    'init': function (spec) {
			// if the spec is a string, then parse the string.
			this._super(spec);
	    },

	    /**
        * Returns `true` if the `value` matches the constraint (i.e. value is an integer number).
        * @param {*} value - value to check
        * @memberof module:core/constraint.Int_Constraint
        * @instance
        * @example
        * var c = Constraint.from_obj("int");
        * c.match(1)  ==> true
        * c.match(1.5)  ==> false
        * c.match("1")  ==> false
        */
	    'match': function (v) {
			return tof(v) == 'number' && parseInt(v) === v;
		},

	    /**
        * Returns the constraint information object (i.e. "int" string).
        * @memberof module:core/constraint.Int_Constraint
        * @instance
        * @example
        * var c = Constraint.from_obj("int");
        * c.to_info_obj()  ==> "int"
        */
	    'to_info_obj': function () {
			return 'int';
		}
		
	})
	
	
	// Type_Constraint
	
	
	// Collection constraints as well
	//  These may not necessirily apply to JSGUI collections, but could be for translating to Table Constraints in SQL.
	
	
	// Collections will have different types of constraints.
	
	// Could be that every item needs to follow a set of field constraints.
	// Could also be that there are unique keys.
	//  May have fields specified.
	
	// This will work very well indeed when this is done. Should be intuitive to create the models, then these models will be very useful for 
	//  translating to different things. Some of the indexing functionality of the DB gets replicated on the client in a relatively small amount of code,
	//  allowing for some things to run in a very optimized way even on IE6.
	
	// It will be nice to see the things working fine in IE6 as well as modern browsers.
	
	
	
	
	
	var Collection_Constraint = Constraint.extend({
		
	    /** 
        * The class is private. 
        * @classdesc Collection constraints base class.
        * @constructs module:core/constraint.Collection_Constraint 
        */
	    'init': function (spec) {
			// if the spec is a string, then parse the string.
			
			// it may make reference to various data types.
			//  text, restricted or unrestricted length
			//  ints, numbers, etc
			//  various tests will be carried out, beyond tof.
			this.__data_type = 'collection_constraint';
			//if (tof(spec) == 'string') {
				
			//}
			
			// A constraint can be / contain multiple other constraints.
			//  Maybe it should have that logic inside it, and these other constraints can be particular ones.
			
			// Code execution path... may be important getting that working before long, but now it does seem that specifying and
			//  validating these various types in JavaScript seems like an important thing to do.
			
			// 
			
			
		}
	// 'matches'
		
	
	});
	
	// Not so sure about this being the same Data_Type_Constraint for Data_Objects...
	
	
	// May also have 
	
	// This can force a collection to hold only a particular type of object, tested with instanceof
	
	//  And not using the field system?
	//   So we could restrict a collection to only holding a String this way.
	
	var object_matches_def = function(value, def) {
		//console.log('object_matches_def');
		//console.log('value ' + stringify(value));
		//console.log('def ' + stringify(def));

		var tv = tof(value);

		//if (def == 'string') {
		//	return tv == 'string'
		//}
		//console.log('tv ' + tv);

		if (tv == def) {
			return true;
		}

		return false;

	}

	
	var Collection_Data_Def_Constraint = Collection_Constraint.extend({

	    /** 
        * @classdesc Collection fields definition constraint.
        *
        * The class public name is <strong>Collection_Data_Def</strong> (e.g. `new Constraint.Collection_Data_Def({})`).
        * @constructs module:core/constraint.Collection_Data_Def_Constraint 
        * @param {object} spec - data definition
        * 
        */
	    'init': function (spec) {

		    this._super();

		    //if (tof(spec) == 'function' && is_constructor_fn(spec)) {
			//	this.data_type_constructor = spec;
			//}
			//console.log('tof(spec) ' + tof(spec));
			//console.log('tof(String) ' + tof(String));
			
			if (tof(spec) === 'object') {
				this.data_def = spec;
			}
			
			// Def is not the data_type in terms of a constructor
			this._constraint_type = 'data_def';
			
		},

	    /**
        * Returns `true` if the `value` matches the fields constraint.
        * @param {object} value - object to check
        * @memberof module:core/constraint.Collection_Data_Def_Constraint
        * @instance
        * @example
        * var c = new Constraint.Collection_Data_Def({ name: "string", age: "number" });
        * c.match({ name: "John", age: 25 })  ==> true
        * c.match({ name: "John", age: "25" })  ==> false
        * c.match({ name: "John" })  ==> false
        */
	    'match': function (value) {
			// value must be an object?
			var that = this;

			var tv = tof(value);
			if (tv == 'object') {
				//console.log('value ' + stringify(value));

				// need to see if the value matches the items in the data_def.
				var allMatch = true;

				each(this.data_def, function(field_name, field_def, stop) {
					var match = object_matches_def(value[field_name], field_def);
					//console.log('match ' + match);

					allMatch = allMatch && match;
					//console.log('allMatch ' + allMatch);
					if (!allMatch) stop();
				});
				return allMatch;
				//throw 'stop';
			}

		} 
	});
	
	// Perhaps rename to Collection_Data_Type_Constructor_Constraint
	var Collection_Data_Type_Constraint = Collection_Constraint.extend({

	    /** 
        * @classdesc Collection item type constraint.
        *
        * The class public name is <strong>Collection_Data_Type</strong> (e.g. `new Constraint.Collection_Data_Type(Object)`).
        * @constructs module:core/constraint.Collection_Data_Type_Constraint 
        * @param {function} spec - item type constructor function
        * 
        */
	    'init': function (spec) {

		    this._super();

		    //if (tof(spec) == 'function' && is_constructor_fn(spec)) {
			//	this.data_type_constructor = spec;
			//}
			//console.log('tof(spec) ' + tof(spec));
			//console.log('tof(String) ' + tof(String));
			
			if (tof(spec) === 'function') {
				this.data_type_constructor = spec;
			}
			
			this._constraint_type = 'data_type';
			
		},
	    /**
        * Returns `true` if the `value` matches the item type constraint.
        * @param {object} value - object to check
        * @memberof module:core/constraint.Collection_Data_Type_Constraint
        * @instance
        * @example
        * var c = new Constraint.Collection_Data_Type(Number);
        * c.match(1)  ==> true
        * c.match("1")  ==> false
        * 
        * 
        * var c2 = new Constraint.Collection_Data_Type(MyBook);
        * c2.match(new MyBook())  ==> true
        * c2.match(new Number(1))  ==> false
        * 
        */
	    'match': fp(function (a, sig) {
			//console.log('');
			//console.log('*  match sig ' + sig);
			//console.log('this.data_type_constructor ' + this.data_type_constructor);
			//console.log('a[0] ' + a[0]);
			//console.log('tof(a[0]) ' + tof(a[0]));
			//console.log('a[0] instanceof this.data_type_constructor ' + (a[0] instanceof this.data_type_constructor));
			
			var ta0 = tof(a[0]);
			//console.log('ta0 ' + ta0);
			if (ta0 == 'number') {
				//console.log(this.data_type_constructor === Number);
				if (this.data_type_constructor === Number) return true;
			}
			// But can perform casting / conversion.
			if (ta0 == 'string') {
				//console.log(this.data_type_constructor === Number);
				if (this.data_type_constructor === String) return true;
			}
			
			if (this.data_type_constructor && a[0] instanceof this.data_type_constructor) {
				return true;
			}
			
			//if (sig == '[D]') {
			//	// matching a Data_Object against these constraints.
				
			//	//var c_res = this.data_object.obj_matches_field_constraints(a[0]);
			//	//return c_res;
				
			//	if (this.data_type_constructor) {
			//		return a[0] instanceof this.data_type_constructor;
			//	}
				
			//	//return 
				
			//}
			
			//// May be given a collection here.
			//if (sig == '[C]') {
			//	// A collection may hold constraints for a type of collection.
				
			//	// Database holds Tables Collection, which is of the Table item.
				
			//	// let's have a look at that collection.
			//	var obj = a[0];
			//	//console.log('obj ' + stringify(obj));
				
			//	// eg collection of tables.
			//	///  probably should have its data type constraint?
				
			//	var obj_name = obj.get('name');
			//	//console.log('obj_name ' + obj_name);
				
				
				
			//	// we may be able to get the data_type_constraint of that collection.
			//	//  It may be a dtc that implies it can take a collection, maybe a collection of a particular type of object.
				
			//	//console.log('obj._data_type_constraint ' + stringify(obj._data_type_constraint));
			//	// so, a collection when given a typed collection as it's data_type will need to respond correctly.
			//	//  setting its _data_type_constraint
				
			//	//console.log('obj._data_type_constraint.data_type_constructor ' + stringify(obj._data_type_constraint.data_type_constructor));
				
			//	//data_type_constructor
				
			//	//console.log('this.data_type_constructor ' + stringify(this.data_type_constructor));
			//	//var stack = new Error().stack
			//	//console.log( stack )				
			//	//throw('13) stop');
				
			//	//var res = obj instanceof obj._data_type_constraint.data_type_constructor;
			//	var res = obj instanceof this.data_type_constructor;
			//	//console.log('res ' + res);
			//	// nice, seems to work.
				
			//	return res;
			//	// see if the collection's _data_type_constraint matches the constructor in this constraint.
				
				
			//	// this does get a bit complicated with the same code being used on different nested levels.
			//	//  I'll need to cut down on feature addition on this, and make sure the API is working and stable.
			//	//  Document it too.
				
			//	// Just need it to generate these relational, or semi-relational databases.
			//	//  Need to get the whole web platform running.
				
			//	// The system has got pretty big, still will need a bit more for the whole database support.
			//	//  Will likely make some database connected extensions... or maybe more sync code in the 'Database' class.
								
			//	//return 
			//}
			//
			return false;
			
		})
	});
	
	// Will be used for checking every Table that gets put into a Database is a Table etc.
	//  Used to enforce ststic typing.
	
	// Something very similar could be used to enforce static typing on Data_Objects.
	//  That will restrict the objects that can get put into Data_Objects to being a particular class / subclass chain.
	
	// Collection_Data_Object_Constraint
	//  Used for making a Collection like a Table in a DB.
	//  This way the Collection is constrained to storing one type of object.
	
	// Could be a data type constraint... used for holding the required fields.
	//  Not just for checking the data_type... must check that the objects conform to the Data_Object's constraints.
	//  May be able to make a data_object that can't be constructed without the right fields...
	
	//var Collection_Data_Object_Constraint = Collection_Constraint.extend({
	//	'init': function(spec) {
	//		if (tof(spec) == 'data_object') {
	//			this.data_object = spec;
	//		}

	//		// May also want to define a table data object constraint like:
	//		//  {"address": "string", "family": "string", "internal": "boolean"}
	//		//  (is it a constraint really? or just a collection of fields?)
	//		//   I think it's a constraint because it restricts their types.

	//		//console.log('Collection_Data_Object_Constraint tof(spec) ' + tof(spec));


			
	//		this._constraint_type = 'data_object';
			
	//	},
	//	'match': fp(function(a, sig) {
	//		//console.log('match sig ' + sig);
	//		//console.log('match a ' + stringify(a));
	//		if (sig == '[D]') {
	//			// matching a Data_Object against these constraints.
				
	//			var c_res = this.data_object.obj_matches_field_constraints(a[0]);
	//			return c_res;
	//		}
			
	//		// May be given a collection here.
	//		if (sig == '[C]') {
	//			// A collection may hold constraints for a type of collection.
				
	//			// Database holds Tables Collection, which is of the Table item.
				
	//			// let's have a look at that collection.
	//			var obj = a[0];
	//			//console.log('obj ' + stringify(obj));
				
	//			// get the constraint for that field...
	//			//  it should have been put in when the field gets specified.
				
	//			//each(obj, function(i, v) {
	//			//	console.log('i ' + i);
	//			//	console.log('v ' + v);
	//			//});
				
	//			// a lower level each?
	//			//  The Collection object has got fairly big and complicated.
	//			//  want to be able to view all its constraints easily.
				
	//			// it may have a data_type_constraint.
	//			/*
	//			var coll_dtc = obj._data_type_constraint;
	//			console.log('coll_dtc ' + coll_dtc);
	//			//console.log('coll_dtc ' + stringify(coll_dtc));
				
				
				
				
	//			var stack = new Error().stack
	//			console.log( stack )
				
				
	//			throw('14) stop');
	//			*/
	//			return true;
				
				
	//		}
			
	//	})
		
	//});
	
	
	
	
	// One of these can be set to primary. The first one is by default.
	//  The order of the unique indexes matters.
	
	var Unique_Constraint = Collection_Constraint.extend({

	    /** 
        * @classdesc Collection unique constraint.
        *
        * The class does not provide the `match()` method, but provides `.fields` property for the unique field names.
        *
        * The class public name is <strong>Unique</strong> (e.g. `new Constraint.Unique()`).
        * @constructs module:core/constraint.Unique_Constraint 
        * @param {string|string[]} spec - unique field name(s)
        * 
        */
	    'init': function (spec) {
			this._super(spec);
			
			//this.set('constraint_type', 'unique');
			
			this._constraint_type = 'unique';
			
			// field (name) or actual field (reference to a field constraint).
			
			// but field could be plural too
			//  will be a convention that the singular here can sometimes refer to plural.
			//  maybe plural would be better?
			if (is_defined(spec.fields)) this.fields = spec.fields;
			
			if (tof(this.fields) == 'array') {
				this._sorted_fields = clone(this.fields).sort();
			}		
	    }

	    /** 
        * @name fields
        * @member
        * @type {string|string[]}
        * @memberof module:core/constraint.Unique_Constraint
        * @instance
        * @example
        * var c = new Constraint.Unique("ID");
        * c.fields  ==> "ID"
        * 
        */


		// not really sure the constraint will do much here... it requires an index to be set up.
		//  perhaps tells the index not to accept duplicates?
	
		// test the constraint?
		//  do that outside for the moment
	
	
	});
	
	
	
	
	//var Relationship_Constraint = Collection_Constraint.extend({
	//	'init': function(spec) {
	//		this._super(spec);
			
	//		// which other collection(s) and field(s) does it reference?
			
	//		// what form does the relationship take?
			
	//		// files in a folder
	//		//  aggregation
	//		//  has (composed of)
	//		//  many-to-one
	//		//   aggregation_to_item (but maybe we would be saying the folder 'has' files)
			
			
	//		// friends
	//		//  many-to-many
	//		//  association
	//		//  has (as friend) / is associated with
	//		//   use join table
	//		//   association_between_items
			
	//		// employees-projects
	//		//  many-to-many
	//		//  association
	//		//  is associated with 
	//		//   use join table
	//		//   association_between_items
			
			
	//		// user_roles
	//		//  aggregation? 
	//		//  maybe association
	//		//  one-to-many
	//		//  user is associated with roles
			
	//		// employee-pay_band
	//		//  association?
	//		//  one_to_one
	//		//  user has that pay band
			
	//		// Compositon for sub-items?
			
	//		// May be interested in mapping inheritance for this object system
	//		//  At the moment, need to just map the JavaScript structures into the database, then we'll get to work with
	//		//  building up the database and components of it that deal with website functionality.
			
	//		// Once things can quickly be declared and then created in the database, it should be relatively fast to implement programmatic
	//		//  components that work quickly with the DB and also can be created quickly.
			
	//		// There is some more to do with this work, but now it is at a really good stage where it is able to do a lot of things in the background.
	//		//  With some more coding, it will do a whole bunch more things.
			
	//		// Will do some more work on the XML / HTML transformation.
	//		//  That would be one of the really amazing things if I were to release it with that.
			
	//		// The declarative writing of these pages would be very interesting and get people interested with the JSGUI platform.
	//		//  That part is also something it would be interesting to get written in C++ or C.
			
	//		// Also, will be interesting to have bits and pieces about technology on the website.
	//		//  Presentations.
			
	//		// I think it could be very good advertising for my own services, and releasing the JSGUI open source framework will do a lot to help this.
	//		//  I'm likely to release the client-side framework, as well as a server distribution.
	//		//  I doubt it would be the full / development / internal distribution, but one that has various very useful features.
			
	//		// I would likely license commercial modules as well, such as a Postgres Connector.
	//		//  Also would have a marketplace for those who wish to sell their own components - and may well be selling advertising to those who
	//		//  want to sell their own components for it, possibly through Google.
			
	//		// May do deals with component makes, could have sponsored listings? 
			
	//		// The basic framework should probably be released as open-source, then I should be set for employing people and getting paid to develop this code
	//		//  further for clients in their systems.
			
	//		// I think this could make it easy to get a high performance web server running.
	//		//  That will be very nice indeed. I think both the ease of use and customizability will be high.
			
	//		// It will be very nice to have an advanced admin interface going alongside it.
	//		//  Won't require installing files, images etc, could be using a few vector images.
	//		//  It may surprise people when they see it, thinking, where did that come from, when they are doing simple, easily,
	//		//   but there is quite a complicated enabling system allowing it to work.
			
	//		// Am getting much closer to the software goals.
	//		//  Think I'll get a really nice system online. Don't know quite how long.
	//		//  I'll get a lot done over the next few days.
			
	//		// There may be a few more things to get really right along the execution path.
	//		//  There is quite a lot to do with the HTML that needs to work.
	//		//  Some of this will be expressed in terms of field corrections and constraints.
			
	//		// There is maybe another 3000 more lines that needs to be written for this?
			
	//		// The server side library will be big, but will be focused on producing efficient client-side output
	//		//  I'll do work on documenting it.
			
	//		// It would be interesting to see how big a build (sequentially ordered) of the JavaScript file is.
	//		//  Perhaps some things would need to be renamed so that lots of vars in the global namespace would work together.
	//		//  There would be a large amount of gain possible in the build process.
			
	//		// The size of the small client library is nudging upwards. Perhaps it will be a 24KB download? Even 32?
	//		//  It will definitely be impressive though, will enable lots of things, useful business interactions.
			
	//		// Could have a very useful system for conference attendees.
	//		//  However, need to do the constraints.
			
			
			
			
	//		// Likely to go into more detail on the relationship constraints when actually making them.
	//		//  Perhaps will be related to something in the same collection or Data_Object?
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
	//		// Could talk to D about setting up the implementations of it.
	//		//  
			
			
			
			
			
			
			
			
			
			
			
			
			
			
	//		// Also like the idea of having a donate for feature box.
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
	//		/*
	//		 * �Each Order is associated with one or more OrderLines.�

	//			�Each OrderLine is associated with one and only one Order.�
				
	//			�Each OrderLine is associated with one and only one Product.�
				
	//			�Each Product is associated with zero or more OrderLines.�
	//		 * 
	//		 */
			
			
			
	//	}
	//	// not really sure the constraint will do much here... it requires an index to be set up.
	//	//  perhaps tells the index not to accept duplicates?
	//});
	
	
	// Relationship
	
	// Foreign_Key constraint?
	//  Maybe call this a Reference or Relationship constraint.
	
	// Expressed in the data model, this could describe a many-to-many relationship that gets expressed using a links table in an RDB.
	//  Possibly using a links, or the general links / relationships table in an ODB.
	
	
	
	
	
	// Not so sure about specifying primary keys here...
	//  The things used as PKs in this system may not be PKs in the database. The PKs may all be incrementing numeric IDs in the database.
	//   That could make a lot more sense, but not in all situations.
	
	// Primary Unique Index in this situation... that will be a constraint that gets translated to unique index.
	
	
	
	
	
	// With collections, they will be saying that records are to have a property, and some uniqueness conditions should be satisfied.
	
	// NOT NULL - collection
	// UNIQUE - collection
	// PRIMARY KEY - collection
	// FOREIGN KEY - collection
	// CHECK - field but likely applied through the collection
	// DEFAULT - field but likely applied through the collection
	
	// There is quite a bit to do to get this data model working within JavaScript.
	//  Then it will be a question of getting it translating itself to other languages.
	//  Creating the RDB model, then the Postgres model, then the actual code used to create it, then running that code.
	//  These translation steps will result in a fairly substantially sized piece of software, quite powerful too.
	//   The functionality could still be fairly small in a download.
	
	// I think this could make a very nice app on the iPad, there would be quite a lot that could be made in terms of database design.
	//  Then emailing the setup code, maybe running the setup code from the iPad.
	// Being able to view all the code, a fairly focused IDE for making Postgres code.
	//  Could do quite a lot on the iPad without selling an app, and then sell an app as well.
	
	// They kind of all refer to fields, but it's to do with how these fields interact with other fields and fields in other tables/collections that
	//  make them either field or collection constraints
	
	// Text_Constraint
	// Number_Type_Constraint
	// Integer_Type_Constraint
	
	// These type constraints could also be able to parse data that does not match the constraint.
	//  Perhaps a regex could be run on a string if it's expecting something else.
	
	// Multiple_Constraint (different constraints get satisfied)
	
	
	// Indexed_Array_Constraint
	
	// All basically run tests on the object to see if it meets the constraint or not.
	
	// also get the constraint from an object.
	// some things will be expressed as (nested) JavaScript objects.
	
	// This, as well as sorting out this parsing system to be like ASP.NET, will take a while longer.
	//  On the server, it will be possible to use much more code to do what is needed.
	//  On the client, making use of existing DOM parsing would make more sense.
	
	
	
	// Different types of constraint.
	//  I think types like 
	/* from_obj instead
	var value_as_field_constraint = function(val) {
		// more flexible than getting it from a string.
		//  may be dealing with nested things too.
		
		
		
		
	}
	*/


	
    /** 
    * Creates a constraint using the definition string. See {@link module:core/constraint.from_str|from_str()} for possible definition strings.
    * @func
    * @name from_obj
    * @variation 1
    * @param {string} str - constraint definition string
    * @memberof module:core/constraint
    * @example
    * c = Constraint.from_obj("int");
    * c = Constraint.from_obj("text(10)");
    */

    /** 
    * Creates a constraint using the "string and number" definition. The following definitions are supported:
    * - `["text", <length>]` - creates {@link module:core/constraint.Text_Constraint|Text_Constraint}, where "`<length>`" is the max text length allowed
    * @func
    * @name from_obj
    * @variation 2
    * @param {array} arr_of_str_and_num - constraint definition
    * @memberof module:core/constraint
    * @example
    * c = Constraint.from_obj(["text", 10]);
    */

    /** 
    * Creates a constraint using the "string and string" definition. The following definitions are supported:
    * - `["unique", <fieldName>]` - creates {@link module:core/constraint.Unique_Constraint|Unique_Constraint}, where "`<fieldName>`" is the unique field name
    * @func
    * @name from_obj
    * @variation 3
    * @param {array} arr_of_str_and_str - constraint definition
    * @memberof module:core/constraint
    * @example
    * c = Constraint.from_obj(["unique", "SomeID"]);
    */




	var from_obj = fp(function(a, sig) {
		// Should be able to interpret things as either Field or Collection constraints.
		//  Nice how Field constraints will be applyable to a Collection.
		//   This will be like setting columns in the database.
		
		// This sophisticated data model will be applicable to many database situations / scenarios.
		//  Should make it really fast to produce a database with CRUD SPs.
		//  Easy to translate from the requirements into the finished product.
		//   Convenient GUI tools for specifying the requirements.
		
		// Would be good to directly monetize this software pretty soon.
		//  I can get something impressive online soon that will get me customers and income from adverts.
		
		// Will definitely put together a good online presence.
		
		// Together with resources, ORM, and Je-Suis XML... will take some time.
		//  Also needing the web database interface.
		
		// It all has been coming on a lot very recently.
		//  Need to do more to turn it into a comprehensive web platform.
		
		// Will be a whole application including CMS.
		
		// For the moment, will continue with the single goal of getting the framework running, fully displaying my HTML website.
		
		//  I envisage my website will make use of some nice animations, and have some nice demos.
		//  A few animations in a portfolio section too.
		//   Section on work I have done (hype Brandon Generator a little bit).
		//  Technology demostrations.
		
		// Will get this whole website very polished, and will see how many people start using it.
		//  I think I could get some more widespread usage of the library, then get consultancy work regarding it.
		// Interact with the customers through the website.
		
		// OK... need to do more on this constraint system.
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		//console.log('constraint.js from_obj sig ' + stringify(sig));
		
		if (sig == '[s]') {
			return constraint_from_str(a[0]);
			
		}

		if (sig == '[D]') {
			//return constraint_from_str(a[0]);

			//console.log('a[0]', a[0]);
			//throw 'stop';

			var res = new Data_Object_Constraint({});
			res.data_object = a[0];
			return res; 
			
		}
		
		
		
		if (a.l == 1 && tof(a[0]) == 'array') {
			//console.log('constraint.js from_obj sig ' + stringify(sig));
			//console.log('constraint.js from_obj obj ' + stringify(a[0]));
			
			var obj = a[0];
			
			var obj_sig = get_item_sig(obj, 1);  // was get_item_sig(obj);
			//console.log('obj_sig ' + obj_sig);
			//console.log('obj ' + stringify(obj));
			
			// could be given [s,n]
			// eg ['text', 32]
			
			if (obj_sig == '[s,n]') {
				var data_type_name = obj[0];
				var length = obj[1];
				
				if (data_type_name == 'text') {
					var constraint = new Text_Constraint({'length': length});
					return constraint;
				}
				
			}
			
			
			if (obj_sig == '[s,s]') {
				var constraint_type = obj[0];
				//  then another parameter, if it's a unique constraint then the other param is the field_name
				//console.log('constraint_type ' + constraint_type);
				if (constraint_type == 'unique') {
					var field_name = obj[1];
					
					// we don't have the actual field, but got its name.
					//  the name would do for the moment.
					var constraint = new Unique_Constraint({
						'fields': field_name
					});
					//console.log('constraint ' + constraint);
					return constraint;
					
					
					
				}
				
				if (constraint_type == 'text') {
					
					
				}
				
				// if it's a text constraint... that's a field type.
				
				
				
				
				
				
			}
			
			
			
		}
		
		//if (sig == '[D]') {			
		//	var constraint = new Collection_Data_Object_Constraint(a[0]);
		//	//console.log('constraint ' + constraint);
		//	return constraint;
		//}
		
		
		
		
		// Need to really do a lot on the execution path of this.
		//  I think the whole database transformation system is necessary to get it to run, it's an integral part of the system.
		//  Getting access to relational databases is critical for the whole software to perform its intended functions.
		
		
		
		
		
		
		// an array, 2 strings...
		
		// may wind up using a variery of constraint definitions
		//  they will be interpreted here into constraint objects, which can be put in collections, and these used to test DataObjects.
		
		// Can be used for making abstract definitions of things, before data goes in.
		//  Then these abstract definitions are used in order to create the database and interact with it
		
		// Made loads of progress with the object system, constraints are going to be a very powerful feature.
		//  Requirements may also be there as a different API, perhaps requiring constraints to be matched,
		//  also some more advanced programmatic checks that would get expressed in JavaScript, whereas the constraints are 
		//  a system that will be translatable into different particular methodologies.
		
		
		
		
		
		
		
		
		
		
		
		//throw ('stop');
		
	})
	
	
    /**
    * Creates a constraint using the definition string. The following definitions are supported:
    * - "int" - creates {@link module:core/constraint.Int_Constraint|Int_Constraint}
    * - "number" - creates {@link module:core/constraint.Number_Constraint|Number_Constraint}
    * - "text" - creates {@link module:core/constraint.Text_Constraint|Text_Constraint} without max length restriction
    * - "text(<length>)" - creates {@link module:core/constraint.Text_Constraint|Text_Constraint}, where "<length>" is the max text length allowed
    * - "guid" - creates {@link module:core/constraint.Guid_Constraint|Guid_Constraint}
    * @func from_str
    * @param {string} str - constraint definition
    * @memberof module:core/constraint
    * @example
    * c = Constraint.from_str("int");
    * c = Constraint.from_str("text(10)");
    */
	var constraint_from_str = function (str) {
		//console.log('constraint_from_str str ' + str);
		// will check the cache for it though.
		
		// will need to choose the type of the constraint.
		
		// if it's a string it won't be that complicated, I think.
		//  may be best to use regular expressions to detect what kind of constraint it is.
		
		// It may be a string with some parameters.
		// Not really wanting essentials to get bigger, but thing some extra string processing may be of use before this.
		//  Jsgui-util currently has the data types, so that one is fairly big.
		
		// Functionality will be brought over from Nested... except it will work differently
		//  In nested, there is a Data_Type_Instance.
		//  In this case, I think it will be Constraints, and more declarative descriptions of the data types.
		
		// It will be intended to mirror in some ways the data types and constraints that are in databases.
		//  Constraints could apply to collections, saying that key values must be unique, eg no one has the same NI number.
		
		
		// examples
		// 'string', 'int', 'text', 'text(32)', 
		
		// Perhaps these are like Data_Type_Instance objects, but they'll be called constraints here.
		//  They may not be limited to being data types, but they should do the same jobs.
		// The data types they reference... not so sure about making Data_Type_Instances or not.
		// Constraints as a concept makes more sense, especially when defining databases.
		
		// I think this system before too long could produce some really advanced functionality.
		//  With this abstraction made it will be possible to get development work uing it I hope.
		
		// Not quite sure how or if this will be competing with backbone.
		//  I think having the jsgui domain, having it there, with a demo and discussion, talking about it on twitter,
		//  showing the twitter feed on the website using nuce UI components...
		
		// Some simple downloadable pieces / builds
		// A system using node.js that will provide the right JavaScript client library to the clients
		// Make it easy to get running from downloads, easy-to-view examples and documentation within the downloads.
		
		// I think it could make a very sophisticated website system. Could have a graphical IDE where componets can be put in place, it generates the code for
		//  that.
		
		
		// Go through, looking for some patterns as regular expressions.
		//  If we have identified them, we have the values needed for the constraint.
		
		var rx_specified_length_text = /^text\((\d+)\)$/;
		// the data type could possibly be handled by input processors.
		//  I think that makes sense, moving input_processors out of nested and into essentials.
		//   It's an expandable system, the basis for it will not take much. The relevant input processors could be added by Data_Object, but 
		//   then be available throughout the system, such as for dealing with function calls, or data types which can have a length.
		
		
		
		
		
		var match_slt = str.match(rx_specified_length_text);
		
		//console.log('match_slt ' + match_slt);
		
		if (match_slt) {
			var length = parseInt(match_slt[1]);
			//console.log('length ' + tof(length));
			var constraint = new Text_Constraint({
				'length': length
			})
			return constraint;
		}
		
		if (str === 'text') {
		    var constraint = new Text_Constraint({})
		    return constraint;
		}

		if (str === 'int') {
		    var constraint = new Int_Constraint({})
		    return constraint;
		}

		if (str === 'number') {
			var constraint = new Number_Constraint({})
			return constraint;
		}
		
		if (str === 'guid') {
			var constraint = new Guid_Constraint({})
			return constraint;
		}
		
		
		
		
		//throw('stop');
		
		
		
		
	}
	
	Constraint.from_obj = from_obj;
	
	Constraint.from_str = constraint_from_str;
	Constraint.obj_matches_constraint = obj_matches_constraint;
	
	Constraint.Not_Null = Not_Null_Constraint;
	Constraint.Unique = Unique_Constraint;
	Constraint.Data_Object_Def_Constraint = Data_Object_Def_Constraint;
	//Constraint.Collection_Data_Object = Collection_Data_Object_Constraint;
	Constraint.Collection_Data_Type = Collection_Data_Type_Constraint;
	Constraint.Collection_Data_Def = Collection_Data_Def_Constraint;
	Constraint.Field_Data_Type = Field_Data_Type_Constraint;
	Constraint.Guid = Guid_Constraint;

    module.exports = Constraint;

	//return Constraint;
//});

                                                   

},{"./jsgui-lang-essentials":37}],27:[function(require,module,exports){

/*
if (typeof define !== 'function') {
    var define = require('amdefine')(module);
}


define(["./jsgui-lang-essentials", "./jsgui-data-structures", "./constraint"], function(jsgui, Data_Structures, Constraint) {
	*/
var jsgui = require('./jsgui-lang-essentials');
var Data_Structures = require('./jsgui-data-structures');
var Constraint = require('./constraint');

	// May need to test controls and data objects separately before running a document server with them.

	// Constraints as well as a modular bolt-on?

	// Creates the Constraints data type... so a constraint specified with a string can be tested against
	//  also a cache of the constraints that have been made through the string - quick to get them again for reuse when testing.

	// Constraint objects can be saves and used in various places.
	//  They may not always be referred to directly, that would save on the amount of code needed.

	// They will help in making a model of what gets put into a database.
	//  A few constraints put in place in the domain model or similar will help with its translation to a database model.

	// These wide-ranging things should help a lot with creating a wide range of performant databases quickly.
	// It will also be a good tool in itself.

	// Interaction between the fields collection and the indexes...
	//  need to have it so that fields get indexed when appropriate.
	// When constructing a Data_Object or Collection, the fields may get set, and the fields need to be indexed accordingly.





	var j = jsgui;
	var Class = j.Class;
	var each = j.each;
	var is_array = j.is_array;
	var is_dom_node = j.is_dom_node;
	var is_ctrl = j.is_ctrl;
	var extend = j.extend;
	var get_truth_map_from_arr = j.get_truth_map_from_arr;
	var get_map_from_arr = j.get_map_from_arr;
	var arr_like_to_arr = j.arr_like_to_arr;
	var tof = j.tof;
	var is_defined = j.is_defined;
	var stringify = j.stringify;
	var functional_polymorphism = j.functional_polymorphism;
	var fp = j.fp;
	var arrayify = j.arrayify;
	var mapify = j.mapify;
	var are_equal = j.are_equal;
	var get_a_sig = j.get_a_sig;
	var get_item_sig = j.get_item_sig;
	var set_vals = j.set_vals;
	var truth = j.truth;
	var trim_sig_brackets = j.trim_sig_brackets;
	var ll_set = j.ll_set;
	var ll_get = j.ll_get;
	var input_processors = j.input_processors;
	var iterate_ancestor_classes = j.iterate_ancestor_classes;
	var is_arr_of_arrs = j.is_arr_of_arrs;
	var is_arr_of_strs = j.is_arr_of_strs;
	var is_arr_of_t = j.is_arr_of_t;
	var clone = jsgui.clone;

	var data_value_index = 0;
	var data_value_abbreviation = 'val';

	// do data objects get an ID when they are initialized.
	jsgui.__data_id_method = 'init';

	var obj_matches_constraint = Constraint.obj_matches_constraint;
	var native_constructor_tof = jsgui.native_constructor_tof;

	var value_as_field_constraint = Constraint.value_as_field_constraint;

	var Ordered_String_List = Data_Structures.Ordered_String_List;

	// When setting the fields, indexes may need to be set too...


	// gets a value as a field_constraint object.
	//var ensure_data_type_data_object_constructor = j.ensure_data_type_data_object_constructor;


	// So, Data_Objects may have a Page_Context, Application_Context, or just Context.
	//  The Context would include info such as which browser is being used.
	//   Controls will render differently depending on the context.

	// jsgui.data_types_info and data_type will become much more closely integrated into this.
	//  Perhaps there should be another module level for this.

	// Not sure about introducing it here. Maybe in lang-essentials? Don't want that to get too big.

	// Data_Object Flags is the next thing here...
	//  But that requires a Collection.
	// Can make Enhanced_Data_Object?
	//  Or make Data_Object enhance itself once it has a Collection.
	//  Or could do Flags on a lower level.

	// Quite a complicated question.
	//  Flags running as a collection of strings makes a lot of sense.
	//   Will be ordered etc.

	var parse_field_text = function(field_text) {
		field_text = field_text.replace(/not null/g, 'not_null');
		var is_unique = false;
		var is_indexed = false;
		var is_not_null = false;
		var is_read_only = false, is_pk = false;
		var field_words = field_text.split(' ');
		var flag_words = [];
		var str_data_type;
		var word;
		for (var c = 0, l = field_words.length; c < l; c++) {
			word = field_words[c];
			if (c < l - 1) {
				flag_words.push(word);
			} else {
				str_data_type = word;
			}
		}
		each(flag_words, function(i, v) {
			if (v == 'unique') {
				is_unique = true;
			}
			if (v == 'pk') {
				is_pk = true;
			}
			if (v == 'indexed') {
				is_indexed = true;
			}
			if (v == 'not_null') {
				is_not_null = true;
			}
			if (v == 'readonly' || v == 'read_only' || v == 'read-only') {
				is_read_only = true;
			}
		});
		var data_type = parse_data_type(str_data_type);
		var res = {
			//'is_unique': is_unique,
			//'is_indexed': is_indexed,
			//'is_not_null': is_not_null,
			'data_type': data_type
		}
		if (is_read_only) {
			res.read_only = is_read_only;
		}
		if (is_pk) {
			res.pk = is_pk;
		}
		if (is_unique) {
			res.unique = is_unique;
		}
		if (is_not_null) {
			res.not_null = is_not_null;
		}
		if (is_indexed) {
			res.indexed = is_indexed;
		}
		return res;
	}


	var parse_data_type = function(data_type_text) {

		//console.log('data_type_text ' + data_type_text);
		// will return the data type info as an object / array

		// could just return a string
		// could return [dt_name, length]

		// should not begin with a number

		//var rx_dt = /^(([a-z]|[A-Z]|_)\w*)(\([a-z]|[A-Z]|_\w+\))?$/;
		var rx_dt = /^(([a-z]|[A-Z]|_)\w*)(\((\d+)\))?/;

		// then check to see the match.

		var match = data_type_text.match(rx_dt);


		//console.log('match ' + stringify(match));

		if (match) {
			var dt_name = match[1];
			var dt_length = parseInt(match[4]);

			if (is_defined(dt_length) &! isNaN(dt_length)) {
				return [dt_name, dt_length];
			} else {
				return dt_name;
			}
		}

		//throw('parse_data_type stop');
	}


	var field_obj_to_text = function(field_obj) {
		//var res = [];

		var words = [];
		if (field_obj.unique) {
			words.push('unique');
		}
		if (field_obj.pk) {
			words.push('pk');
		}
		if (field_obj.indexed) {
			words.push('indexed');
		}
		if (field_obj.not_null) {
			words.push('not_null');
		}
		if (field_obj.read_only) {
			words.push('read_only');
		}


		/*

		if (is_defined(field_obj.length)) {
			words.push(field_obj.data_type);
			words.push('(');
			words.push(field_obj.length);
			words.push(')');
		} else {
			words.push(field_obj.data_type);
		}
		*/

		if (tof(field_obj))

		return words.join(' ');
	}


	// Could make a basic Data_Object too?
	//  Basic_Collection?

	// Then have different levels?
	var Fields_Collection = Class.extend({
		// a way of getting all the field names?

		// The Field_Collection could hold the context perhaps.

		'init': function(spec) {

			// could have a map of positions of fields?
			//  also, a Linked_List may be useful here.

			// That way fields could be quickly added. Order gets maintained.

			// Fields are really used as a system of influencing the lower-level constraints and indices.
			//  They are a convenient way of representing information about a field.

			// Perhaps an Ordered_List makes sense.
			//  Like a Linked_List, a wrapper that uses a Linked List for the Ordered List functionality.

			// Fields are definitely kept in order that way.
			//  Linked_Map seeming like a useful data structure.

			// Not storing a context for the fields?

			this.okvs = new Data_Structures.Ordered_KVS();
			//this.containing_object = spec.containing_object;


		},

		'_get_field_index': function(field_name) {
			//var res = -1;
			//each()

			// Maybe a linked list would work best... that way we can search through it (iterate until stop) to find the relevant item.
			//  linked list with an index as well? map holding a link to the node that holds the field item.

		},


		// Could maybe test just the fields collection?
		//  So we make a new collection of fields not associated with a control?


		// Needs more work on this part...
		//  Making it polymorphic and flexible, covering all or at least enough cases.

		// Non polymorphic version would be a lot faster.
		//  Perhaps using an inner function for the [string, value] operations, and the
		//   iterative version makes use of that.
		//'set': fp(function(a, sig) {
		'set': (function() {
	      var a = arguments;
	      a.l = arguments.length;
	      var sig = get_a_sig(arguments, 1);

			// Prime candidate for optimization here.

			// When setting an indexed array Data_Object, it sets a field collection.
			//  This is the case with a Color Data_Object.
			//   It has fields for red, green, blue. Perhaps alpha.


			/* This needs to work:

			'fields': {
				'products': Products_Collection
			},

			*/

			// [field name, function (constructor)]

			// will add the field to the array.

			//console.log('Fields_Collection set a ' + stringify(a));
			//console.log('Fields_Collection set sig: ' + sig);
			//console.log('Fields_Collection set a ' + stringify(a));
			// and when this has 2 strings...

			//throw 'stop';

			//console.log

			// [[n,s],[n,a]] - That looks possibly wrong anyway.

			// Using a (constructor) function in the field defintion.
			// ['networkInterfaces', NetworkInterfaces]

			var that = this;
			//var containing_object = that.containing_object;
			// str, str
			//  field_name, str_field_def
			// what about setting a single field with an array?

			// can check the formats - string, anything

			// Will have fairly versitile field definitions.

		    // [[['content', ['collection', 'control]]]]
			//console.log(">>> sig=" + sig);
			if (sig == '[a]') {

				//console.log('a.l ' + a.l);

				var item_or_arr = a[0];
				//var ioa_sig = get_item_sig(item_or_arr);
				var ioa_sig = get_item_sig(item_or_arr, 2);

				// want the signature that will go into the array.
				//  need to use a new option on get_item_sig
				//console.log('ioa_sig ' + ioa_sig);
				//console.log('item_or_arr ' + stringify(item_or_arr));
				// need to sort out this code...

				// But we don't want to misinterpret a single field as an array of fields.


				// ioa_sig [[s,~C],[s,s],[s,s],[s,~C],s]

				// array, string

				// [a,a]
				//  data type info is on the left.
				//  then the value(s) are on the right.


				//console.log('item_or_arr ' + stringify(item_or_arr));

				if (ioa_sig == '[s,s]') {
					// string name with string field representation
					var field_name = item_or_arr[0];
					var field_str_def = item_or_arr[1];

					//console.log('field_name ' + field_name);

					//console.log('*** *** field_str_def ' + field_str_def);

					var field_obj = parse_field_text(field_str_def);
					//console.log('field_obj ' + stringify(field_obj));


					var field_arr = [field_name, field_str_def, field_obj];

					//console.log('setting with field_arr ' + stringify(field_arr));

					this.set(field_arr);

					//field_obj.parent(containing_object);

				} else if (ioa_sig == '[s,f]') {
					// the function is a constructor function (should be one, maybe test this?)

					// A Class field.

					var field_name = item_or_arr[0];
					var field_str_def = 'Class';
					var field_obj = item_or_arr[1];

					var field_arr = [field_name, field_str_def, field_obj];

					// then actually do the set.

					//  find the index of the item
					//console.log('putting in okvs field_name: ' + field_name);
					//console.log('putting in okvs field_name: ' + field_name);
					this.okvs.put(field_name, field_arr);

					//throw 'ioa stop';

				} else if (ioa_sig == '[s,s,o]') {
					// string name with string field representation
					var field_name = item_or_arr[0];
					var field_str_def = item_or_arr[1];
					var field_obj = item_or_arr[2];
					//var field_arr = [field_name, field_str_def, field_obj];
					//this.set(field_arr);



					var field_arr = [field_name, field_str_def, field_obj];

					// then actually do the set.

					//  find the index of the item
					//console.log('putting in okvs field_name: ' + field_name);
					//console.log('putting in okvs field_name: ' + field_name);
					this.okvs.put(field_name, field_arr);
					//field_obj.parent(containing_object);

				} else {
					//console.log('other array, check for arr_of_arrs');
					//var ioa_sig = get_item_sig(item_or_arr);

					//console.log('ioa_sig ' + ioa_sig);

					// But there could be a collection - perhaps an abstract collection.
					//  I think indicate type as ~Collection.
					//  and ~C



					// n,s,s,? - the item in the ? is the defailt_value.

					// will use regex \d matching.

					var rx_test_sig_default_value = /\[n,\[s,s,\w\]\]/;


					// Ordinal position of fields...
					//  May need to be careful about that.


					if (ioa_sig == '[n,[s,s]]') {
						// a number, the index in array / sequence, then name, then data_type_name

						//console.log('item_or_arr ' + stringify(item_or_arr));

						var field_def = item_or_arr[1];
						var field_name = field_def[0];
						var field_type_name = field_def[1];

						//console.log('field_name ' + field_name);
						//console.log('field_type_name ' + field_type_name);

						if (field_type_name == 'collection') {
							// should be a collection of that type.

							//var field_arr = [field_name, field_type_name, field_item_type_name];#
							if (field_item_type_name) {
								var field_arr = [field_name, [field_type_name, field_item_type_name]];
							} else {
								var field_arr = [field_name, field_type_name];
							}

							// then actually do the set.
							//  find the index of the item
							//console.log('putting in okvs field_name: ' + field_name);
							this.okvs.put(field_name, field_arr);


						} else {

							// I think the field collection here is really just for storing info about the fields.
							//  It is when the objects represented by fields are get and set that the field functionality really comes into play.

							// can be the same as with collection!
							//  may do some more checks?

							var field_arr = [field_name, field_type_name];

							//console.log('field_arr ' + stringify(field_arr));

							// then actually do the set.
							//  find the index of the item
							//console.log('putting in okvs field_name: ' + field_name);
							this.okvs.put(field_name, field_arr);
							//console.log('done okvs put');

							//throw('7)stop');
						}
					} else if (ioa_sig.match(rx_test_sig_default_value)) {
						//console.log('matches regex, has default value.')
						//console.log('ioa_sig ' + ioa_sig);
						//throw 'stop';
						var field_def = item_or_arr[1];
						//console.log('item_or_arr ' + stringify(item_or_arr));
						var field_name = field_def[0];
						var field_type_name = field_def[1];
						var field_default_value = field_def[2];


						if (field_type_name == 'collection') {
							// should be a collection of that type.
							throw 'Default values for Collection not supported';
							//var field_arr = [field_name, field_type_name, field_item_type_name];#
							if (field_item_type_name) {
								var field_arr = [field_name, [field_type_name, field_item_type_name]];
							} else {
								var field_arr = [field_name, field_type_name];
							}

							// then actually do the set.
							//  find the index of the item
							//console.log('putting in okvs field_name: ' + field_name);
							this.okvs.put(field_name, field_arr);


						} else {

							// I think the field collection here is really just for storing info about the fields.
							//  It is when the objects represented by fields are get and set that the field functionality really comes into play.

							// can be the same as with collection!
							//  may do some more checks?

							var field_arr = [field_name, field_type_name, field_default_value];

							//console.log('field_arr ' + stringify(field_arr));

							// then actually do the set.
							//  find the index of the item
							//console.log('putting in okvs field_name: ' + field_name);
							this.okvs.put(field_name, field_arr);
							//console.log('done okvs put');

							//throw('7)stop');
						}

					}

					// if it's a string and an object


					if (ioa_sig == '[s,[s,s]]') {
						var field_name = item_or_arr[0];
						var field_def = item_or_arr[1];
						var field_type_name = field_def[0];
						var field_item_type_name = field_def[1];

						if (field_type_name == 'collection') {
							// should be a collection of that type.

							//var field_arr = [field_name, field_type_name, field_item_type_name];
							var field_arr = [field_name, [field_type_name, field_item_type_name]];
							// then actually do the set.
							//  find the index of the item
							//console.log('putting in okvs field_name: ' + field_name);
							this.okvs.put(field_name, field_arr);
						}
					} else {
						//console.log('* item_or_arr ' + stringify(item_or_arr));
						//console.log('ioa_sig ' + ioa_sig);
						//console.log('a ' + stringify(a));

						// Have changed the way that signatures work... now it's a for array.


						if (ioa_sig == '[]') {


						} if (ioa_sig == '[o]') {
							//console.log('ioa sig is an object ');
							//console.log('item_or_arr ' + stringify(item_or_arr));
							throw 'stop';
						} else {
							//console.log('pre stop');
							//throw ('6)stop');



							// Should have a more complete picture of the fields... where do these come from?

							// [s,o] object being a more complex definition.
							//  possibly a compound object.

							// An object with more field definitions declared within it.
							//  Will opt for lazy loading in various cases where possible.
							//   But some default values will need to be loaded at times.
							//    May also need to get loaded upon stringify.

							//



							/*
							["object", "dom_attributes", "string"]
							ioa_sig [s,s,s]
							*/

							/*
							'node': 'object',
							'attributes': 'dom_attributes',
							'tagName': 'string'
							*/

							// Maybe do more testing of Data_Object or Data_Object fields.
							//  Will try a single field of a Data_Object with a particular type.

							if (ioa_sig == '[s,o]') {
								// it's a compound definition.
								// will need to create the next level down, ie create the new Data_Object, and set its
								//  fields.

								// An object indicates it's a Data_Object.
								//  It's a field that gets declared with a particular data_type.
								//   That goes into the fields and constraints for that object.
								var fieldName = item_or_arr[0];
								var fieldDef = item_or_arr[1];

								// So there is a data type name? ie field name, and its data inside?
								// anyway, need to make a Data_Object with those fields.

								// Need to be able to make a Data_Object using fields that are supplied as an object
								//  rather than an array of arrays.



								//console.log('fieldDef ' + stringify(fieldDef));

								var field_arr = [fieldName, ['data_object', fieldDef]];
								this.okvs.put(fieldName, field_arr);

								// can we put this in relatively easily?
								//  the complicated part is interpreting the field.

								//throw 'stop';

							}

							//console.log('ioa_sig ' + ioa_sig);
							//console.log('item_or_arr ' + stringify(item_or_arr));
							//console.log('OTHER CASE!!!!');

							// [s,[o]]
							//  means a named array/collection of objects/dataobjects.
							//   in that case, we create a collection, and give it the type defined inside.

							if (ioa_sig == '[s,[o]]') {
								var fieldName = item_or_arr[0];
								var fieldItemDef = item_or_arr[1][0];

								// needs to make a collection field.

								// var field_arr = [field_name, [field_type_name, field_item_type_name]];

								// But won't go making nested data types?
								//  needs to ensure the types specified inside match OK,
								//  so need to (recursively) go into the definition.

								//console.log('fieldItemDef ' + stringify(fieldItemDef));

								// include more data in the info about the fields?
								//  do that to make it work in a more deeply nested way?
								//   or think some more about nested fields.

								// The field needs to be defined as being a collection of that type.
								//var field_arr = [fieldName, ['collection', field_item_type_name]];
								var field_arr = [fieldName, ['collection', fieldItemDef]];
								this.okvs.put(fieldName, field_arr);


								//throw 'stop';

							}



							if (ioa_sig == '[s,~C]') {
								// string, abstract collection

								// Items in an array...

								// need to set the field to hold an abstract collection....

								// Setting a field to an abstract collection of strings.
								//  We have supplied the abstract collection but we want there to be a collection instance.

								// Need to create the field of that actual type within the field collection.

								var t_abstract = native_constructor_tof(item_or_arr[1]._type_constructor);
								//console.log('t_abstract ' + t_abstract);
								//console.log('item_or_arr[1] ' + stringify(item_or_arr[1]));


								if (t_abstract) {
									var field_name = item_or_arr[0];
									var field_arr = [field_name, ['collection', t_abstract.toLowerCase()]];
									//console.log('field_name ' + field_name);
									//console.log('field_arr ', field_arr);
									this.okvs.put(field_name, field_arr);
								} else {
									var field_name = item_or_arr[0];
									var field_arr = [field_name, 'collection'];
									//console.log('field_name ' + field_name);
									//console.log('field_arr ', field_arr);
									this.okvs.put(field_name, field_arr);
								}

								// we can make a new field without the abstract condition of the constructor.
								//  will then eventually get these tags, and css-matched tags operating.
								// Then will be able to set up behaviours relatively easily.

								// Typed collections as data types is another thing to consider, as well as the syntax for declaring
								//  the abstract typed collections.
								// This hopefully will not introduce too much code bloat, it will be very good to get this system
								//  compressed right down for use in client apps. Could have things reduced down to a few KB (maybe 12?)
								//   and this would also allow for various application items to be working nicely.



								//throw 'stop';

							}
						}


					}
					// [[s,[s,s]]]
					// eg ['content', ['collection', 'control']]
					// [items]
					// [[str_name, str_type]]

					// could be a collection of something.

					var aoa = is_arr_of_arrs(item_or_arr);
					//console.log('aoa ' + aoa);

					if (aoa) {
						var c = 0, l = item_or_arr.length;
						for (c = 0; c < l; c++) {
							this.set(item_or_arr[c]);
						}

					}

					//if (aoa) {
					//	each(item_or_arr, function(i, v) {
					//	    that.set(v);
					//	});
					//}
					/*
					if (aoa) {
						//var this_set_call = this.set.call;
						var this_set = this.set;
						for (var c = 0, l = item_or_arr.length; c < l; c++) {
							this_set(item_or_arr[c]);
						}
					}
					*/
				}
			};

			if (sig == '[o]') {
				// add each one
				//var that = this;
				var a0 = a[0];

				if (Object.keys) {
				    // object.keys will hopefully be faster.
				    var a0_keys = Object.keys(a0);
                    //
				    var c = 0, l = a0_keys.length;
				    for (c = 0; c < l; c++) {
				        var a0_key = a0_keys[c];
				        this.set([a0_key, a0[a0_key]]);
				    }
				} else {
				    // Older JS code
                    for (i in a0) {
                        this.set.call(this, [i, a0[i]]);   
                    }
				}


				/*
				each(a[0], function(field_name, field_def) {
					//console.log('i ' + stringify(i));
					//console.log('v ' + stringify(v));
					//console.log('');
					that.set([field_name, field_def]);
				});
				*/



			}

			// then for setting in other ways...
			//  name then field definition.


			if (a.l > 1) {
				//console.log('longer a.l');
				//throw 'stop';
			    //this.set(a);
			    this.set(arr_like_to_arr(a));
            }


			/*
			if (a.l == 1 && tof(a[0]) == 'array') {
				each(a[0], function(i, field_arr) {

				});
			}
			*/
			// [s,[s,o]]

			// s, o
			// o

			// the object representation of a field, can have various flags.

			/* var res = {
				'is_unique': is_unique,
				'is_indexed': is_indexed,
				'is_not_null': is_not_null,
				'data_type': data_type

				// possibly name

			} */

			// str, arr
			//

		}),
		'get': function(a0) {
			//console.log('Fields_Collection get sig: ' + sig);
			var ta0 = typeof a0;
			if (ta0 == 'undefined') {
				// get them all
				// just the objects though?
				return this.okvs.values();
			} else if (ta0 == 'string') {
				return this.okvs.get(a0);
			}
			/*
			if (sig == '[s]') {
				// get a single field.
				//console.log('fc get ' + a[0]);


				//console.log('this.okvs.length() ' + this.okvs.length());
				// does it have anything with that key?

				var res = this.okvs.get(a[0]);

				//console.log('a[0] ' + a[0]);
				//console.log('this.okvs.keys() ' + this.okvs.keys());

				//console.log('Fields_Collection get ** res ' + stringify(res));
				return res;
			}
			*/
		},
		/*
		'_get': fp(function(a, sig) {
			//console.log('Fields_Collection get sig: ' + sig);

			if (sig == '[]') {
				// get them all
				// just the objects though?
				return this.okvs.values();
			}
			if (sig == '[s]') {
				// get a single field.
				//console.log('fc get ' + a[0]);


				//console.log('this.okvs.length() ' + this.okvs.length());
				// does it have anything with that key?

				var res = this.okvs.get(a[0]);

				//console.log('a[0] ' + a[0]);
				//console.log('this.okvs.keys() ' + this.okvs.keys());

				//console.log('Fields_Collection get ** res ' + stringify(res));
				return res;
			}
		}),
		*/
		'fields': function() {
			return this.get.apply(this, arguments);
		},
		/*
		'_fields': fp(function(a, sig) {
			return this.get.apply(this, a);
		}),
		*/

		'out': function(key) {
			this.okvs.out(key);
		},
		'clear': function() {

		}
	})



	Fields_Collection.parse_field_text = parse_field_text;
	Fields_Collection.parse_data_type = parse_data_type;

	//return Fields_Collection;
    module.exports = Fields_Collection;

//})

},{"./constraint":26,"./jsgui-data-structures":35,"./jsgui-lang-essentials":37}],28:[function(require,module,exports){
/*
if (typeof define !== 'function') {
    var define = require('amdefine')(module);
}


define(["./jsgui-lang-essentials", "./jsgui-data-structures", "./constraint", "./data-object-fields-collection"],
	function(jsgui, Data_Structures, Constraint, Fields_Collection) {

	*/
var jsgui = require('./jsgui-lang-essentials');
var Data_Structures = require('./jsgui-data-structures');
var Data_Value = require('./data-value');

var Constraint = require('./constraint');
var Fields_Collection = require('./data-object-fields-collection');
var Evented_Class = require('./evented-class');

	// Creates the Constraints data type... so a constraint specified with a string can be tested against
	//  also a cache of the constraints that have been made through the string - quick to get them again for reuse when testing.

	// Constraint objects can be saved and used in various places.
	//  They may not always be referred to directly, that would save on the amount of code needed.

	// They will help in making a model of what gets put into a database.
	//  A few constraints put in place in the domain model or similar will help with its translation to a database model.

	// These wide-ranging things should help a lot with creating a wide range of performant databases quickly.
	// It will also be a good tool in itself.

	// Change events
	// -------------

	// Want to have different levels of responding to change events.
	//  It gets a bit complicated with the same data represented in different places and also in transmission between them.
	//  Data will have various different statuses.
	//  Need to be able to recieve data from the server, and update the client data models, and announce it within the client app,
	//   without then telling the server that the data has been changed on the client, unless it makes it clear to the server that the client was
	//   making the change as the server requested. That change acknowledgement could be a useful feature on the client.
	//    Don't want that to be more than an acknowledgement though.
	//   Also need to deal with change initiation properly.
	//    The change could be initiated on the client, needs to be updated on the server, and then sent to the various different clients.
	//     Could have different levels of receipt validation there too, so that the client knows once the change has been recieved (and processed?) by
	//      the other clients. This could be useful for amber and green lights in a chat system, for example.
	///    Receipt of message validation would also be useful for data structures and making them transactional if possible.

	// So, we need a type of set that is for updating the data from an updated external source.

	// notify_change_from_external
	//  and when that has processed it could send a receipt of update message notification back to the server.
	//  That should probably be optional.














var j = jsgui;
var Class = j.Class;
var each = j.each;
var is_array = j.is_array;
var is_dom_node = j.is_dom_node;
var is_ctrl = j.is_ctrl;
var extend = j.extend;
var get_truth_map_from_arr = j.get_truth_map_from_arr;
var get_map_from_arr = j.get_map_from_arr;
var arr_like_to_arr = j.arr_like_to_arr;
var tof = j.tof;
var is_defined = j.is_defined;
var stringify = j.stringify;
var functional_polymorphism = j.functional_polymorphism;
var fp = j.fp;
var arrayify = j.arrayify;
var mapify = j.mapify;
var are_equal = j.are_equal;
var get_item_sig = j.get_item_sig;
var get_a_sig = j.get_a_sig;
var set_vals = j.set_vals;
var truth = j.truth;
var trim_sig_brackets = j.trim_sig_brackets;
var ll_set = j.ll_set;
var ll_get = j.ll_get;
var input_processors = j.input_processors;
var iterate_ancestor_classes = j.iterate_ancestor_classes;
var is_arr_of_arrs = j.is_arr_of_arrs;
var is_arr_of_strs = j.is_arr_of_strs;
var is_arr_of_t = j.is_arr_of_t;
var clone = jsgui.clone;

var data_value_index = 0;
var data_value_abbreviation = 'val';

// do data objects get an ID when they are initialized.
jsgui.__data_id_method = 'init';

var obj_matches_constraint = Constraint.obj_matches_constraint;
var native_constructor_tof = jsgui.native_constructor_tof;

var value_as_field_constraint = Constraint.value_as_field_constraint;

var Ordered_String_List = Data_Structures.Ordered_String_List;


// gets a value as a field_constraint object.
//var ensure_data_type_data_object_constructor = j.ensure_data_type_data_object_constructor;


// So, Data_Objects may have a Page_Context, Application_Context, or just Context.
//  The Context would include info such as which browser is being used.
//   Controls will render differently depending on the context.

// jsgui.data_types_info and data_type will become much more closely integrated into this.
//  Perhaps there should be another module level for this.

// Not sure about introducing it here. Maybe in lang-essentials? Don't want that to get too big.

// Data_Object Flags is the next thing here...
//  But that requires a Collection.
// Can make Enhanced_Data_Object?
//  Or make Data_Object enhance itself once it has a Collection.
//  Or could do Flags on a lower level.

// Quite a complicated question.
//  Flags running as a collection of strings makes a lot of sense.
//   Will be ordered etc.

// Could make a basic Data_Object too?
//  Basic_Collection?

// Then have different levels?


var Mini_Context = Class.extend({

    // Need quite a simple mechansm to get IDs for objects.

    // They will be typed objects/

    'init': function(spec) {


        var map_typed_counts = {}
        var typed_id = function(str_type) {
            throw 'stop Mini_Context typed id';

            var res;
            if (!map_typed_counts[str_type]) {
                res = str_type + '_0';
                map_typed_counts[str_type] = 1;
            } else {
                res = str_type + '_' + map_typed_counts[str_type];
                map_typed_counts[str_type]++;
            }
            return res;
            /*
            var iTypedIds = {};
            if (typeof iTypedIds[str_type] === 'undefined') {
                    iTypedIds[str_type] = 1;
            }

            var typed_id = function(str_type) {
                if (typeof iTypedIds[str_type] === 'undefined') {
                    iTypedIds[str_type] = 1;
                }
                var res = iTypedIds[str_type];
                iTypedIds[str_type] = iTypedIds[str_type] + 1;
                return res;
            };
            this.qid = qid;
            */
        }
        this.new_id = typed_id;
        //new_id
    },

    'make': function(abstract_object) {
        if (abstract_object._abstract) {
            //var res = new
            // we need the constructor function.

            var constructor = abstract_object.constructor;
            //console.log('constructor ' + constructor);


            //throw 'stop';

            var aos = abstract_object._spec;

            // could use 'delete?'
            aos.abstract = null;
            //aos._abstract = null;
            aos.context = this;

            //console.log('abstract_object._spec ' + stringify(abstract_object._spec));
            // Not sure it is creating the right constructor.


            var res = new constructor(aos);
            r
            return res;
        } else {
            throw 'Object must be abstract, having ._abstract == true'
        }
    }

});


// Enhanced_Data_Object with flags seems like one of the best options.
//  These flags can easily correspond to CSS classes in an MVC system too, CSS will be automatically updated when the object's properties change.

// And Control will inherit from Enhanced_Data_Object.
//  Flags is not a massive enhancement, but there could be more.
//  Could maintain a Collection of references to other Data_Objects and Enhanced_Data_Objects more conveniently.


// Want either express-like routing, or to lift the routing out of Express.
//  It may be worth integrating Express right into this, for the things that Express does.
//   There may be various things that Express does not do, but could be called upon to assist with.
//    JSGUI seems very much about building the HTML, and acting as MVC on client and server. It could use Express.
//     Or it could incorporate Express.
//      Perhaps JSGUI can be used by Express to render pages.
//       Will have it compatable, but there will be some overlapping features.
//       jsgui could use some Express routing by default.

// Having je suis XML running soon will be nice!
//  Could serve from a directory.
//   Want to get that working as that will really be the code path that is taken.
//   Could get a site up and running using that before so long...
//    But also want to have the discussion forum running. Doubt I want all the ORM for that, but will be able to get it running in a document database before too long.
//   Then the system will definitely be quite fast.
//    Would not be all that much user data, but would need to start to keep it backed up / consistent.

// Data_Object is not using 'nested' at the moment.

// Nested has got fairly complicated, it's fairly good though.
//  Perhaps it will wind up being refactored into Data_Object and uses of that.

// Currently Nested is dealing with data types.

// We need to ensure that data getting put into Data_Objects meets data type criteria.
// Nested also has the ability of transforming data.
// 1) Meets the criteria
// 2) Meets criteria for transformation into the correct data

// The data types can be dealing with nested information too.
//  I think dealing with nested information will wind up in the core.
//  The core may wind up being abit big, but it's all important stuff.
// With 4G and the use in various environments like conference halls, downloading 32KB onto an iPad would not be a problem.
//  I think the whole thing could load very quickly, then present the user with a powerful application.



// The schemas system is going to be namespaced, and will use a Namespaced_Dict object, which will use a B+ tree, for retrieval by prefix.

// Should possibly be called constrints.
// Having Constraints built right into Data_Object may be the most suitable thing to do.

// It is the same terminology as databases.
//  Field constraints makes sense too.

// Constraints that apply to whole collections - the same language used to talk about indexes.
//  Indexes will be used to power unique constraints, so it'll make use of the 'constraint' terminology.

// Bringing the focus to 'constraints' will help bridge the gap into the database world.
// Things will be expressable in a way that is more closely transferrable,
//  though some constraints in this system will be represented using types in other systems.

// This will possibly become quite a widely used MVC paradigm.

// I think having plenty of tests, API documentation, and well-written tutorial / reference documentation will help a lot.
//  Can have quite a few pages of this documentation with Google adverts.
// I would be interested to see how much a small amount of advertising on the documentation part of my site will make.
//  Also, advertising will not be shown to the paying customers.



// constraint function?
//  and can give it multiple constraints?

// be able to get information about the constraints that are applied to a Data_Object as well.
//  Remember, the constraints won't be stored in a collection.


// They will be called constraints.

// constraint?
// singular does make sense because we do keep giving them maps and arrays to process.

// The constraints in use on the Data_Object will be field constraints.

// Data_Object needs more work to do with setting, getting, and checking against its fields.
//  Have checking for collections, but need checking for changing a field's value.

//  The fields system here will have clear, logical results when testing.
//   Possibility of connection a fields check onto the object class, or having one for all objects of that class?
//   Don't want to be holding lots of repeated data about fields in memory, though it's not really a major problem to begin with.



// easy api with add_field etc...
// ensure_field.
// remove_field
//  would need to remove indexes


// perhaps just call them field_constraints for the moment.
//  saying a field is indexed... that has more to do with the collection.

// Will not use a 'Field' object.
//  Fields will be held in the form [name, [string_representation, obj_representation]]

// Fields_Collection?
//  This seems like a nice encapsulation of the fields functionality, stopping the Data_Object from becoming too complicated itself.
//   The fields may have some indexes added for faster lookup at a later stage, Data_Object can easily use the API.
//  set_field  (ensure_field) / set
//  remove_field / remove / out
//  get_field / get(field_name)
//  get_fields / get()
//  set_fields / set(map or array)
//   other lower level things, remove_field_index(field_name), remove_field_unique(field_name), remove_field_flag(field_name, flag_name), add_field_flag etc
//    also while suppressing raising of events (when an index has been deleted, this will be about updating the field so that it does not refer to that index.
//    these will be carried out when indexes or constraints (that refer to fields) are added/removed

// Will also raise events for when fields are added, removed, or changed.
//  This will enable other components, that refer to fields, such as Constraints and Indexes, to remain updated.
//   When adding / removing constraints, will need to have that update the field info, maybe modify fields while suppressing events.

// All lower level collection systems...
//  not arranged around Data_Objects

// The Index_System does the job with indexes on a collection.


// Fields referring to the field constraints.
//  Field constraints being their own classes... fields not being so?

// Fields referring to their actual indexes. Collection has the Index_System, but we need to be referring to indexes from the field?
//  or just hold the info in the field that it is to be indexed. Modifying this can alert the collection so that it removes the index from the field.

// Some constraints / indexes will only apply to fields of objects within a collection.


// Constraints_Collection
// Indexes_Collection?

// [field_name, [str_repr, obj_repr]]

// will coerce the types a little - ensure it is arr3_field format
//  [name, str_def, obj_def]


// This will hold a collection of fields that are used by an object.
//  They get maintained in a particular order.

// But what exactly are these fields?

// Stores an array of fields...?


//var map_jsgui_ids = {};

// Won't be a whole map of IDs for every object made by jsgui.
//  They will be stored within a Page_Context.
//  There had been a great slowdown for subsequent requests. Definitely don't want that.

/*

var new_data_value_id = function() {
    var res = data_value_abbreviation + '_' + data_value_index;
    data_value_index++;
    return res;
};
*/

// I think Data_Object will be made so that it can act as a Data_Value.
//  It will work in a very constrained mode, such as only holding one value, such as a string.
//  It may also hold a field name and a value.
// Data_Object(String);

// Collection using a Data_Value constraint?
//  Constrinat testing is already in Data_Object.

// Data_Value is likely to have a type. It could have type checking. Needs to be lightweight though.

// I think the Data_Value will also have events.
//  Change event being the main one of interest at the moment.








// This system will exist within the Page_Context
//  We don't want loads of these controls / Data_Objects to stay within the normal application memory all the time.


// Context will hold these indexes.
//  A context will be set up for each page request.
//  Request_Context?
//  Page_Context on the client?

// Lots of objects will have links to their contexts.
//  Will make it easy to get info about what browser / front-end capabilities there are.




/*

var data_object_index = 0;
var data_object_abbreviation = 'do';

var new_data_object_id = function() {
    var res = data_object_abbreviation + '_' + data_object_index;
    data_object_index++;
    return res;
};

*/

// What about turning a normal object into a DataObject?
//var t_id_num = 0;
// May be good for testing the collecton and data object.

// Don't want the Data_Object to always be betting IDs (after all).
//  Don't want to always have to have a context - though for many purposes a context will help when rendering HTML.
//   Has got in the way of other simpler things.

var is_js_native = function(obj) {
    var t = tof(obj);
    return t == 'number' || t == 'string' || t == 'boolean' || t == 'array';
}


// Should maybe make it extend Evented_Class
//  Data_Value would extend that as well.

// Control would have specific handling for DOM events.

// With EVented_Class in lang-essentials?



// Data_Objects have contexts.
//  Not sure about registering every Data_Object within the context.
//  It seems worthwhile having Controls registered within a Page_Context.
//  Perhaps data, registered within a Data_Context (which I am yet to make) could enable a spreadsheet to have components that get notified about changes to the data.

// I think that I will have controls register themselves within the context.
//  call context.register_control()


var Data_Object = Evented_Class.extend({
    'init': function(spec) {
        // but it could do a different initialization as an abstract object.
        //  Collection(String) seems more like an abstract collection, or even a newly defined type.
        //  because of its easy syntax, Collection(String) makes a lot of sense to use.
        // going without the new keyword when we are not particularly looking for an actual new collection,
        //  but something that signifies its type as a collection of strings.
        //   May be possible to have these running in abstract (or schema?) mode.
        //   I think abstract mode fits in well with names we already are using.

        //console.log('begin Data_Object init');

        // bound_events needs to be overhauled quite a lot.
        //  There is a major problem with it right now.

        //  It's not staying within the context.
        //   Don't really want to be storing the index of object ids?
        //    could be useful during the creation of the page.


        // can have 'abstract': true in the spec,
        //  we will get this if it was called without the 'new' keyword as well.
        if (!spec) spec = {};
        //if (!is_defined(spec)) {
        //	spec = {};
        //};

        // if it's abstract call the abstract_init.

        if (spec.abstract === true) {
            //throw 'stop abstract';
            // this may need to be more lightweight.

            this._abstract = true;

            // iinit = instance init?
            //  with it only needing to save the spec, not do further initialization?



            //console.log('tof(spec) ' + tof(spec));

            // And with the spec as a function, we'll be able to say that each item must match that constructor
            //  However, there are only a few native JavaScript functions to check this against.

            // As a function, it gives a type constructor.
            //(console.log('tof(spec) ' + tof(spec)));
            var tSpec = tof(spec);

            if (tSpec == 'function') {
                this._type_constructor = spec;
                // could possibly
                // but maybe want to keep this json-friendly.

                // the type constructor could be used in a collection.
                //  could be more leightweight than other things? specific constraint objects.
            }
            // Abstract controls won't be dealing with events for the moment.
            if (tSpec == 'object') {
                this._spec = spec;
                // could possibly
                // but maybe want to keep this json-friendly.

                // the type constructor could be used in a collection.
                //  could be more leightweight than other things? specific constraint objects.
            }

        } else {
            var that = this;
            this._initializing = true;

            var t_spec = tof(spec);
            //console.log('t_spec', t_spec);

            if (!this.__type) {
                this.__type = 'data_object';

            }

            if (!this.hasOwnProperty('_')) {
                this._ = {};
            }

            if (t_spec == 'object') {
                // Normal initialization

                if (spec.context) {
                    //console.log('spec has context');

                    this._context = spec.context;
                }

                if (spec._id) {
                    this.__id = spec._id;
                }

            }
            if (t_spec == 'data_object') {
                // Initialization by Data_Object value (for the moment)

                // Not so sure about copying the id of another object.

                if (spec._context) this._context = spec._context;

                // then copy the values over from spec.

                var spec_keys = spec.keys();
                //console.log('spec_keys', spec_keys);

                each(spec_keys, function(i, key) {
                    that.set(key, spec.get(key));
                });


            }


            // Why would the spec be a function?








            //this._relationships = {};

            // when setting a value with another Data_Object,
            //  make the child one remember the parent relationship.
            //  may be possible to have multiple parents, could be that a data set is referred to in two places. When that data set changes it will get changed in
            //   all of its parents too.

            // not so quick.
            //  Don't want that item appearing unnecessarily.
            //  May ensure it at a later stage.

            //this._requirements = {};

            // then __type_name
            // __data_type_obj? (maybe not needed because of (quick) lookup from name, seems more memory efficient?)

            //var ctr = this.caller;
            //var dtn = ctr.data_type_name;
            //console.log('dtn ' + dtn);
            //console.log('this.__type_name ' + this.__type_name);
            //console.log('this.__data_type_info ' + stringify(this.__data_type_info));

            // and if a data type has been declared, we'll be parsing the input.
            // will essentially be setting the 'value' in the spec.

            // always the case with constructors when given a data_type?
            //console.log('do this.__type ' + this.__type);

            //console.log('jsgui.__data_id_method ' + jsgui.__data_id_method);
            //throw 'stop';

            if (!is_defined(this.__id) && jsgui.__data_id_method == 'init') {

                // It should have the context...
                //  But maybe there can be a default / application / initialization context (not serving a particular page).
                //   Things to do with processing jsgui would be in that context.

                if (this._context) {
                    //console.log('this._context ' + this._context);
                    //console.log('sfy this._context ' + stringify(this._context));
                    this.__id = this._context.new_id(this.__type_name || this.__type);
                    //console.log('DataObject new ID from context: ' + this.__id);

                    //this._context.map_objects[this.__id] = this;
                    // Not keeping a map of objects by id in the context.

                } else {

                    // Use the default context.
                    // possibly make a new_data_object_id function?

                    // Maybe don't need to give all data objects ids.

                    //var create_id = function()
                    /*
                    var new_data_object_id = function() {
                        var res = '_tid_' + t_id_num;
                        t_id_num++;
                        console.log('new temp id ' + res);
                        return res;
                    }

                    console.log('no context found - creating new temp id. should have context');

                    this.__id = new_data_object_id();

                    */
                    // don't think we keep a map of all IDs, or we will do within a Page_Context.
                    //map_jsgui_ids[this.__id] = this;
                    // and make sure it is within the index / map of jsgui objects with ids.
                }


            }

            // don't get it from the prototype
            // It was copying over from the prototype.
            //  01/07/2012, it took a while to track this down.
            //   Copying things over from a prototype could prove very useful.
            //   May do more work on a type system, and then rebuild the whole thing around a type / class system that is definitely more advanced.
            //

            // so, not getting it through the prototype chain.


            // is also going to have a _fields object.
            //  the _fields will have different things in them.

            // Not sure about this.

            if (is_defined(this.__type_name)) {
                spec = {
                    'set': spec
                }
            };

            /*
            if (is_defined(spec.data_def)) {
                //spec = {
                //	'set': spec
                //}

                this.

            };
            */

            // data_def

            //this._ = this._ || {};
            //var _ = this._;

            // ensure(this, '_');
            //var _ = this._ = this._ || {};


            // but the collection could be made in the prototype I
            // think???

            // console.log('that._collection_names ' +
            // that._collection_names);

            // The collection names... could be dealt with using the
            // data_type_instance methods.

            // Interesting... has collections inside.

            // ok, so it works so far.

            // but with the collection properties - can these be
            // initialized here?
            // maybe do that within the collection property....
            // but may need to check too much.

            // the chain of fields... not sure how the chain needs to work backwards.
            //  for person recorded: [[0, ["flags", ~Collection(String)]], [0, ["dob", "date"]], [1, ["name", "string"]]]
            //  maybe need to join them together better? into a fields list?
            //  so we start with the most recent ones?
            //  fields map so we know what they are by name, so ignoring the repeated ones going back, who's definition will have been overwritten.
            //  Then we use the chained fields in the right order... set the fields up?
            //   But I think we want lazy field loading anyway.

            // Need to have the dom field available to HTML.

            var chained_fields = get_chained_fields(this.constructor);
            var chained_fields_list = chained_fields_to_fields_list(chained_fields);

            //var chained_fields_list = chained_fields_to_fields_list(get_chained_fields(this.constructor));
            // need to look at how the chained fields are set up.
            //  I think various (chained) fileds will get set up during the normal initialization of the library.



            // It may not be setting up the fields right for Color.
            //  There is an indexed array of red, green, blue.




            //console.log('chained_fields ' + stringify(chained_fields));


            //console.log('* chained_fields ' + stringify(chained_fields));
            //console.log('* chained_fields_list ' + stringify(chained_fields_list));
            // the chained fields list seem OK.

            // But making just a list of fields out of the chained ones...
            //  is it working OK?

            //throw 'stop';

            //console.log('* chained_fields_list ' + stringify(chained_fields_list));
            //throw 'stop';
            // then process the chained fields to fields list...

            // Need to set the Context?

            // I think only make the fields collection if there are fields.

            if (chained_fields_list.length > 0) {
                this.fc = new Fields_Collection({

                    // Fields collection has a context?

                    //
                    //'containing_object': this
                });

                // but the field object itself may be created on get.
                //  need to make sure at that time it has its parent.

                // need to check how this is getting set now.
                //  This is only really dealing with setting up some info for the fields, the fields will likely be empty until they are needed,
                //   using lazy loading to save memory.
                //console.log('');
                //console.log('');
                //console.log('*** chained_fields_list ' + stringify(chained_fields_list));

                //this.fc.set(chained_fields);
                this.fc.set(chained_fields_list);

                // the fields collection... that needs to handle fields that are given
                //  as constructor functions.
                //   maybe assume a function is a constructor function?
                //    then a 'products' field that is given by a constructor function
                //     would then have a connected field that sets that value.


                var do_connect = this.using_fields_connection();
                if (do_connect) {

                    var arr_field_names = [], field_name;
                    each(chained_fields, function(i, field_info) {
                        //console.log('field_info ' + stringify(field_info));

                        field_name = field_info[1][0];
                        //console.log('field_name ' + field_name);
                        arr_field_names.push(field_name);
                    });

                    // just an array of fields.
                    //console.log('arr_field_names ' + stringify(arr_field_names));
                    this.connect_fields(arr_field_names);
                }
            }


            // does set work OK?



            // that should have done it...
            //  the field collection should now hold info about all of the fields.


            //this.fields(chained_fields);



            // also, if we have fields (obtained through the field chain in this case), we then need to check if the fields get connected.
            //  this is a nice way of doing things, making it easy to specify, but without too much going on automatically.

            //


            // have something in the prototype that says the collection
            // names?
            // order of bound events called not strictly set.


            // could possibly do this at a later stage of initialization, once the variables have been set for sure.
            //  could have already set the variables.
            //console.log('spec ' + stringify(spec));

            //console.log('chained_fields_list ' + stringify(chained_fields_list));


            //var chained_fields_map = mapify(chained_fields_list, 0);
            //console.log('chained_fields_map ' + stringify(chained_fields_map));
            //each(chained_fields_list, function(i, v) {
                //chained_fields_map[v[0]] = v[1];
            //});

            // go through chained_fields_map[i]), setting up fields.

            // maybe best to use the list.

            /*
            each(chained_fields, function(i, chained_field) {
                var field_name = chained_field[0];
                var field_def = chained_field[1];

                // The point is, I think, that I am not making field classes, but processing them using some more basic variable types.

                //console.log('field_name ' + field_name);
                //console.log('field_def ' + stringify(field_def));

                // at least it has those fields... I am not sure it needs to do anything until 'get', maybe even if there are default values.


            })
            */


            //console.log('tof(spec) ' + spec);
            var chained_field_name;

            // If the spec is an object.

            if (t_spec == 'object') {
                each(spec, function(i, v) {

                    // Just copy the functions for the moment?
                    // what about copying everything else?
                    // need to may more attention to adding things?
                    // push the other, non-function items one by one?

                    // Or copy the other things to '_'.

                    // var my_i = that[i];
                    // will save a bit in the Core rewrite. Will eventually
                    // put these techniques in the main lib.
                    // calling the functions???

                    // May be used for controls???
                    // Function calls in spec...
                    // Calling things like 'bind' through the spec.

                    //console.log('i ' + i + ' =v= ' + v + ' that[i] ' + that[i]);

                    // Other thing that we may want to do is just copy
                    // things.
                    // Really not sure about that in general though, with
                    // DataObject being so generally used as a basis for
                    // things like controls.

                    if (typeof that[i] == 'function') {
                        // connected by now!

                        // such as setting the fields...

                        that[i](v);
                    } else {
                        // _[i] = v;

                        // they could be values...
                        //  should set the values

                        // possibly only set them if they correspond to fields?

                        // set values from fields seems like a good idea here.
                        //  that seems like a good level of connectedness.
                        //  want a map of the fields to quickly test them.

                        // setting values from chained fields?
                        //  probably better to set them from the normal fields.

                        //console.log('2* chained_fields ' + stringify(chained_fields));
                        //console.log('2* chained_fields_list ' + stringify(chained_fields_list));

                        // it will be dom.nodeType.



                        // then it should be able to set some values.
                        //console.log('spec ' + stringify(spec));

                        // maybe a map of chained fields would work better.

                        // Could be done a lot more efficiently with a map.

                        if (chained_fields_list.length > 0) {
                            var tcf, chained_field;
                            for (var c = 0, l = chained_fields_list.length; c < l; c++) {
                                chained_field = chained_fields_list[c];
                                tcf = tof(chained_field);

                                if (tcf == 'string') {
                                    chained_field_name = chained_field;
                                } else if (tcf == 'array') {
                                    chained_field_name = chained_field[0];
                                }

                                //console.log('chained_field_name ' + chained_field_name);
                                // coming out as undefined.

                                // I think I need to redo the field chaining system somewhat.
                                //  It's algorithms can be made faster and neater.
                                // Basically, at any level we define fields.
                                // Need to be able to get the fields for this level.
                                //  Would help to get the names of the parents.
                                //   Field definitions of the subclasses overwrite those of the superclasses.

                                // Want to be able to get the field chain...
                                //  That is going backwards getting all of the fields.
                                //   Not overwriting them as older ones are found.




                                // Redoing the field chaining is probably one of the largest
                                //  changes to make in order to get a nicely working system.





                                //console.log('i ' + i);

                                // Need to make sure we a are properly holding the field types.

                                if (chained_field_name == i) {
                                    //console.log('*** chained_field_name ' + chained_field_name);
                                    //console.log('setting');
                                    //that.set([i, v]);

                                    // Need to check setting a collection with an array.
                                    that.set(i, v);

                                    //console.log('that._[i] ' + stringify(that._[i]));
                                }
                            }

                            /*
                             each(chained_fields_list, function(i2, chained_field) {
                             //console.log('chained_field ' + stringify(tof(chained_field)));



                             if (tof(chained_field) == 'string') {
                             chained_field_name = chained_field;
                             }
                             if (tof(chained_field) == 'array') {
                             chained_field_name = chained_field[0];
                             }

                             //console.log('chained_field_name ' + chained_field_name);
                             //console.log('i ' + i);

                             if (chained_field_name == i) {
                             //console.log('chained_field_name ' + chained_field_name);
                             //console.log('setting');
                             //that.set([i, v]);

                             // Need to check setting a collection with an array.
                             that.set(i, v);

                             //console.log('that._[i] ' + stringify(that._[i]));
                             }
                             });
                             */
                        }


                        //throw('stop');
                        /*
                         //chained_fields_list
                         if(chained_fields_map && is_defined(chained_fields_map[i])) {
                         console.log('chained_fields i ' + i);
                         console.log('chained_fields v ' + v);



                         that.set(i, v);
                         }
                         */
                    }
                });

                // events as a list?
                // or named anyway?

                // then there is a list for the events of each name.
                // also, will create the _bound_events object when needed.
                //this._bound_events = {};

                if (is_defined(spec.event_bindings)) {
                    throw '16) stop';
                    each(spec.event_bindings, function(event_name, v) {
                        if (tof(v) == 'array') {
                            each(v, function(event_name, fn_event) {
                                if (tof(fn_event) == 'function') {
                                    this.add_event_listener(event_name, fn_event);
                                }
                            });
                        } else if (tof(v) == 'function') {
                            this.add_event_listener(event_name, v);
                        }
                    });
                }

                var spec_reserved = ['parent', 'event_bindings', 'load_array'];
                var map_spec_reserved = get_truth_map_from_arr(spec_reserved);

                // Don't give the constraint as just the spec!
                //  It's not a good idea. Specify it separately.
                //  Spec can just be the data, it looks like?

                //var o_constraint = {};
                /*
                 each(spec, function(i, v) {
                 if (!map_spec_reserved[i]) {
                 //
                 o_constraint[i] = v;
                 }
                 })
                 */
                if (spec.constraint) that.constraint(spec.constraint);
                // then go through the spec, ignoring the reserved ones, and treat those items as field constraits / field constraint definitions.
                // and _parent?
                // but get(parent) could be really useful.
                // Could be very useful with controls, having this parent
                // structure.
                // Could be useful in bubbling events in controls too.

                // But not just one potential parent.
                // The data object can appear in more than one collection.
                //  Will use 'relationships', where there can be more than one 'parent'
                //  Will have things indexed for faster access.
                // what if the spec is a collection of string keys (representing fields) and string values representing the constraints?

                // parent could be reserved / ignored as a field.
                //  could check an object to see if it's a field definition type.
                //  could be a string. could be an array of the right form.
                //  Field definitions could be a bit tricky - it may actually create such a field definition object if it needs to do so.

                if (is_defined(spec.parent)) {
                    this.set('parent', spec.parent);
                }
            }



            //var that = this;

            // These events seem to get called far too much.
            //  Need to look into the add_event_listener code for dealing with serving multiple pages.


            // only add it if it has a context?

            if (this._context) {
                this.init_default_events();
            }

            //if (spec.fields) {
            //	this.fields(spec.fields);
            //}




            // Want to do this after all initialization.
            //  After the whole init sequence has finished.




            //delete this._initializing;
            this._initializing = false;
        }

        //console.log('end Data_Object init');
    },

    'init_default_events': function() {

        /*
        var that = this;
        this.add_event_listener('add', function(e) {

            if (tof(e) == 'collection') {
                var stack = new Error().stack;
                console.log(stack);
                throw 'The event object should not be a collection.';
            }

            var parent = that.parent();
            if (parent) {
                parent.raise_event('add', e);
                //throw 'stop';
            }

        });

        this.add_event_listener('remove', function(e) {
            var change_e = {};
            each(e, function(i, v) {
                change_e[i] = v;
            });
            change_e.event_name = 'remove';
            that.raise_event('change', change_e);

            var parent = that.parent();
            if (parent) {
                parent.raise_event('remove', e);
                //throw 'stop';
            }
        })
        */


    },

    'data_def': fp(function(a, sig) {
        if (sig == '[o]') {
            // create the new data_def constraint.


        }
    }),

    'keys': function() {
        if (Object.keys) {
            return Object.keys(this._);
        } else {
            var res = [];
            each(this._, function(i, v) {
                res.push(i);
            });
            return res;
        }
    },

    'stringify': function() {
        var res = [];
        res.push('Data_Object(' + stringify(this._) + ')');
        return res.join('');
    },

    'toObject': function() {
        // need to go through each of them...
        var res = {};

        //console.log('this._ ' + stringify(this._));

        each(this._, function(i, v) {
            if (v.toObject) {
                //console.log('tof v ' + tof(v));
                res[i] = v.toObject();
            } else {
                res[i] = v;
            }
        })

        return res;
        //return this._;
    },

    // using_fields_connection()
    //  will search up the object heirachy, to see if the Data_Objects fields need to be connected through the use of functions.
    //  that will make the fields easy to change by calling a function. Should make things much faster to access than when programming with Backbone.
    // then will connect the fields with connect_fields()

    'using_fields_connection': function() {
        var res = false;
        iterate_ancestor_classes(this.constructor, function(a_class, stop) {
            if (is_defined(a_class._connect_fields)) {
                res = a_class._connect_fields;
                stop();
            }
        })
        return res;

    },

    'connect_fields': fp(function(a, sig) {
        //console.log('');
        //console.log('connect_fields sig' + sig);
        //console.log('a ' + stringify(a));

        var that = this;
        //throw '8) stop';

        if (a.l == 1 && tof(a[0]) == 'array') {
            var arr_fields = a[0];
            each(a[0], function(i, v) {
                that.connect_fields(v);
            });
        }

        if (sig == '[s]') {
            // connect that field by name
            // create the function

            // connect a singular field.

            /*
            this[a[0]] = fp(function(a2, sig) {

                //console.log('sig ' + sig);
                if (a2.l == 1) {
                    return that.set(a[0], a2[0]);
                } else if (a2.l == 0) {
                    return that.get(a[0]);
                }
            });
            */

            this[a[0]] = function(a1) {

                if (typeof a1 == 'undefined') {
                    // 0 params
                    return that.get(a[0]);
                } else {
                    // 1 param

                    return that.set(a[0], a1);
                }

                //console.log('sig ' + sig);
                //if (a2.l == 1) {
                //	return that.set(a[0], a2[0]);
                //} else if (a2.l == 0) {
                //	return that.get(a[0]);
                //}
            };



        }

        if (sig == '[o]') {

            throw('16) stop');
        }

    }),

    // does this get overwritten?

    // Various items need to have their parents set properly when starting.

    // fp working?

    // Duck type collection detect -- __type == 'collection'

    // Don't have the array of parents.

    // One parent and one index for the moment. That's what DOM nodes need.

    //'parent': fp(function(a, sig) {
    'parent': function() {
	      var a = arguments;
	      a.l = arguments.length;
	      var sig = get_a_sig(arguments, 1);
        var obj, index;
        //console.log('parent sig', sig);

				// And _parent should be set automatically when the controls are put in place.

        if (a.l == 0) {
					//console.log('this._parent', this._parent);
            return this._parent;
        }
        if (a.l == 1) {
            obj = a[0];

            if (!this._context && obj._context) {
                this._context = obj._context;
            }

            // IDs will only work within the context.



            // Another way of expressing this?

            // Can have a single parent, or multiple parents.
            //  May want something to be the only parent. Could have a different mode for multiple parents.

            //  this._parent = obj?


            //console.log('parent obj_id ' + obj_id);
            //throw 'stop'
            //console.log('obj ' + stringify(obj));
            // should maybe rename or subdivide _relationships.
            //  it will also be useful for databases.
            //  however, would need to work with the constraint system.
            //   likely that they would be syncronised through code.

            var relate_by_id = function(that) {
                var obj_id = obj._id();
                that._relationships[obj_id] = true;
            }

            var relate_by_ref = function(that) {
                that._parent = obj;
            }
            relate_by_ref(this);
        }
        if (a.l == 2) {
            obj = a[0];
            index = a[1];

            if (!this._context && obj._context) {
                this._context = obj._context;
            }

            this._parent = obj;
            this._index = index;
        }

        if (is_defined(index)) {
            // I think we just set the __index property.
            //  I think a __parent property and a __index property would do the job here.
            //  Suits DOM heirachy.
            // A __relationships property could make sense for wider things, however, it would be easy (for the moment?)
            // to just have .__parent and .__index
            //


            // Not sure all Data_Objects will need contexts.
            //  It's mainly useful for Controls so far




        } else {
            // get the object's id...

            // setting the parent... the parent may have a context.





        }
    },

    /*
    'parent': function(a1, a2) {
        var ta1 = typeof a1, ta2 = typeof a2, tri, info;
        if (ta1 == 'undefined') {
            // 0 params

            // could call the simple get function here, but maybe we can have it inline and fast.
            var arr_parents = [];
            for (i in this._relationships) {
                info = this._relationships[i];
                tri = typeof info;
                if (tri == 'number') {

                } else if (tri.__type === 'collection') {
                    arr_parents.push(info);
                } else if (tri.__type === 'data_object') {
                    arr_parents.push(info);
                }
            }
            if (arr_parents.length == 1) {
                return arr_parents[0];
            } else if (arr_parents.length > 1) {
                return arr_parents;
            }

        } else if (ta2 == 'undefined') {
            // 1 param
            if (a1.__type == 'data_object') {
                if (a1._context) this._context = a1._context;
            }

        } else {
            // 2 params
            if (a1.__type == 'data_object' && typeof a2 == 'number') {
                var parent = a1;
                var p_id = parent._id();
                var position_in_array = a2;

                if (parent._context) this._context = parent._context;

                // it's the child saying it's got the attribution to the parent here

                // child knows what poisition it is within parent.

                this._parents = this._parents || {};

                this._parents[p_id] = [parent, position_in_array];
            }
        }
    },
    */

    '_fp_parent': fp(function(a, sig) {

        // Maybe detect if it's a Data_Object or Control relatively quickly here.
        //  Then perhaps call ._parent_Data_Object
        //   there would likely be some more optimized functions.

        // ._parent_get



        //console.log('parent sig ' + sig);
        //throw 'stop';
        if (a.l == 0) {
            // there could be just a single parent...
            //  if there is more they will be returned as an array.

            var arr_parents = [];

            // look at the _relationships.

            // _relationships will be used instead of .parent or ._parent
            //console.log('this._relationships ' + stringify(this._relationships));
            //console.log('this._parents ' + stringify(this._parents));

            //console.log('this ' + stringify(this));

            //var stack = new Error().stack
            //console.log(stack);
            //throw 'stop';

            // and each relationship record may indicate a parent
            //  does so with an integer, which is the index within that parent.
            //   will make for more efficient algorithms than jQuery's .index().
            var tri;
            each(this._relationships, function(relative_id, relationship_info) {
                tri = tof(relationship_info);

                console.log('relative_id ' + relative_id);

                if (tri == 'number') {
                    // Relationships will be changed and tested.

                    // it indicates a parent.
                    // perhaps we should also return the position within the parent?

                    // This needs changing / fixing.

                    throw 'Relationships system needs more work here. Had been using the map of all many objects, which has been removed for web server performance reasons.';

                    /*
                    var id_map = map_jsgui_ids;

                    if (this._context) {
                        id_map = this._context.map_objects;
                    }

                    arr_parents.push(id_map[relative_id]);
                    */


                } else {
                    //console.log('tri ' + tri);

                    if (tri == 'data_object' || tri == 'collection') {
                        arr_parents.push(relationship_info);
                    }
                    //console.log('relative_id ' + relative_id);
                    //console.log('map_jsgui_ids[relative_id] ' + map_jsgui_ids[relative_id]);
                    //throw 'stop';
                }

            });

            /*


            each(this._parents, function(i, v) {
                arr_parents.push(v);
            });
            */
            if (arr_parents.length == 1) {
                return arr_parents[0];
            } else if (arr_parents.length > 1) {
                return arr_parents;
            }

        } else {
            //if (sig == '')
            //throw '2) stop';
            // otherwise, may have been given a parent control.
            //  May make a test suite to test types and signatures.

            // the parent should be a Data_Object (which includes Control), as well as other things.
            //  I think that there will be a lot of power and flexibility in controls when they get used again using the Data_Object underpinnings.
            // It will also be possible to make much more condensed versions of the framework.
            //

            // Parents needs a significant amount more work...
            //  But needs to store the positions within parents.

            // set the parent - but may also need to know the position of the child.

            if (sig == '[D]') {
                var parent = a[0];

                //console.log('[D] parent io Data_Object ' + (parent instanceof Data_Object));
                //console.log('[D] parent io Collection ' + (parent instanceof Collection));

                if (parent._context) this._context = parent._context;

                // maybe better to just use ._parent.

                var use_parent_id = function() {


                    var p_id = parent._id();

                    // This could return the position within that parent?

                    // It may not have its position set - because if the parent is a Data_Object, then it does not have positions as such.
                    var tp = tof(parent);

                    if (tp == 'data_object') {
                        //this._parents = this._parents || {};
                        // but it's position may effectively be the field name...
                        //  may be worth having that.


                        //this._parents[p_id] = parent;

                        this._relationships = this._relationships || {};

                        this._relationships[p_id] = parent;

                    }

                    if (tp == 'collection') {
                        throw 'Required: position in array of item';
                    }

                }

                // an array of parents?
                //  or just set the parent? Multiple parents would help (in theory).
                var use_parent_ref = function() {
                    // will work on parent later on.


                }





            }

            // could be a collection and a number...

            if (sig == '[D,n]') {
                var parent = a[0];
                var p_id = parent._id();
                var position_in_array = a[1];

                if (parent._context) this._context = parent._context;

                // it's the child saying it's got the attribution to the parent here

                // child knows what poisition it is within parent.

                this._parents = this._parents || {};

                this._parents[p_id] = [parent, position_in_array];

                // parent keeps a list of all children?
                // parent can have children in different places, in different other collections.

                //console.log('position_in_array ' + position_in_array);

                //parent.children.


            }

            /*

            if (a.l == 1) {

                //console.log('sig ' + sig);
                //throw 'stop';

                // the signature could be D, a Data_Object.




                console.log('p_id ' + p_id);

                // parents dict of objects... not sure about using an actual collection here.
                //  could get too complicated unnecessarily.
                // Could try it later when data structures are more finished.

                this._parents = this._parents || {};

                this._parents[p_id] = parent;


            }
            */

        }
    }),

    '_id': function() {
        // gets the id.
        //console.log('Data_Object _id this._context ' + this._context);

        // Should get the context at an early stage if possible.
        //  Need to have it as the item is added, I think.
        if (this.__id) return this.__id;

        if (this._context) {
            //console.log('this.__type ' + this.__type);

            // __type will be control?
            // __data_type as control.
            //  that's the overriding type, there are a few of them
            // __type could be the more specific type such as radio_button.

            //console.log('this._context.new_id ' + this._context.new_id);

            this.__id = this._context.new_id(this.__type_name || this.__type);

            //console.log('__id ' + this.__id);
            //throw '!stop';
        } else {
            if (this._abstract) {
                return undefined;
            } else if (!is_defined(this.__id)) {

                // What does not have the abstract?

                //var stack = new Error().stack;
                //console.log(stack);

                // no such function... but there should be something declared in many situations.

                throw 'stop, currently unsupported.';
                this.__id = new_data_object_id();

                console.log('!!! no context __id ' + this.__id);
            }
        }
        return this.__id;
    },

    'fields': fp(function(a, sig) {

        //.fields() may be better suited to getting info about the fields, rather than all of the fields' info.
        //  Making the APIs return relatively simple data is a step to take.
        //  Keeping the functionality but simplifying the APIs.
        //   Sometimes more complicated API calles will be made, but they will take more parameters that shows the coder expects to get
        //   more complicated results back.




        // field names
        // field names and values
        // field names and types
        // field names, types and values

        // I think field names and types is a neat amount of data that will help with debugging.
        //  Can it return an object which has a .values() function?

        //  Check in the fields collection, for the fields' metadata, or could check the fields definition?
        //  Want to be able to tell what Control Fields a Control has, for example.
        // It would be good to have simply named functions return data that's not all that complicated and can be debugged easily, where possible.

        // Can have a different mechanism for getting all fields' values.

        // Also, getting the field objects themselves, they have associated constraints.








        // an easier interface to the fields than fields and constraints.
        //  this may be immutable when it is held in a collection - not sure.
        //  may not want to keep creating new copies of field sets and constraints for use in individual Data_Objects.

        // The individual Data_Objects will need to have their own constraints, to begin with.

        // we may have been given the chained fields here.
        //


        //console.log('***** fields sig ' + sig);

        // Should have had fields set already.
        //  The Data_Object constructor should find out what fields are part of it.
        //  Not sure how easy that is to do from that level... there needs to be a way.

        //

        var that = this;

        if (a.l == 0) {

            // Will be keeping track of the fields internally.
            //  They get stored in an array, so that the order gets maintained.

            /*

            //console.log('fields this._map_field_constraints ' + stringify(this._map_field_constraints));

            var res = [];

            each(this._map_field_constraints, function(field_name, v) {
                //console.log('field_name ' + field_name);
                //console.log('v ' + stringify(v));

                // then for each constraint, get an info object from it.
                // v.to_obj_info
                // v.to_info_obj

                each(v, function(i2, constraint_for_field) {

                    // May also be saying it's a primary key field
                    //  Need more work on setting fields


                    if (constraint_for_field instanceof Constraint.Field_Data_Type) {
                        var field_constraint_info_obj = constraint_for_field.to_info_obj();
                        //console.log('field_constraint_info_obj ' + stringify(field_constraint_info_obj));

                        // find out if the field is read-only.

                        var flags = [];
                        if (that._map_read_only && that._map_read_only[field_name]) {
                            flags.push('read_only');
                        }
                        if (flags.length == 0) {
                            res.push([field_name, field_constraint_info_obj]);
                        } else {
                            res.push([field_name, field_constraint_info_obj, flags]);
                        }
                    }
                });
            });

            return res;
            */

            // an index of the position of a field within the array? Would that be useful?
            //  means some encapsulation may be worthwhile here

            // have a look at the fc (fields_collection)

            var fields_collection = this.fc;
            //console.log('fields_collection ' + fields_collection);

            // not just the field values.
            var res;


            if (fields_collection) {
                res = fields_collection.okvs.values();
            } else {
                res = [];
            }

            return res;


            //return this._arr_fields || [];
            // can get a position map relatively quickly from the array of fields.
            //  can be done after any adjustment on the fields is done.
            // this._field_positions_by_name
            //  or a linked list of fields? That could work for preserving order, iterating, insertion, deletion,


        }

        if (sig == '[s]') {
            // get a single field.

            // get the field from the field_collection.

            var fc = this.fc;
            //console.log('** fc ' + fc);
            var res = fc.get(a[0]);
            //console.log('res ' + stringify(res));
            return res;

        }

        //var that = this;
        if (sig == '[o]') {
            // when giving it the chained fields, need to process them right.
            //  may be best to clone them.

            //console.log('a[0] ' + stringify(a[0]));

            // better to ensure the fields in order...

            //  can set each field individually.

            // Setting a field with a value...
            //  The field type could be a bit more complex.
            //  Need to be careful about using JSON or JS object input to set a field - it may need to be instantiated from that input.





            each(a[0], function(i, v) {
                //console.log('i ' + stringify(i));
                //console.log('v ' + stringify(v));

                // it's using the new set_field in Collection.
                that.set_field(i, v);
                // for setting an existing field...
                //  see if the field exists (search the fields object or other lookup)
                //   if it exists, modify the existing one - complicated when other things depend on this.
                //    the constraints and indexes will also depend on the fields, so a modification in a field can result in the removal of a constraint or index.
                //     removal of a field could necessitate the removal of a constraint or index.
                //      remove_constraints_for_field
                //      remove_indexes_for_field

                // Don't want to remove multi-field constraints when replacing one field - but do want that when properly removing a field.
                //  I guess this will just take a bit more coding and testing to get the desired behaviors.
                // Really want to be using fields as a convenitent interface for constraints.
                //  They will encompass a few things involving them.
            }, that);
        }

    }),

    'constraints': fp(function(a, sig) {
        // or constraints... if given multiple ones.
        //   I think constraints may be the better name here.
        //   Will accept the singular as well.





        //console.log('Data_Object constraint sig ' + sig);

        // was 'fields'

        // as constraints, a Data_Object can also be a Collection, so these will need to apply to collections as well.

        // collections won't have fields though, so Field_Constraints won't apply to them, and collections won't accept them as constraints.


        // field constraints...

        // may be given the field constraints

        if (a.l == 0) {

            // want to get all the constraints.


        }

        // Field rather than column.


        // Collections will have other sorts of constraints, such as table constraints.
        //  Nice to be able to have collections have constraints defined in terms of other collections.


        // Foreign_Key_Constraint is a table constraint
        // Unique is as well... it does not check individual fields, depends on the whole table.
        //  Fine to ingore the fact that SQL can recognise them as column constraints here, we are not dealing with columns,
        //  but fields. Fields won't say they are constrained to unique values... collections will say they constrain fields to unique values.
        //   Would be more memory efficient.


        // the signature... could be a field_constraint?
        // could be a collection_constraint?
        //  that may be worth putting into the signatures, with fc and cc
        //   or FC and CC
        // that's how they get brought into the system at quite a low level, with the flexibility making the code clearer here.


        // function wanted to get and set the fields as well...

        /// it looks like there are field constraints in use here.
        //  the fields will be an object / array with the fields.



        if (sig == '[o]') {
            // setting the field constraints.

            // May have a closer look at those objects.

            // overwrite existing ones.
            var field_constraints = a[0];
            this._field_constraints = field_constraints;


            // does it match the current field constraints?
            //  if not, throw an error.



        }


        // string, ?
        //  it would try to process the ? as a field_constraint for that field
        //  if it already is a field_constraint, then great
        //  if it is an array or a string (possibly other object) it will parse / interpret that as a field_constraint object

        // Making the system of specifying constraints easy, while still providing the full database-like model,
        //  is an interesting challenge. It should make for a nice tool on the front-end that can create code that gets transformed
        //  into the DB code and allows access to it without too much difficulty.

        // This system, in JavaScript, will be able to bind to databases relatively easily.
        //  Should provide the coder with easy access to data in various databases.
        //  This whole constraints and data types system will have wide application to a lot of data available on the internet,
        //   and will be useful for publishing data too.

        // Looking forward to making a resources system that makes it relatively easy to access data that is stored somewhere with an easy API.
        //  May be interesting to open-source some of this technology. May be best to open-source all of it?
        //  I think open sourcing a precise, fairly compact build of it would be nice.
        //   Worth thinking in terms of possible extensions.

        // The system to do with finding and defining metadata, and matching that with data scraped from websites or from web resources...
        //  Not sure about open sourcing some of the core indexing stuff quite yet. Possibly in the future.

        // But my website could make metadata available.
        //  There could be some open-sourced code to do with the core things, I'm sure.

        // Perhaps connecting to various resources.
        //  Hosting data perhaps, identifying it to the index.

        // Perhaps people running hosting software I have written will connect to the central system, also could use the Resources system
        //  to obtain data from elsewhere for their own use, while publishing it with MetaBench indexing systems, APIs and semantics.


        if (a.l == 2 && tof(a[0]) == 'string') {




        }



        // may be returning the field constraints



    }),

    'matches_field_constraint': fp(function(a, sig) {
        // there may be more than one constraint for that field.

        //console.log('matches_field_constraint sig ' + sig);
        //console.log('matches_field_constraint a ' + stringify(a));


        if (sig == '[s,s]') {
            var field_name = a[0];

            // the constraint as just one item.
            //  there could be multiple fields constraints for that item.

            if (tof(a[1]) == 'string') {
                var str_constraint = a[1];

                // then use the constraint module to test these.

                var field_val = this.get(field_name);
                return obj_matches_constraint(field_val, str_constraint);
            }

            if (tof(a[1]) == 'array') {
                throw 'Multiple constraints not yet implemented here';
            }



        }

        //throw('stop')

        // given as string


        //


    }),

    'obj_matches_field_constraints': function(obj) {
        //console.log('matches_field_constraints ');
        var that = this;
        // iterate through the field constraints
        var matches = true;

        // don't check it against the _field_constraints?
        //  get the_field_constraints?
        //  have the .fc (field collection) interacting with the field constraints?
        //   have the fields_collection system store the field constraints?
        //  possibly not, because some constraints will be outside of individual fields.

        // perhaps have _unique_constraints_collection / index that keeps track of the unique constraints.

        // they are different to the field constraints. for the moment they can just be an index.
        //  could maybe have them like flags.

        //  they can be added, removed, they will be indexed for sat retrieval and checking.

        // indexes... another index index? these indicate how things get indexed within the collection, rather than being the indexes themselves.

        // field_index_schema?
        //






        each(this._field_constraints, function(i, v) {
            // does it match?

            matches = matches && obj.matches_field_constraint(i, v)

        })
        return matches;
        //throw('stop');

    },

    // Maybe fields and field constraint heavy lifting should be done elsewhere?
    //  But Data_Object will be right in the core really.

    // I doubt the core will be all that large in terms of file size.
    //  A lot of size savings will be made, and it will be very small and efficient compared to many other systems.
    //  Combining different things into one file would be another days work.

    // I could also do some more work on building up the JavaScript code and evaluating it.
    //  That could save a lot of space with an efficient compression mechanism.


    // Setting a whole bunch of fields, or even a field, may be better done in a collection, because some of the field has to do with how a collection handles it...
    //  indexing it,


    /*
    'fields': fp(function(a, sig) {
        if (sig == '[o]') {
            // overwrite all fields.

            // will use the set_field to set the individual fields?

        }

        //console.log('Collection fields sig ' + sig);


    }),
    */
    // The field constraints, and data_type system is getting quite large and a bit fragmented.
    //  Hopefully it will be closer integrated into the core, and tested with some relatively simple examples to show that it works
    //  and what results to expect.

    // The constraints about what objects can be will go a long way towards the goal of specifiying things in JavaScript that
    //  will work on many systems eventually. These mechanisms will be useful in GUIs, so it will help that they are built into the core of the framework.

    // At the moment I am putting quite a lot in, having spent some time considering what will be needed next.
    //  A later stage will be refactoring things. That may come when it is running in a browser and I see how much it is using.
    //  It may be done after some more code analysys, perhaps enabled by JavaScript parsing and storing the code on the system ready for use
    //   and analysis

    // set_field for the Data_Object... the field is a constraint to do with the type, it could also be that an index is set up for that field.

    //  want read-only fields to operate on the class level as well.
    //  I think the map is useful, I'm not so sure that they are constraints anyway.
    //  Field properties... then can have a field property map or field property index.


    'read_only': arrayify(fp(function(a, sig) {
        var mro = this._map_read_only = this._map_read_only || {};

        var field_name = a[0];

        if (sig == '[s]') {
            // a field name to make read-only
            mro[field_name] = true;
        }
        if (sig == '[s,b]') {
            // a field name to make read-only, boolean value can be false

            var bool_is_read_only = a[1];
            if (bool_is_read_only) {
                return this.read_only(field_name);
            } else {
                //delete mro[field_name];
                mro[field_name] = null;
            }
        }
        // array... process them?
        //  could arrayify the whole function.
    })),

    'set_field': fp(function(a, sig) {

        // This will be overhauled...
        //   It will need to efficiently see if an existing field is there.

        // If it is there, it will update the field. That may then mean that constraints need to get updated as well..
        //  would mean removing some existing ones perhaps?
        // But it would check what constraints are then needed for that field and remove the extraneous ones.
        //  Same with single-field indexes.

        // When adding the field, would also need to update the constraints.
        //  Could have the constraint system respond to field changes, maybe be the first listener.
        //   using this.ensure_field_constraint(field_name, field_info);?


        this.fc = this.fc || new Fields_Collection();

        return this.fc.set.apply(this.fc, a);

        // although it has been added, we need to set the parent...
        //  maybe fc can do this?

        //console.log('set_field sig ' + sig);
        //console.log('set_field a ' + stringify(a));

        // [s,[f]]
        //  data type is defined by a constructor within an array
        //   means a collection of that type.

        // sets a data type constraint on that field
        /*
        if (sig == '[s,[f]]') {

            throw '10) Stop';
        }
        */
        // Collection has something that overrides this.
        /*
        if (sig == '[s,s]') {
            // will need to interpret the second part
            var field_name = a[0];
            var field_text = a[1];

            //console.log('field_text ' + field_text);
            // parse the fiex text. it may have some things to do with constraints that apply to the collection, if it is in a collection.
            //  not so sure about saving these here. They could be saved so that they get put into a collection fine with other unique fields...
            // but then we'll be taking more care specifying things in the collection if necessary.

            var field_info = input_processors['field_text'](field_text);

            //console.log('field_info ' + stringify(field_info));

            // then ensure the constraint(s) corresponding to the field, where possible.
            //  not able to put uniqueness constraint in place here, yet. It's really dealt with and enforced by the Collection class.

            // I think the library core is getting pretty big now, it could still do with more for HTML, CSS processing.
            //  The database side of things will be expanded, it will be good to have code using very nice syntax provided by the library.

            this.ensure_field_constraint(field_name, field_info);

            if (field_info.read_only) {
                this.read_only(field_name);
            }

            // Just need to do quite a lot more...
            //  Quite a bit more needed for the objects to work like they should, then I'll be using those objects for the HTML components, and also for the
            //  database layer.

            // Persisting to that DB layer seems like a really useful stage, not sure about open-sourcing that code.
            //  May be best to... may be better that my ORM is used. I'd still have the powerful web app too?
            //   Could have different licensing for that component... commercial deployments cost money?
            //    But then want to have things distributed nice and easily. Perhaps could have different options for this. With the website running out-of-the-box,
            //     could directly go to the Mongo layer.
            // Would be very nice to have open-source code producing everything that's needed. Could get quite a lot of interest.
            //  Maybe will keep that on my server for the moment, or in the client-side applications people use.
            // Will be fine without OSing all the ORM, but a relatively simple Mongo layer would work fine.
            //  It may be more what people want, and would get developer interest. The ORM would be useful for accessing legacy systems? SQL can be very useful in its
            //   own right, but could be harder to use effectively in this case.


            // does it have the not_null constraint?
            //  each field can have more than one constraint.
            //  not sure about a collection of constraints though.
            //   perhaps a simpler collection would be very useful in implementing some of the more advanced things.
            //  array of constraints for each field will do for the moment.

            // can be both a Not_Null constraint and a data type constrint.
            // easy then to create the field with this information.

            //  find out if there is an existing field (constraint).
            //  find out about existing indexes for that field, create one if needed
            //  find out about existing constraints, such as not_null
            //   perhaps not_null can be a value constraint - but it's something that translates readily into the database system.

            // this will be for setting single field indexes.

            // Other indexes could be defined with multiple fields.

            // Will be useful for iterating through a collection, getting the values that match two given values.

        }
        */

    }),


    // unique, not_null being the field constraints in action.

    //  unique could apply to multiple fields at once. Would need the index with those two fields looking for collisions.

    // constraints: {
    //	'unique': ['school_district', 'district_school_id']
    //}

    // will also try to get a field constraint, based on the field.
    //  but may also do it based on type, maybe get_field_data_type_constraint

    'set_field_data_type_constraint': function(field_name, data_type_constructor) {
        // these dtcs are separate to the fields themselves.

        // May be better using the Field_Collection here.

        var fmc = this._map_field_constraints = this._map_field_constraints || {};
        var fmfc = fmc[field_name];
        if (fmfc) {
            var deletion_index;
            each(fmfc, function(i, v) {
                // if it is a Field_Data_Type_Constraint
                if (v instanceof Constraint.Field_Data_Type) {
                    //return v;
                    //
                    if (v.data_type_constructor === data_type_constructor) {

                    } else {
                        // replace that one.
                        deletion_index = i;
                    }
                }
            })

            if (is_defined(deletion_index)) {
                fmfc.splice(deletion_index, 1);

                // create the new constraint object.
            }
        }
    },

    'get_field_data_type_constraint': function(field_name) {
        var fmc = this._map_field_constraints;
        // field_constraints - they are constraints that apply to the fields. They are not the list of fields.
        var result = undefined;
        //
        if (fmc) {
            var fmfc = fmc[field_name];
            if (fmfc) {
                each(fmfc, function (i, v) {
                    // if it is a Field_Data_Type_Constraint
                    if (v instanceof Constraint.Field_Data_Type) {
                        result = v;
                        return v;
                    }
                });
            }
        }
        return result;
    },


    //

    // ensure_constraint_from_field
    // ensure_constraints_from_field
    //  can have a not null constraint, can have a data type constraint.
    //  can be given the whole [field_name, [str_field, obj_field_info]]
    // possibly not_null constraint would be part of data type constraint?
    //  easier to have separate not null constraint.

    // once we have the field, there are some possible constraints.
    //  could have them indexed... an obj saying not_null, with link to constraint if it is there.
    //  _map_field_constraints...
    //  _map_field_constraints[field_name][constraint_type_name]
    //  _map_field_constraints[field_name]['multi_field']
    //   and then there is a list of all the constraints that have got the field mentioned...

    // some of these things could be done with a quick search.


    //   when we have the field name, we can refer to all its constraints from this.

    // and then there should be the (KVS) map of unique constraints ordered by alphabetic fields...
    //  also storing when a field is mentioned in a constraint, but it's not the only field?
    //   when deleting a field we'll need to get all constraints that a field is involved in.

    //



    //  can also be given [field_name, str_field], can calculate the constraint object.
    //   may at times be given the obj_field_info and need to make the text representation



    'ensure_field_constraint': fp(function(a, sig) {

        // this would also have to interact with the field object if necessary, keeping things in sync.

        // will have different field_constraint maps.
        // or a map of the fields to the constriaint types.
        //


        // (fc_map[field_name]['unique'])
        // fc_map[field_name]['data_type']
        // fc_map[field_name]['not_null']



        //  ensures a single constraint?
        // [s,s] can parse the field text

        if (sig == '[s,o]') {
            var field_name = a[0];
            var field_info = a[1];

            // Different constraints that can apply to the field... but likely to be a data_type constraint really.



            // can ensure not null and data type

            // OK... looks like the field_constraints will need to be organized somehow.
            //  They are another thing that perhaps a simple indexing system would help with.
            // Will be organizing them using the native JavaScript objects.

            // Having an array of field_constraints makes sense, so that the order is maintained.

            // array of field constraints.
            // map of field constraints.

            //this._arr_field_constraints = this._arr_field_constraints || [];

            //  not so sure about this array of constraints again.
            //  perhaps only keeping them in the map is enough.

            // field constraints_by_field
            // _map_field_constraints... this will hold the constraints by field.
            //  there may not be more than one constraint for a particular field, there may be a map of such constraints.

            // so it's organized by field here... easier to get the existing field constraints, overwrite them, or create a new one,
            //  or to look it up.

            //console.log('field_info ' + stringify(field_info));
            //console.log('a ' + stringify(a));

            // Will _map_field_constraints be in the Field_Collection?

            this._map_field_constraints = this._map_field_constraints || {};
            this._map_field_constraints[field_name] = this._map_field_constraints[field_name] || [];
            // don't want an array of constraints there...
            //  there are not many constraints that can be there, such as data_type, not_null

            // The constraints only apply to fields individually
            //  There can be collection constraints that apply, they can be specified, and they get applied to the relevant collection.




            var fc_item_arr = this._map_field_constraints[field_name];
            // Have the fields referencing their constraints.
            //  Also have a map / sorted KVS of constraints by the fields they are for, different ways they need to be looked up
            //   alhabetically sorted list of unique fields kept in a KVS
            //    no such thing as a unique index - only unique constraint.
            //   a single field can be unique (have a unique constraint)
            //   a unique constraint can apply to multiple fields.

            // map of fields objects by name
            //  as well as array of fields
            //   the Fields object - perhaps it should be defined as its own class.
            //    It would make sense.
            // A unique constraint does not really apply to the field, but more to the collection, with reference to the field.
            //  It's still information that should get stored alongside the field.


            // looking for an existing constraint already.
            //  the whole sytem can be improved.
            // I think having an actual ._fields object would help.
            //  It would be an array (or simpler collection?)
            //   A simple collection could be quite nice if it has B+ indexing capability.
            //    But the whole thing has got a bit complicated anyway with Data_Object.
            // Just an array would do fine for the moment.
            //  Want to be sure of maintaining the order.
            //   _map_fields goes to the field by name.

            // The field will reference both indexes and constraints.
            //  Indexes and constraints will refer to particular fields, often by name.

            // Don't want complicated data types to do with fields.
            //  There is a _fields object.
            //  _arr_fields
            //  kvs_fields? it stores the fields by name in a kvs. also for multi-field constraints and indexes?

            // Doing the individual fields, and also the multiple fields when they are applied together.





            // That is a fairly major change for the data_object.
            //  Will not have the constraint map just as it is.
            //  There will be the index for multi-field constraints, but just a simple array for the fields.
            //  _map_field_constraints[field1_name][field2_name][array of constraints applying to that field combination]

            // I think the B+ KVS will be better for storing the constraints by their fields.
            //



            var dt_info = field_info.data_type;

            var new_dt_constraint = Constraint.from_obj(dt_info);
            //console.log('new_dt_constraint ' + stringify(new_dt_constraint));

            if (!is_defined(new_dt_constraint)) {
                //throw '9) New constraint from_obj not profucing constraint';
            } else {



                var dt_constraint;
                //console.log('fc_item_arr ' + stringify(fc_item_arr));
                if (fc_item_arr.length > 0) {
                    // go through the array updating relevant constraints.
                    // really looking for the data_type constraint.

                    var dt_constraints = [];
                    //console.log('fc_item_arr ' + stringify(fc_item_arr));
                    // should only be one in there at maximum
                    each(fc_item_arr, function(i, constraint_item) {
                        //console.log('constraint_item ' + stringify(constraint_item));

                        if (constraint_item instanceof Constraint.Field_Data_Type) {
                            //console.log('constraint_item ' + stringify(constraint_item));

                            var constraint_info = constraint_item.to_info_obj();
                            //console.log('constraint_info ' + stringify(constraint_info));
                            //console.log('field_info ' + stringify(field_info));

                            var stack = new Error().stack
                            //console.log( stack )

                            throw ('6) it is! stop, check to see if it is a Field_Data_Type_Constraint, use instanceOf')


                        }



                        // I think delete any existing dt constraints?
                        //  Do nothing if the constraints match...
                        //  Will likely have events to do with adding and removing constraints.




                    })

                    // check existing constraint against values given. possibly change it, possibly replace it.




                } else {

                    fc_item_arr.push(new_dt_constraint);
                }



            }

            //throw('7) stop');



            // if there is nothing there, create it.

            // if it's there, overwrite any constraints with the relevant one from the field info we were given.



            //console.log('this._arr_field_constraints ' + stringify(this._arr_field_constraints));
            //throw('5 stop');
        }

    }),

    'matches_field_constraints': fp(function(a, sig) {
        if (a.l == 0) {
            return this.matches_field_constraints(this._field_constraints);
        }

        // comparing an object with its field constraints... that could be outside this.

        // check_field_constraints
        //  does the check and says where it fails

        // matches_field_constraints
        //  stops when it fails, returns false

        // does a Data_Object match constraints?

        // may want to check if a Data_Object that gets provided matches the field constraints stored in this Data_Object.
        //  One Data_Object can be used as reference for doing checks.
        //   The Data_Objects that get put in don't have the checks as part of them, but they may have checks done on them before they have
        //   completed updating. This could be used to indicate an error to the user in the GUI.

        // This really won't be so hard to do, and to get right.
        //  Hopefully all these things would be able to be used for various packages.
        // I think declarative writing of much of it, so that a LMS could be set up, or something for social services that
        //  deal with information about individuals, workflows, and reporting (helping produce the required documents and keep
        //  users of the system informed)

        //console.log('matches_field_constraints sig ' + sig);

        if (sig == '[D]') {
            // Does that Data_Object match the constraints of this one?

            var fcs = this._field_constraints;

            //console.log('fcs ' + stringify(fcs));

            var obj = a[0];

            var all_match = true, obj_field_value, matches;

            each(fcs, function(field_name, constraint) {
                // these constraints could potentially be something quite complicated and nested.

                // We would need to be careful about that.
                // Will use this for specifying HTML controls, being sure they are output in a standard format.

                obj_field_value = obj.get(field_name);
                //console.log('obj_field_value ' + obj_field_value);

                //console.log('constraint ' + constraint);

                matches = obj_matches_constraint(obj_field_value, constraint);

                all_match = all_match && matches;
                //if (!matches) return false;
                // returning false from the main loop?
                //  breaking out of my each loop... both these things will need to be looked into.

                // each could be used to build a result... but do want break conditions.

                //check_value_against_constraint

                // a function to check against the constraints.
                //  this is to do with things no longer to do with Data_Object, should be in lang-essentials
                //  possibly worth making an intermediate level.
                // It's going outside of the essentials, but it still is pretty important
                // Maybe have core, which includes essentials and validation, or valid_data
                //  Could have a constraints module.
                //   This would be working in a nested way, the constraints could be nested.

                // Constraints would be defined as objects.
                //  They would often be specified as text, such as 'int'.
                //  They could be specified to be an array, like [['red', 'int'], ['green', 'int'], ['blue', 'int']]
                //  Having a constraint object would help to store maps that are generated to help with that constraint.
                //  They would also act as indexes for some arrays, helping with the JavaScript implementation.

                //  valid_data may be a good name because it will potentially have some more data handling facilities, such as dealing with
                //  nested data. I may be moving functionality out of Nested and putting it somewhere simpler, maybe I'll be better able to express it
                //  with recursive functions.
                // Will be dealing with data types at different levels.
                //  Could be more systematic about maps that express positions of items in arrays.

                // I think that side of things, tidying it up a lot, will help with getting these things running correctly in a web server.


            });

            // Will be faster to break out of each loop.

            return all_match;
        }



        if (sig == '[o]') {

            // may want to test if an object matches the field constraints.

            // obejct representing the constraints...
            //  seeing if this Data_Object meets those constraints.

            // these constraints are given as a field.





            // an object representing those constraints.
            //  not using a Data_Object for this yet.

            // find out which are the current keys (get a truth map of them)

            // see if all of the current ones adhere to the given constraints

            // see if all of the given constraints have been met
            //  could have a map of the given constraints, and delete them from that map as they have been met
            //  then go through the map using each to see which ones have not been met.

            // May use some code to do with data types.
            //  With the HTML processing, will be taking in data with fewer constraints, and transforming it so it matches what is required.

            // I think there will be a fair bit more coding to get the HTML system fully running with the newer Data_Object abstraction,
            //  and data types and transformations specified in terms of the data type, meaning that the code will be more concise and declarative
            // Some quite complex things to do with indexing and data transformation get done elsewhere, for example.

            // I am expecting to get this to work fairly soon, I have made a lot of progress recently.
            // Having the code executing and producing a website will be very nice.
            //  Would be good to get a portfolio online, but very good indeed if it loads quickly, has a nice menu, and just generally is my
            //  professional / business website.

            // It does seem like a real business priority to get this site up online.
            //  It could be very useful for customers, maybe if I am doing front-end development work, can show something and get comments rapidly
            //   within my system.

            // Anyway, need to get this matching the field constraints here.

            /*
            var field_constraints = a[0];


            // check for matching a single constraint



            each(field_constraints, function(i, v) {
                console.log('field_constraints i ' + i);
                console.log('field_constraints v ' + stringify(v));

            });
            */

            return data_object_matches_field_constraints(this, a[0]);

        }


    }),


    // requires is different to accepts.

    // requirements may be needed to do something.
    // accepts is about setting data on it.
    //  could say (or assume) that the fields are required. They could be required in order to persist it to some location.
    // Perhaps only some fields are required, or their reuqirement is met when they are null or undefined.

    //  Saying a field is required is equivalent to saying it is 'not null'.
    //   Fields will possibly not meet this constraint just as the object has been created... but it may be that the object must get created with the necessary
    //   data. It will be possible, though, to have the Data_Object, not containing any data. Maybe it will be considered empty, or dataless
    //   dataless may be better as it does not imply the opposite of 'full'.




    '____requires': fp(function(a, spec) {

        // Leaving this for the moment, developing field constraints.


        // sets items in this object's schema
        //  this could set items in an item-level rather than class-level schema.
        //   there could be two schemas - the one it starts with, and those that override the default schema.
        //   That avoids copying lots of the default schema items, making controls start more quickly and will use less memory.
        //    Less reduntant information being stored.

        // base_schema (this could be set by a string name, referring to jsgui.schemas).
        // overrides_schema (object_schema may be a better name).

        // 'requires' would be setting something on the overrides_schema (or object_schema)

        // object_schema
        // object_type_schema
        // object_base_schema
        // object_schema_additions

        // base_schema
        // schema_additions
        // additional_schema
        // object_schema

        // base_schema
        // object_schema

        // types will be namespaced more
        //  there is the type system of the JavaScript code here
        //  there is an internal type system for arbitrary namespaced objects... they will follow the names of objects here.

        //



        // schemas applied to properties
        //  done so that the checking stage can see that requirments are met.

        // It may be worth putting this in a 'schema' for the object, rather than at this stage.

        // Setting schemas for sub-objects, and setting schemas for the objects themselves makes a lot of sense.
        //  Perhaps the schemas for the sub-objects should be set through the schema for the object itself.

        // this, I think, will be setting a particular item on the object_schema.
        // the object_schema could simple be a data_type_name.
        //  this will tie into jsgui.data_type_name
        // Likely to make the nested system clearer and more compact, and incorporate it into the main part.
        //  I think I'll get things running in a fairly compact way that would enable things to run really well on a mobile device.
        //   Could have significantly advanced programming around the 12KB mark, would have things really optimized, but it needs to get a bit complicated in
        //   order to implement such functionality. A lot can be done in that relatively small size, and more still can be done using that code for the mobile application.

        // Putting the requirement information into the object_schema makes sense
        //  May be similar to using a data_type_name?
        //   or schema_name?

        // schema_name may make more sense.
        // possibly also have a group / collection of schemas.
        //  not sure about collection because these schemas will be used for implementing things to do with the collection.
        //  could have an application-wide dictionary of schemas.
        //  some of these will have to do with HTML, for example.

        // It makes sense to use a schema system in various places where it is appropriate, and call it a schema.
        //  Should be compatable where possible with the object definitions and access, such as indexed_array
        //  Called the jsgui-schema standard I think.
        // I may make some separate components that work using this standard. They could be reference implementations of some things.
        //  Checking that an object's properties conform to the schema
        //   Should make it possible to easily get the schema tester to know how the object's properties are done, such as on Data_Object using get and set
        //   functions.

        // Will also be able to say something requires an object with a particular interface.
        //  Data_Objects will have an 'interfaces' property (private property)
        //   this will help them tell whether the object that is connected has the right interface(s)

        // Objects can have more than one interface.
        //  This is akin to c#. In this case, we don't care about how inheritance is done on the object (it can be done in different ways to c#), but we are saying that the object
        //  conforms to a particulat interface, ie has various properities.
        //   In some cases those properties must be set.

        // Will also be able to specify functions in interfaces (and object_schemas I think), so that it can be run through tests.

        // Interfaces: an interface is a named conformance to either a specified or named schema.

        // jsgui.data_types -> jsgui.schemas

        // These schemas will be usable in form validation, creating HTML forms, processing them, and dealing with objects in databases, perhaps with generated CRUD.
        //  They will be simple to specify.
        //  There will sometime be a GUI tool for specifying schemas.
        //   They won't be too complicated - but they could be used for describing some real-work objects.



        // tell it what to look for with that property.

        // There may be some more complicated cases.
        //  Could be referring to multiple required objects for one property name.
        //  They could be in a collection, or an array.

        // can add an object to the requirements.
        //  checks that the item is there?

        // checks that the item conforms.
        //  possibly to an object_schema.
        // the object_schema system could be used for data types elsewhere - not sure about this. It sounds OK though.

        // elsewhere, whe check if an object conforms to a set type.

        // maybe object_schema should be the same system, or the other system could change over to using an object_schema, to make things clearer.
        //  I think the object_schema abstraction would help a bit.

        // will be making use of jsgui.data_types_info

        // string and an object
        //  the string is the name of the property within this object
        //  the object is the schema for that property.



        // Requirements will be sealt with through the constraints system.
        //  Perhaps it is an assumption that it is required the constraints are satisfied.

        //  A requirements system may operate for resources... not so sure about having requirements in the Data_Object as that seems like it can be
        //   handled by fields and constraints.


        if (a.l == 0) {
            // return the requirements.

            return this._requirements;

        }



    }),


    // meets_requitements, was check_requirements?

    // meets returns a boolean, check returns a report saying where it failed.

    // A resource may require another resource to have started in order to start.
    //  Now working on the code execution path for the MetaBench hosting (expandable) server to be run.
    //  Will host the website as a Resource before long.
    //  Will also be interacting with DBs using a resource API.

    // There is quite a bit of general structure, and lots of scope for specifics to be built.
    //  Do want to get my website hosted.
    //  A few components could display things quite nicely.

    // Will have a demo section showing front-end components.
    //  May have an e-learning section

    // Mobile development
    //


    // Will use field constraints for the moment
    //  Requirements may make an appearance in resources, ie saying that a resource requires another resource (to have started) before it can start.
    '_____meets_requirements': fp(function(a, sig) {

        // Possibly check field constraints, but these would have probably been checked on input or on setting the constraints.

        var requirements = this._requirements;
        if (!requirements) {
            return true;
        } else {
            if (sig == '[s]') {
                var property_name = a[0];

                // does it meet that one requirement?

                // not sure exactly how requirements are expressed right now.
                //  I think many of those things should be written up in documentation on the system and published.

                // 'name': ['regex', rx]

                // could check for different data types as well
                //  could check that something has a particular status, either function result or its own object.


                // How much of this is in 'nested'?
                //  How much of nested should be brought to the core?

            }
        }

    }),


    // although this is not a collection, it is similar to a normal JS dict / object.
    //  would be good to iterate over all the items of data in this.

    'each': function(callback) {
        // could use for i in...


        /*
        each(this._, function(i, v) {
            callback(i, v);
        });
        */

        // Could have inline code here for speed?
        each(this._, callback);


    },


    // could make this polymorphic so that it
    'position_within': function(parent) {
        var p_id = parent._id();
        //console.log('p_id ' + p_id);
        //console.log('this._parents ' + stringify(this._parents));

        if (this._parents && is_defined(this._parents[p_id])) {
            var parent_rel_info = this._parents[p_id];
            //console.log('parent_rel_info ' + stringify(parent_rel_info));

            //var parents = this._parents;
            //if (parents) {
            //
            //}
            var pos_within = parent_rel_info[1];

            // It is indexed by position in parent through the parent.

            return pos_within;

        }


    },

    // Maybe just 'remove' function.
    //  This may be needed with multiple parents, which are not being used at the moment.

    'remove_from': function(parent) {
        var p_id = parent._id();

        if (this._parents && is_defined(this._parents[p_id])) {

            var parent = this._parents[p_id][0];
            var pos_within = this._parents[p_id][1];

            // is the position within accurate?
            var item = parent._arr[pos_within];
            //console.log('item ' + stringify(item));


            //console.log('');
            //console.log('pos_within ' + pos_within);
            // Then remove the item in the collection (or Data_Object?) ....
            // and the actual parent?

            // can get control / dataobject / collection by its ID of course.

            parent.remove(pos_within);

            // Remove it by index.

            delete this._parents[p_id];



        }

    },

    // Will just deal with constraints for the moment.
    //  I'll probably make it so that resources have requirements.



    // Requirements may be more general and flexible than field constraints.
    //  Requirements could be that another component has initialized.


    '_____check_requirements': fp(function(a, sig) {
        // tell it what to look for with that property.

        if (a.l == 0) {
            // then check all of the requirements
            // returns true if successful, otherwise details of where it fails.

            // could maybe lead to a truth(x) function that checks if x === true, rather than is an object that could be giving details of something being false.
        }

        if (sig == '[s]') {
            // then check that one property
            var property_name = a[0];
        }

        if (a.l == 1 && a[0] === true) {
            // that means it's recursive.
            //  we'll be checking the requirements of this, and of any required objects.



        }


    }),

    // will be able to use the DataObject's class_name for get and
    // set.
    // maybe just type_name?
    // Could have a type name heirachy. So that if it does not find
    // get/set methods for div, it uses the ones for control.

    /*
     * 'property_ensure': function(property_name, value) { // like
     * set, but does not overwrite it.
     *
     *
     * var al = this._alias[property_name]; //console.log('al ' +
     * al); if (al) { property_name = al; }
     *
     * //var s3_name = property_name.split('.'); var pos1 =
     * property_name.indexOf('.'); // or call set
     *
     * if (pos1 == -1) { // if (tof(this._[property_name]) ==
     * 'undefined') { this._[property_name] = value; }
     *  } else { // it separates them into sub-properties. // should
     * use the set procedure for the subproperties.
     *  // and the event will say which subproperty has changed.
     * set(this, property_name, value);
     *
     *  }
     *  }
     */

    // Removing events won't work well when there are vary many.
    // Perhaps multiple listeners could be removed relatively
    // quickly.
    // Also, what about event delegation to another object?
    // Something could have an event_parent.
    // Gets told about events.
    // And that will have the event handler
    // Saves attaching so many event handlers.
    // Event propagates / bubbles.
    // Could even have just a 'parent' data object that receives
    // this information about events?
    // May do other things though.
    // Could even have the parent eventl listeners listen for the
    // actual events?
    // Not then throw them in the same way.
    // HTML surfaces will be listening for the events of delegated
    // objects through the HTML event delegation mechanic.
    // So even with no listeners set up, it will tell a delegation
    // parent.
    // Or event parent.
    // Will leave defining the event bubbling here.

    // Backbone does not seem to have this event bubbling mechanism.
    // Seems to be about receiving all events for a page.
    // Quite possibly should have a Data_Object Event class.
    // This will know the target, maybe other things.
    // DO NEED TO keep track of the target when sending these events
    // through a chain.
    // Target is assumed to be this when calling it with 2
    // parameters

    // Events getting raised on too many items when there are objects within different page contexts.

    // Want objects in more independent contexts.



    'load_from_spec': function(spec, arr_item_names) {
        var that = this;
        each(arr_item_names, function(i, v) {
            var spec_item = spec[v];
            if (is_defined(spec_item)) {
                that['set'](v, spec_item);
            }
        });
    },

    'mod_link': function() {
        return jsgui;
    },

    // Could use less polymorphism and recursion here.
    //  Could maybe iterate structure with a while loop.

    'value': function() {
        var res = {};
        this.each(function(i, v) {
            if (typeof v.value == 'function') {
                res[i] = v.value();
            } else {
                res[i] = v;
            }

        });
        return res;
    },

    // Much of the time enhanced_data_object will be used.
    // get() returns the object - will make the object out of field values / just return _.

    // Asyncronous nested get gets tricky - especially when some of the calls to get objects
    //  are asyncronous and some are not. However, need to process the list of property names
    //  asyncronously where necessary.

    // Maybe will do that outside of data-object though.
    //  The non-async get is fairly complicated already.
    //  It may be possible to make a new get function for Resource that makes use of the get function
    //   of data-object.
    //  However, a data-object would need to be able to interact with this...
    //   So I think that data-object needs this capability too.
    //   I think that asyncronous nested get will be a really useful capability to have,
    //   but it won't be so easy to implement.
    //    Need to be methodical about it.
    //  Running through nested get examples and tests would make a lot of sense.
    //  I think making some smaller jsgui test cases would also be very useful.

    // Would it be possible to make some simple resources that take a while to return a simple result, (1s maybe)?
    //  Then they could be in a chain / sequence so that the async get can be tested to work.

    // Perhaps only Resources have an async get() at their own level, getting their own information.

    // get - a word used because JS did not have getters and setters, getting from a local variable
    //       a word used to signify getting from a more remote location, like from disk or over a network
    //                              calculation

    // Making a very flexible get function would be a very useful thing to do. It will cover the various meanings,
    //  dealing with locally stored data as well as remote.

    // Within a Data_Object, it will be getting Data_Object properties syncronously, but when it encounters a Resource,
    //  it may need to get that asyncronously.

    // How about:
    //  If Data_Object get was called asynchronously, it can call async get functions from resources, and continues
    //   through the chain calling asynchronously.
    //  It fails if it tries to make a syncronous call on a Resource.
    //   Integrating promises would be nice, but it's a new style of programming that makes that part
    //    more complicated when used in conjunction with other pieces of coding that I'm also working on.


    // I think the non asyncronous get can be simplified.
    //  It seems like it is definitely worth getting unit testing done.



    'get': fp(function(a, sig) {

        // 17/06/2014 - Nested intrinsic properties.
        //  Need to access object[propertyName], not just object._[propertyName]
        //   However, may want to say some names of properties are never intrinsic.


        // Could have more managable (for the compiler) functions.

        // but when nested is in place, is it still working right?
        // also will have to deal with particular output formats.
        //  many controls / data types for the moment will have default output as HTML formatted.
        //console.log('Data_Object get this.__type_name ' + this.__type_name);
        //console.log('Data_Object get sig ' + sig);
        //console.log('* get a ' + stringify(a));
        // will also be looking at the output processors.
        if (is_defined(this.__type_name)) {
            // should possibly have this assigned for controls...
            //var raw_input = a;
            //console.log('this.__type_name is defined: ' + this.__type_name);

            //var parsed_input_obj = jsgui.input_processors[this.__type_name](raw_input);
            if (a.l == 0) {
                var output_obj = jsgui.output_processors[this.__type_name](this._);
                return output_obj;
            } else {
                throw 'not yet implemented';
            }
        } else {

            if (sig == '[s,f]') {

                // however, it is more complicated than that.
                //  maybe put this in resource level?

                // Though, collections and data-objects handling async operations well would be an advantage.
                //  This may intersperse with the resources, could perhaps have the resource return a promise
                //  (function?) if it had to operate asyncronously.

                // Go through the system with async calls?
                //  May not be all that hard to do...

                // I think this may need more work...
                //  Keep continuing through the chain, using async chaining.
                throw 'Asyncronous access not allowed on Data_Object get.'


                var res = this.get(a[0]);
                var callback = a[1];

                if (typeof res == 'function') {
                    res(callback);
                } else {
                    return res;
                }



                // could check if we had a function returned.
                //  then we execute that function


                //callback(null, res);
            }

            // check to see if there is a field defined.
            if (sig == '[s]') {
                //console.log('get param: ' + a[0]);
                var fc = this.fc;

                // let's have a look at the fields

                // Don't try to stringify field collections (yet).

                //console.log('fc.get() ' + stringify(fc.get()));



                var field_name = a[0];
                // could have .s in it, making it nested, and have removed nested from here.
                //console.log('pre fc get');
                var field;
                if (fc) {
                    field = fc.get(a[0]);
                }


                //throw 'stop';

                // being told to get 'dom.attributes.class'.
                //console.log('field ' + field);
                // should be able to get 'dom' field first.

                // so if it is multi-level, we can have a function that processes this multi-level request.

                //console.log('field_name ' + field_name);

                if (field_name.indexOf('.') > -1) {
                    // Then we are dealing with a request for a nested object.
                    // Split up the field_name into the various field names for the levels, then have a recursive function here
                    //  process through the levels. Will keep the recursive part small in size and located here.
                    // May not need to even be recursive.

                    var arr_field_names = field_name.split('.');

                    var level = 0, l = arr_field_names.length;
                    var current_obj = this, new_obj, fname;
                    while(level < l) {
                        fname = arr_field_names[level];
                        if (!current_obj) {
                            return undefined;
                        }

                        // OK, but we may be dealing asyncronously now. If the current object is a function,
                        // it gets called and we use the callback to do its stuff.

                        // I think this branch should only handle synchronous chaining.
                        /*
                        if (typeof current_obj == 'function') {
                            // the gotten info is there I hope
                            // This totally would not work in a while loop I think.
                            //  Maybe would need to split up the getting, and ending the while loop.
                            // May be worth seeing what is next...

                            // if this was called without a callback, and needs to be async, can return
                            //  a function to call.

                            // let's have a look at the next levels field names...
                            console.log('level', level);
                            console.log('arr_field_names', arr_field_names);

                            // want to get the slice of arr_field_names until the next
                            //  maybe return a promise to get it here?
                            //   and set it up so that it proceeds to get it...

                            var next = arr_field_names.slice(level).join('.');

                            return function(callback) {
                                //return current_obj.get(next, callback);
                                return current_obj(function(err, res) {
                                    console.log('got res', res);
                                    console.log('got res', stringify(res));

                                    // That's assuming res is a resource or data_object?

                                    res.get(next, callback);
                                    //res(next, callback);
                                    //callback(null, res);
                                })
                            }


                            // want to call get on the item returned.


                            //throw 'stop';

                            //current_obj(function(err, gotten) {
                            //	//new_obj = current_obj.get(fname);
                            //	level++;
                            //	// too late by now. would need to break out of the while.
                            //	//  not really possibly (right now)?
                            //	//

                            //	current_obj = new_obj;
                            //})

                        } else {
                        */
                        new_obj = current_obj.get(fname);
                        //console.log('fname ' + fname);

                        // So, when the dom object is obtained, it should have its own fields.
                        //  The 'get' function will need to be modified to return objects of the right type / class.

                        //console.log('new_obj ' + stringify(new_obj));
                        //console.log('current_obj ' + stringify(current_obj));

                        level++;
                        current_obj = new_obj;
                        /*
                        }
                        */



                    }

                    // but could this return a function?
                    //  could that be handled?

                    return current_obj;
                }

                //console.log('field_name ' + field_name);
                //console.log('field ' + stringify(field));

                // fields seem to stop having been set up properly.

                //console.log('get: field ' + (field));
                //throw 'stop';
                if (field) {
                    //console.log('tof(field) ' + tof(field));
                    //console.log('field ' + stringify(field));

                    //throw 'stop';

                    //console.log('this._[field_name] ' + this._[field_name]);
                    // depending on the type, such as if it is a collection or some other kind of Data_Object, define it.
                    //if (!is_defined())

                    // do we know the field name yet?
                    // yes
                    //console.log('field_name ' + field_name);
                    //console.log('this._[field_name] ' + this._[field_name]);


                    if (!this._[field_name]) {

                        //console.log('did not find object for field. will make one if appropriate. field_name = ' + field_name);
                        //console.log('this._[field_name] ' + this._[field_name]);
                        // create the new item of that type.
                        //  just collections for the moment.

                        var sig_field = get_item_sig(field, 20);
                        //console.log('1) sig_field ' + stringify(sig_field));
                        //console.log('field ' + stringify(field));
                        // And a function here? The definition of a field? String consructor etc.
                        //  Harder to differentiate between that and callbacks now.

                        // A constructor function or a callback?
                        //  There would need to be a way to tell the difference, even if we assign a
                        //  _is_constructor property to the constructors.

                        // Perhaps stop using this?
                        //  We can get fields anyway, without specifying the types.
                        //  Also the constructor function there gets confused with callbacks potentially.

                        if (sig_field == '[s,s,f]') {
                            var field_name = field[0];
                            var fieldStrType = field[1];
                            var fieldDef = field[2];

                            // Maybe look out for String?
                            //  Dealing with String fields, given as a String class?


                            // But if it is a String, maybe we use a Data_Value

                            if (fieldDef == String) {
                                //console.log('is a String');
                                //throw 'stop';

                                var dval = new Data_Value({
                                    'context': this._context
                                })
                                this._[field_name] = dval;
                                return this._[field_name];


                            } else if (fieldDef == Number) {
                                //console.log('is a String');
                                //throw 'stop';

                                var dval = new Data_Value({
                                    'context': this._context
                                })
                                this._[field_name] = dval;
                                return this._[field_name];


                            } else if (fieldStrType == 'Class') {
                                // Can't create a new string like this...

                                var FieldConstructor = fieldDef;
                                var nObj = new FieldConstructor({
                                    'context': this._context
                                })
                                this._[field_name] = nObj;
                                return this._[field_name];

                            }



                        }

                        if (sig_field == '[s,[s,u]]') {
                            // it looks like it has gone wrong.
                            var stack = new Error().stack;
                            console.log(stack);
                        }

                        if (sig_field == '[s,s,o]') {
                            var field_name = field[0];
                            var field_type_name = field[1];
                            var field_info = field[2];

                            //field_name
                            //console.log('* field_name ' + field_name);
                            //console.log('* field_type_name ' + field_type_name);
                            //console.log('* field_info ' + stringify(field_info));
                            // need to cover cases where we have the field info.
                            //  it may need to create a new object matching that field, with the check
                            //   that the data fits into that field.
                            // Data_Value would likely be a good type for a variety of fields.





                            if (field_type_name == 'collection') {
                                //console.log('lazy loading - creating new collection');
                                this._[field_name] = new jsgui.Collection({
                                    'context': this._context
                                });
                                return this._[field_name];
                            } else {
                                // if it's just a string?

                                // 'data_object'
                                //  may get the data_type_object_constructor here.

                                if (field_type_name == 'data_object') {
                                    var dobj = new Data_Object({'context': this._context});
                                    this._[field_name] = dobj;
                                    dobj.parent(this);
                                    return this._[field_name];
                                }


                                if (field_type_name == 'ordered_string_list') {
                                    var osl = new Ordered_String_List();
                                    this._[field_name] = osl;
                                    return this._[field_name];
                                } else if (field_type_name == 'string') {
                                    // use a Data_Value?
                                    //throw 'stop';
                                    var dv = new Data_Value({
                                        'context': this._context
                                    });
                                    //dv.set()

                                    //console.log('dv.__id ' + dv.__id);
                                    //console.log('dv._id() ' + dv._id());
                                    //throw 'stop';
                                    this._[field_name] = dv;

                                    // not providing an index
                                    dv.parent(this);

                                    //console.log('dv ' + stringify(dv));

                                    return this._[field_name];
                                } else {

                                    // need to look into more info about the field.
                                    //
                                    //console.log('field_info ' + stringify(field_info));
                                    // ignore indexed here I think.

                                    // Can get data type object constructors for various types of field, such as
                                    //  {"data_type": ["text", 32], "indexed": true}
                                    //  indexed text(32)


                                    //if (field_info.data_type == )
                                    // need to see if it's a text field.
                                    //  data_type = [name, length]
                                    //  and look at the item_sig for the data_type.
                                    var dt = field_info.data_type;
                                    var dt_sig = get_item_sig(dt, 4);
                                    //console.log('dt_sig ' + dt_sig);

                                    if (dt_sig == '[s,n]') {
                                        var data_type_name = dt[0];
                                        var data_type_length = dt[1];

                                        // then for text, just make a Data_Value

                                        if (data_type_name == 'text') {
                                            var dVal = new Data_Value({
                                                'context': this._context
                                            });
                                            //dVal.parent(this);
                                            //value.set(field_val);
                                            this._[field_name] = dVal;
                                            return this._[field_name];
                                        }

                                        // If the data type is just a string, need to process some specific
                                        //  data types.
                                        // This may be possible using input processors?


                                    } else if (dt_sig == 's') {
                                        var data_type_name = dt;
                                        //console.log('*** data_type_name ' + data_type_name);

                                        if (data_type_name == 'int') {
                                            var dVal = new Data_Value({
                                                'context': this._context
                                            });
                                            //dVal.parent(this);
                                            //value.set(field_val);
                                            this._[field_name] = dVal;
                                            return this._[field_name];
                                        }
                                        //if (data_type_name == '')
                                    } else {
                                        var dtoc = this.mod_link().ensure_data_type_data_object_constructor(field_type_name);
                                        //console.log('dtoc ' + dtoc);
                                        // then use this to construct the empty field.

                                        //throw '!!stop';

                                        var field_val = new dtoc({'context': this._context});
                                        field_val.parent(this);
                                        this._[field_name] = field_val;
                                        return this._[field_name];
                                    }



                                    // throw 'stop';


                                }

                                // check if it is a defined data type.
                                //  if so, we can do something with it.
                                //   input with that data type, and output from it.

                                // This code is getting quite big. I think it won't be all that big when compressed, refactored a bit.
                                //  Once it has been tested it can be refactored down quite a lot, don't want to do that while it is still being built.

                                // if there is an input processor, we know how to deal with it for the moment.
                                //  same with output processor?

                                // so you get the dom data_object?
                                //  I think automatically created and nested Data_Objects are the way.

                                // a Data_Object of that type?
                                //  automatic Data_Object extensions?

                                //throw('5) stop');
                            }

                        } else if (sig_field == '[s,s]') {
                            var field_name = field[0];
                            var field_type_name = field[1];

                            //console.log('field_name ' + field_name);
                            //console.log('field_type_name ' + field_type_name);

                            // perhaps getting collection fields should be moved to enhanced_data_object?
                            //  not keen on interdependencies here.



                            if (field_type_name == 'collection') {

                                // lazy creation of fields.

                                throw 'not supported here. should use code in enhanced-data-object.';

                                // So, Collection has been added to jsgui by now.
                                console.log('pre make coll');

                                // Maybe Collection has not been added to jsgui.
                                //  Need to ensure it does get added when it's getting used.

                                // seems like the Collection object does not get put back on this...
                                //  or at least not always.

                                // looks like we use the module as it is.

                                var coll = new jsgui.Collection({
                                    'context': this._context
                                });

                                console.log('pre set coll parent');
                                coll.parent(this);

                                this._[field_name] = coll;
                                return this._[field_name];

                            } else if (field_type_name == 'data_object') {
                                var dobj = new jsgui.Data_Object({
                                    'context': this._context
                                })
                                dobj.parent(this);
                                this._[field_name] = dobj;
                                return this._[field_name];

                            } else {
                                var dtoc = jsgui.ensure_data_type_data_object_constructor(field_type_name);
                                //console.log('dtoc ' + dtoc);
                                //throw '!stop';
                                // then use this to construct the empty field.
                                //  without the new constructor it was trying to make an abstract version!!!
                                var obj = new dtoc({'context': this._context});
                                //if (this._context) obj._context = this._context;
                                obj.parent(this);

                                this._[field_name] = obj;
                                //console.log('this._ ' + stringify(this._));

                                return this._[field_name];
                            }
                        } else if (sig_field == '[s,[s,s]]') {
                            var field_name = field[0];
                            var field_info = field[1];

                            //console.log('field_info ' + stringify(field_info));

                            if (field_info[0] == 'collection') {
                                var collection_type_name = field_info[1];

                                // new Collection('string') should work.

                                // context needs to be set at the beginning though.
                                //  Can't make a collection from this module.

                                // Need a way to be able to!

                                //var ncoll = new jsgui.Collection({'context': this._context})

                                //var ncoll = new jsgui.Collection(collection_type_name);
                                //if (this._context) ncoll._context = this._context;

                                //ncoll.parent(this);
                                //this._[field_name] = ncoll;
                                //return this._[field_name];
                            }
                        } else if (sig_field == '[s,[s,o]]') {
                            // [fieldName,['collection', objDef]]

                            // eg field ["entries", ["collection", {"address": "string", "family": "string", "internal": "boolean"}]]
                            // it's a collection?? (check, with the particular data type)

                            var field_name = field[0];
                            var field_info = field[1];
                            var data_type_name = field_info[0];

                            if (data_type_name == 'collection') {
                                var objDef = field_info[1];
                                throw 'not supported here. should use code in enhanced-data-object.';

                                // Need to do more than this.
                                //var ncoll = new jsgui.Collection({'context': this._context})

                                //var ncoll = new jsgui.Collection(collection_type_name);
                                //if (this._context) ncoll._context = this._context;

                                //ncoll.parent(this);
                                //this._[field_name] = ncoll;
                                //return this._[field_name];
                            }

                        }


                    } else {
                        //console.log('did find field obj ' + field_name);

                        return this._[field_name];
                    }

                    //var tf = tof(this._[field_name]);
                    //console.log('tf ' + tf);
                    //if ()

                } else {
                    // Without a field... t

                    var res = ll_get(this._, a[0]);


                    if (!res) {
                        if (field_name.indexOf('.') > -1) {
                            throw 'not yet handled';
                        } else {
                            res = this[a[0]];
                        }
                    }
                    // Instrinsic get...



                    //console.log('property_name ' + property_name);

                    // Breaks it with stringify, is hard to track down.
                    //  Maybe worth keeping as an example gotcha.
                    //console.log('res ' + res);
                    return res;
                }



            } else if (a.l == 0) {
                // need to get the values of all fields.
                //  Think they are now being held in the field collection, fc.

                return this._;
            }
        }


    }),

    // trying a different way of doing things.

    '___get_fields_chain': function() {
        // is this the prototype / constructor.

        var my_fields = this._fields;

        // a bit difficult...


        console.log('my_fields ' + stringify(my_fields));

        var con = this.constructor;
        console.log('con ' + stringify(con));

        //this._super();

        /*

        var sc = this._superclass;
        console.log('sc ' + sc);



        console.log('this._fields ' + stringify(this._fields));

        if (con) {
            var con_fields = con._fields;
            console.log('con_fields ' + stringify(con_fields));

            var con_super = con._superclass;
            console.log('con_super ' + stringify(con_super));

            var con_pro = con.prototype;
            console.log('con_pro ' + stringify(con_pro));

            var con_pro_super = con.prototype._superclass;
            console.log('con_pro_super ' + stringify(con_pro_super));

            var con_pro_fields = con_pro._fields;
            console.log('con_pro_fields ' + stringify(con_pro_fields));


        }


        var pro = this.prototype;
        console.log('pro ' + pro);

        if (pro) {
            var pro_fields = pro._fields;
            //var con_pro = con.prototype;
            console.log('pro_fields ' + stringify(pro_fields));


            var pro_super = pro._super;
            console.log('pro_super ' + stringify(pro_super));


        }
        */
    },

    '_get_input_processors': function() {
        //throw 'stop';
        return jsgui.input_processors;
    },

    //


    //'set': fp(function(a, sig) {
    'set': (function() {
      var a = arguments;
      a.l = arguments.length;
      var sig = get_a_sig(arguments, 1);
      //console.log('sig', sig);
        // property_name, value

        // May override this with collections...
        //  Clear, then push first item, when given a Data_Object.

        //console.log('Data_Object set sig ' + stringify(sig));
        //console.log('this._abstract', this._abstract);
        if (this._abstract) return false;

        var that = this, res;

        //console.log('');


        // May want to add it to a collection in some cases.
        //  Or make it the only item in the collection.

        // The signature for set as well?

        //console.log('');
        //console.log('set');

        //console.log('this.__type_name ' + this.__type_name);
        //console.log('this._data_type_name ' + this._data_type_name);



        var input_processors;
        if (this._module_jsgui) {
            input_processors = this._module_jsgui.input_processors;
        } else {
            input_processors = this._get_input_processors();
        }

        //console.log('*** input_processors ' + stringify(Object.keys(input_processors)));

        // or some other value will be set?
        //console.log('jsgui.input_processors ' + stringify(jsgui.input_processors));
        // These input processors need to be available throughout.
        //  Not sure about where to retrieve them from when using AMD.
        //   Could pass forward a request fot input processors.
        // so would have _get_input_processors function.
        //  that would retrieve it from whichever module it is from.

        // so there may not be an input processor set up already for it.
        //  some classes won't need it.

        // Need to refactor this.


        // setUsingInputProcessor

        // setUsingThis




        // Less important a distinction now.
        //  The data types may have been set up so that they just apply fields, not that they have got
        //   input and output processors.

        if (is_defined(this._data_type_name) && input_processors[this._data_type_name]) {
            // use the input processor of the data_type.

            throw 'stop';

            console.log('is_defined _data_type_name and input_processors[this._data_type_name]');

            //console.log('this.__type_name ' + this.__type_name);
            //throw 'stop';
            var raw_input = a;

            // we may not have the means to parse that raw input...
            //console.log('input_processors)

            // OK, so when setting using the type that has come about through the type system...

            //console.log('raw_input ' + stringify(raw_input));


            // if there is no input processor, to set _, we process it directly.

            // ['name, value'];
            //  set our own fields.
            //if (input_processors[this._data_type_name]) {
                var parsed_input_obj = input_processors[this._data_type_name](raw_input);
                //console.log('parsed_input_obj ' + stringify(parsed_input_obj));
                //throw('2) stop');

                this._ = parsed_input_obj;

            this.trigger('change');
            //} else {

            //}





            // set, just with a value... just with the __type_name.
            //  Uses the data type parsing to do this.
            //  Should work for fields.





            // but then with get() - get according to an output format like HTML / CSS, or the internal JSGUI representation.
            //  could still make use of _ for the internal representation.


        } else {
            //console.log('no dtn defined');
            //console.log('a.l ' + a.l);
            //console.log('');


            if (a.l == 2 || a.l == 3) {


                var property_name = a[0], value = a[1];

                var ta2 = tof(a[2]);
                //console.log('ta2', ta2);

                var silent = false;
                var source;

                if (ta2 == 'string' || ta2 == 'boolean') {
                    silent = a[2]
                }

                if (ta2 == 'control') {
                    source = a[2];
                }

                //silent = false || a[2];


                //console.log('set property_name ' + property_name + ', value ' + value);
                //console.log('set value ' + value);
                //console.log('set value ' + stringify(value));

                // is the property read_only?

                if (!this._initializing && this._map_read_only && this._map_read_only[property_name]) {
                    throw 'Property "' + property_name + '" is read-only.';
                } else {

                    //console.log('***');

                    // not using ll_set any longer.

                    // need to use a routine that deals with the data_types.

                    // Think we need some kind of recursive get-set type of routine.
                    //  Get will get it to greate objects that are fields anyway.

                    //console.log('property_name', property_name);

                    var split_pn = property_name.split('.');
                    //console.log('split_pn.length ' + split_pn.length);

                    // When setting some types of Data_Object class
                    //  (like Server, a subclass of Data_Object, and a Resource)
                    // need to make sure it sets it with the item given.



                    if (split_pn.length > 1 && property_name != '.') {
                        //console.log('split_pn ' + stringify(split_pn));

                        var spn_first = split_pn[0];
                        var spn_arr_next = split_pn.slice(1);

                        // For dealing with a root item?
                        //  So can set its . property?

                        // I think we have a special '.' field.
                        //  Treat it as an object.



                        //console.log('spn_first ' + stringify(spn_first));
                        //console.log('spn_arr_next ' + stringify(spn_arr_next));

                        var data_object_next = this.get(spn_first);
                        //console.log('data_object_next', data_object_next);
                        if (data_object_next) {

                            var res = data_object_next.set(spn_arr_next.join('.'), value);

                            if (!silent) {

                                var e_change = {
                                    'name': property_name,
                                    'value': value,
                                    'bubbled': true
                                };

                                if (source) {
                                    e_change.source = source;
                                }

                                // I think this is bubbling.
                                //  Maybe mark it as bubbled.

                                this.raise_event('change', e_change);
                            }


                            return res;

                        } else {

                            // Could create a new Data_Object.

                            //var ndo = new Data_Object({
                            //	// with a context?
                            //	'context': this._context
                            //});

                            // but for the '.' property...









                            // Is this recursive?
                            //  Need to fix this.

                            // May need to specify a data model?
                            //  But we want this to be flexible?

                            // Maybe we need to declare that Script has got some deeper attributes.

                            //var data_object_next = new

                            // Not sure how this is recursing properly.
                            //  Maybe work on this at some other time, using an example that's more sandboxed,
                            //   such as the US presidents example.





                            //var stack = new Error().stack
                            //console.log(stack);
                            throw('No data object at this level.');
                        }
                        throw('10)stop');
                        // call a multi-level-set function?
                        //  could do it recursively here for the moment I think, without much code.
                        //   like it is now :)


                    } else {

                        //console.log('2) no split');

                        // not necessarily, it still may apply to a data_object.

                        //console.log('pre get ');
                        //  if there is nothing, get should return undefined / null.
                        //   perhaps make it if it is an expected object though.
                        //    it looks like it is expected? or we have it from the value anyway.
                        //    maybe it's only fine to set it to a data_object / data_value.

                        // if it is just a string we can make a Data_Value to hold it and then put it in place.
                        // can use the dobj function???

                        // can just set the value.
                        //  could just record the string in here.
                        //  putting it in a Data_Value would eventually help with automatic string indexing.
                        //   And it would potentially be an indexed field anyway.

                        // Potentially parsing object input?
                        //  Will have more of that working to do with some HTML properties to start with.





                        // get it???
                        //  that could work... could create the right constructor.

                        //  There maybe will only be a

                        // Maybe don't need to get this...
                        //console.log('---');
                        // We may be able to get it, using lazy loading in some cases.
                        //  This may look at the fields and create a new object.

                        //console.log('1) property_name ' + property_name);
                        // But we are setting it!!!



                        // May do away with data_object_next.
                        //

                        var data_object_next = this.get(property_name);

                        // Looking for these in resources, and doing more than needs to be done on init?



                        // So, the property has not been defined correctly.
                        //  Need to make it so that data_def sets up the fields so that they work.




                        //console.log('---');
                        //  gets it as a string?


                        // Stringifying this causes an endless loop (sometimes)
                        //console.log('data_object_next ' + stringify(data_object_next));

                        // failing to get tagName property - it's a string proper

                        // and when setting the tag_name object?

                        //console.log('property_name ' + property_name);
                        //console.log('value ', (value));
                        //console.log('***** data_object_next ' + data_object_next);
                        if (!is_defined(data_object_next)) {

                            // add it to the fields collection?
                            //this._[property_name] = new Data_Object({});
                            //return this.set(property_name, value);
                            //console.log('tof(value) ' + tof(value));


                            //var tv = tof(value);
                            var tv = typeof value;

                            /*
                            if (tv == 'data_object') {
                                // copy directly in more cases than this... maybe just for primitive types do we use the
                                //  data_value.

                            } else {

                            }
                            */
                            var dv;
                            //console.log('tv ' + tv);
                            if (tv == 'string' || tv == 'number' || tv == 'boolean' || tv == 'date') {
                                dv = new Data_Value({'value': value});
                            } else {
                                dv = value;
                            }


                            //console.log('dv ' + stringify(dv));
                            //this._[property_name] = value;
                            //throw 'Should make a new Data_Value';

                            this._[property_name] = dv;
                            // Not making a new Data_Value?

                            //console.log('this._[property_name] ' + this._[property_name])

                            //this.raise_event('change', [property_name, dv]);

                            if (!silent) {
                                var e_change = {
                                    'name': property_name,
                                    'value': dv
                                }

                                if (source) {
                                    e_change.source = source;
                                }

                                this.raise_event('change', e_change);
                            }




                            //throw 'stop!!!';

                            // Perhaps should return the Data_Value?

                            return value;

                        } else {
                            //console.log('this ' + stringify(this));
                            //console.log('2) property_name ' + property_name);
                            //console.log('data_object_next ' + stringify(data_object_next));
                            //console.log('tof data_object_next ' + tof(data_object_next));

                            // Just because we can get the server as a next data object, does not mean we need to.

                            //  If we have been given a value, use it.
                            //  However, need to clarify this code here.
                            //   At some times we will want it to produce the next level of data object, but not at others.

                            // Setting a field should be a fairly simple procedure if possible, maybe this code could
                            //  be refactored.

                            // So when we have been given a server property, we want to set ._.server to it

                            //


                            // REFACTOR?



                            // if it is a data object?
                            //  if it is a native type?



                            if (is_js_native(data_object_next)) {
                                //console.log('is_js_native');
                                //this.set
                                // but maybe that object should be wrapped in Data_Object?
                                this._[property_name] = value;
                                res = value;


                            } else {
                                //console.log('not is_js_native');
                                //var res = data_object_next.set(value);

                                this._[property_name] = value;
                                res = value;

                                //console.log('set data object next using value');
                            }




                            //var res = ll_set(this._, property_name, value);
                            // should raise an event here.

                            // this.raise_event('set', [property_name, value]);
                            // then the event tells everything that is listening to it.
                            //console.log('this', this);

                            //this.trigger('change', [property_name, value]);
                            //console.log('property_name', property_name);
                            //console.log('value', value);
                            //console.log('this', this);

                            if (!silent) {
                                var e_change = {
                                    'name': property_name,
                                    'value': value
                                };
                                if (source) {
                                    e_change.source = source;
                                }
                                this.trigger('change', e_change);
                            }


                            // want to listen to the set event for some things such as GUI components in particular.

                            return res;
                        }
                    }
                }
            } else {
                // But maybe it should be a data_value, not a data_object.

                //console.log('3) else sig ' + sig);

                // And for a Data_Object?
                //  Basically put it into place.

                if (sig == '[D]') {
                    //console.log('property_name ' + property_name);
                    this._[property_name] = value;

                    this.raise_event('change', [property_name, value]);

                    // Raise a change event?
                    //  Or is set event OK?

										return value;



                }

                if (sig == '[o]') {
                    //console.log('setting with a provided object');

                    var that = this;
                    // may need to be recursive.
                    var res = {};
                    each(a[0], function(i, v) {
                        //console.log('i ' + i);
                        //console.log('v ' + stringify(v));

                        res[i] = that.set(i, v);
                        //that.raise_event('change', [i, v]);

                    });
                    return res;
                }

                // C for collection?
                if (sig == '[c]') {
                    //this._[]
                    this._[property_name] = value;
                    this.raise_event('change', [property_name, value]);
                    //throw 'unsupported';
										return value;
                }
            }
        }
    }),
    'has' : function(property_name) {
        return is_defined(this.get(property_name));
    }
});

var initializing = false, fnTest = /xyz/.test(function() {
    xyz;
}) ? /\b_super\b/ : /.*/;


var get_fields_chain = function(data_object_class) {
    var res = [];
    var inner = function(data_object_class) {
        // _fields... fields will be given as an array by default, to preserve the order.

        var fields = data_object_class._fields;


        //console.log('get_fields_chain fields ' + stringify(fields));
        if (fields) {
            res.push(fields);
        }
        // Could be pushing an array containing an array that represents one field.

        var sc = data_object_class._superclass;
        //console.log('sc ' + sc);
        //if (sc) console.log('sc.constructor._fields ' + stringify(sc.constructor._fields));
        if (sc) {
            inner(sc);
        }
    };
    inner(data_object_class);
    //console.log('get_fields_chain res ' + stringify(res));
    return res;
}


// But the fields may have an order. It may be necessary to preserve that order.
//  The order of fields is not of great imporance usually. May be nice to have their order guaranteed to stay the same...
//   it may be that different JavaScript engines will do this anyway.

var get_chained_fields = function(data_object_class) {
    // would be nice to do this in a way that preserves the order.
    //  an array of fields may be better.

    // The fields chain... need to make sure that is getting the separate fields.
    var fc = get_fields_chain(data_object_class);



    var i = fc.length; //or 10

    //var res = {};
    var res = [];

    // Not so sure about doing this... is it breaking up a field into more than one field when it should not be?


    while(i--)
    {
      //...
        var item = fc[i];

        // the item can be an object... or an array. Array is better.

        //each(item, function(i2, v) {
        //	res[i2] = v;
        //});

        // [field_name, field_info]

        // Not so sure about including the number?
        //  Is it necessary?
        // Maybe it can be ignored at a later stage.
        //  However, do want it to properly interpret the fields at a later stage.

        var c = 0;

        //console.log('item', item);
        // item is either an object or an array.

        each(item, function(i2, field_info) {

            //console.log('');
            //console.log('i2 ' + i2);

            if (tof(i2) == 'string') {
                c = c + 1;
                res.push([c, [i2, field_info]]);
            } else {
                res.push([i2, field_info]);
                c = i2;
            }

            //console.log('field_info ' + stringify(field_info));

            //res[i2] = v;
            // field_info could just be the field_name and some text. that should be fine.

        });

    }
    // not sure that all fields will have simple types.
    //  some will be constructors even.
    // Fields should have been set correctly, not like get_chained_fields res [[0, "indexed_array"], [1, [["red", "number"], ["green", "number"], ["blue", "number"]]]]
    //console.log('get_chained_fields res ' + stringify(res));
    return res;
}

var chained_fields_to_fields_list = function(chained_fields) {


    /*
    var res = [];
    each(chained_fields, function(i, v) {
        var field_number = v[0];
        var field = v[1];
        res.push(field);
    });
    */

    //console.log('chained_fields ' + stringify(chained_fields));

    var l = chained_fields.length;
    //console.log('l ' + l);
    var res = new Array(l);
    //var res_push = res.push;
    for (var c = 0; c < l; c++) {
        //res_push.call(res, chained_fields[c][1]);
        //res.push(chained_fields[c][1]);
        res[c] = chained_fields[c][1];
    };


    return res;
};

jsgui.map_classes = {};

/*
Object.prototype.begetObject = function () {
    function F() {}
    F.prototype = this;
    return new F();
};

newObject = oldObject.begetObject();
*/

// Also want to specify functions that execute upon initialization that call
//  a function, using a parameter that gets set in the definition.
// This will be used to enable a Collection subclass to be defined as
//  Collection.extend({'data_object': Data_Object_Subclass});
//   Like a collection of products holding the Product Data_Object type and having that
//   easily and clearly declared within the model code.
// Could this be done in the normal init?
//  or use propsToMerge?

Data_Object.extend = function(prop, post_init) {
    var _super = this.prototype;
    initializing = true;
    var prototype = new this();

    // copying accross some old things?
    //  keeping some things in the prototype chain?
    var for_class = {};

    initializing = false;

    //if (tof(prop) === 'string') {
    if (typeof prop === 'string') {
        // giving it a data_type from the jsgui.data_types_info
        var data_type_name = prop;
        var dtis = jsgui.data_types_info;
        //console.log('dtis ' + stringify(dtis));
        //return dtis;
        var data_type_info = dtis[data_type_name];
        //console.log('data_type_name ' + stringify(data_type_name));
        //console.log('data_type_info ' + stringify(data_type_info));
        for_class[data_type_name] = data_type_name;
        for_class[data_type_info] = data_type_info;
        // then it will be read from the class object itself.
        //  will be able to get the constructor object, I think.
        // maybe not best to do this through the prototype?
        //  having difficulty getting the constructor, within the constructor function.
        prototype['__type_name'] = data_type_name;
        prototype['__data_type_info'] = data_type_info;

        prop = {};

        // then this effectively sets its fields.
        //  create the fields, in order, and have a numeric index saying which field is which.
        //  will have an _operating_mode.
        //  the data_object will be able to operate as an indexed_array... but not sure about making a collection and giving it named items?
        //   collection already takes named items.

        // Will also need to deal with collections of objects here.
        //  Will be very nice when the HTML code is very declarative.

        // Data_Type_Instance? Or the constructor to the relevant Data_Object functions as its instance?
        //  It's not exactly an instance, it's a constructor, but constructors can have their own methods too.

        // Then this is the data_type_instance, effectively.

        // so it will hold the data type info within the constructor?
        //  or named reference to it is fine.

        //throw('*1 stop');
    }
    var prop_item, t_prop_item, tmp, name, res;

    var keys = Object.keys(prop);
    //var key;
    for (var c = 0, l = keys.length; c < l; c++) {
      name = keys[c];
      prop_item = prop[name];

      if (name.charAt(0) === '#') {

          // direct copy with '#'... not been using that.

          prototype[name.substring(1)] = prototype[prop_item];
      } else {
          // if it's a function, then do the following.

          // if it's an object, then it may be something specific to the DataObject type.
          //  such as setting / extending fields of an object.

          // some specific non-object things will be set to the prototype.
          //  it will be possible to look at this info, the fields chain in the object, will take a bit of trial, error and design.

          t_prop_item = typeof prop_item;
          //console.log('prop_item' + prop_item);
          if (t_prop_item === 'function') {

              prototype[name] = typeof _super[name] === 'function' && fnTest.test(prop_item) ?
              // had some difficulty using fp() with 'init' functions. could
              // it have to do with function names?

              (function(name, fn) {
                  return function() {
                      tmp = this._super;
                      this._super = _super[name];
                      res = fn.apply(this, arguments);
                      this._super = tmp;
                      return res;
                  };
              })(name, prop[name]) : prop[name];

          } else if (t_prop_item === 'object' || t_prop_item === 'boolean') {

              // don't put these in the prototype.
              //  they are not for the object itself.
              //console.log('property name', name);
              if (name == 'class_name') {
                  for_class['_class_name'] = prop_item;
              } else if (name == 'fields') {
                  // maybe call it something else, fields is a function.
                  // fields could be a function, so call it _fields
                  // it sets the array of fields... could be an object representing fields but an array is better because the order gets preserved.
                  //for_class['_fields'] = prop_item;
                  for_class._fields = prop_item;
                  //this['_fields'] = prop_item;
                  // then the fields will be read upon initialization?
                  //  getting all the fields up the chain...
              } else if (name == 'connect_fields') {
                  // maybe call it something else, fields is a function.
                  // fields could be a function, so call it _fields

                  //for_class['_connect_fields'] = prop_item;
                  for_class._connect_fields = prop_item;

                  // then the fields will be read upon initialization?
                  //  getting all the fields up the chain...

              } else {
                  prototype[name] = prop[name];
              }

          }  else {
              prototype[name] = prop[name];
          }
      };
    }

    //for (name in prop) {


    //};

    // Looks like this needs to be changed just to be local...

    var Class = function() {

        //console.log('Data_Object initializing ' + initializing);
        //console.log('Data_Object !!this.init ' + !!this.init);

        if (!initializing) {
            if (this.init) {
                this.init.apply(this, arguments);
                if (this.post_init) {
                    //this.post_init();
                    this.post_init.apply(this, arguments);
                }

                //if (post_init) {
                //    post_init.call(this);
                //}
                // Check to see if there are further functions to call...
                //  things that have got put into the extend function?



            } else {
                var spec = arguments[0] || {};
                spec.abstract = true;
                //var newClass = new Class(spec);

                //return newClass;
                return new Class(spec);
            }
        }

    };
    Class.prototype = prototype;
    //Class.constructor = Class;
    Class.prototype.constructor = Class;
    // but constructor loses info. not sure how to get back at the constructor from an object?
    //  what is the original constructor even?

    Class.extend = arguments.callee;

    /*
    if (for_class) {
        for (var c = 0, l = for_class.length; c < l; c++) {
            Class[i] = for_class[v];
        }
    }
    */
    //console.log('for_class', for_class);
    for (i in for_class) {
        Class[i] = for_class[i];
    }


    //each(for_class, function(i, v) {
    //	Class[i] = v;
    //});

    // jsgui.map_classes[]

    if (Class['class_name']) {
        jsgui.map_classes[Class['class_name']] = Class;
    }

    //console.log('_superprototype ' + _super.prototype);

    //Class.prototype._superclass = _super;

    Class._superclass = this;

    //Class._superprototype = _super;


    // * if (namespcExtension) { each(namespcExtension, function(i, n) {
    // * Class[i] = n; }); }; if (propsToMerge) { each(propsToMerge,
    // * function(i, n) { if (typeof Class.prototype[i] === 'undefined') {
    // * Class.prototype[i] = n; } else { $.extend(true, Class.prototype[i],
    /// * n); }; }); }


    return Class;
};


// Will have actual Constraint programming objects.
//  They may translate to the database level as well.
//  In many cases the constraints will be expressed as strings such as 'text(32)'.
//   Would then be translated to varchar(32) on a different level.



var data_object_matches_field_constraints = function(data_object, field_constraints) {
    // Field constraints given as a normal object.

    // returns true or false
    //  though could return failure information as well if asked for it.
    //  making it into another polymorphic function.

    each(field_constraints, function(fc_name, fc_value) {
        //console.log('fc_name ' + fc_name);
        //console.log('fc_value ' + fc_value);

    });
};
// That data object will be indexable.

var Enhanced_Data_Object = null;

var set_Enhanced_Data_Object = function (EDO) {
    Enhanced_Data_Object = EDO;
};

var get_Enhanced_Data_Object = function () {
    return Enhanced_Data_Object;
};


// seems like an overlap with the new jsgui.fromObject function.
//  That will initially go in the Enhanced_Data_Object module, or jsgui-enh

var dobj = function(obj, data_def) {
    // could take a data_def?
    // Could use the enhanced data object if we patch backwards?
    //  So Enhanced_Data_Object could hopefully patch backwards in the code?

    //var tdd = tof(data_def);

    var cstr = Data_Object;
    if (Enhanced_Data_Object) cstr = Enhanced_Data_Object;
    //console.log('Enhanced_Data_Object ' + Enhanced_Data_Object);

    var res;
    if (data_def) {
        res = new cstr({'data_def': data_def});
    } else {
        res = new cstr({});
    }

    var tobj = tof(obj);

    //console.log('obj ' + stringify(obj));
    if (tobj == 'object') {
        var res_set = res.set;
        each(obj, function(i, v) {
            //res.set(i, v);
            res_set.call(res, i, v);
        });
    }

    return res;
};


// This code could be done using other means in other parts of the system.
//  The framework code will provide more to do with data type definitions and interpreting input data.

// this seems like part of an input processor.
//  changes from text to the JavaScript objects that get understood.


// parsing a data type
// similar to parsing a JavaScript function call, but only one ting in the brackets, and there may not be brackets anyway


var parse_field_text = Fields_Collection.parse_field_text;
var parse_data_type = Fields_Collection.parse_data_type;
// We can't extend this further down while using requirejs
//  Not sure how to achieve this now, requirejs was meant to be for convenience.

// Can have some sort of function chaining.
//  And having a function within the right module called...
//  That could be a 'linking function.'
// mod_link.

// A new constructor for these?
//  Curried functions?
//  Or Boolean_DV... Would have tests possibly.

jsgui.map_data_type_data_object_constructors = jsgui.map_data_type_data_object_constructors || {};
jsgui.map_data_type_data_object_constructors['boolean'] = Data_Value;
//boolean': Data_Value



// Could do something like pass the ensure_data_type_data_object_constructor function around?
//  Or the HTML module will have its own way of making object constructors.

// I think only having object constructor functions going down the module loading heirachy will work.
//  May have a map of various loading functions that get made in each module.

// They are basically constructor functions.

// But this could have access or need access to more information about how to construct objects.
//  Want to get this working for 'color'.
var ensure_data_type_data_object_constructor = function(data_type_name) {

    //console.log('');
    //console.log('');
    //console.log('jsgui.map_data_type_data_object_constructors[data_type_name] ' + stringify(jsgui.map_data_type_data_object_constructors[data_type_name]));
    //console.log('');
    //console.log('');

    // Hardet to bring that map through all dependencies and back.
    //  However, need to have access to that map variable.

    //console.log('jsgui.map_data_type_data_object_constructors ' + jsgui.map_data_type_data_object_constructors);

    if (!jsgui.map_data_type_data_object_constructors[data_type_name]) {
        //console.log('creating new Data_Object constructor for data_type: ' + data_type_name)

        // Need to get the variable back through the modules...
        //  Missing global variables?
        //  Move this function somewhere else?
        //  Maybe we could have some storage available in jsgui-lang-essentials through a closure.
        //  That way the code could be sent back... but do we still have different instances running?

        // Could just be different execution contexts... co can't feed back this information about other objects.
        //  But can feed functionality forards.

        // May need to have things more independant.
        //

        //var dti = jsgui.get('dti');
        //console.log('dti ' + dti);
        //throw 'stop';

        var dto = jsgui.data_types_info[data_type_name];

        //console.log('dto ' + stringify(dto));

        var dtc = Data_Object.extend({
            'fields': dto
        })
        jsgui.map_data_type_data_object_constructors[data_type_name] = dtc;
    }
    return jsgui.map_data_type_data_object_constructors[data_type_name];
}
jsgui.ensure_data_type_data_object_constructor = ensure_data_type_data_object_constructor;

input_processors.field_text = parse_field_text;
input_processors.data_type = parse_data_type;

// Maybe do without the following.
//  Have different, simpler, flatter namespacing. Put lots of things in jsgui.
//  Then when the files get built together they get turned into local variables.

//Data_Object.Data_Value = Data_Value;



Data_Object.Fields_Collection = Fields_Collection;
Data_Object.dobj = dobj;
Data_Object.matches_field_constraints = data_object_matches_field_constraints;
Data_Object.parse_field_text = parse_field_text;
Data_Object.get_chained_fields = get_chained_fields;
Data_Object.chained_fields_to_fields_list = chained_fields_to_fields_list;
Data_Object.map_data_type_data_object_constructors = jsgui.map_data_type_data_object_constructors;
Data_Object.Mini_Context = Mini_Context;
Data_Object.set_Enhanced_Data_Object = set_Enhanced_Data_Object;
Data_Object.get_Enhanced_Data_Object = get_Enhanced_Data_Object;
Data_Object.ensure_data_type_data_object_constructor = ensure_data_type_data_object_constructor;

//return Data_Object;
module.exports = Data_Object;
//})

},{"./constraint":26,"./data-object-fields-collection":27,"./data-value":29,"./evented-class":31,"./jsgui-data-structures":35,"./jsgui-lang-essentials":37}],29:[function(require,module,exports){
var jsgui = require('./jsgui-lang-essentials');

var j = jsgui;
var Class = j.Class;
var each = j.each;
var is_array = j.is_array;
var is_dom_node = j.is_dom_node;
var is_ctrl = j.is_ctrl;
var extend = j.extend;
var get_truth_map_from_arr = j.get_truth_map_from_arr;
var get_map_from_arr = j.get_map_from_arr;
var arr_like_to_arr = j.arr_like_to_arr;
var tof = j.tof;
var is_defined = j.is_defined;
var stringify = j.stringify;
var functional_polymorphism = j.functional_polymorphism;
var fp = j.fp;
var arrayify = j.arrayify;
var mapify = j.mapify;
var are_equal = j.are_equal;
var get_item_sig = j.get_item_sig;
var set_vals = j.set_vals;
var truth = j.truth;
var trim_sig_brackets = j.trim_sig_brackets;
var ll_set = j.ll_set;
var ll_get = j.ll_get;
var input_processors = j.input_processors;
var iterate_ancestor_classes = j.iterate_ancestor_classes;
var is_arr_of_arrs = j.is_arr_of_arrs;
var is_arr_of_strs = j.is_arr_of_strs;
var is_arr_of_t = j.is_arr_of_t;
var clone = jsgui.clone;

var Evented_Class = require('./evented-class');


var Data_Value = Evented_Class.extend({
    'init': function(spec) {

        this._super();
        // the spec will be the value.
        //  could be the value and its type.

        //console.log('jsgui.__data_id_method ' + jsgui.__data_id_method);
        //throw 'stop';

        // so if the data_id_method is lazy, we get the id through a function.

        // Could take the context as another parameter...
        //  Can make it more flexible in terms of how it gets initialised.
        //  Data_Value(value) makes the most sense.

        if (spec && spec.context) {
            this._context = spec.context;

        }

        if (spec) {
            //console.log('!* spec.value ' + spec.value);
            //console.log('spec ' + stringify(spec));
        }

        if (spec && is_defined(spec.value)) {
            this._ = spec.value;
        }

        /*
        if (jsgui.__data_id_method == 'init') {
            //throw 'stop';
            // and there may be a map in the context.

            if (this._context) {

                // the context no longer keeps a map of the objects.
                //  Will work more on the relationships in a bit.



                //this._context.map_objects[this.__id] = this;
            } else {
                // don't want to be using IDs out of context.

                //throw 'Data_Value needs context';

                // but we'll try this - not setting the ID.
                //  really it needs an ID when it's in a page.
                //  Data_Values should be able to work at other times, such as rendering HTML examples.

                // But maybe it should be able to operate with no context or ID.
                //  It may be a demand of the context that it has an ID.
                //   (maybe not is some contexts though).

                //this.__id = new_data_value_id();



                //map_jsgui_ids[this.__id] = this;


            }
        }
        */

        //this._val = spec;

        this.__type = 'data_value';

        //this._bound_events = {};


        this._relationships = {};
    },
    'get': function() {
        //return this._val;
        return this._;
    },
    'value': function() {
        return this.get();
    },
    'toObject': function() {
        //if (this._.toObject) {
        //	return this._.toObject();
        //} else {
        //	return this._;
        //}
        return this._;

    },
    'set': function(val) {
        //this._val = val;
        var old_val = this._;

        this._ = val;
        this.raise('change', {
            'old': old_val,
            'value': val
        });

        return val;
    },
    'toString': function() {
        //return stringify(this.get());
        // con

        //console.log('this._val ' + stringify(this._val));
        //throw 'stop';

        return this.get();
    },
    // Maybe a particular stringify function?
    'stringify': function() {
        //return stringify(this.get());
        // con

        //console.log('this._val ' + stringify(this._val));
        //throw 'stop';

        var val = this.get();

        //var tval = tof(val);
        var tval = typeof val;
        if (tval == 'string') {
            return '"' + val + '"';
        } else {
            return val;
        }
    },

    'clone': function() {
        var val = this.value();

        var res = new Data_Value({
            'value': val
        });

        //console.log('res', res);
        //throw 'stop';

        return res;
    },


    '_id': function() {
        // gets the id.
        //console.log('this._context ' + this._context);
        //throw 'stop';
        if (this.__id) return this.__id;
        if (this._context) {
            //console.log('this.__type ' + this.__type);
            //throw 'stop';
            this.__id = this._context.new_id(this.__type_name || this.__type);

        } else {
            if (!is_defined(this.__id)) {
                throw 'DataValue should have context';
                this.__id = new_data_value_id();
            }
        }


        return this.__id;

    },
    'parent': fp(function(a, sig) {
        var obj, index;
        //console.log('parent sig', sig);


        if (a.l == 0) {
            return this._parent;
        }
        if (a.l == 1) {
            obj = a[0];

            if (!this._context && obj._context) {
                this._context = obj._context;
            }

            // IDs will only work within the context.



            // Another way of expressing this?

            // Can have a single parent, or multiple parents.
            //  May want something to be the only parent. Could have a different mode for multiple parents.

            //  this._parent = obj?


            //console.log('parent obj_id ' + obj_id);
            //throw 'stop'
            //console.log('obj ' + stringify(obj));
            // should maybe rename or subdivide _relationships.
            //  it will also be useful for databases.
            //  however, would need to work with the constraint system.
            //   likely that they would be syncronised through code.

            //var relate_by_id = function () {
            //    var obj_id = obj._id();
            //    this._relationships[obj_id] = true;
            //}

            //var relate_by_ref = function () {
            //    this._parent = obj;
            //}
            //relate_by_ref();

            var relate_by_id = function (that) {
                var obj_id = obj._id();
                that._relationships[obj_id] = true;
            }

            var relate_by_ref = function (that) {
                that._parent = obj;
            }
            relate_by_ref(this);
        }
        if (a.l == 2) {
            obj = a[0];
            index = a[1];

            if (!this._context && obj._context) {
                this._context = obj._context;
            }

            this._parent = obj;
            this._index = index;
        }

        if (is_defined(index)) {
            // I think we just set the __index property.
            //  I think a __parent property and a __index property would do the job here.
            //  Suits DOM heirachy.
            // A __relationships property could make sense for wider things, however, it would be easy (for the moment?)
            // to just have .__parent and .__index
            //


            // Not sure all Data_Objects will need contexts.
            //  It's mainly useful for Controls so far




        } else {
            // get the object's id...

            // setting the parent... the parent may have a context.





        }
    })
});

module.exports = Data_Value;

},{"./evented-class":31,"./jsgui-lang-essentials":37}],30:[function(require,module,exports){
/*

if (typeof define !== 'function') {
    var define = require('amdefine')(module);
}

define(["./jsgui-lang-util", "./data-object-fields-collection"], function(jsgui, Fields_Collection) {
    */

var jsgui = require('./jsgui-lang-util');
var Data_Value = require('./data-value');
var Data_Object = require('./data-object');
var Fields_Collection = require('./data-object-fields-collection');

var Data_Object = jsgui.Data_Object;
var Collection = jsgui.Collection;
var get_a_sig = jsgui.get_a_sig;
var fp = jsgui.fp;
var stringify = jsgui.stringify;
// Using actual JavaScript objects like String should be quite good.
//  JavaScript Primitive Contructors.

var is_defined = jsgui.is_defined, ll_get = jsgui.ll_get, get_item_sig = jsgui.get_item_sig;

// Having a Collection of strings here...
//  May need to choose the right collection context.
//  Don't want to have to deal with these contexts all the time though.
//   Or make it very fast to do so.

// A function to ensure the latest data types?

// Module level functions to register / syncronise things...
//  That makes a lot of sense.

var register_data_type = function(data_type_name, def) {
    jsgui.data_types_info[data_type_name] = def;
}

var ensure_data_type_data_object_constructor = function(data_type_name) {
    //console.log('ENH ensure_data_type_data_object_constructor');
    //console.log('data_type_name ' + data_type_name);

    if (!jsgui.map_data_type_data_object_constructors[data_type_name]) {

        // Can we get it from the most up-to-date module?
        //  Or even make use of a global variable?
        //  JSGUI?




        var dto = jsgui.data_types_info[data_type_name];
        //console.log('dto ' + stringify(dto));

        // Do we need to be accessing the latest data here?
        //  Can we patch the required component backwards?



        var dtc = Enhanced_Data_Object.extend({
            'fields': dto
        })
        jsgui.map_data_type_data_object_constructors[data_type_name] = dtc;
    }
    return jsgui.map_data_type_data_object_constructors[data_type_name];
}
// Maybe the Enhanced_Data_Object will have access to Collection?
var dop = Data_Object.prototype;
var do_init = dop.init;
var do_get = dop.get;

// And making it a collection will give it good enough indexing anyway.
var Enhanced_Data_Object = Data_Object.extend({
    // Can we define a Collection like that?

    // the flags is a collection of strings... but we want to connect the flags.

    // But we can choose the context for the object.
    //  Will need to do that.

    // But maybe object could only have flags if they are used?
    //  Dormant fields?

    // Collection(String) being in the general context?
    //  It could be a special case, for abstract collections.
    //  Also, not using the 'new' keyword.

    'fields': [['flags', Collection(String)]],

    // Collection(String) may be hard to understand... Collection is a Class and is normally called with a constructor.
    //  It has not normally been declared with a native data type inside (or any data type) but it could be done and is convenient
    //   syntax. I think without the constructor, but with the object inside, it could be an abstract or representative object,
    //   and used so that we know Collection(String) is a collection of strings (probably implemented using Data_Value objects).

    // so will this flags field start up OK?
    //  that should be enough to get the flags field there.

    //'init': function(spec) {
    //	this._super(spec);
    //},

    /*

    'init': function(spec) {
        //this._super(spec);
        do_init.call(this, spec);
        // need to respond to flag fields being added and removed.
        //  when a flag gets added, there needs to be the flag's connected function.

        //.flags().selected?
        //.flags('selected');

        // .selected(true); .selected(1);

        // can leave the flags unconnected for the moment, and return to the flags connection so there is
        //  easier syntax and probably faster code.

        // but want it so we know when flags have changed (the collection of flags)?

        // also when any flags' value has changed.

        // can quite simply add and remove flags from an object.
        //  also may pay some attention to a restricted list of flags, where if the flags are not set then we know
        //  the values are false.

        // want to make it easy to deal with flags that correspond to css as well.

    },
    */
    // or an enhanced version of the set function that deals with more input processors?
    //  Or have the supercalssed set function send mack the input processors in parameters.
    //   I think that is the best option.

    '_get_input_processors': function() {
        //throw 'stop';
        return jsgui.input_processors;
    },
    'add_flag': function(flag_name) {
        var flags = this.get('flags');
        //console.log('flags ' + stringify(flags));
        var fields = this.fields();
        //console.log('fields ' + stringify(fields));
        // unfortunate that no fields are found???
        //  should probably be a few.
        if (!flags.has(flag_name)) {
            flags.add(flag_name);
        }
    },
    'remove_flag': function(flag_name) {
        var flags = this.get('flags');
        //console.log('flags ' + stringify(flags));
        //throw 'stop';
        var has_flag = flags.has(flag_name);
        //console.log('has_flag ' + has_flag);

        if (has_flag) {
            flags.remove(flag_name);
            console.log('flags ' + stringify(flags));

            flags = this.get('flags');
            console.log('flags ' + stringify(flags));
            //throw 'stop';
        }

    },
    'has_flag': function(flag_name) {
        var flags = this.get('flags');
        return flags.has(flag_name);
    },

    // copied from Data_Object because Data_Object was not able to deal with collections within itself.
    //  code works, but should make this call data_object code where possible.

    // Candidate for optimization

    //'get': fp(function(a, sig) {
    'get': (function() {
      var a = arguments;
      a.l = arguments.length;
      var sig = get_a_sig(arguments, 1);

        // More difficult to maintain with the separate get code.
        //  Handle specific cases here, otherwise use _super.

        // In some cases, an automatically constructed object, like a control_dom, should have fields.

        // but when nested is in place, is it still working right?
        // also will have to deal with particular output formats.
        //  many controls / data types for the moment will have default output as HTML formatted.
        //console.log('Data_Object get this.__data_type_name ' + this.__data_type_name);
        //console.log('Enhanced_Data_Object get a ' + stringify(a));
        //console.log('Enhanced_Data_Object get sig ' + sig);
        // will also be looking at the output processors.
        //console.log('this.__data_type_name ' + this.__data_type_name);
        //if (is_defined(this.__data_type_name)) {
        if (typeof this.__data_type_name !== 'undefined') {

            // should possibly have this assigned for controls...
            //var raw_input = a;
            //console.log('this.__data_type_name is defined: ' + this.__data_type_name);

            //var parsed_input_obj = jsgui.input_processors[this.__data_type_name](raw_input);
            //this._super.apply(this, a);
            do_get.apply(this, a);

        } else {
            // check to see if there is a field defined.
            if (sig === '[s]') {
                //console.log('get param: ' + a[0]);

                if (!this.fc) this.fc = new Fields_Collection({
                    //
                    //'containing_object': this
                });

                var fc = this.fc;

                //console.log('fc ' + (fc));

                //console.log('fc.get() ' + stringify(fc.get()));
                var field_name = a[0];
                //console.log('field_name ' + field_name);
                //console.log('this.fields() ' + stringify(this.fields()));
                // could have .s in it, making it nested, and have removed nested from here.
                //console.log('pre fc get');
                var field = fc.get(field_name);
                //console.log('EDO field ' + stringify(field));

                if (field_name.indexOf('.') > -1) {

                    //console.log('EDO get has field ' + field_name);

                    // Then we are dealing with a request for a nested object.
                    // Split up the field_name into the various field names for the levels, then have a recursive function here
                    //  process through the levels. Will keep the recursive part small in size and located here.
                    // May not need to even be recursive.
                    var arr_field_names = field_name.split('.');

                    var level = 0, l = arr_field_names.length;
                    var current_obj = this, new_obj, fname;
                    while (level < l) {
                        fname = arr_field_names[level];
                        new_obj = current_obj.get(fname);
                        //console.log('fname ' + fname);

                        // So, when the dom object is obtained, it should have its own fields.
                        //  The 'get' function will need to be modified to return objects of the right type / class.

                        //console.log('new_obj ' + stringify(new_obj));
                        //console.log('current_obj ' + stringify(current_obj));

                        level++;
                        current_obj = new_obj;
                    }
                    return current_obj;
                }

                //console.log('field ' + stringify(field));

                // fields seem to stop having been set up properly.

                //console.log('field ' + (field));


                //console.log('* field_name ' + field_name);
                //console.log('* field ' + stringify(field));


                if (field) {
                    // May not be able to stringify the field object without making an infinite loop / call stack error.
                    //console.log('this._[field_name] ' + stringify(this._[field_name]));
                    //console.log('field_name ' + field_name);
                    // So the DOM attributes were not created properly.




                    if (!this._[field_name]) {
                        //console.log('does not have field already');

                        var sig_field = get_item_sig(field, 20);
                        //console.log('');
                        //console.log('---------------');
                        //console.log('');
                        //console.log('enhanced data_object sig_field ' + stringify(sig_field));
                        //console.log('field ' + stringify(field));

                        //console.log('sig_field ' + sig_field);


                        if (sig_field == '[s,[s,u]]') {
                            // it looks like it has gone wrong.
                            var stack = new Error().stack;
                            console.log(stack);
                        }

                        // ss?
                        // s,s,b
                        //  the last param is the default value???
                        //   not right now.

                        if (sig_field == '[s,s,o]') {
                            var field_name = field[0];
                            var field_type_name = field[1];

                            // default_value?

                            var field_info = field[2];

                            //console.log('field_type_name ' + field_type_name);



                            if (field_type_name == 'collection') {
                                //console.log('lazy loading - creating new collection');
                                this._[field_name] = new jsgui.Collection({
                                    'context': this._context
                                });
                                return this._[field_name];
                            } else {
                                // if it's just a string?
                                if (field_type_name == 'ordered_string_list') {
                                    var osl = new Ordered_String_List();
                                    return this._[field_name] = osl;
                                    //return this._[field_name];
                                } else if (field_type_name == 'string') {
                                    // use a Data_Value?
                                    // Data value with no context?

                                    //var dv = new Data_Value({
                                        //'context': this._context
                                    //});
                                    // Tell the Data_Value it's a string only?
                                    // context?
                                    var dv = new Data_Value({
                                        'context': this._context
                                    });

                                    if (field_info.default) {
                                        dv.set(field_info.default);
                                    }

                                    dv.parent(this);


                                    //dv.set()

                                    return this._[field_name] = dv;

                                    //return this._[field_name];
                                } else {
                                    //console.log('');
                                    //console.log('field_type_name ' + field_type_name);

                                    var default_value = field_info.default;
                                    //console.log('')



                                    //var dtoc = this.mod_link().ensure_data_type_data_object_constructor(field_type_name);
                                    var dtoc = ensure_data_type_data_object_constructor(field_type_name);

                                    var context = this.context;
                                    if (context) {
                                        var field_val = new dtoc({'context': this._context});
                                    } else {
                                        var field_val = new dtoc();
                                    }
                                    if (is_defined(default_value)) {
                                        field_val.set(default_value);
                                    }

                                    //throw 'stop';

                                    field_val.parent(this);
                                    this._[field_name] = field_val;
                                    return this._[field_name];
                                }
                            }

                        } else if (sig_field == '[s,s]') {
                            //console.log('!!!!!');
                            //console.log('field ' + stringify(field));
                            var field_name = field[0];
                            var field_type_name = field[1];

                            //console.log('field_name ' + field_name);
                            //console.log('field_type_name ' + field_type_name);

                            // perhaps getting collection fields should be moved to enhanced_data_object?
                            //  not keen on interdependencies here.

                            if (field_type_name === 'collection') {

                                // lazy creation of fields.

                                //throw 'not supported here. should use code in enhanced-data-object.

                                // So, Collection has been added to jsgui by now.
                                //console.log('pre make coll');

                                // Maybe Collection has not been added to jsgui.
                                //  Need to ensure it does get added when it's getting used.

                                // seems like the Collection object does not get put back on this...
                                //  or at least not always.

                                // looks like we use the module as it is.

                                var coll = new jsgui.Collection({
                                    'context': this._context
                                });

                                //console.log('pre set coll parent');
                                coll.parent(this);

                                this._[field_name] = coll;
                                return this._[field_name];

                            } else if (field_type_name === 'control') {
                                // want to put the control in place basically.
                                //  but it the control is not there, we can't get it.
                                // no lazy loading of controls like for other data items.
                                return undefined;


                            } else if (field_type_name === 'string') {
                                var dv = new Data_Value();
                                dv.parent(this);
                                this._[field_name] = dv;
                            } else {
                                    //

                                // a different function?
                                //  we could look for the input processors?
                                // Then use the input processor to create a Data Object or Data Value.
                                var input_processors;
                                var data_type_info;
                                var module_jsgui = this._module_jsgui;
                                //console.log('module_jsgui ' + module_jsgui);

                                // Need a way to get back to the common jsgui module.


                                if (module_jsgui) {
                                    input_processors = module_jsgui.input_processors;
                                    data_types_info = module_jsgui.data_types_info;

                                    //console.log('data_types_info ' + stringify(data_types_info));

                                    // so we may have the information needed to construct such a Data_Object.

                                    // This needs to be set in various objects.


                                    // Shoudl make be careful to ensure these exist...
                                    //  Need the constructor for the control_dom object.

                                    // Perhaps doing a sub-project on the data system is worth it?
                                    //  Or do that once the basis is working for HTML serving?


                                    // but will we have data object constructors for this yet?
                                    object_constructor = module_jsgui.map_data_type_data_object_constructors[field_type_name];

                                    //console.log('object_constructor ' + stringify(object_constructor));

                                    // ensure_data_type_data_object_constructor
                                    //  that is used where we have the data type definition for that data type.

                                    // and look at the data types object constructors?
                                    //  or data types constructos.
                                    if (object_constructor) {

                                        var obj = new object_constructor({'context': this._context});
                                        obj.parent(this);

                                        this._[field_name] = obj;
                                        return obj;
                                    }


                                    //throw 'stop';
                                };

                            }

                                //console.log('this._ ' + stringify(this._));

                            return this._[field_name];

                        } else if (sig_field === '[s,[s,s]]') {
                            var field_name = field[0];
                            var field_info = field[1];


                            //console.log('field_info ' + stringify(field_info));

                            if (field_info[0] === 'collection') {
                                var collection_type_name = field_info[1];
                                var ncoll = new jsgui.Collection({'context': this._context});
                                ncoll.parent(this);
                                this._[field_name] = ncoll;
                                return this._[field_name];
                            }
                        } else if (sig_field === '[s,[s,o]]') {
                            // [fieldName,['collection', objDef]]

                            // eg field ["entries", ["collection", {"address": "string", "family": "string", "internal": "boolean"}]]
                            // it's a collection?? (check, with the particular data type)

                            var field_name = field[0];
                            var field_info = field[1];
                            var data_type_name = field_info[0];

                            if (data_type_name === 'collection') {
                                var objDef = field_info[1];
                                //throw 'not supported here. should use code in enhanced-data-object.';

                                // Need to do more than this.
                                //  Defining a collection with a specified data type.
                                var ncoll = new jsgui.Collection({'context': this._context});
                                // Specifying a collection constraint as well (perhaps these are fields for the obejcts)
                                //  I think calling it a collection constraint with specified fields for the objects makes
                                //  sense.
                                //console.log('objDef ' + stringify(objDef));
                                // will be an object rather than array (for now at least)

                                // Not sure about setting through fields...
                                ncoll.fields(objDef);
                                // that should set the constraint as well.
                                //ncoll.

                                // Specifying fields on a collection.
                                //  Need to say itemFields, as a collection itself could have fields as well as
                                //   items contained? Or the collection's fields apply to each item.



                                //var ncoll = new jsgui.Collection(collection_type_name);
                                if (this._context) ncoll._context = this._context;

                                ncoll.parent(this);
                                this._[field_name] = ncoll;
                                return this._[field_name];
                            }

                        }

                    } else {
                        return this._[field_name];
                    }
                } else {
                    //console.log('this._ ' + stringify(this._));

                    var res = ll_get(this._, a[0]);

                    if (!res) {
                        if (field_name.indexOf('.') > -1) {
                            throw 'not yet handled';
                        } else {
                            res = this[a[0]];
                        }
                    }

                    //console.log('res ' + res);

                    //if (!is_defined(res)) {
                        // No, don't thin we just create a new one. It may need to get overwritten by some other code.



                        //res = new Enhanced_Data_Object({'context': this._context});
                    //}

                    //console.log('property_name ' + property_name);
                    //console.log('res ' + res);
                    return res;
                }
            } else if (a.l === 0) {
                return this._;
            }
        }
    })


});

// Data_Object.extend = function(prop, namespcExtension, propsToMerge) {

Enhanced_Data_Object.extend = function(prop, namespcExtension, propsToMerge) {
    //var res = Data_Object.extend(prop, namespcExtension, propsToMerge);
    var res = Data_Object.extend.call(this, prop, namespcExtension, propsToMerge);
    // but the fields are not going in properly.???
    // quite possibly need to set up the fields (_fields on the Enhanced_Data_Object object.
    // but need to merge the properties from this...
    // but also need to look out for the flags.
    // if in the prop or map_props there is something called 'flags' we need to pay attention.
    //  That will then get put in the prototype (or constructor?)
    /*
    for (var name in prop) {

    }
    */
    if (prop.flags) {
        //res[
        res._flags = prop.flags;
    }
    return res;
}


jsgui.ensure_data_type_data_object_constructor = ensure_data_type_data_object_constructor;

Enhanced_Data_Object.map_data_type_data_object_constructors = Data_Object.map_data_type_data_object_constructors;
Enhanced_Data_Object.Mini_Context = Data_Object.Mini_Context;

Data_Object.set_Enhanced_Data_Object(Enhanced_Data_Object);

Enhanced_Data_Object.register_data_type = register_data_type;

module.exports = Enhanced_Data_Object;

	//return Enhanced_Data_Object;
//});

},{"./data-object":28,"./data-object-fields-collection":27,"./data-value":29,"./jsgui-lang-util":38}],31:[function(require,module,exports){
var jsgui = require('./jsgui-lang-essentials');

var j = jsgui;
var Class = j.Class;
var each = j.each;
var is_array = j.is_array;
var is_dom_node = j.is_dom_node;
var is_ctrl = j.is_ctrl;
var extend = j.extend;
var get_truth_map_from_arr = j.get_truth_map_from_arr;
var get_map_from_arr = j.get_map_from_arr;
var arr_like_to_arr = j.arr_like_to_arr;
var tof = j.tof;
var is_defined = j.is_defined;
var stringify = j.stringify;
var functional_polymorphism = j.functional_polymorphism;
var fp = j.fp;
var arrayify = j.arrayify;
var mapify = j.mapify;
var are_equal = j.are_equal;
var get_item_sig = j.get_item_sig;
var set_vals = j.set_vals;
var truth = j.truth;
var trim_sig_brackets = j.trim_sig_brackets;
var ll_set = j.ll_set;
var ll_get = j.ll_get;
var input_processors = j.input_processors;
var iterate_ancestor_classes = j.iterate_ancestor_classes;
var is_arr_of_arrs = j.is_arr_of_arrs;
var is_arr_of_strs = j.is_arr_of_strs;
var is_arr_of_t = j.is_arr_of_t;
var clone = jsgui.clone;

var Evented_Class = Class.extend({

    // Needs to initialize the bound events to start with.

    'init': function() {
        this._bound_events = {};
    },

    'raise_event': fp(function(a, sig) {

        var that = this;
        var c, l;

        //console.log('raise_event sig', sig);

        if (sig == '[s]') {
            // just raise an event, given with no parameters,
            //  maybe like 'started'.

            var target = this;
            var event_name = a[0];

            //console.log('Data_Object raise_event ' + event_name);

            var bgh = this._bound_general_handler;

            var be = this._bound_events;
            var res = [];
            if (bgh) {
                for (c = 0, l = bgh.length; c < l; c++) {
                    res.push(bgh[c].call(target, event_name));
                }
            }

            if (be) {
                // This is attaching events to the same object.
                //  Not sure why, but this needs to be fixed.


                var bei = be[event_name];

                //console.log('bei', bei);
                //console.log('tof bei', tof(bei));
                if (tof(bei) == 'array') {
                    //console.log('1) raise_event bei.length ' + bei.length);
                    //var res = [];

                    for (c = 0, l = bei.length; c < l; c++) {
                      res.push(bei[c].call(target));
                    }

                    //console.log('Evented_Class raise_event [s] res', res);
                    return res;
                }// else if (tof(bei) == 'function') {
                //	bei.call(target, target, event_name);
                //}
            }
        }

        if (a.l > 2) {
            var target = this;
            var event_name = a[0];

            //console.log('event_name ' + event_name);

            var additional_args = [];
            var bgh_args = [event_name];

            for (c = 1, l = a.l; c < l; c++) {
                additional_args.push(a[c]);
                bgh_args.push(a[c]);
            }

            var be = this._bound_events;
            var bgh = this._bound_general_handler;

            var res = [];

            if (bgh) {
                for (c = 0, l = bgh.length; c < l; c++) {
                    res.push(bgh[c].apply(target, bgh_args));
                }
            }


            //console.log('be ' + tof(be));
            if (be) {
                // The controls that are activated on the clients need to have bound events.

                //console.log('event_name', event_name);
                var bei = be[event_name];
                //console.log('bei ', bei);
                if (tof(bei) == 'array') {
                    //console.log('1) raise_event bei.length ' + bei.length);

                    if (bei.length > 0) {


                        // They are handlers that get called.

                        for (c = 0, l = bei.length; c < l; c++) {
                          if (bei[c]) res.push(bei[c].apply(target, additional_args));

                        }

                        return res;
                    } else {
                        return res;
                    }


                    //console.log('2) raised the bound events');
                }
                // Or if it's just a function?

            }

        }

        if (sig == '[s,o]') {
            var be = this._bound_events;

            // And its general bound events as well.
            var bgh = this._bound_general_handler;
            var event_name = a[0];

            var res = [];
            if (bgh) {

                //console.log('bgh.length', bgh.length);

                for (c = 0, l = bgh.length; c < l; c++) {
                    res.push(bgh[c].call(target, event_name, a[1]));
                }
            }


            //console.log('this._bound_events', this._bound_events);
            if (be) {
                var bei = be[event_name];

                //console.log('bei.length', bei.length);
                //console.log('tof bei', tof(bei));
                if (tof(bei) === 'array') {
                    //console.log('1) raise_event bei.length ' + bei.length);


                    for (c = 0, l = bei.length; c < l; c++) {
                      res.push(bei[c].call(target, a[1]));
                    }

                    //each(bei, function(i, v) {
                    //    res.push(v.call(target, a[1]));
                    //});

                    //console.log('Evented_Class raise_event [s] res', res);
                    //return res;
                }
            }
        }

        return res;
    }),

    // also just raise and trigger?

    //'raise': function() {
    //    return this.raise_event.apply(this, arguments);
  //},
    //'trigger': function() {
    //    return this.raise_event.apply(this, arguments);
    //},


    'add_event_listener' : fp(function(a, sig) {

        // event listener for all events...
        //  that could work with delegation, and then when the code finds the event it interprets it.
        //console.log('');
        //console.log('data_object add_event_listener sig ' + sig);

        // Why is this getting called so many times, for the same object?



        //console.log('');
        // Why is the bound events array getting so big?

        if (sig == '[f]') {
            //var stack = new Error().stack;
            //console.log(stack);
            //throw 'stop';



            this._bound_general_handler = this._bound_general_handler || [];
            if (Array.isArray(this._bound_general_handler)) {
            //if (tof(this._bound_general_handler) == 'array') {
                this._bound_general_handler.push(a[0]);
            };
        }
        // Why does a change event listener get bound to the wrong control, or bound multiple times?
        //  Changes getting pushed up through the tree?


        if (sig == '[s,f]') {
            // bound to a particular event name

            // want the general triggering functions to be done too.
            //  with a different function
            var event_name = a[0], fn_listener = a[1];
            //console.log('event_name ' + event_name);
            this._bound_events = this._bound_events || {};

            // removing from a bound general handler being slow?
            //  perhaps... but we won't have so many of these anyway.
            //  could get id for object and have it within collection.
            //   But not sure about using collections for events... collections use events...?

            // Different controls binding to the same array of events?

            if (!this._bound_events[event_name]) this._bound_events[event_name] = [];

            var bei = this._bound_events[event_name];
            //console.log('this._id() ' + this._id());
            if (Array.isArray(bei)) {
            //if (tof(bei) == 'array') {
                //console.log('this', this);
                //console.log('add_event_listener bei.length ' + bei.length);
                bei.push(fn_listener);
            };
        }

    }),

    // A way of proxying functions below?
    //  Or simply use function alias?
    'on': function() {
        // However, need to make use of some document events.
        //  With some controls, we need to pass through

        return this.add_event_listener.apply(this, arguments);


    },

    'remove_event_listener': function(event_name, fn_listener) {


        // TODO
        // And remove something that's bound to the general handler...?



        // needs to go through the whole array?
        // think so....

        //console.log('remove_event_listener');
        //console.log('this._bound_events', this._bound_events);
        if (this._bound_events) {
            //console.log('event_name', event_name);
            var bei = this._bound_events[event_name] || [];

            //var tbei = tof(bei);
            //console.log('tbei', tbei);

            if (Array.isArray(bei)) {
                // bei.push(fn_listener);

                var c = 0, l = bei.length, found = false;

                //console.log('l', l);

                while (!found && c < l) {
                    if (bei[c] === fn_listener) {
                        found = true;
                    } else {
                        c++;
                    }
                }
                //console.log('found', found);
                //console.log('c', c);
                if (found) {
                    bei.splice(c, 1);
                }
            };
        }


    },

    'off': function() {
        // However, need to make use of some document events.
        //  With some controls, we need to pass through

        return this.remove_event_listener.apply(this, arguments);

    },
    'one': function(event_name, fn_handler) {

        var inner_handler = function(e) {

            //var result = fn_handler.call(this, e);
            fn_handler.call(this, e);
            this.off(event_name, inner_handler);
            //return result;
        };

        this.on(event_name, inner_handler);
    }
});

var p = Evented_Class.prototype;
p.raise = p.raise_event;
p.trigger = p.raise_event;

module.exports = Evented_Class;

},{"./jsgui-lang-essentials":37}],32:[function(require,module,exports){


/*
if (typeof define !== 'function') {
    var define = require('amdefine')(module);
}


// May sway implementations of the particular items more easily when they are in their own files.

define(["./jsgui-lang-essentials", "./jsgui-data-structures-stiffarray"], function (jsgui, StiffArray) {
*/

var jsgui = require('./jsgui-lang-essentials');
var StiffArray = require('./jsgui-data-structures-stiffarray');

    /** 
    * B+ Tree module.
    * @module core/jsgui-data-structures-b-plus-tree
    * @exports core/jsgui-data-structures-b-plus-tree
    */

    // B+ Tree

    // some B+ Tree description can be found here:
    // http://www.cs.berkeley.edu/~kamil/teaching/su02/080802.pdf
    // http://baze.fri.uni-lj.si/dokumenti/B+%20Trees.pdf


    // sample tree classic presentation:
    //
    //	              [] 7 []
    //	              /     \
    //	             /       -----------------
    //	            /                         \
    //	           /                           \
    //	     [] 3 [] 5 []                  [] 8 [] 8 []
    //	     /    |     \                  /     \    \
    //	    /     |      \                /       |    ----
    //     /      |       \              /         \       \
    //  {1,2}   {3,4}    {5,6,7}      {8,8,8}    {8,8}    {8,9}
    //
    //   the diagram notation:
    //   numbers are "keys" array items
    //   "[]" figures are "children" array items


    // sample tree toText() presentation:
    //
    //	      {1,2}
    //	    3
    //	      {3,4}
    //	    5
    //	      {5,6,7}
    //  7
    //	      {8,8,8}
    //	    8
    //	      {8,8}
    //	    8
    //	      {8,9}


    // sample tree toString() presentation:
    //
    // {{{1,2}3{3,4}5{5,6,7}}7{{8,8,8}8{8,8}8{8,9}}}


    // some remarks:
    //
    //  children.length == keys.length + 1
    //
    //  (max children[i] key) <= (keys[i]) <= (min children[i+1] key)
    //
    //  the node overflow threshold referred somewhere as "node order" is referred as "node capacity" here


    // -----------------------------------------
    //
    //	              global variables:
    //
    // -----------------------------------------

    //var B_Plus_Tree_NextNodeDebugId = 1;
    // uncomment the line above to include unique node IDs 
    // to the toString() and toTest() output

    // -----------------------------------------
    //
    //	              B_Plus_Node:
    //
    // -----------------------------------------

    // Likely to get this into the core, and do some more polymorphic optimization to reduce file size.
    //  One various things are running, I will focus on some code size optimizations to bring things down to really small sizes when used in
    //  conjunction with Essentials.

    // Not sure about the B+ tree making use of Collections but with no indexing?
    //  I think by making Collection really flexible, and a version that mixes in other functionality to a more basic one,
    //  it would be possible to make the B+ tree use a Collection with StiffArray capabilities.
    //   Not worth it right now. Keep StiffArray as a low level component used for the tree. Maybe move it out of its own JavaScript file, not sure it
    //    will be used for that much else. Not sure, could be good for when binary searches are required.








    // B+ tree index node:

    var B_Plus_Node = function (nodeCapacity) {

        // -----------------------------------------
        //              public interface:
        // -----------------------------------------

        var m_public = {
            isLeaf: false,
            parent: null,
            keys: new StiffArray(nodeCapacity + 1),     // +1: to allow temporary owerflow
            children: new StiffArray(nodeCapacity + 2) // +2: children.length == keys.length + 1
        };

        // -----------------------------------------
        //                  debug ID:
        // -----------------------------------------

        //if (typeof (B_Plus_Tree_NextNodeDebugId) != "undefined") m_public.debugId = B_Plus_Tree_NextNodeDebugId++;

        // -----------------------------------------
        //       return the public interface:
        // -----------------------------------------

        return m_public;
    };

    // -----------------------------------------
    //
    //	              B_Plus_Leaf:
    //
    // -----------------------------------------

    // B+ tree leaf node:

    var B_Plus_Leaf = function (nodeCapacity) {

        // -----------------------------------------
        //              public interface:
        // -----------------------------------------

        var m_public = {
            isLeaf: true,
            parent: null,
            keys: new StiffArray(nodeCapacity + 1),
            values: new StiffArray(nodeCapacity + 1),
            //
            // leafs chain:
            prevLeaf: null,
            nextLeaf: null
        };

        // -----------------------------------------
        //                  debug ID:
        // -----------------------------------------

        //if (typeof(B_Plus_Tree_NextNodeDebugId) != "undefined") m_public.debugId = B_Plus_Tree_NextNodeDebugId++;

        // -----------------------------------------
        //       return the public interface:
        // -----------------------------------------

        return m_public;
    };


    // -----------------------------------------
    //
    //	              B_Plus_Tree:
    //
    // -----------------------------------------

    // B+ tree:

    // Using Crockford's Module Pattern.
    //  Need to be careful about how it is not initialized with a constructor and the 'new' keyword.

    /**
    *
    * @constructor
    * @classdesc
    *
    * This class is used for the findFirst/findNext iteration pattern:
    * - findFirst() gets the search criteria, finds the first item, store the search state to FindInfo
    * (including the criteria, found item, and all other related information), and returns the FindInfo.
    * - the client process the found item (from the returned FindInfo), and calls findNext() passing the FindInfo.
    * - findNext() uses the search state from FindInfo to find next item, updates the search state, and returns the updated FindInfo.
    * - the client process the found item, and calls findNext() again and again - until null will be returned.
    *
    * The FindInfo() constructor is intended for internal use only. You should call findFirst(), findNext(), findLast() etc. to get the FindInfo object.
    *
    * @--param {*} key
    * @--param {*} value
    * @--param {boolean} isPrefixSearch
    * @memberof module:core/jsgui-data-structures-b-plus-tree
    * 
    * @example
    * 
    *     // get all the key/value pairs:
    * 
    *     var findInfo = tree.findFirst();
    *     while (findInfo !== null) {
    *       console.log("key=" + findInfo.foundKey() + " value=" + findInfo.foundValue());
    *       findInfo = tree.findNext(findInfo);
    *     }
    * 
    * 
    *     // get all the key/value pairs in reverse order:
    * 
    *     var findInfo = tree.findLast();
    *     while (findInfo !== null) {
    *       console.log("key=" + findInfo.foundKey() + " value=" + findInfo.foundValue());
    *       findInfo = tree.findPrevious(findInfo);
    *     }
    * 
    * 
    *     // get all the values for "010" key:
    * 
    *     var findInfo = tree.findFirst("010");
    *     while (findInfo !== null) {
    *       console.log("key=" + findInfo.foundKey() + " value=" + findInfo.foundValue());
    *       findInfo = tree.findNext(findInfo);
    *     }
    * 
    * 
    *     // get all the key/value pairs prefixed by "01" in reverse order:
    * 
    *     var findInfo = tree.findLastPrefix("01");
    *     while (findInfo !== null) {
    *       console.log("key=" + findInfo.foundKey() + " value=" + findInfo.foundValue());
    *       findInfo = tree.findPrevious(findInfo);
    *     }
    * 
    * 
    * 
    */

    var FindInfo = function (key, value, isPrefixSearch) {
        isPrefixSearch = !!isPrefixSearch;
        var isKeyPresent = (key != undefined);
        var isValuePresent = (value != undefined);
        var prefixLength = 0;
        if (isPrefixSearch) {
            if (typeof (key) != "string") {
                isPrefixSearch = false;
            } else {
                prefixLength = key.length;
            }
        }
        //
        return {
            /* * 
            * key to find (if present)
            * @memberof module:core/jsgui-data-structures-b-plus-tree.FindInfo.prototype 
            */
            key: key,     // key to find (if present)
            /* * 
            * value to find (if present)
            * @memberof module:core/jsgui-data-structures-b-plus-tree.FindInfo.prototype 
            */
            value: value, // value to find (if present)
            /* * 
            * prefix search mode
            * @memberof module:core/jsgui-data-structures-b-plus-tree.FindInfo.prototype 
            */
            isPrefixSearch: isPrefixSearch, // prefix search mode
            /* * 
            * found leaf
            * @memberof module:core/jsgui-data-structures-b-plus-tree.FindInfo.prototype 
            */
            leaf: null,   // found leaf
            /* * 
            * found leaf item index
            * @memberof module:core/jsgui-data-structures-b-plus-tree.FindInfo.prototype 
            */
            index: -1,    // found leaf item index
            /* * 
            * is the search criteria contains key
            * @memberof module:core/jsgui-data-structures-b-plus-tree.FindInfo.prototype 
            */
            isKeyPresent: isKeyPresent, // function () { return this.key !== undefined; }, // is the search criteria contains key
            /* * 
            * is the search criteria contains value
            * @memberof module:core/jsgui-data-structures-b-plus-tree.FindInfo.prototype 
            */
            isValuePresent: isValuePresent, // function () { return this.value !== undefined; }, // is the search criteria contains value
            /** 
            * found items's key
            * @memberof module:core/jsgui-data-structures-b-plus-tree.FindInfo.prototype 
            */
            foundKey: function () { return this.leaf.keys.items[this.index]; }, // found items's key
            /** 
            * found item's value
            * @memberof module:core/jsgui-data-structures-b-plus-tree.FindInfo.prototype 
            */
            foundValue: function () { return this.leaf.values.items[this.index]; }, // found item's value
            //
            prefix_length: prefixLength, // prefix length
            check_prefix: function () {  // check the current key to match the prefix
                if (!isPrefixSearch) return false;
                if (this.index >= this.leaf.keys.count) return false;
                var keyToCheck = this.foundKey();
                if (this.prefix_length > keyToCheck.length) return false;
                return (keyToCheck.substr(0, this.prefix_length) == this.key)
            }
        };
    };



    var B_Plus_Tree = function (nodeCapacity) {

        // -----------------------------------------
        //            arguments processing:
        // -----------------------------------------

        if (nodeCapacity === undefined) nodeCapacity = 10;
        if (nodeCapacity < 4) throw "B_Plus_Tree(): node capacity must be >= 4";

        // -----------------------------------------
        //              public interface:
        // -----------------------------------------

        /**
        * Creates the B+ Tree.
        * @constructor
        * @classdesc 
        *
        * B+ Tree
        *
        * some B+ Tree description can be found here:
        *
        * {@link http://www.cs.berkeley.edu/~kamil/teaching/su02/080802.pdf}
        *
        * {@link http://baze.fri.uni-lj.si/dokumenti/B+%20Trees.pdf}
        *
        * sample tree classic presentation:
        *
        * <pre>
        * <code>
        *                 [] 7 []
        *                 /     \
        *                /       -----------------
        *               /                         \
        *              /                           \
        *        [] 3 [] 5 []                  [] 8 [] 8 []
        *        /    |     \                  /     \    \
        *       /     |      \                /       |    ----
        *      /      |       \              /         \       \
        *   {1,2}   {3,4}    {5,6,7}      {8,8,8}    {8,8}    {8,9}
        * </code>
        * </pre>
        *
        *   the diagram notation:
        *  - numbers are "keys" array items
        *  - "[]" figures are "children" array items
        *
        * @alias B_Plus_Tree
        * @param {number} [nodeCapacity=10] - tree node capacity (maximum possible number of items in each node).
        * @memberof  module:core/jsgui-data-structures-b-plus-tree
        * @example
        *
        * var tree = new B_Plus_Tree();
        */


        var m_public = {
            /** 
            * the tree root node
            * @type {B_Plus_Node|B_Plus_Leaf}
            * @instance
            */
            // tree root:
            root: new B_Plus_Leaf(nodeCapacity),
            //
            /** 
            * first leaf in the "all leaves" chain
            * @type {B_Plus_Leaf}
            * @instance
            */
            // leafs chain:
            firstLeaf: null,
            //
            /** 
            * last leaf in the "all leaves" chain
            * @type {B_Plus_Leaf}
            * @instance
            */
            lastLeaf: null,
            //
            // ---------------------
            //     editing:
            // ---------------------
            //
            /** 
            * clear the tree (remove all items)
            * @func
            * @instance
            */
            // clear the tree:
            clear: function () {
                p_Clear();
            },
            //

            /** 
            * insert key and value
            * @name insert
            * @func
            * @variation 1
            * @param {*} key
            * @param {*} value
            * @instance
            * @memberof module:core/jsgui-data-structures-b-plus-tree.B_Plus_Tree
            */

            /** 
            * insert key and value: key is arr[0], value is arr[1]; i.e. `insert([key, value])`
            * @func
            * @variation 2
            * @param {array} arr
            * @instance
            */

            // insert(key, value)
            // insert([key, value])
            insert: function (key, value) {
                if (arguments.length == 2) {
                    return p_Insert(key, value);
                } else {
                    return p_Insert(key[0], key[1]);
                }
            },
            //

            /** 
            * remove all values with given key
            * @name remove
            * @func
            * @param {*} key
            * @instance
            * @memberof module:core/jsgui-data-structures-b-plus-tree.B_Plus_Tree
            */

            /** 
            * remove one value occurrence
            * @func
            * @param {*} key
            * @param {*} value
            * @instance
            */


            // remove(key) - remove all values with given key
            // remove(key, value) - remove one value occurrence
            remove: function (key, value) {
                if (arguments.length == 2) {
                    return p_Remove(key, value);
                } else {
                    p_RemoveKey(key);
                }
            },
            //
            // ---------------------
            //       finding:
            // ---------------------
            //

            /** 
            * find the very first item
            * @func
            * @name findFirst
            * @variation 1
            * @returns {module:core/jsgui-data-structures-b-plus-tree.FindInfo} - find info
            * @instance
            * @memberof module:core/jsgui-data-structures-b-plus-tree.B_Plus_Tree
            */

            /** 
            * find the first item for the given key
            * @func
            * @name findFirst
            * @variation 2
            * @param {*} key
            * @returns {module:core/jsgui-data-structures-b-plus-tree.FindInfo} - find info
            * @instance
            * @memberof module:core/jsgui-data-structures-b-plus-tree.B_Plus_Tree
            */

            /** 
            * find the first key+value occurrence
            * @func
            * @name findFirst
            * @variation 3
            * @param {*} key
            * @param {*} value
            * @returns {module:core/jsgui-data-structures-b-plus-tree.FindInfo} - find info
            * @instance
            * @memberof module:core/jsgui-data-structures-b-plus-tree.B_Plus_Tree
            */

            // findFirst() - find the very first item
            // findFirst(key) - find the first item for the given key
            // findFirst(key, value) - find the first key+value occurrence
            //
            // returns the FindInfo object:
            //    key: key,     // key to find (if present)
            //    value: value, // value to find (if present)
            //
            //    leaf: null,   // the current found leaf
            //    index: -1,    // the current found index
            //
            //    foundKey():   // the current found key
            //    foundValue(): // the current found value
            //
            findFirst: function (key, value) {
                return p_FindFirst(key, value);
            },
            //
            /** 
            * find first key matching the prefix
            * @func
            * @param {string} prefix
            * @returns {module:core/jsgui-data-structures-b-plus-tree.FindInfo} - find info
            * @instance
            * @memberof module:core/jsgui-data-structures-b-plus-tree.B_Plus_Tree
            */
            // find first key matching the prefix:
            findFirstPrefix: function (prefix) {
                return p_FindFirst(prefix, undefined, true);
            },
            //
            /** 
            * find next search conditions occurence
            * @func
            * @param {module:core/jsgui-data-structures-b-plus-tree.FindInfo} findInfo
            * @returns {module:core/jsgui-data-structures-b-plus-tree.FindInfo} - find info
            * @instance
            * @memberof module:core/jsgui-data-structures-b-plus-tree.B_Plus_Tree
            */
            // find next search conditions occurence
            findNext: function (findInfo) {
                return p_FindNext(findInfo);
            },

            /** 
            * find the very last item
            * @func
            * @name findLast
            * @variation 1
            * @returns {module:core/jsgui-data-structures-b-plus-tree.FindInfo} - find info
            * @instance
            * @memberof module:core/jsgui-data-structures-b-plus-tree.B_Plus_Tree
            */

            /** 
            * find the last item for the given key
            * @func
            * @name findLast
            * @variation 2
            * @param {*} key
            * @returns {module:core/jsgui-data-structures-b-plus-tree.FindInfo} - find info
            * @instance
            * @memberof module:core/jsgui-data-structures-b-plus-tree.B_Plus_Tree
            */

            /** 
            *  find the last key+value occurrence
            * @func
            * @name findLast
            * @variation 3
            * @param {*} key
            * @param {*} value
            * @returns {module:core/jsgui-data-structures-b-plus-tree.FindInfo} - find info
            * @instance
            * @memberof module:core/jsgui-data-structures-b-plus-tree.B_Plus_Tree
            */


            //
            // findLast() - find the very last item
            // findLast(key) - find the last item for the given key
            // findLast(key, value) - find the last key+value occurrence
            findLast: function (key, value) {
                return p_FindLast(key, value);
            },
            //
            /** 
            * find last key matching the prefix
            * @func
            * @param {string} prefix
            * @returns {module:core/jsgui-data-structures-b-plus-tree.FindInfo} - find info
            * @instance
            * @memberof module:core/jsgui-data-structures-b-plus-tree.B_Plus_Tree
            */
            // find last key matching the prefix:
            findLastPrefix: function (prefix) {
                return p_FindLast(prefix, undefined, true);
            },
            //
            /** 
            * find previous search conditions occurence
            * @func
            * @param {module:core/jsgui-data-structures-b-plus-tree.FindInfo} findInfo
            * @returns {module:core/jsgui-data-structures-b-plus-tree.FindInfo} - find info
            * @instance
            * @memberof module:core/jsgui-data-structures-b-plus-tree.B_Plus_Tree
            */
            // find previous search conditions occurence
            findPrevious: function (findInfo) {
                return p_FindPrev(findInfo);
            },
            //
            // ---------------------
            // dictionary-like usage:
            // ---------------------
            //
            /** 
            * get one value by key (or null if the key not found)
            *
            * [getValue()]{@link module:core/jsgui-data-structures-b-plus-tree.B_Plus_Tree#getValue} and [setValue()]{@link module:core/jsgui-data-structures-b-plus-tree.B_Plus_Tree#setValue} methods pair provides a dictionary-like usage pattern.
            *
            * @func
            * @param {*} key
            * @instance
            * @example
            *
            * var tree = new B_Plus_Tree();
            * //
            * tree.setValue(101, "value 101");
            * tree.setValue(101, "value 101.2");
            *
            * tree.getValue(101) // "value 101.2"
            * tree.getValue(102) // null
            *
            */
            // get one value by key (or null):
            getValue: function (key) {
                return p_GetValue(key);
            },
            /** 
            * set one value by key (insert or update)
            *
            * [getValue()]{@link module:core/jsgui-data-structures-b-plus-tree.B_Plus_Tree#getValue} and [setValue()]{@link module:core/jsgui-data-structures-b-plus-tree.B_Plus_Tree#setValue} methods pair provides a dictionary-like usage pattern.
            *
            * @func
            * @param {*} key
            * @param {*} value
            * @instance
            * @example
            *
            * var tree = new B_Plus_Tree();
            * //
            * tree.setValue(101, "value 101");   // insert
            * tree.setValue(101, "value 101.2"); // update
            *
            * tree.getValue(101) // "value 101.2"
            * tree.getValue(102) // null
            *
            */
            // set one value by key (insert or update):
            setValue: function (key, value) {
                p_SetValue(key, value);
            },
            //
            //
            // ---------------------
            //   other functions:
            // ---------------------
            //

            /** 
            * count all values
            * @name count
            * @func
            * @variation 1
            * @instance
            * @memberof module:core/jsgui-data-structures-b-plus-tree.B_Plus_Tree
            */

            /** 
            * count values with the given key
            * @func
            * @variation 2
            * @param {*} key
            * @instance
            */

            // count() - count all values
            // count(key) - count values with the given key
            count: function (key) {
                if (arguments.length == 1) {
                    return p_CountKey(key);
                } else {
                    return p_Count();
                }
            },
            //

            /** 
            * returns the tree nodes capacity (also referred somewhere as "node order")
            * @func
            * @instance
            */
            // tree capacity:
            getCapacity: function () {
                return m_nodeMaxCount;
            },
            //
            // ---------------------
            // additional functions:
            // ---------------------
            //
            /** 
            * iterate through each key + value pair<br />
            * callback is `function(key, value)`
            * @func
            * @param {function} callback
            * @instance
            * @example
            *
            * var tree = new B_Plus_Tree();
            * //
            * tree.insert(101, "value 101");
            * tree.insert(102, "value 102");
            * tree.insert(103, "value 103");
            * //
            * tree.each(function(key, value) {
            *   console.log("key=" + key + " value=" + value);
            * });
            *
            */
            // iterate through each key + value pair
            // callback is function(key, value)
            'each': function (callback) {
                return p_each(callback);
            },
            //
            /** 
            * get all keys
            * @func
            * @instance
            * @example
            *
            * var tree = new B_Plus_Tree();
            * //
            * tree.insert(101, "value 101");
            * tree.insert(102, "value 102");
            * tree.insert(103, "value 103");
            * //
            * console.log(tree.keys()); // 101,102,103
            *
            */
            // get all keys
            'keys': function () {
                return p_keys();
            },
            //
            /** 
            * get all [key, value] pairs
            * @func
            * @instance
            * @example
            *
            * var tree = new B_Plus_Tree();
            * //
            * tree.insert(101, "value 101");
            * tree.insert(102, "value 102");
            * tree.insert(103, "value 103");
            * //
            * console.log(tree.keys_and_values()); // [101,"value 101"],[102,"value 102"],[103,"value 103"]
            *
            */
            // get all [key, value] pairs
            'keys_and_values': function () {
                return p_keys_and_values();
            },
            //
            //
            /** 
            * get keys and values by prefix
            * @func
            * @param {string} prefix
            * @instance
            * @example
            *
            * var tree = new B_Plus_Tree();
            * //
            * tree.insert("111", "value 111");
            * tree.insert("122", "value 122");
            * tree.insert("123", "value 123");
            * //
            * console.log(tree.get_by_prefix("12")); // ["122","value 122"],["123","value 123"]
            *
            */
            // get keys and values by prefix
            'get_by_prefix': function (prefix) {
                return p_get_by_prefix(prefix);
            },
            //
            /** 
            * get keys by prefix
            * @func
            * @param {string} prefix
            * @instance
            * @example
            *
            * var tree = new B_Plus_Tree();
            * //
            * tree.insert("111", "value 111");
            * tree.insert("122", "value 122");
            * tree.insert("123", "value 123");
            * //
            * console.log(tree.get_keys_by_prefix("12")); // "122","123"
            *
            */
            // get keys by prefix
            'get_keys_by_prefix': function (prefix) {
                return p_get_keys_by_prefix(prefix);
            },
            //
            /** 
            * get values related to the passed key
            * @func
            * @param {*} key
            * @instance
            * @example
            *
            * var tree = new B_Plus_Tree();
            * //
            * tree.insert("101", "value 101");
            * tree.insert("102", "value 102.1");
            * tree.insert("102", "value 102.2");
            * //
            * console.log(tree.get_values_by_key("102")); // "value 102.1","value 102.2"
            *
            */
            // get values at key...
            'get_values_by_key': function (key) {
                return p_get_values_by_key(key);
            }
        };

        // -----------------------------------------
        //              initialization:
        // -----------------------------------------

        m_public.firstLeaf = m_public.root;
        m_public.lastLeaf = m_public.root;

        // -----------------------------------------
        //              private variables:
        // -----------------------------------------

        var m_nodeMaxCount = nodeCapacity;
        var m_nodeMinCount = Math.floor(m_nodeMaxCount / 2);

        // -----------------------------------------
        //                 clear():
        // -----------------------------------------

        // clear the tree
        // (just create new empty root)
        var p_Clear = function () {
            m_public.root = new B_Plus_Leaf(m_nodeMaxCount);
            m_public.firstLeaf = m_public.root;
            m_public.lastLeaf = m_public.root;
        };

        // -----------------------------------------
        //                iterations:
        // -----------------------------------------

        var p_keys = function () {
            var res = [];
            _p_each_key(function (key) {
                res.push(key);
            });
            return res;
        }

        var p_keys_and_values = function () {
            var res = [];
            p_each(function (key, value) {
                res.push([key, value]);
            });
            return res;
        }

        var _p_each_key = function (callback) {
            var findInfo = p_FindFirst();
            while (findInfo != null) {
                var fk = findInfo.foundKey();
                callback(fk);
                findInfo = p_FindNext(findInfo);
            }
        }

        var p_each = function (callback) {
            var findInfo = p_FindFirst();

            var doStop = false;
            

            while (findInfo != null) {
                //var stop = 
                //console.log('doStop ' + doStop);
                var fk = findInfo.foundKey();
                var fv = findInfo.foundValue();
                // callback with the key and the value
                callback(fk, fv, function() {
                    //throw 'stop';
                    //console.log('stop!!!');
                    doStop = true;
                });
                //console.log('2) doStop ' + doStop);
                if (doStop) {
                    findInfo = null;
                } else {
                    findInfo = p_FindNext(findInfo);
                }
                
            }
        }

        // -----------------------------------------
        //                insert():
        // -----------------------------------------

        // insert (key, value) item to the tree
        var p_Insert = function (key, value) {
            //
            // search leaf to insert:
            var searchResult = searchLeaf(key);
            var leaf = searchResult.node;
            //
            // insert to the leaf:
            leaf.keys.insert(searchResult.index, key);
            leaf.values.insert(searchResult.index, value);
            //
            // if overflow:
            if (leaf.keys.count > m_nodeMaxCount) {
                if ((leaf.prevLeaf != null) && (leaf.prevLeaf.keys.count < m_nodeMaxCount) && (leaf.prevLeaf.parent == leaf.parent)) {
                    rotateAmongLeavesToLeft(leaf.prevLeaf, leaf);
                } else if ((leaf.nextLeaf != null) && (leaf.nextLeaf.keys.count < m_nodeMaxCount) && (leaf.nextLeaf.parent == leaf.parent)) {
                    rotateAmongLeavesToRight(leaf, leaf.nextLeaf);
                } else {
                    splitLeaf(leaf);
                }
            }
        };

        // split leaf to 2 leaves
        // (create right sibling)
        var splitLeaf = function (leaf) {
            var leftCount = m_nodeMinCount;
            var rightCount = leaf.keys.count - leftCount;
            //
            // create right leaf:
            var newRightLeaf = new B_Plus_Leaf(m_nodeMaxCount);
            newRightLeaf.parent = leaf.parent;
            //
            // copy to the right:
            newRightLeaf.keys.copy_from(leaf.keys, leftCount, rightCount);
            newRightLeaf.values.copy_from(leaf.values, leftCount, rightCount);
            //
            // update the left:
            leaf.keys.count = leftCount;
            leaf.values.count = leftCount;
            //
            // update leafs chain:
            newRightLeaf.nextLeaf = leaf.nextLeaf;
            if (newRightLeaf.nextLeaf != null) newRightLeaf.nextLeaf.prevLeaf = newRightLeaf;
            newRightLeaf.prevLeaf = leaf;
            leaf.nextLeaf = newRightLeaf;
            if (m_public.lastLeaf == leaf) m_public.lastLeaf = newRightLeaf;
            //
            // update parent:
            if (leaf.parent != null) {
                var leafIndex = calcChildIndex(leaf.parent, leaf);
                insertToParent(leaf.parent, newRightLeaf, newRightLeaf.keys.first(), leafIndex + 1);
            } else {
                createNewRoot(leaf, newRightLeaf, newRightLeaf.keys.first());
            }
        };

        // create new root
        var createNewRoot = function (nodeLeft, nodeRight, key) {
            // create new root containing nodeLeft and nodeRight children
            // btw nodeLeft and nodeRight can be leaves
            //
            // create the root node:
            var newRoot = new B_Plus_Node(m_nodeMaxCount);
            newRoot.keys.add(key);
            newRoot.children.add(nodeLeft);
            newRoot.children.add(nodeRight);
            //
            // update parent references:
            nodeLeft.parent = newRoot;
            nodeRight.parent = newRoot;
            //
            // update root reference:
            m_public.root = newRoot;
        };

        // insert newChildNode with key newChildFirstKey into the parentNode
        // the newChildNode inserts into the newChildIndex position in the children
        var insertToParent = function (parentNode, newChildNode, newChildFirstKey, newChildIndex) {
            //
            // insert child info:
            parentNode.keys.insert(newChildIndex - 1, newChildFirstKey); // -1: the related key is "before" the child
            parentNode.children.insert(newChildIndex, newChildNode);
            //
            // update parent reference:
            newChildNode.parent = parentNode;
            //
            // update parent if overflow:
            if (parentNode.keys.count > m_nodeMaxCount) {
                splitNode(parentNode);
            }
        };

        // split the overflowed node into 2 nodes
        var splitNode = function (node) {
            // split node: create right sibling
            //
            var newLeftCount = m_nodeMinCount;
            var newRightCount = m_nodeMaxCount - newLeftCount;
            var middleKey = node.keys.items[newLeftCount]; // key to move up
            //
            // create right node:
            var newRightNode = new B_Plus_Node(m_nodeMaxCount);
            newRightNode.keys.copy_from(node.keys, newLeftCount + 1, newRightCount);
            newRightNode.children.copy_from(node.children, newLeftCount + 1, newRightCount + 1);
            //
            // update the node:
            node.keys.count = newLeftCount;
            node.children.count = newLeftCount + 1;
            //
            // update children's parent:
            for (var i = 0; i < newRightNode.children.count; i++) newRightNode.children.items[i].parent = newRightNode;
            //
            // update parent:
            if (node.parent == null) {
                createNewRoot(node, newRightNode, middleKey);
            } else {
                var nodeIndex = calcChildIndex(node.parent, node);
                insertToParent(node.parent, newRightNode, middleKey, nodeIndex + 1);
            }
        };

        // -----------------------------------------
        //                remove():
        // -----------------------------------------

        // remove (key, value) item from the tree
        var p_Remove = function (key, value) {
            var searchResult = searchLeafValue(key, value);
            if (!searchResult.found) return false;
            //
            removeFromLeaf(searchResult.node, searchResult.index);
            return true;
        };

        // remove all the items with given key
        var p_RemoveKey = function (key) {
            while (true) {
                var searchResult = searchLeaf(key);
                if (!searchResult.found) break;
                //
                removeFromLeaf(searchResult.node, searchResult.index);
            }
        };

        // remove the item from index position of the leaf
        var removeFromLeaf = function (leaf, index) {
            leaf.keys.removeAt(index);
            leaf.values.removeAt(index);
            //
            // the item is removed; then update the tree if the leaf is underflowed:
            if (leaf.keys.count < m_nodeMinCount) {
                if ((leaf.prevLeaf != null) && (leaf.parent == leaf.prevLeaf.parent) && (leaf.prevLeaf.keys.count > m_nodeMinCount)) {
                    rotateAmongLeavesToRight(leaf.prevLeaf, leaf);
                } else if ((leaf.nextLeaf != null) && (leaf.parent == leaf.nextLeaf.parent) && (leaf.nextLeaf.keys.count > m_nodeMinCount)) {
                    rotateAmongLeavesToLeft(leaf, leaf.nextLeaf);
                } else {
                    mergeLeaf(leaf);
                }
            }
            return true;
        };

        // merge the underflowed leaf with left or right sibling 
        var mergeLeaf = function (leaf) {
            // if the leaf is root, then underflow is allowed:
            if (leaf.parent == null) {
                return;
            }
            //
            // calculate keys count in left and right sibling:
            var leftCount = m_nodeMaxCount + 1;
            var rightCount = m_nodeMaxCount + 1;
            if ((leaf.prevLeaf != null) && (leaf.prevLeaf.parent == leaf.parent)) {
                leftCount = leaf.prevLeaf.keys.count;
            }
            if ((leaf.nextLeaf != null) && (leaf.nextLeaf.parent == leaf.parent)) {
                rightCount = leaf.nextLeaf.keys.count;
            }
            //
            // select sibling to merge:
            if (leftCount < rightCount) {
                if (leftCount + leaf.keys.count > m_nodeMaxCount) throw "B_Plus_Tree.mergeLeaf(): leftCount";
                mergeLeaves(leaf.prevLeaf, leaf);
            } else {
                if (rightCount + leaf.keys.count > m_nodeMaxCount) throw "B_Plus_Tree.mergeLeaf(): rightCount";
                mergeLeaves(leaf, leaf.nextLeaf);
            }
        };

        // merge 2 leaf nodes: leafLeft and leafRight
        var mergeLeaves = function (leafLeft, leafRight) { // merge (left + right) -> left
            //
            // add right to left:
            leafLeft.keys.add_from(leafRight.keys);
            leafLeft.values.add_from(leafRight.values);
            //
            // update leafs chain:
            leafLeft.nextLeaf = leafRight.nextLeaf;
            if (leafLeft.nextLeaf != null) leafLeft.nextLeaf.prevLeaf = leafLeft;
            if (m_public.lastLeaf == leafRight) m_public.lastLeaf = leafLeft;
            //
            // remove right from parent:
            var parent = leafRight.parent;
            var leafRightIndex = calcChildIndex(parent, leafRight);
            parent.keys.removeAt(leafRightIndex - 1);
            parent.children.removeAt(leafRightIndex);
            //
            // update parent if underflow:
            if (parent.keys.count < m_nodeMinCount) {
                mergeNode(parent);
            };
        };

        // fix underflower index (non-leaf) node:
        // rotate among sibling, or merge with sibling
        var mergeNode = function (node) { // merge the node with sibling
            var parent = node.parent;
            //
            // remove root if the node became empty root:
            if (node.parent == null) {
                if (node.keys.count == 0) {
                    m_public.root = node.children.items[0];
                    m_public.root.parent = null;
                }
                return;
            }
            //
            // find left and right siblings:
            var nodeIndex = calcChildIndex(parent, node);
            var leftSibling = (nodeIndex > 0) ? parent.children.items[nodeIndex - 1] : null;
            var rightSibling = ((nodeIndex + 1) < parent.children.count) ? parent.children.items[nodeIndex + 1] : null;
            //
            // try rotation:
            if ((leftSibling != null) && (leftSibling.keys.count > m_nodeMinCount)) {
                rotateAmongNodesToRight(leftSibling, node);
                return;
            }
            if ((rightSibling != null) && (rightSibling.keys.count > m_nodeMinCount)) {
                rotateAmongNodesToLeft(node, rightSibling);
                return;
            }
            //
            // calculate siblings key count:
            var leftCount = m_nodeMaxCount + 1;
            var rightCount = m_nodeMaxCount + 1;
            if (leftSibling != null) {
                leftCount = leftSibling.keys.count;
            }
            if (rightSibling != null) {
                rightCount = rightSibling.keys.count;
            }
            //
            // select sibling to merge:
            if (leftCount < rightCount) {
                if (leftSibling == null) throw "B_Plus_Tree.mergeNode(): leftSibling";
                mergeNodes(leftSibling, node, nodeIndex);
            } else {
                if (rightSibling == null) throw "B_Plus_Tree.mergeNode(): rightSibling";
                mergeNodes(node, rightSibling, nodeIndex + 1);
            }
        };

        // merge 2 index (non-leaf) nodes nodeLeft and nodeRight into one node
        // the nodeRightIndex is the nodeRight index in parent's children array;
        // the nodeRightIndex is known in caller, so it's not needed to calculate it here
        var mergeNodes = function (nodeLeft, nodeRight, nodeRightIndex) { // merge (left + right) -> left
            var parent = nodeLeft.parent;
            //
            // update right children parent:
            for (var i = 0; i < nodeRight.children.count; i++) nodeRight.children.items[i].parent = nodeLeft;
            //
            // move down key from parent:
            nodeLeft.keys.add(nodeLeft.parent.keys.items[nodeRightIndex - 1]);
            //
            // add right to left:
            nodeLeft.keys.add_from(nodeRight.keys);
            nodeLeft.children.add_from(nodeRight.children);
            //
            // remove right from parent:
            parent.keys.removeAt(nodeRightIndex - 1);
            parent.children.removeAt(nodeRightIndex);
            //
            // update parent if underflow:
            if (parent.keys.count < m_nodeMinCount) {
                mergeNode(parent);
            };
        };


        // -----------------------------------------
        //          findFirst() / findNext():
        // -----------------------------------------

        // FindInfo nested class
        // contains the search criteria (key, value) and search result (leaf, index)


        // find first item matching (key, value) search criteria
        // use cases:
        // p_FindFirst()
        // p_FindFirst(key)
        // p_FindFirst(key, value)
        // p_FindFirst(key, undefined, true)
        var p_FindFirst = function (key, value, isPrefixSearch) {
            var findInfo = new FindInfo(key, value, isPrefixSearch);
            //
            if (findInfo.isKeyPresent) {
                if (findInfo.isPrefixSearch && findInfo.isValuePresent) throw "B_Plus_Tree.p_FindFirst(): arguments error: isPrefixSearch, but value is present";
                //
                var searchResult = findInfo.isValuePresent ? searchLeafValue(key, value) : searchLeaf(key);
                findInfo.leaf = searchResult.node;
                findInfo.index = searchResult.index;
                if (!searchResult.found) {
                    if (!findInfo.check_prefix()) {
                        return null;
                    }
                }
            } else {
                if (findInfo.isValuePresent) throw "B_Plus_Tree.findFirst(): arguments error: key is not present, but value is present";
                //
                findInfo.leaf = m_public.firstLeaf;
                findInfo.index = 0;
                if (findInfo.leaf.keys.count <= 0) return null;
            }
            //
            return findInfo;
        };

        // find last item matching (key, value) search criteria
        // use cases:
        // p_FindLast()
        // p_FindLast(key)
        // p_FindLast(key, value)
        // p_FindLast(key, undefined, true)
        var p_FindLast = function (key, value, isPrefixSearch) {
            var findInfo = new FindInfo(key, value, isPrefixSearch);
            //
            if (findInfo.isKeyPresent) {
                if (findInfo.isPrefixSearch && findInfo.isValuePresent) throw "B_Plus_Tree.p_FindLast(): arguments error: isPrefixSearch, but value is present";
                //
                if (findInfo.isPrefixSearch) {
                    var searchResult = searchLastLeafByPrefix(key);
                    findInfo.leaf = searchResult.node;
                    findInfo.index = searchResult.index;
                    if (!searchResult.found) {
                        return null;
                    }
                } else {
                    var searchResult = findInfo.isValuePresent ? searchLastLeafValue(key, value) : searchLastLeaf(key);
                    findInfo.leaf = searchResult.node;
                    findInfo.index = searchResult.index;
                    if (!searchResult.found) {
                        return null;
                    }
                }
            } else {
                if (findInfo.isValuePresent) throw "B_Plus_Tree.findLast(): arguments error: key is not present, but value is present";
                //
                findInfo.leaf = m_public.lastLeaf;
                findInfo.index = findInfo.leaf.keys.count - 1;
                if (findInfo.index < 0) return null;
            }
            //
            return findInfo;
        };

        // move to next item
        var findGoToNext = function (findInfo) {
            findInfo.index++;
            if (findInfo.index >= findInfo.leaf.keys.count) {
                findInfo.leaf = findInfo.leaf.nextLeaf;
                findInfo.index = 0;
            }
            //
            return (findInfo.leaf != null);
        };

        // move to previous item
        var findGoToPrev = function (findInfo) {
            findInfo.index--;
            if (findInfo.index < 0) {
                findInfo.leaf = findInfo.leaf.prevLeaf;
                if (findInfo.leaf == null) return false;
                findInfo.index = findInfo.leaf.keys.count - 1;
            }
            //
            return true;
        };

        // find next item after the findInfo's found item, matching the findInfo's search criteria
        var p_FindNext = function (findInfo) {
            while (true) {
                if (!findGoToNext(findInfo)) return null;
                //
                if (findInfo.isPrefixSearch) {
                    if (!findInfo.check_prefix()) return null;
                } else {
                    if (findInfo.isKeyPresent && (findInfo.key != findInfo.foundKey())) return null;
                }
                //
                if (findInfo.isValuePresent) {
                    if (findInfo.value == findInfo.foundValue()) return findInfo;
                } else {
                    return findInfo;
                }
            }
        };

        // find previous item after the findInfo's found item, matching the findInfo's search criteria
        var p_FindPrev = function (findInfo) {
            while (true) {
                if (!findGoToPrev(findInfo)) return null;
                //
                //if (findInfo.isKeyPresent && (findInfo.key != findInfo.foundKey())) return null;
                if (findInfo.isPrefixSearch) {
                    if (!findInfo.check_prefix()) return null;
                } else {
                    if (findInfo.isKeyPresent && (findInfo.key != findInfo.foundKey())) return null;
                }
                //
                if (findInfo.isValuePresent) {
                    if (findInfo.value == findInfo.foundValue()) return findInfo;
                } else {
                    return findInfo;
                }
            }
        };

        // -----------------------------------------
        //          additional methods:
        // -----------------------------------------

        // get values at key...
        //  make this always return an array, even if there is one item.
        //  will make interpretation easier.

        // will move the prefix search code into here.

        // iterate nodes by prefix... that may be a more efficient way of doing this, may be less efficient, it assigns one more thing I think.
        //  possibly a fast iterator?

        //  definitely would be easier code, I think it would be worth doing.
        //  could also be given its own check function.
        //   maybe gets given starting location.+


        var p_get_values_by_key = function (key) {
            var res = [];
            var findInfo = p_FindFirst(key);
            while (findInfo != null) {
                res.push(findInfo.foundValue());
                findInfo = p_FindNext(findInfo);
            }
            return res;
        }

        // get keys and values by prefix

        var p_get_by_prefix = function (prefix) {
            var res = [];
            var findInfo = m_public.findFirstPrefix(prefix);
            while (findInfo != null) {
                res.push([findInfo.foundKey(), findInfo.foundValue()]);
                findInfo = m_public.findNext(findInfo);
            }
            return res;
        }

        // get keys by prefix

        var p_get_keys_by_prefix = function (prefix) {
            var res = [];
            var findInfo = m_public.findFirstPrefix(prefix);
            while (findInfo != null) {
                res.push(findInfo.foundKey());
                findInfo = m_public.findNext(findInfo);
            }
            return res;
        }


        // -----------------------------------------
        //          getValue() / setValue():
        // -----------------------------------------

        // get value for the given key
        var p_GetValue = function (key) {
            var searchResult = searchLeaf(key);
            if (!searchResult.found) return null;
            return searchResult.node.values.items[searchResult.index];
        };

        // set value for the given key
        var p_SetValue = function (key, value) {
            var searchResult = searchLeaf(key);
            if (searchResult.found) {
                removeFromLeaf(searchResult.node, searchResult.index);
            }
            //
            p_Insert(key, value);
        };

        // -----------------------------------------
        //                 count():
        // -----------------------------------------

        // count all the value items in the tree
        // is that an easier way to iterate?

        var p_Count = function () {
            var result = 0;
            //
            var leaf = m_public.firstLeaf;
            while (leaf != null) {
                result += leaf.keys.count;
                leaf = leaf.nextLeaf;
            }
            //
            return result;
        };

        // count the value items with given key in the tree
        var p_CountKey = function (key) {
            var result = 0;
            //
            var findInfo = m_public.findFirst(key);
            while (findInfo != null) {
                result++;
                findInfo = m_public.findNext(findInfo);
            }
            //
            return result;
        };

        // -----------------------------------------
        //                 toText():
        // -----------------------------------------

        // returns multi-line text presentation for the tree

        /*
	    
        var _p_ToText = function () {
        var result = m_public.root.toText("");
        //
        if (typeof (B_Plus_Tree_NextNodeDebugId) != "undefined") {
        // print leafs chain:
        result += "\r\n";
        var leaf = m_public.firstLeaf;
        while (leaf != null) {
        result += "(" + leaf.debugId + ") ";
        leaf = leaf.nextLeaf;
        }
        }
        //
        return result;
        };

        */

        // -----------------------------------------
        //                rotations:
        // -----------------------------------------

        // "rotation" means moving items between siblings instead of split/merge

        // the following conditions are true when rotation is called:
        // leftNode.parent == rightNode.parent
        // leftLeaf.parent == rightLeaf.parent

        // move a key item to the left between leftNode and rightNode index (non-leaf) nodes
        // right node first item -> parent
        // parent item -> left node
        var rotateAmongNodesToLeft = function (leftNode, rightNode) {
            // move item from rightNode to LeftNode
            //
            var parent = rightNode.parent;
            var rightIndex = calcChildIndex(parent, rightNode);
            //
            // move the key:
            leftNode.keys.add(parent.keys.items[rightIndex - 1]); // copy the key down
            parent.keys.items[rightIndex - 1] = rightNode.keys.first(); // copy the key up
            rightNode.keys.removeFirst(); // remove from right
            //
            // move the child reference:
            rightNode.children.first().parent = leftNode; // update parent reference
            leftNode.children.add(rightNode.children.first()); // copy to left
            rightNode.children.removeFirst(); // remove from right
        };

        // move a key item to the right between leftNode and rightNode index (non-leaf) nodes
        // left node last item -> parent
        // parent item -> right node
        var rotateAmongNodesToRight = function (leftNode, rightNode) {
            // move item from leftNode to rightNode
            //
            var parent = rightNode.parent;
            var rightIndex = calcChildIndex(parent, rightNode);
            //
            // move the key:
            rightNode.keys.insert(0, parent.keys.items[rightIndex - 1]); // copy the key down
            parent.keys.items[rightIndex - 1] = leftNode.keys.last(); // copy the key up
            leftNode.keys.removeLast(); // remove from left
            //
            // move the child reference:
            rightNode.children.insert(0, leftNode.children.last()); // copy to right
            rightNode.children.first().parent = rightNode; // update parent reference
            leftNode.children.removeLast(); // remove from left
        };

        // move an item to the left between leftLeaf and rightLeaf leaf nodes
        // right leaf first item -> left leaf
        var rotateAmongLeavesToLeft = function (leftLeaf, rightLeaf) {
            // move item from rightLeaf to leftLeaf
            //
            var rightIndex = calcChildIndex(rightLeaf.parent, rightLeaf);
            //
            // copy to left:
            leftLeaf.keys.add(rightLeaf.keys.first());
            leftLeaf.values.add(rightLeaf.values.first());
            //
            // remove from right:
            rightLeaf.keys.removeFirst();
            rightLeaf.values.removeFirst();
            //
            // update parent:
            rightLeaf.parent.keys.items[rightIndex - 1] = rightLeaf.keys.first();
        };

        // move an item to the right between leftLeaf and rightLeaf leaf nodes
        // left leaf last item -> right leaf
        var rotateAmongLeavesToRight = function (leftLeaf, rightLeaf) {
            // move from leftLeaf to rightLeaf
            //
            var rightIndex = calcChildIndex(rightLeaf.parent, rightLeaf);
            //
            // copy to right:
            rightLeaf.keys.insert(0, leftLeaf.keys.last());
            rightLeaf.values.insert(0, leftLeaf.values.last());
            //
            // remove from left:
            leftLeaf.keys.removeLast();
            leftLeaf.values.removeLast();
            //
            // update parent:
            rightLeaf.parent.keys.items[rightIndex - 1] = rightLeaf.keys.first();
        };

        // -----------------------------------------
        //             internal searches:
        // -----------------------------------------

        // short description: returns the "child" index in the "node"
        // long description: calculates the "child" node index in the "node.children" array
        // (usually node == child.paren)
        var calcChildIndex = function (node, child) {
            var key = child.keys.first();
            var searchResult = node.keys.search_first(key);
            if (!searchResult.found) {
                if (node.children.items[searchResult.index] != child) throw "B_PlusTree.calcChildIndex(): 1";
                return searchResult.index;
            }
            //
            var index = searchResult.index;
            for (; ; ) {
                if (node.children.items[index] == child) return index;
                //
                index++;
                if (index >= node.children.count) break;
                if (node.keys.items[index - 1] != key) break;
            }
            throw "B_PlusTree.calcChildIndex(): 2";
        };

        // returns leaf node containing an item with the given key
        var searchLeaf = function (key) {
            // 
            var doSearchLeaf = function (node, key) {
                var searchResult = node.keys.search_first(key);
                //
                if (node.isLeaf) {
                    return { node: node, found: searchResult.found, index: searchResult.index };
                }
                //
                if (searchResult.found) {
                    // illustration: [left child] key [right child]
                    // both children (left and right i.e. before and after the key) can contain the key
                    //
                    // try the left child first:
                    var resultLeft = doSearchLeaf(node.children.items[searchResult.index], key);
                    if (resultLeft.found) return resultLeft;
                    //
                    // try the right child
                    return doSearchLeaf(node.children.items[searchResult.index + 1], key);
                } else {
                    // the pointed key is greater than the searched key. Only left child can be considered:
                    return doSearchLeaf(node.children.items[searchResult.index], key);
                }
            };
            //
            return doSearchLeaf(m_public.root, key);
        };

        // returns last leaf node containing an item with the given key
        var searchLastLeaf = function (key) {
            // 
            var doSearchLastLeaf = function (node, key) {
                var searchResult = node.keys.search_last(key);
                //
                if (node.isLeaf) {
                    return { node: node, found: searchResult.found, index: searchResult.index };
                }
                //
                if (searchResult.found) {
                    // illustration: [left child] key [right child]
                    // both children (left and right i.e. before and after the key) can contain the key
                    //
                    // try the right child first:
                    var resultRight = doSearchLastLeaf(node.children.items[searchResult.index + 1], key);
                    if (resultRight.found) return resultRight;
                    //
                    // try the left child
                    return doSearchLastLeaf(node.children.items[searchResult.index], key);
                } else {
                    // the pointed key is greater than the searched key. Only left child can be considered:
                    return doSearchLastLeaf(node.children.items[searchResult.index], key);
                }
            };
            //
            return doSearchLastLeaf(m_public.root, key);
        };

        // returns last leaf node containing an item with the given prefix
        var searchLastLeafByPrefix = function (prefix) {
            // 
            var doSearchLastLeafByPrefix = function (node, prefix) {
                var searchResult = node.keys.search_last_prefix(prefix);
                //
                if (node.isLeaf) {
                    return { node: node, found: searchResult.found, index: searchResult.index };
                }
                //
                if (searchResult.found) {
                    // illustration: [left child] key [right child]
                    // both children (left and right i.e. before and after the key) can contain the prefix
                    //
                    // try the right child first:
                    var resultRight = doSearchLastLeafByPrefix(node.children.items[searchResult.index + 1], prefix);
                    if (resultRight.found) return resultRight;
                    //
                    // try the left child
                    return doSearchLastLeafByPrefix(node.children.items[searchResult.index], prefix);
                } else {
                    // the pointed key is greater than the searched prefix. Only left child can be considered:
                    return doSearchLastLeafByPrefix(node.children.items[searchResult.index], prefix);
                }
            };
            //
            return doSearchLastLeafByPrefix(m_public.root, prefix);
        };

        // returns leaf node containing an item with the given key and value
        var searchLeafValue = function (key, value) {
            // search the key:
            var searchResult = searchLeaf(key);
            if (!searchResult.found) return searchResult;
            //
            // search the value (if there are several the same keys):
            var valueFound = false;
            var leaf = searchResult.node;
            var index = searchResult.index;
            for (; ; ) {
                if (index >= leaf.values.count) {
                    leaf = leaf.nextLeaf;
                    if (leaf == null) break;
                    index = 0;
                }
                if (leaf.keys.items[index] != key) break;
                if (leaf.values.items[index] == value) {
                    valueFound = true;
                    break;
                }
                index++;
            }
            //
            return { node: leaf, found: valueFound, index: index };
        };

        // returns last leaf node containing an item with the given key and value
        var searchLastLeafValue = function (key, value) {
            // search the key:
            var searchResult = searchLastLeaf(key);
            if (!searchResult.found) return searchResult;
            //
            // search the value (if there are several the same keys):
            var valueFound = false;
            var leaf = searchResult.node;
            var index = searchResult.index;
            //var foundIndex = 0;
            for (; ; ) {
                if (index < 0) {
                    leaf = leaf.prevLeaf;
                    if (leaf == null) break;
                    index = leaf.values.count - 1;
                }
                if (leaf.keys.items[index] != key) break;
                if (leaf.values.items[index] == value) {
                    valueFound = true;
                    break;
                }
                index--;
            }
            //
            return { node: leaf, found: valueFound, index: index };
        };

        // -----------------------------------------
        //       return the public interface:
        // -----------------------------------------

        return m_public;
    };

    B_Plus_Tree.FindInfo = FindInfo;

    //return B_Plus_Tree;
    module.exports = B_Plus_Tree;


//});



},{"./jsgui-data-structures-stiffarray":34,"./jsgui-lang-essentials":37}],33:[function(require,module,exports){

// could rename this ds_doubly_linked_list.js

// maybe not really a part of jsgui?

/*
if (typeof define !== 'function') {
    var define = require('amdefine')(module);
}



define(["./jsgui-lang-essentials"], function(jsgui) {

*/

var jsgui = require('./jsgui-lang-essentials');

    /** 
    * Doubly linked list module.
    * @module core/jsgui-data-structures-doubly-linked-list 
    * @exports Doubly_Linked_List
    */

	// Essentials provides a fair few things... at least I can use functional polymorphism.

	var j = jsgui;
	var Class = j.Class;
	var each = j.each;
	var is_array = j.is_array;
	var is_dom_node = j.is_dom_node;
	var is_ctrl = j.is_ctrl;
	var extend = j.extend;
	var x_clones = j.x_clones;
	var get_truth_map_from_arr = j.get_truth_map_from_arr;
	var get_map_from_arr = j.get_map_from_arr;
	var arr_like_to_arr = j.arr_like_to_arr;
	var tof = j.tof;
	var is_defined = j.is_defined;
	var stringify = j.stringify;
	var functional_polymorphism = j.functional_polymorphism;
	var fp = j.fp;
	var arrayify = j.arrayify;
	var are_equal = j.are_equal;
	var get_item_sig = j.get_item_sig;
	var set_vals = j.set_vals;
	var truth = j.truth;
	var trim_sig_brackets = j.trim_sig_brackets;
	
// This may use some more generic graph node?
	
	// This may need to get adapted further for use in some other components.
	
	// Nodes having a key - they get inserted in a particular position.
	//  Having a value too? A key value pair array?
	//   Possibly could maintain the sorted order of a list. That will get used for the B+ tree.
	
	// Each node has a parent, and various children / branches.
	//  I think there can be some relatively generic tree / node systems, with b+ functionality implemented on top of that.
	
	// The B+ tree node could be an extension from Sorted_Doubly_Linked_list
	//  It will override insert code with code that can insert within other Node objects within it.
	
	// There will be a B+ tree class that makes use of these nodes, and will perform rebalancing where necessary.
	
	// Want an interface, linked_hash_map, that has the linked list internally
	// Linked list that has an object inside each node.
	
	
	// Doing more work on a linked list, and linked mapped list will be helpful.
	//  Sorted_KVS, Ordered_KVS?
	//  Ordered_List?
	//  Ordered_KVS makes sense when each value has a key but the order needs to be preserved.
	//   Could be a wrapper around Linked_Map.
	
    /**
    * Creates the node.
    * @constructor
    * @classdesc Represents a doubly linked list item (named "node").
    * @alias Doubly_Linked_List.Node
    * @param {object} spec - {value: (node value)}
    * @memberof module:core/jsgui-data-structures-doubly-linked-list
    * @example
    *
    * var node101 = new Doubly_Linked_List.Node({ value: 101 });
    */
	var Node = Class.extend({
		'init': function(spec) {
			// previous and next held as an array.
			
			// neighbours
			//  it could have no neighbours.
			//   a list will be empty, with no nodes.
			//   then it will have a node with no neighbours, which is both the first and the last node.
			//   then 2 nodes, 1 with each neighbour
			//   then 3 nodes, with the end nodes still having no neighbours.
			
			// This will just be for iterating through the list, adding, removing, doing basic operations.
			//  I may leave inefficient operations out, so the linked list gets used for what it is best at.
			//   But the inefficient/less efficient operations may be done to lower amounts, such as 12, by maintaining small LLs in data structures such as B+ trees.
			
			this.neighbours = spec.neighbours || [];
			
		    /**
            * The node's value.
            * @memberof module:core/jsgui-data-structures-doubly-linked-list.Doubly_Linked_List.Node
            * @instance
            * @name value
            */
		    // Adding and removing while maintaining an order?
			this.value = spec.value;
			
			
			// parent
			
		},
	    /**
        * Returns previous node in the list.
        * @memberof module:core/jsgui-data-structures-doubly-linked-list.Doubly_Linked_List.Node.prototype
        */
		'previous': function () {
			return this.neighbours[0];
		},
	    /**
        * Returns next node in the list.
        * @memberof module:core/jsgui-data-structures-doubly-linked-list.Doubly_Linked_List.Node.prototype
        */
		'next': function () {
			return this.neighbours[1];
		}
	});
	
	// Do these linked list nodes need to have anything?
	//  Just the means to insert their nodes etc?
	//   Then their nodes could be made to carry other data by other components.
	
	// Doubly_Linked_List could extend Node.
	//  That way it can be put in a tree, and used for holding the data in a tree.
	//  Want a B+ tree so that items can get put in correctly.
	
	// Having a whole tree made up of a doubly linked list, with other structures indexing it?
	//  Need some more fundamental data structures. The Collection and Data_Object will be good, but it will be good to store the fields in an appropriate object.
	
	
	// Ordered_KVS - may be a useful one.
	//  Would have the double linked list inside and map.
	
	
	// Mapped_Linked_List? would need to know what field to look at.
	
	var nodify = function(fn) {
		
		var res = function(val) {
			if (val instanceof Node) {
				return fn(val);
			} else {
				var node = new Node({'value': val});
				return fn(node);
			}
			
		};
		return res;
		
	}
	
	
    /**
    * Creates the doubly linked list.
    * @constructor
    * @classdesc Represents a doubly linked list.
    * @memberof module:core/jsgui-data-structures-doubly-linked-list
    */
	var Doubly_Linked_List = Class.extend({
		'init': function(spec) {
			// spec could be the initial items for the list.
			
			this.first = null;
			this.last = null;
			
			this.length = 0;
			// harder to maintain the length when nodes could be moved around the list.
			//  would need to be able to see if a node is in the list to begin with...
			//   so each node could have a container object, and if it is set to the list already when an insert is done, then the list will be able to keep track of
			//    its length. That would be better than having to count them.
			
		},
		
	    /**
        * Iterates over the list nodes calling the function for each node.
        * @param {function} callback - callback function: callback(node, stop)
        * - node: the list node
        * - stop: function to break iterations.
        * @memberof module:core/jsgui-data-structures-doubly-linked-list.Doubly_Linked_List.prototype
        * @example
        *
        * function getNodes(list) {
        *     var result = [];
        *     //
        *     list.each_node(function (node) { result.push(node); });
        *     //
        *     return result;
        * }
        *
        */
		'each_node': function (callback) {
			//console.log('each_node this.length ' + this.length);
			
			var node = this.first;
			var ctu = true;
			var stop = function() {
				ctu = false;
			};
			while (node && ctu) {
				callback(node, stop);
				node = node.neighbours[1];
			}
		},
		
	    /**
        * Iterates over the list nodes calling the function for each node's value.
        * @param {function} callback - callback function: callback(value, stop)
        * - value: the list node value
        * - stop: function to break iterations.
        * @memberof module:core/jsgui-data-structures-doubly-linked-list.Doubly_Linked_List.prototype
        * @example
        *
        * function getValues(list) {
        *     var result = [];
        *     //
        *     list.each(function (value) { result.push(value); });
        *     //
        *     return result;
        * }
        *
        */
		'each': function (callback) {
			this.each_node(function(node, stop) {
				callback(node.value, stop);
			});
		},
		
	    /**
        * Removes the node from the list.
        * @param {Node} node - node to remove
        * @memberof module:core/jsgui-data-structures-doubly-linked-list.Doubly_Linked_List.prototype
        * @example
        *
        * var list = new Doubly_Linked_List();
        * var node101 = new Doubly_Linked_List.Node({ value: 101 });
        *
        * list.push(node101);
        * list.remove(node101);
        *
        * // the list is empty now
        */
		'remove': (function (node) {
			
			// can not remove a value... have to remove a node.
			//  this will be more useful when there is a map of values.
			
			if (node.neighbours[0]) {
				node.neighbours[0].neighbours[1] = node.neighbours[1];
			} else {
				this.first = node.neighbours[1];
			}
			
			if (node.neighbours[1]) {
				node.neighbours[1].neighbours[0] = node.neighbours[0];
			} else {
				this.last = node.neighbours[0];
			}
			
			node.neighbours = [];
			
			if (node.parent == this) {
				delete node.parent;
				this.length--;
			}
			
		}),
		
		// check to see if the item is a 'node' object.
		//  if it is, can insert it as a node, otherwise create the node object and insert it.
		//   a bit like wrapping values in Data_Value.
		
	    /**
        * Inserts the node at the beginning of the list.
        * @param {Node|*} node - node to insert, or node value
        * @memberof module:core/jsgui-data-structures-doubly-linked-list.Doubly_Linked_List.prototype
        * @example
        *
        * var list = new Doubly_Linked_List();
        * var node101 = new Doubly_Linked_List.Node({ value: 101 });
        *
        * list.insert_beginning(node101);
        * list.insert_beginning(102);
        *
        * // list values: 102, 101
        */
		'insert_beginning': function (val) {
			if (val instanceof Node) {
				if (this.first == null) {
					this.first = val;
					this.last = val;
					val.neighbours = [];
					if (val.parent != this) {
						val.parent = this;
						this.length++;
					}
				} else {
					// insert it before first item.
					this.insert_before(val, this.first);
				}
				return val;
			} else {
				var node = new Node({'value': val});
				return this.insert_beginning(node);
			}
		},
		
		// could use a nodify function.
		//  or ensure_data_wrapper
		
	    /**
        * Inserts the node before the specified node.
        * @param {Node|*} val - node to insert, or node value
        * @param {Node} node - insert point
        * @memberof module:core/jsgui-data-structures-doubly-linked-list.Doubly_Linked_List.prototype
        * @example
        *
        * var list = new Doubly_Linked_List();
        * var node101 = new Doubly_Linked_List.Node({ value: 101 });
        *
        * list.push(node101);
        * list.insert_before(102, node101);
        *
        * // list values: 102, 101
        */
		'insert_before': function (val, node) {
			// check to see if the new value is a node.
			
			if (val instanceof Node) {
				val.neighbours = [node.neighbours[0], node];
				if (node.neighbours[0] == null) {
					this.first = val;
				} else {
					node.neighbours[0].neighbours[1] = val;
				}
				node.neighbours[0] = val;
				
				if (val.parent != this) {
					val.parent = this;
					this.length++;
				}
				return val;
			} else {
				var new_node = new Node({'value': val});
				return this.insert_before(new_node, node);
			}
			
		},
		
	    /**
        * Inserts the node after the specified node.
        * @param {Node|*} val - node to insert, or node value
        * @param {Node} node - insert point
        * @memberof module:core/jsgui-data-structures-doubly-linked-list.Doubly_Linked_List.prototype
        * @example
        *
        * var list = new Doubly_Linked_List();
        * var node101 = new Doubly_Linked_List.Node({ value: 101 });
        *
        * list.push(node101);
        * list.insert_after(102, node101);
        *
        * // list values: 101, 102
        */
		'insert_after': function (val, node) {
			if (val instanceof Node) {
				//console.log('insert after node ' + node);
				
				val.neighbours = [node, node.neighbours[1]];
				if (node.neighbours[1] == null) {
					this.last = val;
				} else {
					node.neighbours[1].neighbours[0] = val;
					
				}
				node.neighbours[1] = val;
				
				//node.neighbours[0].neighbours[1] = val;
				if (val.parent != this) {
					val.parent = this;
					this.length++;
				}
				return val;
			} else {
				var new_node = new Node({'value': val});
				return this.insert_after(new_node, node);
			}
		},
		// not wrapping the item in a node?
		
		// want one where we are not pushing nodes, but items stored in nodes.
		//  Perhaps this is a Data_Value?
		// Or a doubly_linked_node.
		
		// Doubly_Linked_Node could take the form [prev, item, next]
		//  [prev, item, key, next]? probably not
		
		//  Maybe we could put more private variables, such as 'neighbours' as a var within the init statement.
		
	    /**
        * Inserts the node at the end of the list.
        * @param {Node|*} val - node to insert, or node value
        * @memberof module:core/jsgui-data-structures-doubly-linked-list.Doubly_Linked_List.prototype
        * @example
        *
        * var list = new Doubly_Linked_List();
        * var node101 = new Doubly_Linked_List.Node({ value: 101 });
        *
        * list.push(node101);
        * list.push(102);
        *
        * // list values: 101, 102
        */
		'push': function (val) {
			
			if (val instanceof Node) {
				if (this.last == null) {
					this.insert_beginning(val);
				} else {
					return this.insert_after(val, this.last);
					/*
					var last = this.last;
					last.neighbours[1] = val;
					this.last = val;
					
					//console.log('val.parent ' + val.parent);
					//console.log('this ' + this);
					
					if (val.parent != this) {
						val.parent = this;
						this.length++;
					}
					*/
				}
				return val;
			} else {
				var new_node = new Node({'value': val});
				return this.push(new_node);
			}
			// the item gets wrapped in a node.?
			
			
			
		}
	});
	
    /**
    * The list node class.
    * @memberof module:core/jsgui-data-structures-doubly-linked-list.Doubly_Linked_List
    * @name Doubly_Linked_List.Node
    */

	Doubly_Linked_List.Node = Node;
	
	
	// var jsgui = {};
	// alert('returning jsgui from jsgui-lang');
	//return jsgui;
module.exports = Doubly_Linked_List;

	//return Doubly_Linked_List;
	
	
//});

},{"./jsgui-lang-essentials":37}],34:[function(require,module,exports){

// This is resulting in smaller code in other parts of the framework.
//  This section is getting quite big (again)
//  Still need to make use of the B+ free for ordered indexing.

// Moving some code to jsgui-lang-essentials
//  Will be publishing a 0.4 version of that before so long?
//   Maybe with more explanation?

// It may be worth publishing this, and a discussion forum about it on my own web forum.
//  Perhaps that could come later, but jsgui-lang-essentials may be a good step. Could call it version 0.35.
//   Could have a few examples
//   Would be a useful toolkit I could use while working elsewhere.

//  I think that web site would be lightening fast, and impress people with its speed compared to other web platforms that they are used to
//   (though Facebook is OK)

/*
if (typeof define !== 'function') {
    var define = require('amdefine')(module);
}


// May sway implementations of the particular items more easily when they are in their own files.

define(["./jsgui-lang-essentials"], function (jsgui) {
    */
var jsgui = require('./jsgui-lang-essentials');

    // StiffArray: an array with pre-allocated items
    // it seems that this array is usually faster (excluding IE javascript engine)
    // probably there is a reason to provide IE implementation based on usual dynamic arrays

    /** 
    * Stiff Array module.
    * @module core/jsgui-data-structures-stiffarray
    * @exports StiffArray
    */


    var StiffArray = function (capacity) {

        // -----------------------------------------
        //              public interface:
        // -----------------------------------------

        /**
        * Creates the stiff array.
        * @constructor
        * @classdesc 
        * An array with pre-allocated items.
        * It seems that this array is usually faster (excluding IE javascript engine).
        * Probably there is a reason to provide IE implementation based on usual dynamic arrays.
        *
        * @alias StiffArray
        * @param {number} capacity - array capacity (maximum possible number of items).
        * @memberof  module:core/jsgui-data-structures-stiffarray
        * @example
        *
        * var array = new StiffArray(7);
        */

        var m_public = {
            /** 
            * internal storage array 
            * @type {Array}
            * @instance
            */
            items: new Array(capacity),
            /** 
            * items count
            * @type {number}
            * @instance
            */
            count: 0,
            /** 
            * Returns the first item
            * @instance
            */
            first: function () {
                if (this.count == 0) throw "StiffArray.first()";
                return this.items[0];
            },
            /** 
            * Returns the last item
            * @instance
            */
            last: function () {
                if (this.count == 0) throw "StiffArray.last()";
                return this.items[this.count - 1];
            },
            /** 
            * Adds item
            * @instance
            * @param {*} item - item to add
            */
            add: function (item) {
                if (this.count >= capacity) throw "StiffArray.add()";
                //
                this.items[this.count++] = item;
            },
            /** 
            * Adds all the items from the  source (to the end of the existing items)
            * @param {StiffArray} source - source stiff array
            * @instance
            */
            add_from: function (source) {
                if (this.count + source.count > capacity) throw "StiffArray.add_from()";
                //
                for (var i = 0; i < source.count; i++) this.items[this.count++] = source.items[i];
            },
            /** 
            * Inserts the item at the specified index.
            * @param {number} index - index for the new item (zero-based)
            * @param {*} item - item to insert
            * @instance
            */
            insert: function (index, item) {
                if ((index < 0) || (index > this.count)) throw "StiffArray.insert(): index";
                if (this.count >= capacity) throw "StiffArray.insert(): overflow";
                //
                for (var i = this.count; i > index; i--) this.items[i] = this.items[i - 1];
                this.items[index] = item;
                this.count++;
            },
            /** 
            * Removes the item at the specified index.
            * @param {number} index - index of the removing item (zero-based)
            * @instance
            */
            removeAt: function (index) {
                if ((index < 0) || (index >= this.count)) throw "StiffArray.removeAt()";
                //
                this.count--;
                for (var i = index; i < this.count; i++) this.items[i] = this.items[i + 1];
            },
            /** 
            * Removes the first item.
            * @instance
            */
            removeFirst: function () {
                this.removeAt(0);
            },
            /** 
            * Removes the last item.
            * @instance
            */
            removeLast: function () {
                this.removeAt(this.count - 1);
            },
            /** 
            * Replaces all the items to the subset of the other StiffArray items.
            * @param {StiffArray} source - source stiff array
            * @param {number} index - index of the first item of the subset
            * @param {number} count - number of items in the subset
            * @instance
            */
            copy_from: function (source, index, count) {
                for (var i = 0; i < count; i++) {
                    this.items[i] = source.items[i + index];
                }
                this.count = count;
            },
            /** 
            * Performs a binary search for the first occurrence of the item in the stiff array. Uses an usual JavaScript items comparison: item1 < item2.
            * @param {*} item - item to search
            * @returns {object} { found: f, index: i } object:
            * - found: true if the item is found, false otherwise
            * - index: index of the found item, or index to insert new (non-found) item
            * @instance
            * @example
            *
            * var arr = new StiffArray(10);
            * arr.add(1); // [0]
            * arr.add(2); // [1]
            * arr.add(2); // [2]
            * arr.add(3); // [3]
            * arr.add(3); // [4]
            * arr.add(3); // [5]
            *
            * arr.search_first(0)  ==>  { found: false, index: 0 }
            * arr.search_first(1)  ==>  { found: true, index: 0 }
            * arr.search_first(2)  ==>  { found: true, index: 1 }
            * arr.search_first(3)  ==>  { found: true, index: 3 }
            * arr.search_first(4)  ==>  { found: false, index: 6 }
            */
            search_first: function (item) {
                var cnt = this.count;
                var first = 0;
                while (cnt > 0) {
                    var step = Math.floor(cnt / 2);
                    var index = first + step;
                    if (this.items[index] < item) {
                        first = index + 1;
                        cnt -= (step + 1);
                    } else {
                        cnt = step;
                    }
                }
                //
                if (first < this.count) {
                    return { found: (this.items[first] == item), index: first };
                }
                return { found: false, index: first };
            },
            /** 
            * Performs a binary search for the last occurrence of the item in the stiff array. Uses an usual JavaScript items comparison: item1 >= item2.
            * @param {*} item - item to search
            * @returns {object} { found: f, index: i } object:
            * - found: true if the item is found, false otherwise
            * - index: index of the found item, or index to insert new (non-found) item
            * @instance
            * @example
            *
            * var arr = new StiffArray(10);
            * arr.add(1); // [0]
            * arr.add(2); // [1]
            * arr.add(2); // [2]
            * arr.add(3); // [3]
            * arr.add(3); // [4]
            * arr.add(3); // [5]
            *
            * arr.search_last(0)  ==>  { found: false, index: 0 }
            * arr.search_last(1)  ==>  { found: true, index: 0 }
            * arr.search_last(2)  ==>  { found: true, index: 2 }
            * arr.search_last(3)  ==>  { found: true, index: 5 }
            * arr.search_last(4)  ==>  { found: false, index: 6 }
            */
            search_last: function (item) {
                var cnt = this.count;
                var first = 0;
                while (cnt > 0) {
                    var step = Math.floor(cnt / 2);
                    var index = first + step;
                    if (item >= this.items[index]) {
                        first = index + 1;
                        cnt -= (step + 1);
                    } else {
                        cnt = step;
                    }
                }
                //
                if ((first > 0) && (first <= this.count)) {
                    if (this.items[first - 1] == item) {
                        return { found: true, index: first - 1 };
                    }
                }
                return { found: false, index: first };
            },
            /** 
            * Performs a binary search for the last occurrence of the prefix in the stiff array. Useful when the stiff array items are strings.
            *
            * A search_first_prefix() method is not implemented because search_first() can be used instead; but search_last() cannot be used instead of the search_last_prefix().
            *
            * @param {string} prefix - prefix to search
            * @returns {object} { found: f, index: i } object:
            * - found: true if the prefixed item is found, false otherwise
            * - index: index of the found item, or index to insert new (non-found) item
            * @instance
            * @example
            *
            * var arr = new StiffArray(10);
            * arr.add("111"); // [0]
            * arr.add("121"); // [1]
            * arr.add("122"); // [2]
            * arr.add("131"); // [3]
            *
            * arr.search_last_prefix("")  ==>  { found: true, index: 3 }
            *
            * arr.search_last_prefix("0")  ==>  { found: false, index: 0 }
            * arr.search_last_prefix("1")  ==>  { found: true, index: 3 }
            * arr.search_last_prefix("2")  ==>  { found: false, index: 4 }
            *
            * arr.search_last_prefix("10")  ==>  { found: false, index: 0 }
            * arr.search_last_prefix("11")  ==>  { found: true, index: 0 }
            * arr.search_last_prefix("12")  ==>  { found: true, index: 2 }
            * arr.search_last_prefix("13")  ==>  { found: true, index: 3 }
            * arr.search_last_prefix("14")  ==>  { found: false, index: 4 }
            *
            *
            *
            */
            search_last_prefix: function (prefix) {
                var prefix_length = prefix.length;
                //
                var check_prefix = function (item) {  
                    if (prefix_length > item.length) return false;
                    return (item.substr(0, prefix_length) == prefix)
                }
                //
                var cnt = this.count;
                var first = 0;
                while (cnt > 0) {
                    var step = Math.floor(cnt / 2);
                    var index = first + step;
                    var item = this.items[index];
                    if ((prefix > item) || check_prefix(item)) {
                        first = index + 1;
                        cnt -= (step + 1);
                    } else {
                        cnt = step;
                    }
                }
                //
                if ((first > 0) && (first <= this.count)) {
                    if (check_prefix(this.items[first - 1])) {
                        return { found: true, index: first - 1 };
                    }
                }
                return { found: false, index: first };
            },
            toString: function () {
                return this.items.slice(0, this.count).toString();
            }
        };


        // -----------------------------------------
        //       return the public interface:
        // -----------------------------------------

        return m_public;
    };
module.exports = StiffArray;


    //return StiffArray;


//});



},{"./jsgui-lang-essentials":37}],35:[function(require,module,exports){
// This is resulting in smaller code in other parts of the framework.
//  This section is getting quite big (again)
//  Still need to make use of the B+ free for ordered indexing.

// Moving some code to jsgui-lang-essentials
//  Will be publishing a 0.4 version of that before so long?
//   Maybe with more explanation?

// It may be worth publishing this, and a discussion forum about it on my own web forum.
//  Perhaps that could come later, but jsgui-lang-essentials may be a good step. Could call it version 0.35.
//   Could have a few examples
//   Would be a useful toolkit I could use while working elsewhere.

//  I think that web site would be lightening fast, and impress people with its speed compared to other web platforms that they are used to
//   (though Facebook is OK)




// May sway implementations of the particular items more easily when they are in their own files.

// It looks like things are pointing towards the Compressed Dynamic Suffix Array.

//  Want something that provides full-text matches.
//   Some simpler data structures may work better to start with.
//   For unit tests, could compare them to a very simple and inefficient algorithm that goes through the whole string.

// Suffixes seem like one of the important things to focus on.

//  Prefix trees seemed like a good way of doing things before.

// I think suffix arrays, compressed suffix arrays, and compressed dynamic ones seem like the major route to take.
// Suffix trees too, those may lead to suffix arrays as well.
//  Definitely do want these fairly difficult features.

// CDSAs are not necessarily Mikael Salson's version either.
//  Could approach it myself.
//  Need the suffix array
//  Need to compress it
//   Changing the uncompressed suffix array
//   Changing a compressed suffix array

// Going from the operation, doing something, to all the steps needed to change the array.
//  Can do some experiments with the suffix arrays, compressing them to another type of suffix array, and decompressing them as well.
//   Performing search operations on the compressed suffix array.
/*
if (typeof define !== 'function') {
    var define = require('amdefine')(module);
}

define(["./jsgui-lang-essentials", "./jsgui-data-structures-doubly-linked-list", "./jsgui-data-structures-b-plus-tree"], function(jsgui, Doubly_Linked_List, B_Plus_Tree) {
    */
    var jsgui = require('./jsgui-lang-essentials');
var Doubly_Linked_List = require('./jsgui-data-structures-doubly-linked-list');
var B_Plus_Tree = require('./jsgui-data-structures-b-plus-tree');

    /** 
    * Data structures module.
    * @module core/jsgui-data-structures
    * @exports Data_Structures
    */


	// The data structures will be needed to support some components
	
	var Class = jsgui.Class;
	//console.log('Class ' + Class);
	var mapify = jsgui.mapify;
	//console.log('mapify ' + mapify);

	var is_defined = jsgui.is_defined;
	var stringify = jsgui.stringify;
	var each = jsgui.each;
	var fp = jsgui.fp;
	var tof = jsgui.tof;

	// Also will get the Doubly_Linked_List.
	// Various data structures will be defined separately and this will link them together.
	
	//  I think some data structures would be nice when published online.
	//   They will rely on essentials. A microframework version could be published with the necessary essentials already built in.
	
	
	//  Could include some Jasmine unit tests with them.
	
	
	// Now that this is isolated, removing it and replacing it with a different / better version seems easier... it's just a component.
	
	// This is acting as a friendlier wrapper to the B+ tree.
	//  Not so sure about it having it maintain a dict index too... but maybe it is best to have ksvs
	//  KSVS could possibly be extended so that it makes use of both the tree and the dict.
	
	// I'm interested in making a data structure that uses these sibling lists as well as a dict. That will mean they can be located by full key in O(1) time.
	//  Then the tree can be moved through.
	//   This would mean indexing the leaf node for the object. Then it will be possible to move through the tree.
	//   Finding the place where an item would be put... similar to finding the first key after a certain value.
	//   Then can proceed through the tree (quick to move to the next node) until we have moved past nodes with the specified prefix.
	
	// The point is to have various data structures here that are named, and have APIs as per their usage.
	// Eg Key-Value-Store rather than B+ tree
	
	// Sorted_KVS
	
	//  Could make an API / interface for this.
	
	// May be better to work on the XML processing for the moment?
	
	// Transforming an XML / jsgui page jsguiml? actually ASP.NET?
	//  JSUI (Je Suis, I like that name, it's announcing that things 'are', it's a very declarative statement.)
	//   JSUI-XML
	//   JeSui_XML
	//   Je_Suis_Xml
	
	//  JSUI-ML
	
	// I think maintaining and consuming these data structures as resources will be a very useful functionality.
	//  Distributed result finding could be very useful, where a function in execution is sent over the network.
	//  The function gets sent over to its next node when it has a result from one node.
	//   It could branch as well when necessary, meaning lookups take place in parallel.
	//    Would maybe need or benefit from high latency alert reporting.
	
	// Publishing various data structures such as a sorted list over a network would be useful.
	//  Even if the list itself may not be distributed, it could be a component in a distributed system.
	
	// There will wind up being a variety of different classes that do similar things, but in different ways.
	
	// Could have a high throughput system.
	
	// There could be a KVS resource that is used as a shard, with a published index for the sharding system, and the client machines
	//  using a KVS_Shards(_Client) resource. That will mean that systems that rely on a large array like structure, like a B+ tree, could make use of it.
	// Client access for using the B+ tree could be done accross the network (if its not for locks!)
	//  May run into trouble because of data change and access to it.
	//  Could also implement a locking mechanism? What exactly would it do? Or more like a rapid update notifier? Or again no need because everything gets updated in the shards?
	//  Want to avoid multiple updates taking place at once. The lack of logic could be messy.
	//   Maybe there is a way to partition things so that some part of a tree becomes locked?
	
	// I think a sharded lower level unsorted KSV would be really useful for making a sorted KVS, and also a full-text index.
	//  There could be multiple nodes that access it, but 
	
	// Full text index:
	//  Key(string), text_value(string)
	//  key used to identify the text and for returning the result.
	
	// Full text index on the client would indeed be quite useful.
	//  It would probably be possible to make a text index incorporating some things like BWT for use on the client.
	
	
	
	// The data for the tree would be distributed over the KVS shards, and would then 
	
	
	/*
	
	var Sorted_List = Class.extend({
		'init': function(spec) {
			
			this.tree = new BTree(12);
			
			
		},
		'clear': function() {
			this.tree.clear();
		},
		'put': function(value) {
			var insert_res = this.tree.insert(key);
		},
		'out': function(value) {
			this.tree.remove(key);
		},
		'has': function(value) {
			// tree.has?
			
			
		},
		'values': function(value) {
			
		},
		'count': function() {
			
		},
		'get_cursor': function() {
			
		}
	})
	
	*/
	
	
	// Will have the ordered string list here as well
	//  Commented out for the moment
	
	/*
	 * 
	 * 
	
	var Ordered_String_List = Class.extend({
		'init' : function() {
			// console.log('init osl sig ' + sig);

			var arr = [];
			var dict_indexes = {};

			var reindex_dict_indexes = function() {
				dict_indexes = {};
				for ( var c = 0, l = arr.length; c < l; c++) {
					dict_indexes[arr[c]] = c;
				}
			}

			// (add), remove, get, get_all, has, put, move, splice
			this.has = function(value) {
				return (typeof dict_indexes[value] !== 'undefined');
			}

			this.put = function(value) {
				// by default puts it at the end.
				if (this.has(value)) {
					// stays in same place.
					// arr[dict_indexes[value]]
					// do nothing
				} else {
					var index = arr.length;
					arr.push(value);
					dict_indexes[value] = index;
				}

			}

			this.out = function(value) {
				if (this.has(value)) {
					var idx = dict_indexes[value];
					arr.splice(idx, 1);

					delete dict_indexes[value];

					for ( var c = idx, l = arr.length; c < l; c++) {
						var i = arr[c];
						dict_indexes[i]--;
					}
					// will need the items after it and lower their indexes.

				}
			}

			this.toggle = function(value) {
				if (this.has(value)) {
					this.out(value);
				} else {
					this.put(value);
				}
			}

			this.move_value = function(value, index) {
				if (this.has(value) && dict_indexes[value] != index) {

					// gets removed from current position, causes items after it
					// to move back.
					// gets put in new position, gets items after that to move
					// forwards.

					var old_index = dict_indexes[value];
					arr.splice(old_index, 1);

					arr.splice(index, 0, value);

					if (index < old_index) {
						// moving back.
						// dict_indexes[]
						dict_indexes[arr[index]] = index;
						// the index object of the one it

						// for (var c = index, l = arr.length; c < l; c++) {
						for ( var c = index + 1; c <= old_index; c++) {
							dict_indexes[arr[c]]++;
						}
					} else if (index > old_index) {
						dict_indexes[arr[index]] = index;
						for ( var c = old_index; c < index; c++) {
							dict_indexes[arr[c]]--;
						}
					}

				}

			}
			// for testing

			this._index_scan = function() {
				for ( var c = 0, l = arr.length; c < l; c++) {
					console.log('c ' + c + ' arr[c] ' + arr[c] + ' idx '
							+ dict_indexes[arr[c]]);
				};
			}

			this.toString = function() {
				var res = arr.join(' ');
				return res;
			}

			this.toString.stringify = true;

			this.set = fp(function(a, sig) {
				if (sig == '[s]') {
					arr = a[0].split(' ');
					// console.log('arr ' + jsgui.stringify(arr));
					reindex_dict_indexes();
				}
			});

			// if (sig == '[s]') {
			// this.set(a[0]);
			// }

			var a = arguments;
			if (a.length == 1) {
				var spec = a[0];
				if (tof(spec) == 'string') {
					// console.log('setting');
					this.set(spec);
				}
			}

		}
	});
	 */
	
	
    /**
    * Creates the Sorted_KVS.
    * @constructor
    * @classdesc Represents a sorted key/value pairs storage (with fast access by the key).
    * @memberof module:core/jsgui-data-structures
    */
	
	// Multiple items could be stored in one position.
	//  This may have another layer of functionality beyond the tree.
	
	var Sorted_KVS = Class.extend({
		'init': function(spec) {
			spec = spec || {};
			// both a dict and a BTree
			//  that is used in this case because the BTree only stores string keys.
			//  the improved B+ tree will have value objects/pointers within them
			
			if (is_defined(spec.unique_keys)) this.unique_keys = spec.unique_keys;
			//this.tree = new B_Plus_Tree(12); // order 12
			this.tree = B_Plus_Tree(12); // order 12
			
			
			//this.dict = {};
			// likely to make the dict refer to the tree node
			
			
		},

	    /**
        * Clears the storage, removing all the key/value pairs.
        * @memberof module:core/jsgui-data-structures.Sorted_KVS
        * @instance
        */
		'clear': function () {
			this.tree.clear();
			//this.dict = {};
		},

	    /**
        * Puts the key/value pairs from the passed object into the storage.
        * @func
        * @param {object} obj
        * @memberof module:core/jsgui-data-structures.Sorted_KVS
        * @instance
        * @example
        * var kvs = new Data_Structures.Sorted_KVS();
        * kvs.put({ a: 1});
        * kvs.put({ b: 2, c: 3});
        */
		'put': mapify(function (key, value) {
			// inserting a bunch of things at once... could that be done more efficiently, such as in one traversal?
			//  sort the items, then can skip through the tree a bit quicker?
			
			
			var insert_res = this.tree.insert(key, value);
			// with tree.insert - nice if we can keep the treenode as a result.
			//  the tree does not store objects in the node.
			//   could make the tree node hold a reference to the object?
			
			
			
			
			//console.log('put insert_res ' + insert_res);
			//this.dict[key] = value;
		}),


	    /**
        * Removes from the storage values for the passed key.
        * @func
        * @param {*} key
        * @memberof module:core/jsgui-data-structures.Sorted_KVS
        * @instance
        */
		'out': function (key) {
			//console.log('key ' + key);
			//
		
			this.tree.remove(key);
			//console.log('this.tree.keys_and_values() ' + stringify(this.tree.keys_and_values()));
			//throw '2.stop';
			//delete this.dict[key];
		},

	    /**
        * Gets from the storage values for the passed key, returns the values array.
        * @func
        * @param {*} key
        * @memberof module:core/jsgui-data-structures.Sorted_KVS
        * @instance
        */
		'get': function (key) {
			//console.log('Sorted_KVS get');
			//console.log('key ' + stringify(key));

			
			// get all nodes with that key
			
			//var tree_res = this.tree.
			//console.log('this.tree.keys() ' + stringify(this.tree.keys()));
			//throw ('stop');
			
			//return 
			// if this is treating the keys as unique it will just return 1 item or undefined / null.
			// otherwise it returns array on n items
			
			// don't want KVPs
			
			return this.tree.get_values_by_key(key);
			
			//return this.dict[key];
		},


	    /**
        * Returns true if the storage contains the passed key.
        * @func
        * @param {*} key
        * @memberof module:core/jsgui-data-structures.Sorted_KVS
        * @instance
        */
		'has': function (key) {
			//return (typeof this.dict[key] !== 'undefined');
			
			return this.key_count(key) > 0;
			
		},
		'get_cursor': function() {
			//var res = new KSVS_Cursor(this);
			//res.move_first();
			//return res;
		},


	    /**
        * Returns an array of all the keys in the storage.
        * @func
        * @memberof module:core/jsgui-data-structures.Sorted_KVS
        * @instance
        */
		'keys': function () {
			
			return this.tree.keys();
			
			//return this.tree.keys();
		},

	    /**
        * Returns an array of [key, value] arrays for all the items in the storage.
        * @func
        * @memberof module:core/jsgui-data-structures.Sorted_KVS
        * @instance
        */
		'keys_and_values': function () {
			return this.tree.keys_and_values();
		},
		
		/*
		'values': function() {
			var keys = this.keys();
			var res = [];
			var that = this;
			console.log('keys.length ' + keys.length );
			console.log('keys ' + jsgui.stringify(keys));
			
			each(keys, function(i, v) {
				res.push(that.dict[v]);
			});
			return res;
		},
		*/
		
	    /**
        * Returns an amount of all the keys in the storage.
        * @name key_count
        * @func
        * @memberof module:core/jsgui-data-structures.Sorted_KVS
        * @instance
        */

	    /**
        * Returns an amount of the passed key occurrences in the storage.
        * @func
        * @param {*} key
        * @memberof module:core/jsgui-data-structures.Sorted_KVS
        * @instance
        */
		'key_count': function (key) {
			
			if (is_defined(key)) {
				return this.tree.count(key);
			} else {
				return this.tree.count();
			}
			
			// also want to do it for a particular key
			
			
		},
		
		/*
		
		'get_keys_by_prefix': function(prefix) {
			var leaf = this.tree.searchLeaf(prefix);
			var node = leaf.node;
			var res = [];
			var index = leaf.index;
			var plen = prefix.length;
			var check_prefix = function(key) {
				if (plen > key.length) return false;
				return (key.substr(0, plen) == prefix)
			}
			var has_prefix = true;
	        while (node != null && has_prefix) {
	        	// what is the original index?
	        	var key = node.keys.items[index];
	        	console.log('key ' + key);
	        	//var value = node.values.items[index];
	        	has_prefix = check_prefix(key);
	        	if (has_prefix) {
	        		if (index >= node.keys.count) {
			        	res.push(key);
			            node = node.nextLeaf;
		        		index = 0;
		        	} else {
			        	res.push(key);
		        		index++;
		        	}
	        	}
	        }
	        return res;
		},
		
		*/
		
	    /**
        * Returns an array of the keys that start from the passed prefix.
        * @func
        * @param {string} prefix
        * @memberof module:core/jsgui-data-structures.Sorted_KVS
        * @instance
        */
		'get_keys_by_prefix': function (prefix) {
			return this.tree.get_keys_by_prefix(prefix);
		},
		
	    /**
        * Invokes the callback function for each item in the storage: `callback(key, value)`
        * @func
        * @param {function} callback
        * @memberof module:core/jsgui-data-structures.Sorted_KVS
        * @instance
        */
		'each': function (callback) {
			// iterate through every item
			//  key, value
			return this.tree.each(callback);
		},
		
	    /**
        * Returns an array of [key, value] arrays for the keys that start from the passed prefix.
        * @func
        * @param {string} prefix
        * @memberof module:core/jsgui-data-structures.Sorted_KVS
        * @instance
        */
		'get_by_prefix': function (prefix) {
			
	        return this.tree.get_by_prefix(prefix);
		}
	});



    /**
    * Creates the Ordered_KVS.
    * @constructor
    * @classdesc Represents an unsorted key/value pairs storage, but with fast access by the key. The each()-based operations 
    * (e.g. keys(), values() etc.) returns the items in the same order as they was added. But the get() and out() operations 
    * use a fast key access. Unfortunately these operation works with the last added value only if several values have equal keys.
    * @memberof module:core/jsgui-data-structures
    */

	// Double Linked List inside, as well as a simple dict with references to the nodes.
	// Use liked list nodes?
	
	// Items are identified with a key, but stored in any order.
	//  This could be useful for storing a list of fields. Allows fast retrieval by field name, also preserves the ordering.
	
	// will have functions for re-ordering as well.
	
	var Ordered_KVS = Class.extend({
		'init': function() {
			this.dll = new Doubly_Linked_List();
			this.node_map = {};
		},


	    /**
        * Returns an amount of items in the storage.
        * @func
        * @memberof module:core/jsgui-data-structures.Ordered_KVS
        * @instance
        */
		'length': function () {
			return this.dll.length;
		},


	    /**
        * Adds the key/value pair to the storage.
        * @func
        * @param {*} key
        * @param {*} value
        * @memberof module:core/jsgui-data-structures.Ordered_KVS
        * @instance
        */
		'put': function (key, value) {
			// does it already exist with that key - if so that item gets replaced, stays in the same position?
			// or maybe push - that means the item that goes in gets added to the end.
			return this.push(key, value);
		},


	    /**
        * Returns the value for the passed key, or `undefined` if the key does not exists. <br />
        * If the key was added several times, then returns the latest added value.
        * @func
        * @param {*} key
        * @memberof module:core/jsgui-data-structures.Ordered_KVS
        * @instance
        */
		'get': function (key) {
			//console.log('get key ' + key);
			var kvs_node = this.node_map[key];
			if (kvs_node) {
				return kvs_node.value;
			} else {
				return undefined;
				//throw 'Missing KVS node: ' + key;
			}
		},


	    /**
        * Adds the key/value pair to the storage.
        * @func
        * @param {*} key
        * @param {*} value
        * @memberof module:core/jsgui-data-structures.Ordered_KVS
        * @instance
        */
		'push': function (key, value) {
			// does it already have a node with that key?
			var node = this.dll.push(value);
			node.key = key;
			this.node_map[key] = node;
		},

	    /**
        * Removes the pair with the passed key from the storage. Throws an exception if the key does not exists. <br />
        * If the key was added several times, then removes the latest added pair only (and throws an exception for the next time).
        * @func
        * @param {*} key
        * @memberof module:core/jsgui-data-structures.Ordered_KVS
        * @instance
        */
		'out': function (key) {
			var node = this.node_map[key];
			//delete node.key;
			delete this.node_map[key]
			
			this.dll.remove(node);
		},

	    /**
        * Invokes the callback function for each item in the storage: `callback(key, value, stop)`
        * @func
        * @param {function} callback
        * @memberof module:core/jsgui-data-structures.Ordered_KVS
        * @instance
        */
		'each': function(callback) {
			
			// return the key as well as the value in the callback.
			this.dll.each_node(function(node, stop) {
				callback(node.key, node.value, stop);
			});
			
			
			//this.dll.each(callback);
		},

	    /**
        * Returns an array of all the values in the storage.
        * @func
        * @memberof module:core/jsgui-data-structures.Ordered_KVS
        * @instance
        */
		'values': function () {
			var res = [];
			this.each(function(key, value) {
				res.push(value);
			});
			return res;
		},

	    /**
        * Returns an array of all the keys in the storage.
        * @func
        * @memberof module:core/jsgui-data-structures.Ordered_KVS
        * @instance
        */
		'keys': function () {
			var res = [];
			this.each(function(key, value) {
				res.push(key);
			});
			return res;
		},

	    /**
        * Returns an array of [key, value] arrays for all the items in the storage.
        * @func
        * @memberof module:core/jsgui-data-structures.Ordered_KVS
        * @instance
        */
		'keys_and_values': function () {
			var res = [];
			this.each(function(key, value) {
				res.push([key, value]);
			});
			return res;
		}
		// will not need to deal with nodes on the user level.
		// want to be able to add and remove items, normally items will get pushed to the end of the list.
		
		// will provide a key and value in order to do this.
	});
	// have a KSVS cursor - this will be able to get the key and value at any position.
	//  Need to be able to move the cursor.
	
	/*
	
	var Sorted_KVS_Cursor = Class.extend({
		'init': function(ksvs) {
			this.ksvs = ksvs;
			this.b_plus_cursor = new BTreeCursor();
			this.b_plus_cursor.move_first();
		},
		'move_first': function() {
			return this.b_plus_cursor.move_first();
		},
		'move_next': function() {
			return this.b_plus_cursor.move_next();
		},
		'move_prev': function() {
			return this.b_plus_cursor.move_prev();
		},
		'kv': function() {
			var key = this.b_plus_cursor.get_value();
			var value = this.ksvs.dict[key];
			return [key, value];
		}
	});
	*/



    /**
    * Creates the Ordered_String_List.
    * @classdesc Represents an unsorted string list.
    * @constructor
    * @param {string} [values] - space-separated list of values
    * @memberof module:core/jsgui-data-structures
    * @example
    * var list1 = new Data_Structures.Ordered_String_List();
    * var list2 = new Data_Structures.Ordered_String_List("value1 value2 value3");
    */

	// This could be useful for a few things, like storing tables in a DB
	// schema.
	// Maybe quite a few more things.

	// May make some objects with friendlier interfaces...
	//  And may use collection for this to store lists of strings.
	//  Like CSS flags at the moment.

	// Uses private variables.
	var Ordered_String_List = Class.extend({
		'init' : function() {
			// console.log('init osl sig ' + sig);

			var arr = [];
			var dict_indexes = {};

			var reindex_dict_indexes = function() {
				dict_indexes = {};
				for ( var c = 0, l = arr.length; c < l; c++) {
					dict_indexes[arr[c]] = c;
				}
			}

		    /**
            * Returns `true` if the passed value exists in the list.
            * @func
            * @alias has
            * @param {string} value
            * @memberof module:core/jsgui-data-structures.Ordered_String_List
            * @instance
            */
		    // (add), remove, get, get_all, has, put, move, splice
			this.has = function(value) {
				return (typeof dict_indexes[value] !== 'undefined');
			}

		    /**
            * Adds the passed value to the end of the list. Does nothing if the value already exists in the list.
            * @func
            * @alias put
            * @param {string} value
            * @memberof module:core/jsgui-data-structures.Ordered_String_List
            * @instance
            */
			this.put = function (value) {
				// by default puts it at the end.
				if (this.has(value)) {
					// stays in same place.
					// arr[dict_indexes[value]]
					// do nothing
				} else {
					var index = arr.length;
					arr.push(value);
					dict_indexes[value] = index;
				}

			}

		    /**
            * Removes the passed value from the list. Does nothing if the value does not exists in the list.
            * @func
            * @alias out
            * @param {string} value
            * @memberof module:core/jsgui-data-structures.Ordered_String_List
            * @instance
            */
			this.out = function (value) {
				if (this.has(value)) {
					var idx = dict_indexes[value];
					arr.splice(idx, 1);

					delete dict_indexes[value];

					for ( var c = idx, l = arr.length; c < l; c++) {
						var i = arr[c];
						dict_indexes[i]--;
					}
					// will need the items after it and lower their indexes.

				}
			}

		    /**
            * Toggles the passed value presence in the list: if the value already exists then removes it, or adds the value on other case.
            * @func
            * @alias toggle
            * @param {string} value
            * @memberof module:core/jsgui-data-structures.Ordered_String_List
            * @instance
            */
			this.toggle = function (value) {
				if (this.has(value)) {
					this.out(value);
				} else {
					this.put(value);
				}
			}

		    /**
            * Toggles the passed value to the specified position in the list. Does nothing if the value does not exists in the list.
            * @func
            * @alias move_value
            * @param {string} value
            * @param {number} index - new index for the value (zero-based)
            * @memberof module:core/jsgui-data-structures.Ordered_String_List
            * @instance
            * @example
            * var list = new Data_Structures.Ordered_String_List("v0 v1 v2");
            * list.move_value("v0", 1);
            * console.log(list.toString()); // "v1 v0 v2"
            */
			this.move_value = function (value, index) {
				if (this.has(value) && dict_indexes[value] != index) {

					// gets removed from current position, causes items after it
					// to move back.
					// gets put in new position, gets items after that to move
					// forwards.

					var old_index = dict_indexes[value];
					arr.splice(old_index, 1);

					arr.splice(index, 0, value);

					if (index < old_index) {
						// moving back.
						// dict_indexes[]
						dict_indexes[arr[index]] = index;
						// the index object of the one it

						// for (var c = index, l = arr.length; c < l; c++) {
						for ( var c = index + 1; c <= old_index; c++) {
							dict_indexes[arr[c]]++;
						}
					} else if (index > old_index) {
						dict_indexes[arr[index]] = index;
						for ( var c = old_index; c < index; c++) {
							dict_indexes[arr[c]]--;
						}
					}

				}

			}
			// for testing

			this._index_scan = function() {
				for ( var c = 0, l = arr.length; c < l; c++) {
					console.log('c ' + c + ' arr[c] ' + arr[c] + ' idx '
							+ dict_indexes[arr[c]]);
				};
			}

		    /**
            * Returns the string representation of the list: all the string values separated by space.
            * @func
            * @alias toString
            * @memberof module:core/jsgui-data-structures.Ordered_String_List
            * @instance
            */
			this.toString = function () {
				var res = arr.join(' ');
				return res;
			}

			this.toString.stringify = true;

		    /**
            * Sets the values in the list.
            * @func
            * @alias set
            * @param {string} values - space-separated list of values
            * @memberof module:core/jsgui-data-structures.Ordered_String_List
            * @instance
            */
			this.set = fp(function (a, sig) {
				if (sig == '[s]') {
					arr = a[0].split(' ');
					// console.log('arr ' + jsgui.stringify(arr));
					reindex_dict_indexes();
				}
			});

			// if (sig == '[s]') {
			// this.set(a[0]);
			// }

			var a = arguments;
			if (a.length == 1) {
				var spec = a[0];
				if (tof(spec) == 'string') {
					// console.log('setting');
					this.set(spec);
				}
			}

		}
	});

	
	
	var Data_Structures = {
		'Doubly_Linked_List': Doubly_Linked_List,
		'B_Plus_Tree': B_Plus_Tree,
		'Sorted_KVS': Sorted_KVS,
		'Ordered_KVS': Ordered_KVS,
		'Ordered_String_List': Ordered_String_List
		//'Sorted_KVS_Cursor': Sorted_KVS_Cursor
	}
	

	// var jsgui = {};
	// alert('returning jsgui from jsgui-lang');
	//return jsgui;
	
	// maybe should mix the data structures into jsgui.
	//  These data structures are likely to be necessary for various things
	
	
	
	
	
	//return Data_Structures;
    module.exports = Data_Structures;
//});
},{"./jsgui-data-structures-b-plus-tree":32,"./jsgui-data-structures-doubly-linked-list":33,"./jsgui-lang-essentials":37}],36:[function(require,module,exports){
// This is resulting in smaller code in other parts of the framework.
//  This section is getting quite big (again)
//  Still need to make use of the B+ free for ordered indexing.

// Moving some code to jsgui-lang-essentials
//  Will be publishing a 0.4 version of that before so long?
//   Maybe with more explanation?

// It may be worth publishing this, and a discussion forum about it on my own web forum.
//  Perhaps that could come later, but jsgui-lang-essentials may be a good step. Could call it version 0.35.
//   Could have a few examples
//   Would be a useful toolkit I could use while working elsewhere.

//  I think that web site would be lightening fast, and impress people with its speed compared to other web platforms that they are used to
//   (though Facebook is OK)

// This is going to be using data_types as well.
// Will also have a system of requirements.
//  That could mean they need to be both the right data type, as well as having some other specified properties.

/*
if (typeof define !== 'function') {
    var define = require('amdefine')(module);
}

define(["./jsgui-lang-util", "./enhanced-data-object"], function(jsgui, Enhanced_Data_Object) {

    */
var jsgui = require('./jsgui-lang-util');
var Enhanced_Data_Object = require('./enhanced-data-object');
	
	// Will use data structures.
	//  Not sure about using all of them here.
	
	// A mix-in system of enhancing the data structures may work best.
	//  It does not start with B+ tree, but that gets brought in?
	
	// However, having B+ as part of it could work quite nicely.
	var tof = jsgui.tof;
	var Collection = jsgui.Collection;
	var Data_Value = jsgui.Data_Value;

	jsgui.Enhanced_Data_Object = Enhanced_Data_Object;

	// Not sure about this for the moment.
	//  Quite a lot is going in lang-util.
	//jsgui.map_data_type_data_object_constructors = Enhanced_Data_Object.map_data_type_data_object_constructors;

	jsgui.Mini_Context = Enhanced_Data_Object.Mini_Context;

	// Maybe can give a context as well?

	var fromObject = function(value) {
		var tValue = tof(value);
		if (tValue == 'array') {
			var collRes = new Collection();

			for (var c = 0, l = value.length; c < l; c++) {
				collRes.push(fromObject(value[c]));
			}
			return collRes;

		}
		if (tValue == 'object') {
			var edoRes = new Enhanced_Data_Object();
			for (i in value) {
				edoRes.set(i, fromObject(value[i]));
			}
			return edoRes;
		}
		if (tValue == 'string') {
			var dvRes = new Data_Value({'value': value});
			return dvRes;
		}
		if (tValue == 'number') {
			var dvRes = new Data_Value({'value': value});
			return dvRes;
		}

	}

	jsgui.fromObject = fromObject;
	
    //Enhanced_Data_Object.prototype._get_input_processors = function() {
    //	return jsgui.input_processors;
    //}
    module.exports = jsgui;
	//return jsgui;

//});
},{"./enhanced-data-object":30,"./jsgui-lang-util":38}],37:[function(require,module,exports){
(function (Buffer){


   /**
    * lang essentials module.
    * @module core/jsgui-lang-essentials
    * @version 0.4.4
    */

/* Changelog:

	0.4.4
	-----
	Removed excess comments, inlcuding unused commented-out code

	0.4.3
	-----
	Added comment about changing arr_like_to_arr

	0.4.2
	-----

	Performance improvements, based on profiling
	isArray uses Array.isArray if available


*/

/*
if (typeof define !== 'function') {
    var define = require('amdefine')(module);
}
*/

if (typeof window === 'undefined') {
    //exports.foo = {};
    var Stream = require('stream');
} else {
    //window.foo = {};
}


// needs to use node.js's stream for the moment.
// Will make a new jsgui-node-lang-essentials version because it's got node-specific & dependant code now.

//define(['Stream'],
//function (Stream) {


//define(function() {

    // ========================================================
    //                      Class
    // ========================================================

    // seems based on http://ejohn.org/blog/simple-javascript-inheritance/

    /**
    * Base class like John Resig's "Simple JavaScript Inheritance" tehnique.
    *
    * In addition, when the inherited class contains a property that name starts from '#',
    * then the property adds to the class without '#', and the property value is the base class property value,
    * but the base class property name used is the rest of the initial property name (after the '#').
    * @see [John Resig's "Simple JavaScript Inheritance"]{@link http://ejohn.org/blog/simple-javascript-inheritance/}
    * @name Class
    * @member
    * @memberof module:core/jsgui-lang-essentials
    */


	var initializing = false, fnTest = /xyz/.test(function() { xyz; }) ? /\b_super\b/ : /.*/;
	var Class = function() {
	};

	// not so sure of the utility of namespcExtension, propsToMerge
	Class.extend = function(prop) {
		var _super = this.prototype;
		initializing = true;
		var prototype = new this();
		initializing = false;
		for (var name in prop) {
			if (name.charAt(0) === '#') {
				prototype[name.substring(1)] = prototype[prop[name]];
			} else {
				prototype[name] = typeof prop[name] === 'function'
						&& typeof _super[name] === 'function'
						&& fnTest.test(prop[name]) ?
				// had some difficulty using fp() with 'init' functions. could
				// it have to do with function names?

				(function(name, fn) {
					return function() {
						var tmp = this._super;
						this._super = _super[name];
						var res = fn.apply(this, arguments);
						this._super = tmp;
						return res;
					};
				})(name, prop[name]) : prop[name];
			};
		};
		function Class() {
			//console.log('initializing ' + initializing);
			//console.log('!!this.init ' + !!this.init);
			if (!initializing && this.init) {
				this.init.apply(this, arguments);
				//if (this.post_init) {
				//	this.post_init();
				//}
			}
		};
		Class.prototype = prototype;
		Class.prototype.constructor = Class;
		//Class.constructor = Class;
		Class.extend = arguments.callee;
		//Class._superclass = _super;

		Class._superclass = this;

		return Class;
	};


    // ========================================================
    //                      functions
    // ========================================================



    /**
    * Break iteration callback function.
    * @example
    * jsgui.each([1, 2, 3, 4, 5], function(index, element, stop){
    *    if (element > 3) stop();
    * });
    *
    * jsgui.eac([1, 2, 3, 4, 5], function(element, index, stop){
    *    if (element > 3) stop();
    * });
    *
    * @callback module:core/jsgui-lang-essentials.stopIterationCallback
    */

    /**
    * Array iterator callback function.
    *
    * @callback module:core/jsgui-lang-essentials.arrayIteratorCallback
    * @param {number} index
    * @param {*} element
    * @param {module:core/jsgui-lang-essentials.stopIterationCallback} stop
    */

    /**
    * Object iterator callback function.
    *
    * @callback module:core/jsgui-lang-essentials.objectIteratorCallback
    * @param {string} key
    * @param {*} value
    * @param {module:core/jsgui-lang-essentials.stopIterationCallback} stop
    */


    /**
    * Iterates over a collection calling the collection.each(fn, context) method.
    *
    * @name each
    * @func
    * @param {Collection} collection - collection of elements
    * @param {function} fn - iterator function
    * @param {Object} [context] - context object
    * @memberof module:core/jsgui-lang-essentials
    * @example
    *
    * // TODO..............
    *
    */


    /**
    * Iterates over the array elements. The iterator function calls for each element: fn(index, element, stop):
    * - index: the element index
    * - element: the element value
    * - stop: call this function to prevent further iterations
    *
    * The iterator function is bound to the context object, if passed.
    *
    * @name each
    * @func
    * @param {Array} arr - array of elements
    * @param {module:core/jsgui-lang-essentials.arrayIteratorCallback} fn - iterator function
    * @param {Object} [context] - context object
    * @memberof module:core/jsgui-lang-essentials
    * @example
    *
    * jsgui.each([1, 2, 3, 4, 5], function(index, element, stop){
    *    console.log(index + ":" + element);  // 0:1 1:2 2:3 3:4 4:5
    *    if (index > 1000) stop();
    * });
    *
    */


    /**
    * Iterates over the object properties. The iterator function calls for each element: fn(key, value, stop):
    * - key: the property key
    * - value: the property value
    * - stop: call this function to prevent further iterations
    *
    * The iterator function is bound to the context object, if passed.
    *
    * @name each
    * @func
    * @param {Object} obj - object
    * @param {module:core/jsgui-lang-essentials.objectIteratorCallback} fn - iterator function
    * @param {Object} [context] - context object
    * @memberof module:core/jsgui-lang-essentials
    * @example
    *
    * jsgui.each({a: 1, b: 2}, function(key, value, stop){
    *    if (key == "secretKey"){
    *      stop();
    *      return;
    *    }
    *    console.log(key + ":" + value);  // a:1  b:2
    * });
    *
    */
	// new addition with the loop being stoppable using a function call. 18/06/2012
	var each = function(collection, fn, context) {
		// each that puts the results in an array or dict.
		if (collection) {

			if (collection.__type == 'collection') {
				return collection.each(fn, context);
			}

			// could have a break function that stops the loop from continuing.
			//  that would be useful as a third parameter that can get called.
			//  stop() function
			var ctu = true;
			var stop = function() {
				ctu = false;
			}

			if (is_array(collection)) {
			    var res = [], res_item;
				for (var c = 0, l = collection.length; c < l; c++) {
					res_item;
					if (ctu == false) break;

					if (context) {
						res_item = fn.call(context, c, collection[c], stop);

					} else {
						res_item = fn(c, collection[c], stop);
					}
					res.push(res_item);
				}
				return res;
			} else {
				var name, res = {};
				for (name in collection) {
					if (ctu == false) break;
					if (context) {
					    res[name] = fn.call(context, name, collection[name], stop);
					} else {
						res[name] = fn(name, collection[name], stop);
					}
				}
				return res;
			}
		}

	};

    /**
    * Array iterator callback function.
    *
    * @callback module:core/jsgui-lang-essentials.arrayIteratorCallback-eac
    * @param {number} index
    * @param {*} element
    * @param {module:core/jsgui-lang-essentials.stopIterationCallback} stop
    */

    /**
    * Object iterator callback function.
    *
    * @callback module:core/jsgui-lang-essentials.objectIteratorCallback-eac
    * @param {string} key
    * @param {*} value
    * @param {module:core/jsgui-lang-essentials.stopIterationCallback} stop
    */

    /**
    * Iterates over a collection calling the collection.each(fn, context) method.
    *
    * <mark>maybe collection.each() must be changed to collection.eac()?</mark>
    *
    * @name eac
    * @func
    * @param {Collection} collection - collection of elements
    * @param {function} fn - iterator function
    * @param {Object} [context] - context object
    * @memberof module:core/jsgui-lang-essentials
    * @example
    *
    * // TODO.......
    *
    */

    /**
    * Iterates over an array, just like the [each()]{@link module:core/jsgui-lang-essentials.each} function, but the iterator function parameters order is changed:<br>
    * `fn(element, index, stop)` instead of `fn(index, element, stop)`
    *
    * Better each function, first param of callback is obj, 2nd is index. Will replace all each functions with this version then change the name to each.
	*  Useful for new code.
    *
    * @name eac
    * @func
    * @param {Array} arr - array of elements
    * @param {module:core/jsgui-lang-essentials.arrayIteratorCallback-eac} fn - iterator function
    * @param {Object} [context] - context object
    * @memberof module:core/jsgui-lang-essentials
    * @example
    *
    * jsgui.each([1, 2, 3, 4, 5], function(element, index, stop){
    *    console.log(index + ":" + element);  // 0:1 1:2 2:3 3:4 4:5
    *    if (index > 1000) stop();
    * });
    *
    */

    /**
    * Iterates over the object properties, just like the [each()]{@link module:core/jsgui-lang-essentials.each} function, but the iterator function parameters order is changed:<br />
    * `fn(value, key, stop)` instead of `fn(key, value, stop)`
    *
    * Better each function, first param of callback is obj, 2nd is index. Will replace all each functions with this version then change the name to each.
	*  Useful for new code.
    *
    * @name eac
    * @func
    * @param {Object} obj - object
    * @param {module:core/jsgui-lang-essentials.objectIteratorCallback-eac} fn - iterator function
    * @param {Object} [context] - context object
    * @memberof module:core/jsgui-lang-essentials
    * @example
    *
    * jsgui.eac({a: 1, b: 2}, function(value, key, stop){
    *    if (key == "secretKey"){
    *      stop();
    *      return;
    *    }
    *    console.log(key + ":" + value);  // a:1  b:2
    * });
    *
    */
	var eac = function (collection, fn, context) {
		// each that puts the results in an array or dict.
		if (collection) {

			if (collection.__type == 'collection') {
				return collection.eac(fn, context);
			}

			// could have a break function that stops the loop from continuing.
			//  that would be useful as a third parameter that can get called.
			//  stop() function
			var ctu = true;
			var stop = function() {
				ctu = false;
			}

			if (is_array(collection)) {
				var res = [], res_item;
				for (var c = 0, l = collection.length; c < l; c++) {
					res_item;
					if (ctu == false) break;

					if (context) {
						res_item = fn.call(context, collection[c], c, stop);

					} else {
						res_item = fn(collection[c], c, stop);
					}
					res.push(res_item);
				}
				return res;
			} else {
				var name, res = {};
				for (name in collection) {
					if (ctu == false) break;
					if (context) {
						res[name] = fn.call(context, collection[name], name, stop);
					} else {
						res[name] = fn(collection[name], name, stop);
					}
				}
				return res;
			}
		}
	};



	var jq_class2type = {};
	var jq_type = function (obj) {
	    //return obj == null ? String(obj) : jq_class2type[toString.call(obj)] || "object";
	    if (obj == null) return String(obj);
	    var s = Object.prototype.toString.call(obj);
	    return jq_class2type[s] || "object";
	};



    /**
    * Returns `true` if the passed `obj` is an `Array`. Delegates to the native `Array.isArray()` function if it exists.
    * @func
    * @param {Object} obj - object to check
    * @memberof module:core/jsgui-lang-essentials
    */
	var is_array = Array.isArray || function (obj) {
	        return jq_type(obj) === "array";
	};

    /**
    * Returns `true` if the passed `obj` is a DOM node. Uses the duck typing.
    * @func
    * @param {Object} obj - object to check
    * @memberof module:core/jsgui-lang-essentials
    */
    var is_dom_node = function isDomNode(obj) {
		return (!!obj && typeof obj.nodeType != 'undefined' && typeof obj.childNodes != 'undefined');
	};


    jq_class2type["[object Boolean]"] = "boolean";
    jq_class2type["[object Number]"] = "number";
    jq_class2type["[object String]"] = "string";
    jq_class2type["[object Function]"] = "function";
    jq_class2type["[object Array]"] = "array";
    jq_class2type["[object Date]"] = "date";
    jq_class2type["[object RegExp]"] = "regexp";
    jq_class2type["[object Object]"] = "object";

    /* each() calls isArray(), isArray() calls jq_type(), jq_type() uses jq_class2type[] in turn
    each("Boolean Number String Function Array Date RegExp Object".split(" "),
		function(i, name) {
			if (typeof(name) == 'string') {
		        jq_class2type["[object " + name + "]"] = name.toLowerCase();
		    }
		});*/

	/*
	 * var jq_type = function( obj ) { return obj == null ? String(obj):
	 * jq_class2type[toString.call(obj)] || "object"; };
	 */

	var jq_isFunction = function(obj) {
		return jq_type(obj) === "function";
	};

	var jq_isWindow = function(obj) {
		return obj && typeof obj === "object" && "setInterval" in obj;
	};

	var hasOwn = Object.prototype.hasOwnProperty;

	var jq_isPlainObject = function(obj) {
		// Must be an Object.
		// Because of IE, we also have to check the presence of the constructor
		// property.
		// Make sure that DOM nodes and window objects don't pass through, as
		// well
		if (!obj || jq_type(obj) !== "object" || obj.nodeType
				|| jq_isWindow(obj)) {
			return false;
		}

		// Not own constructor property must be Object
		if (obj.constructor && !hasOwn.call(obj, "constructor")
				&& !hasOwn.call(obj.constructor.prototype, "isPrototypeOf")) {
			return false;
		}
		// Own properties are enumerated firstly, so to speed up,
		// if last one is own, then all properties are own.

		var key;
		for (key in obj) {
		}

		return key === undefined || hasOwn.call(obj, key);
	};

	// jQuery Extend

    /**
    * Merge the contents of two or more objects together into the first object. Returns the updated object.
    * If only one parameter is passed, the extends `this`.
    * @func
    * @param {boolean} [deep] - if true, performs recursive deep copy. if false or omitted, performs simple reference copy.
    * @param {(object|array)} [target] - target object; if omitted then `this` is used.
    * @param {...(object|array)} extender - object(s) to add the content
    * @memberof module:core/jsgui-lang-essentials
    * @example
    *   jq_extend({a:1}, {b:2})  ==> {a:1, b:2}
    *   jq_extend([1,2,3], [4,5])  ==> [4,5,3]
    *
    *   var ext = {sub2:{prop2:2}};
    *   var result1 = jq_extend(true, {}, ext)  ==> {sub2:{prop2:2}}
    *   var result2 = jq_extend(false, {}, ext)  ==> {sub2:{prop2:2}}
    *   ext.sub2.prop2 = 20;  ==> (result1.sub2.prop2 == 2) & (result2.sub2.prop2 == 20)
    */
	var jq_extend = function() {
		var options, name, src, copy, copyis_array, clone, target = arguments[0]
				|| {}, i = 1, length = arguments.length, deep = false;

		// Handle a deep copy situation
		if (typeof target === "boolean") {
			deep = target;
			target = arguments[1] || {};
			// skip the boolean and the target
			i = 2;
		}
		// Handle case when target is a string or something (possible in deep
		// copy)
		if (typeof target !== "object" && !jq_isFunction(target)) {
			target = {};
		}

		// (extend (jQuery) itself if only one argument is passed) no longer in
		// jQuery
		if (length === i) {
			target = this;
			--i;
		}

		for (; i < length; i++) {
			// Only deal with non-null/undefined values
			if ((options = arguments[i]) != null) {
				// Extend the base object

				// nope... need to go through all items in the array if its an
				// array, copying undefined as needed.

				if (is_array(options)) {

					// could maybe use each here anyway.
					// but a direct function may be faster.

					for ( var name = 0, l = options.length; name < l; name++) {
						src = target[name];
						copy = options[name];

						// Prevent never-ending loop
						if (target === copy) {
							continue;
						}

						// Recurse if we're merging plain objects or arrays
						if (deep
								&& copy
								&& (jq_isPlainObject(copy) || (copyis_array = is_array(copy)))) {
							if (copyis_array) {
								copyis_array = false;
								clone = src && is_array(src) ? src : [];
							} else {
								clone = src && jq_isPlainObject(src) ? src : {};
							}
							// Never move original objects, clone them
							target[name] = jq_extend(deep, clone, copy);
							// Don't bring in undefined values???
						} // else if ( copy !== undefined ) {
						else {
							target[name] = copy;
						}
					}

				} else {
					for (name in options) {

						// console.log('name ' + name);

						src = target[name];
						copy = options[name];

						// Prevent never-ending loop
						if (target === copy) {
							continue;
						}

						// Recurse if we're merging plain objects or arrays
						if (deep
								&& copy
								&& (jq_isPlainObject(copy) || (copyis_array = is_array(copy)))) {
							if (copyis_array) {
								copyis_array = false;
								clone = src && is_array(src) ? src : [];
							} else {
								clone = src && jq_isPlainObject(src) ? src : {};
							}
							// Never move original objects, clone them
							target[name] = jq_extend(deep, clone, copy);
							// Don't bring in undefined values
						} else if (copy !== undefined) {
							target[name] = copy;
						}
					}
				}

			}
			// console.log('arguments[i] ' + stringify(arguments[i]));
			// console.log('options ' + stringify(options));
		}
		// Return the modified object
		// console.log('target ' + stringify(target));
		return target;
	};

    /**
    * Alias to the [jq_extend()]{@link module:core/jsgui-lang-essentials.jq_extend} function.
    * @func
    * @memberof module:core/jsgui-lang-essentials
    */
    var extend = jq_extend;

	/*
	var x_clones = function(obj, x) {

	};
	*/

    /**
    * Returns a truth map created from the given array.
    *
    * The truth map is an object containing key/value pairs; the keys are the array elements, the values are all true.
    * @example get_truth_map_from_arr(["a", "b", "c"]) ==> { a: true, b: true, c: true}
    * @func
    * @param {Array} arr - source array
    * @memberof module:core/jsgui-lang-essentials
    */
	var get_truth_map_from_arr = function(arr) {
		var res = {};
		each(arr, function(i, v) {
			res[v] = true;
		});
		return res;
	};

    /**
    * Returns a map created from the given array.
    *
    * The map is an object containing key/value pairs; the keys are the array elements, the values are the array indexes.
    * @example get_map_from_arr(["a", "b", "c"]) ==> { a: 0, b: 1, c: 2}
    * @func
    * @param {Array} arr - source array
    * @memberof module:core/jsgui-lang-essentials
    */
	// not a truth map because 0 == false. Could use this but do different
	// check, like is_defined.
	var get_map_from_arr = function(arr) {
		var res = {};
		for (var c = 0, l = arr.length; c < l; c++) {
			res[arr[c]] = c;
		}
		//each(arr, function(i, v) {
		//	res[v] = i;
		//});
		return res;
	}

	//var arrSliceCall = Array.prototype.slice.call;

    /**
    * Returns an array created from the given "array-like" object (e.g. `arguments`).
    * @func
    * @param {Object|Array} arr_like - the array-like object
    * @example
    * function example(){
    *    var arguments_array = arr_like_to_arr(arguments);
    *    console.log(arguments_array);
    * }
    * @memberof module:core/jsgui-lang-essentials
    */
	var arr_like_to_arr = function(arr_like) {
		// like an arguments list
		// is this working in Safari?

		//var res = [];
		//return arrSliceCall(arr_like, 0);


		//return Array.prototype.slice(arr_like);
		// May have better way of doing this.



		var res = new Array(arr_like.length);


		// This was not working in Safari! Worked in Chrome. Probably
		// (mis?)recognised it as an object.
		// each(arr_like, function(i, v) {
		// res.push(v);
		// });

		for (var c = 0, l = arr_like.length; c < l; c++) {
			//res.push(arr_like[c]);
			res[c] = arr_like[c];
		};
		return res;
	};



	// Could do better... could check actual instanceof
	//  But a more advanced jsgui level could do this check, and have its own tof function.
	//  That would be jsgui-lang-html has the check for is control.

    /**
    * <mark>description...</mark>
    * @func
    * @memberof module:core/jsgui-lang-essentials
    */
	var is_ctrl = function(obj) {
		return (typeof obj != 'undefined' && obj != null && is_defined(obj._) && is_defined(obj.__type_name));
	};


    // Also a bit of node.js specific code.
    //  May make node version of jsgui-lang-essentials, jsgui-node-lang-essentials.

    /**
    * Returns the type of the given object as a string. If the t1 parameter is passed, then returns t1 for all the t1 values excepting 'object' one.
    * Possible results are:
    * - "number"
    * - "string"
    * - "function"
    * - "boolean"
    * - "object"
    * - "undefined"
    * - "null"
    * - <mark>obj.__type</mark>
    * - "date"
    * - "array"
    * - "control"
    * - "regex" (obj instanceof RegExp)
    * - "buffer" (obj instanceof Buffer)
    * - "readable_stream" (obj instanceof Stream.Readable)
    * - "writable_stream" (obj instanceof Stream.Writable)
    * @func
    * @param {*} obj - object to inspect type
    * @param {string} [t1] - type to return (?)
    * @memberof module:core/jsgui-lang-essentials
    * @example
    * tof(1) ==> "number"
    * tof([]) ==> "array"
    * tof(1, "myType") ==> "myType"
    * tof(1, "object") ==> "object"
    * tof([], "object") ==> "array"
    */
	// may change to the jq_type code.
	var tof = function(obj, t1) {
		var res = t1 || typeof obj;

		if (res === 'number' || res === 'string' || res === 'function' || res === 'boolean') {
		    return res;
		}


		if (res === 'object') {

			if (typeof obj !== 'undefined') {

				if (obj === null) {
					return 'null';
				}



				//console.log('typeof obj ' + typeof obj);
				//console.log('obj === null ' + (obj === null));

				if (obj.__type) {
					return obj.__type;
				} else {

          if (is_ctrl(obj)) {
              //return res;
              return 'control';
          }

					// Inline array test, earlier on?

					if (obj instanceof Date) {
						return 'date';
					}


					if (is_array(obj)) {
				        //res = 'array';
				        //return res;
				        return 'array';
				    } else {

				        if (obj instanceof RegExp) res = 'regex';

				        // For running inside Node.
				        //console.log('twin ' + typeof window);
				        if (typeof window === 'undefined') {
				        	//console.log('obj.length ' + obj.length);
				        	if (obj instanceof Buffer) res = 'buffer';

							if (obj instanceof Stream.Readable) res = 'readable_stream';
							if (obj instanceof Stream.Writable) res = 'writable_stream';
				        }


				    }
				    //console.log('res ' + res);
					return res;

				}
			} else {
				return 'undefined';
			}

		}

		return res;
	};

	// Bug for a test case - checking if a function is an instanceOf stream.

    /**
    * Returns an array containing type strings for the passed array elements. The type strings are made using the [tof()]{@link module:core/jsgui-lang-essentials.tof} function.
    * @func
    * @param {Array} arr - source array
    * @memberof module:core/jsgui-lang-essentials
    * @example
    * atof([1, "", null]) ==> ["number", "string", "null"]
    */
	var atof = function(arr) {

		var res = new Array(arr.length);
		//each(arr, function(i, v) {
		//	res.push(tof(v));
		//});
		for (var c = 0, l = arr.length; c < l; c++) {
			//res.push(tof(arr[c]));
			res[c] = tof(arr[c]);
		}

		return res;
	};

    /**
    * Returns true if the value is defined (e.g. not equals to undefined)
    * @func
    * @param {*} value - value to check
    * @memberof module:core/jsgui-lang-essentials
    * @example
    * is_defined(Math.PI) ==> true
    * is_defined(Math.PI_PI_PI) ==> false
    */
	var is_defined = function(value) {
		// tof or typeof

		return typeof (value) != 'undefined';
	}, isdef = is_defined;

	var is_data_object = function(obj) {

		if(obj) {
			if (obj.__type == 'data_object') return true;
			if (obj.__type == 'collection') return true;
		}

		//this.__type = 'collection'

		return false;

	}

	// will test for control using similar means as well.

	var is_collection = function(obj) {
		//if (obj.__type == 'data_object') return true;

		if (obj) {
			if (obj.__type == 'collection') return true;
		}


		//this.__type = 'collection'

		return false;

	}

    /**
    * Outputting a string in a convenient format - currently JSON.
    * @func
    * @param {*} obj - value to convert
    * @param {bool} [includeFunctions] - if true, then include functions to the result
    * @param {array(string)} [excludingProps] - exclude the listed object properties from the result
    * @memberof module:core/jsgui-lang-essentials
    * @example
    * stringify(1) ==> '1'
    * stringify("1") ==> '"1"'
    * stringify([1, "a", null]) ==> '[1, "a", null]'
    * stringify({p1:1, p2:"a", p3:null}) ==> '{"p1": 1, "p2": "a", "p3": null}'
    */
	var stringify = function(obj, includeFunctions, excludingProps) {

		var _stringify = function(obj, includeFunctions, callerObjItem) {

			//_stringify(a, b, { prev: callerObjItem, obj: obj });

			var isCircularReference = function(obj, callerObjItem){
				while(callerObjItem){
					if (callerObjItem.obj === obj) return true;
					callerObjItem = callerObjItem.prev;
				}
				return false;
			};

			if (isCircularReference(obj, callerObjItem)) return "(CircularRef)";

			// Likely optimization: use array to build the string, then join it for
			// the result.
			// Now updated.
			// Could probably use polymorphism here and save space

			// Designed for stringifying specs including functions in mind.

			// Could use tof as well... I think that would make a lot of sense.

			var t = typeof obj, res = [];

			// to stringify a collection?

			if (obj === String) {
				return 'JS_String';
			}

			if (t == 'object') {
				// will be testing it to see if it is a Data_Object
				//  and then if it is a Collection


				if (obj && is_defined(obj.stringify)) {
					return obj.stringify();
				} else {

					var ia = is_array(obj);
					if (ia) {
						// res = res + '[';
						res.push('[');
						var first = true;
						for ( var c = 0; c < obj.length; c++) {
							// if (!first) res = res + ', ';
							if (!first)
								res.push(', ');
							// res = res + stringify(obj[c]);
							//res.push(_stringify(obj[c], undefined, { prev: callerObjItem, obj: obj }));
							res.push(_stringify(obj[c], includeFunctions, { prev: callerObjItem, obj: obj }));
							first = false;
						}
						;
						// res = res + ']';
						res.push(']');
					} else if (obj == null) {
						res = [ 'null' ];
						// don't do this is_control test.
					//} else if (is_ctrl(obj)) {
						// res = res + '{"ctrl": "' + obj.id() + '"}';
					//	res.push('{"ctrl": "' + obj.id() + '"}');
					} else {
						// console.log('obj ' + obj);

						// a way of checking for a non-native toString?
						if (is_defined(obj.toString) && obj.toString.stringify === true) {
							res.push('"' + obj.toString() + '"');
						} else {
						    var propIsPrintable = function (name, value) {
						        if (!includeFunctions && tof(value) === 'function') return false;
						        //
						        if (excludingProps) {
						            for (var i = 0; i < excludingProps.length; i++) {
						                if (name == excludingProps[i]) return false;
						            }
						        }
						        //
						        return true;
						    };
                            //
							var first = true;
							// res = res + '{';
							res.push('{');
							each(obj, function(i, v) {
								//console.log(tof(v));
								//
								//var propIsPrintable = true;
								//if (propIsPrintable && !includeFunctions && tof(v) === 'function') propIsPrintable = false;
								//if (propIsPrintable && excludingProps && excludingProps.indexOf(i)>=0) propIsPrintable = false;
								//
								/*if (includeFunctions !== false
										&& tof(v) !== 'function') {
									// if (!first) res = res + ', ';
									if (!first)
										res.push(', ');
									// res = res + '"' + i + '": ' +
									// stringify(v);
									res.push('"' + i + '": ' + _stringify(v, undefined, { prev: callerObjItem, obj: obj }));
									first = false;
								}*/
								//
							    if (propIsPrintable(i, v)) {
							        if (!first) res.push(', ');
							        //res.push('"' + i + '": ' + _stringify(v, undefined, { prev: callerObjItem, obj: obj }));
							        res.push('"' + i + '": ' + _stringify(v, includeFunctions, { prev: callerObjItem, obj: obj }));
							        first = false;
							    }
							});
							// res = res + '}';
							res.push('}');
						}
					};

				}

			} else if (t == 'string') {
				// Escape characters in JSON string?
				// res = '"' + obj + '"';
				res.push('"' + obj + '"');
			} else if (t == 'undefined') {
				res = [ 'undefined' ];
			} else if (t == 'function') {
				//if (includeFunctions !== false) {
				if (!!includeFunctions) {
					res = [obj.toString()];
				}
			} else {
				res = [obj.toString()];
			}
			return res.join('');
		}; // var _stringify =

		return _stringify(obj, includeFunctions);
	};



    /**
    * Returns a type signature for the given value.
    * Possible results are:
    * - "s" (string)
    * - "n" (number)
    * - "b" (boolean)
    * - "f" (function)
    * - "a" (array)
    * - "o" (object)
    * - "u" (undefined)
    * - "!" (null)
    * - "c" (control)
    * - "r" (RegEx)
    * - "B" (Buffer)
    * - "R" (readable_stream)
    * - "W" (writable_stream)
    * - "X" (collection_index)
    * - "D" (data_object)
    * - "~D" (abstract data_object)
    * - "V" (data_value)
    * - "~V" (abstract data_value)
    * - "C" (collection)
    * - "~C" (abstract collection)
    * @func
    * @param {*} i - value to get the type signature
    * @param {*} [arr_depth] - array nesting depth to include the array element signatures
    * @memberof module:core/jsgui-lang-essentials
    * @example
    * get_item_sig(1) ==> 'n'
    * get_item_sig("1") ==> 's'
    * get_item_sig([1, 2]) ==> 'a'
    * get_item_sig([1, 2], 1) ==> '[n,n]'
    */

  var get_a_sig = function(a) {
    // For arguments
    // String building optimized for newer JS?

    var c = 0, l = a.length;
    var res = '[';
    var first = true;
    for (c = 0; c < l; c++) {
      if (!first) {
        res = res + ',';
      } else {
        first = false;
      }
      res = res + get_item_sig(a[c]);
    }

    res = res + ']';
    return res;

  }


	var get_item_sig = function(i, arr_depth) {

	    // an option about how far into the array to look.



		// also want to be able to do polymorphic rearrangements.
		// these will need to be specified so they get rearranged as required.
		// will check for some signatures and rearrange the arguments, and
		// return that array. Will be useful all over the place in the library.

		// v2 = [i, i], v3 = [i, i, i]
		// or even i2 = [i, i]? maybe not for the moment, plenty of
		// simplification already, could maybe express things like that at some
		// stage.

		// rearrangement - '[i, i], s' <- 's, [i, i]'
		// if second arrangement, output the items in the order given.
		// that seems to require parsing these signature strings.

		// returns the polymorphic signature.
		// same for each item in the array.

		// will get the poly signature for each item in the array?
		// is it an array?


		var res;
		var t1 = typeof i;

		// could possibly have two functions - one that will be very fast, and a more dynamic, slower one.



		if (t1 === 'string') {
			res = 's';
		} else if (t1 === 'number') {
			res = 'n';
		} else if (t1 === 'boolean') {
			res = 'b';
		} else if (t1 === 'function') {
			res = 'f';
		} else {
			var t = tof(i, t1);

			//if (i === 0) {
				//console.log('i ' + i);
				//console.log('t ' + t);
			//}

      // But with array-like?



			//console.log('i ' + i);
			//console.log('t ' + t);

			// likely to use a map for this logic instead.
			// console.log('t ' + t);
			if (t === 'array') {

			    // look into it with one nested level...
			    if (arr_depth) {
			        res = '['
	                for (var c = 0, l = i.length; c < l; c++) {
	                    if (c > 0) res = res + ',';
	                    res = res + get_item_sig(i[c], arr_depth - 1);
	                }
	                res = res + ']';
			    } else {
			        res = 'a';
			    }
			    //console.log('res* ' + res);

				// return res;
			//} else if (t == 'string') {
				// is it a string that parses to an integer?
				// parses to a decimal number
				// parses to an rgb value
				// parses to hex value
				// various string regexs used (optionally), can say what we are
				// looking for (for various parameters).
				// may want a quick basic poly.

			//	res = 's';
			//} else if (t == 'boolean') {
			//	res = 'b';
			//} else if (t == 'function') {
			//	res = 'f';
    } else if (t === 'control') {
				res = 'c';
			} else if (t === 'date') {
				res = 'd';
			} else if (t === 'regex') {
				res = 'r';
			} else if (t === 'buffer') { // may remove for non node.js.
				res = 'B';
			//} else if (t == 'stream') { // may remove for non node.js.
			//	res = 'S';

			// Will also incorporate dubplex and transformation streams.

    } else if (t === 'readable_stream') { // may remove for non node.js.
				res = 'R';
			} else if (t === 'writable_stream') { // may remove for non node.js.
				res = 'W';
			//} else if (t == 'number') {
				// is it an integer?
				// is it a decimal?

				// are we checking for those anyway? maybe not by default.

			//	res = 'n';
    } else if (t === 'object') {

				// not sure about showing all the details of the object.

				res = 'o';
			} else if (t === 'undefined') {
				res = 'u';
			} else {

				if (t == 'collection_index') {
					return 'X';
				} else if (t === 'data_object') {
					if (i._abstract) {
						res = '~D';
					} else {
						res = 'D';
					}


				} else {
					if (t === 'data_value') {
						if (i._abstract) {
							res = '~V';
						} else {
							res = 'V';
						}


					} else if (t === 'null') {
						res = '!';
					} else if (t === 'collection') {
						if (i._abstract) {
							res = '~C';
						} else {
							res = 'C';
						}

					} else {


						//console.log('t ' + t);
						throw 'Unexpected object type ' + t;
					}
				}

				// May have decimal type as well?

				// d for the moment?
				//  May want decimal numbers too?
				//  D is better for Data_Object.

				// c for Control
				// C for Collection

				// Could say Data_Object is D
				// Collection is C?

			}
		}
		return res;

	};


    /**
    * Removes the leading and trailing square brackets from the signature, if the brackets are presented.
    * @func
    * @param {string} sig - the signature
    * @memberof module:core/jsgui-lang-essentials
    * @example
    * trim_sig_brackets("[n]") ==> "n"
    * trim_sig_brackets("n") ==> "n"
    */
	var trim_sig_brackets = function(sig) {
	    if (tof(sig) === 'string') {
	        if (sig.charAt(0) == '[' && sig.charAt(sig.length - 1) == ']') {
				return sig.substring(1, sig.length - 1);
			} else {
				return sig;
			}
		}
	};

    /**
    * Returns an array without the trailing undefined values, made from the array-like source.
    * @func
    * @param {array-like} arr_like - the source
    * @memberof module:core/jsgui-lang-essentials
    * @example
    * arr_trim_undefined([undefined, 1, undefined]) ==> [undefined, 1]
    */
	var arr_trim_undefined = function(arr_like) {
		var res = [];
		var last_defined = -1;
		var t, v;
		for (var c = 0, l = arr_like.length; c < l; c++) {
			v = arr_like[c];
			t = tof(v);
			if (t == 'undefined') {

			} else {
				last_defined = c;
			}
		}

		for (var c = 0, l = arr_like.length; c < l; c++) {
			if (c <= last_defined) {
				res.push(arr_like[c]);
			}
		}
		return res;
	};

    /**
    * Helps to create a polymorphic version of the passed function. The function will get 2 parameters: `a` and `sig`.
    * Array `a` will contains the actual parameters, `a.l` property will contains the parameters count.
    * The `sig` parameter will contains the parameter types array signature. The function will use these parameters
    * to select a required polymorphic code branch to execute.
    * @func
    * @param {*} [options] - not used
    * @param {function} fn - the function
    * @memberof module:core/jsgui-lang-essentials
    * @example
    * var myFunc = functional_polymorphism(function(a, sig){
    *    return stringify(a) + ": " + sig;
    * });
    *
    * myFunc(1, "a", [null])  ==>  '[1, "a", [null]]: [n,s,a]'
    *
    */
	var functional_polymorphism = function(options, fn) {
		var a0 = arguments;
		if (a0.length === 1) {
			fn = a0[0];
			options = null;
		}

		//is there a this?

		//var that = this;
		//var _super = that._super;

		// not having access to this here
		var arr_slice = Array.prototype.slice;
		var arr, sig, a2, l, a;

		return function() {

			//that = this;

			// not sure we want super here?
			//  We hardly ever use this, it would slow things down.
			//var _super = that._super;

			a = arguments;
			// and if there is an array of arguments given... give as one
			// argument.
			l = a.length;

			if (l === 1) {
				sig = get_item_sig([a[0]], 1);
				//console.log('fp sig, a.l == 1 ' + sig);
				// a 'l' property given to array given
				a2 = [a[0]];
				a2.l = 1;
				//return fn.call(that, a2, sig, _super);
				return fn.call(this, a2, sig);
			} else if (l > 1) {
				//var arr = arr_like_to_arr(a);
				//var arr = arr_slice.call(a, 0);
				//
				arr = arr_trim_undefined(arr_slice.call(a, 0));

				//arr = arr_trim_undefined(arr);
				//var sig = get_item_sig(arr, 1);
				sig = get_item_sig(arr, 1);
				//arr.l = l;
				arr.l = arr.length;
			    //console.log('arr.l ' + arr.l);
				//return fn.call(that, arr, sig, _super);
				return fn.call(this, arr, sig);
			} else if (a.length === 0) {
				arr = new Array(0);
				arr.l = 0;
				//return fn.call(that, arr, '[]', _super);
				return fn.call(this, arr, '[]');
			}
		}
	};

    /**
    * A shortcut for the [functional_polymorphism()]{@link module:core/jsgui-lang-essentials.functional_polymorphism} function.
    * @func
    * @memberof module:core/jsgui-lang-essentials
    */
    var fp = functional_polymorphism;


    /**
    * Returns an array containing [key, value] arrays of the passed object properties.<br />
    *
    * @name arrayify
    * @func
    * @param {object} obj - arrayifing object
    * @memberof module:core/jsgui-lang-essentials
    *
    * @example
    *
    * arrayify({a: 1, b: 2})  ==> [["a", 1], ["b", 2]]
    *
    */


    /**
    * Returns an arrayified version of the function. The arrayified version accepts an array of values instead of single value for some parameter.
    * For example: `func(a, b) ==> arrayified_func([a], b)`
    * The original function will be called several times, one time for each value from the array. The result of the arrayified function
    * will be an array containing the original function return values.
    *
    * By default it arrayifies the first parameter. You can specify the arrayifying parameter index as the first argument of the arrayify() function: <br />
    * `arrayify(func)  ==>  arrayified_func([a], b, c, d, ...)` <br />
    * `arrayify(2, func)  ==>  arrayified_func(a, b, [c], d, ...)`
    *
    * You can arrayify an async function as well. If the very last argument passed to the arrayified version is function, then this case is considered
    * as async function call. The last parameter is considered as a callback function receiving the async array processing final result. The callback
    * format is `callback(error, result)`, where `error` is an error object or null, and `result` is the result array.
    *
    * The original async function must call a callback function in turn. The callback function is passed as a last argument to the async function
    * call, following the usual [call_multiple_callback_functions()]{@link module:core/jsgui-lang-essentials.call_multiple_callback_functions} rules.
    *
    * @func
    * @param {number} [param_index = 0] - arrayifing parameter index
    * @param {function} fn - arrayifing function
    * @memberof module:core/jsgui-lang-essentials
    *
    * @example
    *
    * // ------- arrayifing a function: -------
    *
    * var multiply = function (a, b) {
    *     return a * b;
    * };
    *
    * // multiply([a], b):
    *
    * var arrayified_multiply = jsgui.arrayify(multiply);
    *
    * console.log(arrayified_multiply([1, 5, 10], 2));  // [2, 10, 20]);
    *
    * // multiply(a, [b]):
    *
    * var arrayified_multiply2 = jsgui.arrayify(1, multiply);
    *
    * console.log(arrayified_multiply2(10, [1, 5, 10])); // [10, 50, 100]);
    *
    *
    * // ------- arrayifing an async function: -------
    *
    * var asyncMultiply = function (a, b, cb) {
    *     setTimeout(function () { cb(null, a * b); }, 1000);
    * };
    *
    * var arrayified_asyncMultiply = jsgui.arrayify(asyncMultiply); // asyncMultiply([a], b, cb)
    *
    * var callback = function (error, result) {
    *     console.log(error);  // null
    *     console.log(result); // [2, 10, 20]);
    *     done();
    * };
    *
    * arrayified_asyncMultiply([1, 5, 10], 2, callback);
    *
    */
	var arrayify = fp(function(a, sig) {
        // but when the function has it's last parameter as a function...
        //  can we assume it is a callback?
        // when given a whole bunch of strings (or numbers) these can be used to make a map for the results.
        //  ie for load_file could give a bunch of string files, it loads them, can provide the results as one object.
        // may also want to specify if functions get called in parallel, and the limit to how many get called at once.
        // this could take options in the signature - be able to return a results map.
		// What about arrayifying a map rather than a function?
		// Turns it into name/value pairs. Easier to process with each or
		// measure the length of.

		// what about a pf function that provides an 'a' map.
		// has whatever properties have been provided and asked for.
		var param_index, num_parallel = 1, delay = 0, fn;
		// (param_index, fn)
		var res;
		var process_as_fn = function() {
		    //console.log('process_as_fn');
			res = function() {
				// could use pf here? but maybe not
				//console.log('arguments.length ' + arguments.length);
				//console.log('arguments ' + stringify(arguments));
				var a = arr_like_to_arr(arguments), ts = atof(a), t = this;
			    //console.log('a ' + stringify(a));
                var last_arg = a[a.length - 1];
                //console.log('last_arg ' + last_arg);
                //console.log('a.length ' + a.length);
                if (tof(last_arg) == 'function') {
                    // it seems like a callback function.

                    // will do callback result compilation.

                    //console.log('ts[param_index] ' + ts[param_index]);

                    if (typeof param_index !== 'undefined' && ts[param_index] == 'array') {
                        // var res = [], a2 = a.slice(1); // don't think this makes
                        // a copy of the array.
                        var res = []; // don't think this makes a copy of the
                                        // array.
                        // console.log('fn ' + fn);

                        // but we can make this process a function with a callback.


                        var fns = [];

                        each(a[param_index], function(i, v) {
                            var new_params = a.slice(0, a.length - 1);
                            new_params[param_index] = v;
                            // the rest of the parameters as normal

                            // context, function, params
                            fns.push([t, fn, new_params]);

                            //var result = fn.apply(t, new_params);
                            // console.log('result ' + stringify(result));
                            //res.push(result);
                        });
                        //return res;

                        // call_multi not working right?
                        //console.log('delay', delay);
                        //throw 'stop';

                        call_multiple_callback_functions(fns, num_parallel, delay, function(err, res) {
                            if (err) {
                                throw err;
                            } else {
                                //

                                //console.log('res ' + stringify(res));

                                // we get back the results of the multiple callback functions.
                                //  let's put them in one array.

                                // maybe make result array concat optional.
                                //  likely to be needed.

                                // concat all of the arrays in the results.

                                var a = [];
                                a = a.concat.apply(a, res);

                                var callback = last_arg;
                                //console.log('last_arg ' + last_arg);
                                callback(null, a);
                            }
                        })
                    } else {
                        return fn.apply(t, a);
                    }
                } else {
									//console.log('not cb fn');
									//console.log('arguments', arguments);

                    if (typeof param_index !== 'undefined' && ts[param_index] == 'array') {
                        // var res = [], a2 = a.slice(1); // don't think this makes
                        // a copy of the array.
                        var res = []; // don't think this makes a copy of the
                                        // array.
                        // console.log('fn ' + fn);
                        // but we can make this process a function with a callback.

												for (var c = 0, l = a[param_index].length; c < l; c++) {
												    //a[param_index] = a[param_index][c];
												    a[param_index] = arguments[param_index][c];
													var result = fn.apply(t, a);
													// console.log('result ' + stringify(result));
													res.push(result);
												}

												/*
                        each(a[param_index], function(i, v) {
                            //var new_params = a;
                            a[param_index] = v;
                            // the rest of the parameters as normal
                            var result = fn.apply(t, a);
                            // console.log('result ' + stringify(result));
                            res.push(result);
                        });
												*/


                        return res;
                    } else {
                        return fn.apply(t, a);
                    }
                }
				// console.log('a.length ' + a.length);
				// console.log('a ' + stringify(a));
				// console.log('param_index ' + param_index);
				// console.log('ts ' + stringify(ts));
                // but if the last function there is a function... it may be best to compile the results into one object.
			};
		}

		if (sig == '[o]') {
			var res = [];
			each(a[0], function(i, v) {
				res.push([i, v]);
			});
		} else if (sig == '[f]') {
			param_index = 0, fn = a[0];
			process_as_fn();
		} else if (sig == '[n,f]') {
		    param_index = a[0], fn = a[1];
			process_as_fn();
		} else if (sig == '[n,n,f]') {
            param_index = a[0], num_parallel = a[1], fn = a[2];
            process_as_fn();
        } else if (sig == '[n,n,n,f]') {
            param_index = a[0], num_parallel = a[1], delay = a[2], fn = a[3];
            process_as_fn();
        }

		// maybe done with pf for getting function signature.
		// console.log('using arrayify');
		// if (typeof param_index == 'undefined') param_index = 0;

		return res;
	});


    /**
    * Returns an object containing keys and values from the [key, value] pairs of the array.
    *
    * @name mapify
    * @func
    * @param {array} arr - mapifying array
    * @memberof module:core/jsgui-lang-essentials
    *
    * @example
    *
    * mapify([["name", "John"], ["age", 22]])  ==> { name: "John", age: 22 }
    *
    */

    /**
    * The array is an objects array. The mapify() function gathers values of the (by_property_name) properties. The values will be keys (property names) of the
    * returning object. The values of the returning object will be the objects itself.
    *
    * @name mapify
    * @func
    * @param {array} arr - mapifying array
    * @param {string} by_property_name - mapping property name
    * @memberof module:core/jsgui-lang-essentials
    *
    * @example
    *
    * var obj_arr = [{ name: "Larry", age: 21 }, { name: "John", age: 22 }];
    *
    * mapify(obj_arr, "name")  ==> { Larry: { name: "Larry", age: 21 }, John: { name: "John", age: 22 } }
    *
    */

    /**
    * Returns an mapified version of the function. The orginal function receives 2 parameters: key and value. The mapified version receives an object, and
    * calls the original function for each key/value pair of the object.
    *
    * You can mapify an async function as well. If you pass a function as the second parameter to the mapified version call, then this case is considered
    * as async function call. The second parameter is considered as a callback function receiving the async object processing final result. The callback
    * format is `callback(error, result)`, where `error` is an error object or null, and `result` is the result array.
    *
    * The original async function must call a callback function in turn. The callback function is passed as a last argument to the async function
    * call, following the usual [call_multiple_callback_functions()]{@link module:core/jsgui-lang-essentials.call_multiple_callback_functions} rules.
    *
    * So, the mapified function parameters are (object) or (object, function). You can call the mapified function with other parameters type, but in
    * this case it will just call the original function (if the parameters number >= 2).
    *
    * @func
    * @param {function} fn - mapifying function
    * @memberof module:core/jsgui-lang-essentials
    *
    * @example
    *
    * var keys = [];
    * var values = [];
    *
    * var addKeyValue = function (key, value) {
    *     keys.push(key);
    *     values.push(value);
    * };
    *
    * var mapified_addKeyValue = jsgui.mapify(addKeyValue);
    *
    * mapified_addKeyValue({ a: 1, b: 2, name: "John" });
    *
    * console.log(keys); // ["a", "b", "name"]
    * console.log(values); // [1, 2, "John"]
    *
    *
    * // ------- mapify an async function: -------
    *
    *
    * var keys = [];
    * var values = [];
    *
    * var asyncAddKeyValue = function (key, value, cb) {
    *     setTimeout(function () {
    *         keys.push(key);
    *         values.push(value);
    *         cb(null, key + "=" + value);
    *     }, 1000);
    * };
    *
    * var callback = function (error, result) {
    *     console.log(result); // ["a=1", "b=2", "name=John"]
    *     //
    *     console.log(keys);   // ["a", "b", "name"]
    *     console.log(values); // [1, 2, "John"]
    * };
    *
    * var mapified_asyncAddKeyValue = jsgui.mapify(asyncAddKeyValue);
    *
    * mapified_asyncAddKeyValue({ a: 1, b: 2, name: "John" }, callback);
    *
    *
    * // ------- call the original function: -------
    *
    * var func = function (a, b, c) {
    *     console.log(a + " " + b + " " + c);  // 1 5 10
    * };
    *
    * var mapified_func = jsgui.mapify(func);
    *
    * mapified_func(1, 5, 10);
    *
    *
    */
    // that target function could take a callback(err, res) parameter.
    //  that means, when calling the function, if the last function is a callback, we can act differently.
	var mapify = function(target) {
		var tt = tof(target);
		if (tt == 'function') {
			var res = fp(function(a, sig) {
				var that = this;
				//console.log('mapified fn sig ' + sig);
				if (sig == '[o]') {
					var map = a[0];
					each(map, function(i, v) {
					    //fn.call(that, i, v);
					    target.call(that, i, v);
					});
				} else if (sig == '[o,f]') {
				    var map = a[0];
				    // call_multi on the function, using the items in the map, calling with 1 param (+callback).
				    var callback = a[1];
				    var fns = [];
				    each(map, function(i, v) {
				        fns.push([target, [i, v]]);
				    });
				    call_multi(fns, function(err_multi, res_multi) {
				        if (err_multi) {
				            callback(err_multi);
				        } else {
				            callback(null, res_multi);
				        }
				    });

				} else if (a.length >= 2) {
				    // applying the target function with a callback...

				    //var last_arg = a[a.length - 1];

					// could take functions, but not dealing with objects may be
					// tricky?
					// or just if there are two params its fine.
					target.apply(this, a);
				}
			});
			return res;
		} else if (tt == 'array') {

            // If it's an array of strings, want to make a truth map from it.

            // I think check to see if it's an array of strings would help.





			// a bunch of items, items could have name

			// could just be given an array to mapify.

			var res = {};

			if (arguments.length == 1) {

                if (is_arr_of_strs(target)) {
                    each(target, function(i, v) {
                        res[v] = true;
                    });
                } else {
                    each(target, function(i, v) {
                        res[v[0]] = v[1];
                    });
                }


				// dealing with [name, value] pairs

			} else {
				var by_property_name = arguments[1];
				each(target, function(i, v) {
					res[v[by_property_name]] = v;
				});
			}

			return res;

		}
		// we may be given a function,
		// we may be given an array.

		// been given a map / object

	};

    /**
    * Creates a clone of the given value. The result depends of the input value type:
    * - array: an array containing clones of the input array elements
    * - undefined: undefined
    * - string: same string
    * - number: same number
    * - function: same function reference
    * - boolean: same boolean value
    * - null: null
    * - other (object): deep copy of the object
    *
    * If the second parameter is passed, then returns an array containing the requested number of the clones.
    * @func
    * @param {*} obj - source value
    * @param {number} [count] - number of the output values
    * @memberof module:core/jsgui-lang-essentials
    * @example
    *  clone(1) ==> 1
    *
    *  clone("abc") ==> "abc"
    *  clone("abc", 3) ==> ["abc", "abc", "abc"]
    *
    *  clone([1, undefined]) ==> [1, undefined]
    *
    *  clone({a: 1, b:{c:2}}) ==> {a: 1, b:{c:2}}
    *
    */
	// had x_clones folded into it
	var clone = fp(function(a, sig) {
		var obj = a[0];
		if (a.l == 1) {


			var t = tof(obj);
			if (t == 'array') {

				// slice removes undefined items
				// console.log('clone obj ' + stringify(obj));
				// console.log('obj.length ' + obj.length);

				var res = [];


				eac(obj, function(v) {
					//console.log('i ' + i);
					res.push(clone(v));
				});




				return res;

				//return obj.slice();

				// deep clone...?

			} else if (t == 'undefined') {
				return undefined;
			} else if (t == 'string') {
			    return obj;
			} else if (t == 'number') {
			    return obj;
			} else if (t == 'function') {
			    return obj;
			} else if (t == 'boolean') {
			    return obj;
			} else if (t == 'null') {
			    return obj;
			} else {

				// extend not cloning the undefined values in the array properly,
				// don't want them trimmed.

				return extend(true, {}, obj);
			}

		} else if (a.l == 2 && tof(a[1]) == 'number') {
			var res = [];
			for ( var c = 0; c < a[1]; c++) {
				res.push(clone(obj));
			}
			return res;

		}


	});

    /**
    * Returns true if all the passed arguments are equals. Performs a "deep equals" for objects and arrays.
    *
    * If one array argiment passed, then returns true if all the array elements are equals.
    *
    * If one other (non-array) argument passed, returns true.
    *
    * If no arguments passed, returns null.
    *
    * @func
    * @param {...*} obj - values to compare.
    * @memberof module:core/jsgui-lang-essentials
    * @example
    *
    * are_equal(1, 1, 1) => true
    * are_equal(1, 2, 1) => false
    *
    * are_equal([1, 1, 1]) => true
    * are_equal([1, 2, 1]) => false
    *
    * are_equal([1, { b1: "2", b2: 2 }, 3], [1, { b1: "2", b2: 2 }, 3]) => true
    * are_equal([1, { b1: "2", b2: 2 }, 3], [1, { b1: 2, b2: 2 }, 3]) => false
    *
    */
	var are_equal = function() {
		var a = arguments;
		if (a.length == 0)
			return null;
		if (a.length == 1) {
			var t = jsgui.tof(a[0]);
			if (t == 'array' && a[0].length > 1) {
				for ( var c = 1, l = a[0].length; c < l; c++) {
					if (!jsgui.are_equal(a[0][0], a[0][c]))
						return false;
				}
			} else {
				return true;
			}
		}
		if (a.length == 2) {
			var ts = jsgui.atof(a);
			if (ts[0] != ts[1])
				return false;
			var t = ts[0];
			if (t == 'string' || t == 'number')
				return a[0] == a[1];
			if (t == 'array') {
				if (a[0].length != a[1].length)
					return false;
				for ( var c = 0, l = a[0].length; c < l; c++) {
					if (!jsgui.are_equal(a[0][c], a[1][c]))
						return false;
				}
				;
			} else if (typeof a[0] == 'object') {
			    // get the dict of keys for both, compare the lengths, (compare
			    // the keys), get merged key map
			    var merged_key_truth_map = {};
			    var c1 = 0;
			    each(a[0], function (i, v) {
			        merged_key_truth_map[i] = true;
			        c1++;
			    });
			    var c2 = 0;
			    each(a[1], function (i, v) {
			        merged_key_truth_map[i] = true;
			        c2++;
			    });
			    if (c1 != c2)
			        return false;
			    var objects_are_equal = true;
			    each(merged_key_truth_map, function (i, v) {
			        if (!jsgui.are_equal(a[0][i], a[1][i])) {
			            objects_are_equal = false;
			            return;
                    }
			    });
			    return objects_are_equal;
			} else {
			    return a[0] == a[1];
			}
		}
		if (a.length > 2) {
			var ts = jsgui.atof(a);
			if (!jsgui.are_equal(ts))
				return false;
			var o = a[0];
			for ( var c = 1, l = a.length; c < l; c++) {
				if (a[c] !== o)
					return false;
			}
		};
		return true;
	};


    /**
    * Assigns property values from map to obj.
    * @func
    * @param {object} obj - target object
    * @param {object} map - source key/value object
    * @returns undefined
    * @memberof module:core/jsgui-lang-essentials
    * @example
    *
    *  var obj1 = {};
    *  jsgui.set_vals(obj1, { a: 1, b: 2});  // obj1 == { a: 1, b: 2 }
    *
    *  var obj2 = { a: 1, b: 2};
    *  jsgui.set_vals(obj2, { b: 200, c: 300});  // obj2 == { a: 1, b: 200, c: 300 }
    *
    */
	var set_vals = function(obj, map) {
		each(map, function(i, v) {
			obj[i] = v;
		});
	};


    /**
    * Assigns a property value of the object using a qualified (dotted) property name. Nested sub-objects are created if needed.
    *
    * if the object contains an internal object named "_", then assigns the internal object property.
    *
    * @func
    * @param {object} obj - target object
    * @param {string} prop_name - property name
    * @param {*} prop_value - property value
    * @returns property value
    * @memberof module:core/jsgui-lang-essentials
    * @example
    *
    *  // object itself:
    *
    *  var obj1 = {};
    *  jsgui.ll_set(obj1, "a", 1);  // obj1 == { a: 1 }
    *
    *  var obj2 = {};
    *  jsgui.ll_set(obj2, "a.b.c", 1);  // obj2 == { a: { b: { c: 1 } } }
    *
    *  var obj3 = { a: { b: { c: 1 } };
    *  jsgui.ll_set(obj3, "a.b.c", 100);  // obj3 == { a: { b: { c: 100 } } }
    *
    *  // internal object:
    *
    *  var obj4 = { _: {}, a: 100 };
    *  jsgui.ll_set(obj4, "a", 1);  // obj4 == { _: { a: 1 }, a: 100 }
    */
	var ll_set = function(obj, prop_name, prop_value) {
		// not setting sub-properties specifically. sub-properties are
		// properties of a kind
		// however will not use ll_set inappropriately eg border.width works
		// differently

		var arr = prop_name.split('.');
		//console.log('arr ' + arr);
		var c = 0, l = arr.length;
		var i = obj._ || obj, s;

		while (c < l) {
			s = arr[c];
			//console.log('s ' + s);
			if (typeof i[s] == 'undefined') {
				if (c - l == -1) {
					// console.log('default_value ' + default_value);
					i[s] = prop_value;
				} else {
					i[s] = {};
				}
			} else {
				if (c - l == -1) {
					// console.log('default_value ' + default_value);
					i[s] = prop_value;
				}
			}
			i = i[s];
			c++;
		};
		return prop_value;
	};

	/*
	var ll_get_inner = function(a0, a1) {
		var i = a0._ || a0;
		var arr = a1.split('.');

		// shows how much the ll functions get used when they get logged!

		//console.log('ll_get arr ' + arr);
		var c = 0, l = arr.length, s;

		while (c < l) {
			s = arr[c];
			//console.log('s ' + s);
			//console.log('typeof i[s] ' + typeof i[s]);
			//console.log('c ' + c);
			//console.log('l ' + l);
			if (typeof i[s] == 'undefined') {
				if (c - l == -1) {
					// console.log('default_value ' + default_value);
					// console.log(i[s]);
					//i[s] = a[2];
					//return i[s];
				} else {
					// i[s] = {};
					throw 'object ' + s + ' not found';
				}
			} else {
				if (c - l == -1) {
					// console.log('default_value ' + default_value);
					// console.log(i[s]);
					// i[s] = a[2];
					return i[s];
				}
			}
			i = i[s];
			c++;
		}
	}
	*/


    /**
    * Returns a property value of the object using a qualified (dotted) property name.
    *
    * Returns `undefined` if the property does not exists.
    *
    * Throwns an exception if an inner object containing the property does not exists.
    *
    * if the object contains an internal object named "_", then return the value of the internal object property.
    *
    * Allows to pass "." (dot) as the `prop_name` parameter returning a value of the '.' property for the object or internal "_" object (if the value exists).
    *
    * @func
    * @param {object} obj - object
    * @param {string} prop_name - property name
    * @returns property value
    * @memberof module:core/jsgui-lang-essentials
    * @example
    *
    *  // object itself:
    *
    *  jsgui.ll_get({}, "a");  ==> undefined
    *  jsgui.ll_get({ a: 1 }, "a");  ==> 1
    *  jsgui.ll_get({ '.': 1 }, ".");  ==> 1
    *
    *  jsgui.ll_get({ a: { b: { c: 1 } } }, "a.b.c");  ==> 1
    *  jsgui.ll_get({ a: { b: { } } }, "a.b.c");  ==> undefined
    *  jsgui.ll_get({ a: { } }, "a.b.c");  ==> exception
    *  jsgui.ll_get({ }, "a.b.c");  ==> exception
    *
    *  // internal object:
    *
    *  jsgui.ll_get({ _ : { '.': 1 } }, ".");  ==> 1
    *  jsgui.ll_get({ _ : { a: { b: { c: 1 } } } }, "a.b.c");  ==> 1
    *  jsgui.ll_get({ _ : { '.': 1 } }, "a.b.c");  ==> exception
    *
    */
	var ll_get = function(a0, a1) {

		if (a0 && a1) {
			var i = a0._ || a0;

			if (a1 == '.') {
				//(function() {
					if (typeof i['.'] == 'undefined') {
						//throw 'object ' + s + ' not found';
						return undefined;
					} else {
						return i['.'];
					}
				//})();

			} else {

				//return ll_get_inner(a0, a1);


				var arr = a1.split('.');

				// shows how much the ll functions get used when they get logged!

				//console.log('ll_get arr ' + arr);
				var c = 0, l = arr.length, s;

				while (c < l) {
					s = arr[c];
					//console.log('s ' + s);
					//console.log('typeof i[s] ' + typeof i[s]);
					//console.log('c ' + c);
					//console.log('l ' + l);
					if (typeof i[s] == 'undefined') {
						if (c - l == -1) {
							// console.log('default_value ' + default_value);
							// console.log(i[s]);
							//i[s] = a[2];
							//return i[s];
						} else {
							// i[s] = {};
							throw 'object ' + s + ' not found';
						}
					} else {
						if (c - l == -1) {
							// console.log('default_value ' + default_value);
							// console.log(i[s]);
							// i[s] = a[2];
							return i[s];
						}
					}
					i = i[s];
					c++;
				}



			}
			// return i;
		}
	};


	/*
	var ll_get = fp(function(a, sig) {

		if (a.l == 2) {
			var i = a[0]._ || a[0];

			if (a[1] == '.') {
				if (typeof i['.'] == 'undefined') {
					//throw 'object ' + s + ' not found';
					return undefined;
				} else {
					return i['.'];
				}
			} else {
				var arr = a[1].split('.');

				// shows how much the ll functions get used when they get logged!

				//console.log('ll_get arr ' + arr);
				var c = 0, l = arr.length;


				while (c < l) {
					var s = arr[c];
					//console.log('s ' + s);
					//console.log('typeof i[s] ' + typeof i[s]);
					//console.log('c ' + c);
					//console.log('l ' + l);
					if (typeof i[s] == 'undefined') {
						if (c - l == -1) {
							// console.log('default_value ' + default_value);
							// console.log(i[s]);
							//i[s] = a[2];
							//return i[s];
						} else {
							// i[s] = {};
							throw 'object ' + s + ' not found';
						}
					} else {
						if (c - l == -1) {
							// console.log('default_value ' + default_value);
							// console.log(i[s]);
							// i[s] = a[2];
							return i[s];
						}
					}
					i = i[s];
					c++;
				}
			}
			// return i;
		}
	});
	*/

    /**
    * Returns true only if the passed value is a boolean true.
    * @param {*} value - value to check
    * @func
    * @memberof module:core/jsgui-lang-essentials
    * @example
    *
    *  jsgui.truth(true)  ==> true
    *  jsgui.truth(1)  ==> false
    *
    *
    *
    */
	var truth = function(value) {
		return value === true;
	};

    /**
    * Iterates over ancestor classes hierarchy calling the callback function for each class in the inheritance tree. Starts from the passed class, ends on jsgui.Class.
    *
    * The iteration can be broken calling the `stop()` function (the callback second parameter).
    *
    * @func
    * @param {jsgui.Class} obj - class to start the iteration
    * @param {function} callback - callback function (obj, stop).
    * @memberof module:core/jsgui-lang-essentials
    * @example
    *
	*  var Class = jsgui.Class;
	*  var Person = Class.extend({});
	*  var Ninja = Person.extend({});
    *
	*  var classes = [];
    *
	*  var callback = function (_class, stop) {
	*    classes.push(_class);
	*  };
	*
	*  jsgui.iterate_ancestor_classes(Ninja, callback);  // classes == [Ninja, Person, Class]
    *
    */
	var iterate_ancestor_classes = function(obj, callback) {

		/*
		if (obj.constructor &! obj._superclass) {
			iterate_ancestor_classes(obj.constructor, callback)
		} else {
			callback(obj);
			if (obj._superclass) {
				iterate_ancestor_classes(obj._superclass, callback);
			}

		}
		*/

		var ctu = true;

		var stop = function() {
			ctu = false;
		}

		callback(obj, stop);
		if (obj._superclass && ctu) {
			iterate_ancestor_classes(obj._superclass, callback);
		}


	}



    /**
    * Returns `true` if the passed object is an array containing values of the specified type only.
    * @param {*} obj - object to check
    * @param {string} type_name - estimated type name
    * @func
    * @memberof module:core/jsgui-lang-essentials
    * @example
    *
    *  jsgui.is_arr_of_t("1", "string")  ==>  false
    *
    *  jsgui.is_arr_of_t([], "string")  ==>  true
    *
    *  jsgui.is_arr_of_t(["1", "2", "3"], "string")  ==>  true
    *
    *  jsgui.is_arr_of_t(["1", 2, "3"], "string")  ==>  false
    *
    */
	var is_arr_of_t = function(obj, type_name) {
		var t = tof(obj), tv;
		if (t == 'array') {
			var res = true;

			each(obj, function(i, v) {
				//console.log('2) v ' + stringify(v));
				tv = tof(v);
				//console.log('tv ' + tv);
				//console.log('type_name ' + type_name);
				if (tv != type_name) res = false;
			});
			return res;
		} else {
			return false;
		}

	}

    /**
    * Returns `true` if the passed object is an array containing arrays in turn.
    * @param {*} obj - object to check
    * @func
    * @memberof module:core/jsgui-lang-essentials
    * @example
    *
    *  jsgui.is_arr_of_arrs([])  ==>  true
    *
    *  jsgui.is_arr_of_arrs(["1", "2", "3"])  ==>  false
    *
    *  jsgui.is_arr_of_arrs([[], [1, "2"]])  ==>  true
    *
    */
	var is_arr_of_arrs = function(obj) {
		return is_arr_of_t(obj, 'array');
	}


    /**
    * Returns `true` if the passed object is an array containing strings only.
    * @param {*} obj - object to check
    * @func
    * @memberof module:core/jsgui-lang-essentials
    * @example
    *
    *  jsgui.is_arr_of_strs("1")  ==>  false
    *
    *  jsgui.is_arr_of_strs([])  ==>  true
    *
    *  jsgui.is_arr_of_strs(["1", "2", "3"])  ==>  true
    *
    *  jsgui.is_arr_of_strs(["1", 2, "3"])  ==>  false
    *
    */
	var is_arr_of_strs = function(obj) {
		//console.log('obj ' + stringify(obj));
		return is_arr_of_t(obj, 'string');
	}


    /**
    * <mark>description... TODO</mark>
    * @member
    * @memberof module:core/jsgui-lang-essentials
    */
	var input_processors = {};

    /**
    * <mark>description... TODO</mark>
    * @member
    * @memberof module:core/jsgui-lang-essentials
    */
	var output_processors = {};

	// for data types...
	//  don't look up the data types directly for the moment.
	//  they are composed of input processors, validation and output processors.


    /**
    * <mark>Returns `true` if the passed object has a prototype (typically the object is a function).</mark>
    * @func
    * @param {function} fn - object to check
    * @memberof module:core/jsgui-lang-essentials
    * @example
    *
    *  jsgui.is_constructor_fn(Object)  ==>  true
    *  jsgui.is_constructor_fn(new Object())  ==>  false
    *
    *  jsgui.is_constructor_fn(setInterval)  ==>  true
    *
    */
	var is_constructor_fn = function(fn) {
		return is_defined(fn.prototype);
	}


	//var output_processors = {};

	// Possibly validators here too.
	//  They may well get used for data structures that deal with these data types. The typed constraints could make use of them (the basis that is set in essentials)
	//  while adding to them. Perhaps a 'core' intermediate layer will be there extending essentials with some of the data types that are to be used throughout the system.

	// May find that the functionality for 'nested' gets moved out from that code file. Not so sure about using the Data_Type_Instance...
	//  it could be useful, but not really useful on the level of what the user wants the system to do.
	//  Want to get the Data_Object and Collections system working in some more generic tests, also want to explore some of the more complicated data structures
	//  that will be used for HTML. The idea is that the HTML section will not need so much code because it is making use of some more generally defined things.

	// Defining an element's style attributes... will use a Data_Object system internally that is customized to reformat data.
	//  That seems like a fairly big goal, want to get these things working on a simpler level and in collections.
	//  Will use some kind of polymorphic rearrangement to rearrange where suitable.

    /**
    * Executes several tasks one by one (default) or simultaneously (up to specified amount of tasks at the same time).
    *
    * Each task can be a function, or an array in. The following task formats are supported:
    * - fn
    * - [context, fn]
    * - [fn, params]
    * - [fn, params, fn_callback]
    * - [context, fn, params]
    * - [context, fn, params, fn_callback]
    *
    * The task parts mean:
    * - context: execution context ("this" value)
    * - fn - task function
    * - params - task function parameters array
    * - fn_callback - callback function calling when the task is completed: fn_callback(null, result), where "result" is the task function result
    *
    * The task function must call a predefined callback function. The callback function is passed as the last parameter to the task function.
    * The callback function looks as follows: callback(error, result)
    * - error: an error object or null
    * - result: the task result
    *
    * The "main" callback (passed to the call_multiple_callback_functions() call) looks as follows:
    * callback(error, result), where "result" is all the tasks result array.
    *
    * @example
    * var tasks = [];
    *
    * var task1 = function(arg1, arg2, cb) {
    *    setTimeout(function () { cb(null, (arg1 * arg2)); }, 1000); // multiply arg1 * arg2
    * };
    *
    * tasks.push([task1, [10, 2]]);   // multiply 10 * 2
    *
    * call_multiple_callback_functions(tasks, function(error, result) {
    *    console.log("All the tasks are done. The first task result is " + result[0]);
    * });
    *
    *
    * @func
    * @param {array} tasks - tasks array
    * @param {number} [num_parallel = 1] - maximum amount of tasks running simultaneously
    * @param {function} callback - callback function called when all the tasks are completed
    * @param {boolean} [return_params = false] - include the task parameters to the task result
    * @memberof module:core/jsgui-lang-essentials
    */
	var call_multiple_callback_functions = fp(function(a, sig) {
		// will look at the signature and choose what to do.
		//if (sig == )
		// need to be checking if the item is an array - nice to have a different way of doing that with fp.

		// and want to look out for a number in there.
		//  want it to call multiple functions, but have them running in parallel too.
		//  like the async library, but also accepting parameters.

		// arr_functions_params_pairs, callback
		var arr_functions_params_pairs, callback, return_params = false;
        var delay;

		//console.log('a.l ' + a.l);
		//console.log('');
		//console.log('');
		//console.log('call_multi sig ' + sig);

        // what about num_parallel being zero to do them all in parallel?
        //  maybe try just a very high number at the moment.



		var num_parallel = 1;
		//console.log('a.l', a.l);
		if (a.l == 2) {
			arr_functions_params_pairs = a[0];
			//console.log('arr_functions_params_pairs', arr_functions_params_pairs);
			callback = a[1];
			//console.log('callback', callback);
		}
		if (a.l == 3) {
		    // look at the sig
		    // arr, num, fn - number is the number of parallel to do at once.
		    // return_params is a boolean?

		    // want a signature that just treats an array as a?
		    //  may make more sense for these function signatures.
		    //   at least for the first stage... could look in more detail at the array.
		    //   not using the more complicated signatures right now. could change to a different sig method when needed, or use different sig or fp options.

		    //console.log('sig ' + sig);

		    if (sig == '[a,n,f]') {
		        arr_functions_params_pairs = a[0];
		        num_parallel = a[1];
		        callback = a[2];
		    }
            if (sig == '[n,a,f]') {
                arr_functions_params_pairs = a[1];
                num_parallel = a[0];
                callback = a[2];
            }
		    if (sig == '[a,f,b]') {
		        arr_functions_params_pairs = a[0];
                callback = a[1];
                return_params = a[2];
		    }


		}
        if (a.l == 4) {
            // look at the sig
            // arr, num, fn - number is the number of parallel to do at once.
            // return_params is a boolean?

            // want a signature that just treats an array as a?
            //  may make more sense for these function signatures.
            //   at least for the first stage... could look in more detail at the array.
            //   not using the more complicated signatures right now. could change to a different sig method when needed, or use different sig or fp options.

            //console.log('sig ' + sig);

            if (sig == '[a,n,n,f]') {
                arr_functions_params_pairs = a[0];
                num_parallel = a[1];
                delay = a[2];
                callback = a[3];
            }
            if (sig == '[n,n,a,f]') {
                arr_functions_params_pairs = a[2];
                num_parallel = a[0];
                delay = a[1];
                callback = a[3];
            }
            //if (sig == '[a,f,b]') {
            //    arr_functions_params_pairs = a[0];
            //    callback = a[1];
            //    return_params = a[2];
            //}

        }



		// also want the context.

		var res = [];

		var l = arr_functions_params_pairs.length;
		var c = 0;
		var that = this;

		var count_unfinished = l;

		// the number of processes going

		// the maximum number of processes allowed.
        //  num_parallel

        var num_currently_executing = 0;

		var process = function(delay) {
            num_currently_executing++;
            var main = function() {

                // they may not be pairs, they could be a triple with a callback.
                //console.log('num_currently_executing ' + num_currently_executing);
                //console.log('num_parallel', num_parallel);
                //console.log('c ' + c);

                var pair = arr_functions_params_pairs[c];
                // maybe there won't be a pair.
                //  should try to prevent this situation.





                //console.log('pair', pair);

                // object (context / caller), function, params
                // object (context / caller), function, params, fn_callback

                var context;
                var fn, params, fn_callback;
                // function, array
                // context
                //console.log('pair.length ' + pair.length);
                var pair_sig = get_item_sig(pair);
                //console.log('pair_sig ' + pair_sig);
                //console.log(jsgui.atof(pair));
                //console.log('pair.length ' + pair.length);

                var t_pair = tof(pair);
                //console.log('t_pair', t_pair);

                if (t_pair == 'function') {
                    fn = pair;
                    params = [];
                } else {


                    if (pair) {
                        if (pair.length == 1) {

                        }

                        if (pair.length == 2) {
                            // [context, fn]
                            // [fn, params]

                            //if (tof(pair[0]) == 'function' && tof(pair[1]) == 'array' && pair.length == 2) {
                            //	fn = pair[0];
                            //	params = pair[1];
                            //}
                            // ?, function

                            if (tof(pair[1]) == 'function') {
                                context = pair[0];
                                fn = pair[1];
                                params = [];
                            } else {
                                fn = pair[0];
                                params = pair[1];
                            }
                        }

                        // function, array, function
                        if (pair.length == 3) {
                            // [fn, params, fn_callback]
                            // [context, fn, params]

                            if (tof(pair[0]) == 'function' && tof(pair[1]) == 'array' && tof(pair[2]) == 'function') {
                                fn = pair[0];
                                params = pair[1];
                                fn_callback = pair[2];
                            }
                            // object / data_object?
                            // ?, function, array
                            if (tof(pair[1]) == 'function' && tof(pair[2]) == 'array') {
                                //console.log('has context');
                                context = pair[0];
                                fn = pair[1];
                                params = pair[2];

                                // may not be a fn_callback in this case.
                            }
                        }

                        if (pair.length == 4) {
                            // [context, fn, params, fn_callback]

                            // context, function being called, params, cb
                            context = pair[0];
                            fn = pair[1];
                            params = pair[2];
                            fn_callback = pair[3];
                        }
                    } else {
                        //console.log('missing pair');

                    }

                    // For some reason the pair can be undefined.

                    // We don't have a pair of them.
                    //  Have we called with the wrong data?
                    //   Do a callback, result is false.






                }



                var i = c;
                // not sure it keeps this same value of i.
                //  can try some tests on this.

                c++;
                //throw 'stop';

                var cb = function(err, res2) {
                    num_currently_executing--;
                    count_unfinished--;
                    //console.log('cb num_currently_executing ' + num_currently_executing + ', c ' + c);
                    if (err) {
                        var stack = new Error().stack;
                        //console.log(stack);
                        throw err;
                    } else {
                        //console.log('i ' + i + ', res2 ' + res2);
                        if (return_params) {
                            //console.log('call_multi inner cb return_params ' + stringify(return_params));
                            //throw 'stop';
                            //console.log('params ' + params);
                            res[i] = [params, res2];
                        } else {
                            res[i] = res2;
                        }
                        //console.log('pair.length ' + pair.length);

                        if (fn_callback) {
                            fn_callback(null, res2);
                        }
                        /*

                         if (pair.length == 3) {
                         fn_callback(null, res2);
                         }
                         if (pair.length == 4) {
                         fn_callback(null, res2);
                         }
                         */
                        //console.log('c', c);
                        //console.log('l', l);

                        if (c < l) {

                            // only process if the num executing is less than the max num to execute.
                            // otherwise the process will be done when a callabck is produced from the function.
                            //console.log('num_currently_executing', num_currently_executing);
                            if (num_currently_executing < num_parallel) {
                                process(delay);
                            }


                        } else {
                            //console.log('count_unfinished', count_unfinished);
                            if (count_unfinished <= 0) {
                                callback(null, res);
                            }
                        }
                    }
                };
                // Clone the params?
                //  Really not sure about that.
                var arr_to_call = clone(params) || [];
                //var arr_to_call = (params) || [];
                //console.log('params', params);
                //console.log('arr_to_call', arr_to_call);
                //console.log('params ' + params);
                //console.log('fn ' + fn);
                arr_to_call.push(cb);
                // but if the function does not have a callback?
                //console.log('context ' + context);

                if (fn) {
                    if (context) {
                        fn.apply(context, arr_to_call);
                    } else {
                        fn.apply(that, arr_to_call);
                    }
                } else {
                    //cb(null, undefined);
                }
            }
            //console.log('2) delay', delay);

            if (arr_functions_params_pairs[c]) {
                if (delay) {
                    setTimeout(main, delay);
                } else {
                    main();
                }
            }
		}
		//console.log('** arr_functions_params_pairs.length ' + arr_functions_params_pairs.length);
		if (arr_functions_params_pairs.length > 0) {
		    while ((c < l)  && (num_currently_executing < num_parallel)) {
                if (delay) {
                    //console.log('sto');
                    //setTimeout(process, delay * c);
                    process(delay * c);
                } else {
                    process();
                }
		    }
		} else {
		    if (callback) {
		        //callback(null, null);
            }
		}
	});
	var multi = call_multiple_callback_functions;
    /**
    * Alias to the [call_multiple_callback_functions()]{@link module:core/jsgui-lang-essentials.call_multiple_callback_functions} function.
    * @func
    * @memberof module:core/jsgui-lang-essentials
    */
    var call_multi = call_multiple_callback_functions;
    /**
    * Returns a [call_multiple_callback_functions()]{@link module:core/jsgui-lang-essentials.call_multiple_callback_functions} helper object. The object is an array with `go()` method added.
    * You can add the [call_multiple_callback_functions()]{@link module:core/jsgui-lang-essentials.call_multiple_callback_functions} tasks to the array, then call the go() method passing the callback function.
    * @func
    * @memberof module:core/jsgui-lang-essentials
    * @example
    *
	*   var taskPlus = function (a, b, cb) { cb(null, a + b); };
	*   var taskMinus = function (a, b, cb) { cb(null, a - b); };
    *
	*   var fns = jsgui.Fns();
    *
	*   fns.push([taskPlus, [1, 2]]);
	*   fns.push([taskPlus, [3, 4]]);
	*   fns.push([taskMinus, [1, 2]]);
	*   fns.push([taskPlus, [10, 12]]);
    *
	*   fns.go(function (error, result) {
	*       console.log(result);  //  [3, 7, -1, 22]
	*   });
    *
    */
	var Fns = function() {
	    var fns = [];
	    fns.go = function(parallel, delay, callback) {

            // Should have better param checking here.




            //if (!callback) {
            //    call_multi(fns, parallel);
            //} else {
            //    call_multi(parallel, fns, callback);
            //}

            var a = arguments;
            var al = a.length;



            // No, we may give the number in parallel, alongside a callback.

            // call cases:
	        // (callback)
	        // (parallel, callback)
	        // (parallel, delay, callback)

            if (al == 1) {
                call_multi(fns, parallel); // meaning call_multi(fns, callback);
            }
            if (al == 2) {
                call_multi(parallel, fns, delay); // meaning call_multi(parallel, fns, callback);
            }
            if (al == 3) {
                call_multi(parallel, delay, fns, callback);
            }




	    }
	    return fns;
	}

    /**
    * Returns a name of the passed native constructor function. Possible return values are:
    * - "String"
    * - "Number"
    * - "Boolean"
    * - "Array"
    * - "Object"
    * - undefined (for all other arguments)
    *
    * @func
    * @memberof module:core/jsgui-lang-essentials
    * @example
    *
    * jsgui.native_constructor_tof(String)  ==>  "String"
    *
    * jsgui.native_constructor_tof(Date)  ==>  undefined
    *
    */
	var native_constructor_tof = function(value) {
		if (value === String) {
			return 'String';
		}
		if (value === Number) {
			return 'Number';
		}
		if (value === Boolean) {
			return 'Boolean';
		}
		if (value === Array) {
			return 'Array';
		}
		if (value === Object) {
			return 'Object';
		}
	}

	//var storage_closure

	// jsgui.get and jsgui.set
	//  so JSGUI itself would have some properties within a closure.
	//  Not sure if that would allow some kind of global variables (again).
	var storage_map = {};


    /**
    * Gets value from the module's internal key/value storage.
    * @func
    * @param {string|*} key - the value key
    * @memberof module:core/jsgui-lang-essentials
    * @example
    *
    * jsgui.set("a", 1);
    * jsgui.set(100, 2);
    *
    *
    * jsgui.get("a")  ==>  1
    * jsgui.get(100)  ==>  2
    *
    */
	var get = function(key) {
		return storage_map[key];
	}

    /**
    * Sets value for the module's internal key/value storage.
    * @func
    * @param {string|*} key - the value key
    * @param {*} value - the value
    * @memberof module:core/jsgui-lang-essentials
    * @example
    *
    * jsgui.set("a", 1);
    * jsgui.set(100, 2);
    *
    *
    * jsgui.get("a")  ==>  1
    * jsgui.get(100)  ==>  2
    *
    */
	var set = function(key, value) {
		storage_map[key] = value;
	}


    var sig_match = function(sig1, sig2) {
        // Does sig2 match sig1

        // We go through sig1, checking item by item.

        // Sigs have to be the same length I think?

        // I think just check flat sigs?
        //  Or we could do this recursively anyway.

        var sig1_inner = sig1.substr(1, sig1.length - 2);
        //console.log('sig1_inner', sig1_inner);

        var sig2_inner = sig2.substr(1, sig2.length - 2);
        //console.log('sig2_inner', sig2_inner);

        if (sig1_inner.indexOf('[') > -1 || sig1_inner.indexOf(']') > -1 || sig2_inner.indexOf('[') > -1 || sig2_inner.indexOf(']') > -1) {
            throw 'sig_match only supports flat signatures.';
        }

        var sig1_parts = sig1_inner.split(',');
        //var sig2_parts = sig1_inner.split(',');
        var sig2_parts = sig2_inner.split(',');

        var res = true;

        if (sig1_parts.length == sig2_parts.length) {
            var c = 0, l = sig1_parts.length, i1, i2;
            while (res && c < l) {
                i1 = sig1_parts[c];
                i2 = sig2_parts[c];

                if (i1 === i2) {

                } else {
                    if (i1 !== '?') {
                        res = false;
                    }
                }

                c++;
            }
            return res;
        } else {
            return false;
        }

        //throw 'stop';






    }


	/*

	(function() {


	})();

	*/
	// will put functions into the jsgui object.

	// with the functions listed like this it will be easier to document them.

	var jsgui = {
		'Class' : Class,
		'each' : each,
		'eac': eac,
		'is_array' : is_array,
		'is_dom_node' : is_dom_node,
		'is_ctrl' : is_ctrl,
		'extend' : extend,
		'clone' : clone,
		//'x_clones' : x_clones,
		'get_truth_map_from_arr' : get_truth_map_from_arr,
		'arr_trim_undefined': arr_trim_undefined,
		'get_map_from_arr' : get_map_from_arr,
		'arr_like_to_arr' : arr_like_to_arr,
		'tof' : tof,
		'atof' : atof,
		'is_defined' : is_defined,
		'stringify' : stringify,
		'functional_polymorphism' : functional_polymorphism,
		'fp' : fp,
		'arrayify' : arrayify,
		'mapify' : mapify,
		'are_equal' : are_equal,
    'get_a_sig': get_a_sig,
		'get_item_sig' : get_item_sig,
		'set_vals': set_vals,
		'truth': truth,
		'trim_sig_brackets' : trim_sig_brackets,
		'll_set': ll_set,
		'll_get': ll_get,
		'iterate_ancestor_classes': iterate_ancestor_classes,
		'is_constructor_fn': is_constructor_fn,
		'is_arr_of_t': is_arr_of_t,
		'is_arr_of_arrs': is_arr_of_arrs,
		'is_arr_of_strs': is_arr_of_strs,
		'input_processors': input_processors,
		'output_processors': output_processors,
		'call_multiple_callback_functions': call_multiple_callback_functions,
		'call_multi': call_multi,
		'multi': call_multi,
		'native_constructor_tof': native_constructor_tof,
		'Fns': Fns,
		'get': get,
		'set': set,
        'sig_match': sig_match
	};


    /**
    * description...
    * @alias data_types_info
    * @member
    * @memberof module:core/jsgui-lang-essentials
    */
	// Maybe this will be moved to an intermediate layer.
	jsgui.data_types_info = jsgui.data_types_info || {};




	// and the local variable shortcuts that go at the beginning:

	/*

	 var j = jsgui;
	 var Class = j.Class;
	 var each = j.each;
	 var is_array = j.is_array;
	 var is_dom_node = j.is_dom_node;
	 var is_ctrl = j.is_ctrl;
	 var extend = j.extend;
	 var x_clones = j.x_clones;
	 var get_truth_map_from_arr = j.get_truth_map_from_arr;
	 var get_map_from_arr = j.get_map_from_arr;
	 var arr_like_to_arr = j.arr_like_to_arr;
	 var tof = j.tof;
	 var is_defined = j.is_defined;
	 var stringify = j.stringify;
	 var functional_polymorphism = j.functional_polymorphism;
	 var fp = j.fp;
	 var arrayify = j.arrayify;
	 var mapify = j.mapify;
	 var are_equal = j.are_equal;
	 var get_item_sig = j.get_item_sig;
	 var set_vals = j.set_vals;
	 var truth = j.truth;
	 var trim_sig_brackets = j.trim_sig_brackets;
	 var ll_set = j.ll_set;
	 var ll_get = j.ll_get;
	 var is_constructor_fn = j.is_constructor_fn;
	 var is_arr_of_arrs = j.is_arr_of_arrs;
	 var is_arr_of_strs = j.is_arr_of_strs;
	 var is_arr_of_t = j.is_arr_of_t;
	 */


	// var jsgui = {};
	// alert('returning jsgui from jsgui-lang');
	//return jsgui;
    module.exports = jsgui;
//});

}).call(this,require("buffer").Buffer)

},{"buffer":2,"stream":21}],38:[function(require,module,exports){
// This is resulting in smaller code in other parts of the framework.
//  This section is getting quite big (again)
//  Still need to make use of the B+ free for ordered indexing.

// Moving some code to jsgui-lang-essentials
//  Will be publishing a 0.4 version of that before so long?
//   Maybe with more explanation?

// It may be worth publishing this, and a discussion forum about it on my own web forum.
//  Perhaps that could come later, but jsgui-lang-essentials may be a good step. Could call it version 0.35.
//   Could have a few examples
//   Would be a useful toolkit I could use while working elsewhere.

//  I think that web site would be lightening fast, and impress people with its speed compared to other web platforms that they are used to
//   (though Facebook is OK)

// This is going to be using data_types as well.
// Will also have a system of requirements.
//  That could mean they need to be both the right data type, as well as having some other specified properties.
/*
if (typeof define !== 'function') {
    var define = require('amdefine')(module);
}


define(["./jsgui-lang-essentials", "./jsgui-data-structures", "./data-object", "./collection"],
	function(jsgui, Data_Structures, Data_Object, Collection) {
	*/
    var jsgui = require('./jsgui-lang-essentials');
var Data_Structures = require('./jsgui-data-structures');
var Data_Value = require('./data-value');
var Evented_Class = require('./evented-class');
var Data_Object = require('./data-object');
var Collection = require('./collection');

	// Will use data structures.
	//  Not sure about using all of them here.

	// A mix-in system of enhancing the data structures may work best.
	//  It does not start with B+ tree, but that gets brought in?

	// However, having B+ as part of it could work quite nicely.


 var j = jsgui;
 var Class = j.Class;
 var each = j.each;
 var is_array = j.is_array;
 var is_dom_node = j.is_dom_node;
 var is_ctrl = j.is_ctrl;
 var extend = j.extend;
 var x_clones = j.x_clones;
 var get_truth_map_from_arr = j.get_truth_map_from_arr;
 var get_map_from_arr = j.get_map_from_arr;
 var arr_like_to_arr = j.arr_like_to_arr;
 var tof = j.tof;
 var atof = j.atof;
 var is_defined = j.is_defined;
 var stringify = j.stringify;
 var functional_polymorphism = j.functional_polymorphism;
 var fp = j.fp;
 var arrayify = j.arrayify;
 var mapify = j.mapify;
 var are_equal = j.are_equal;
 var get_item_sig = j.get_item_sig;
 var set_vals = j.set_vals;
 var truth = j.truth;
 var trim_sig_brackets = j.trim_sig_brackets;

jsgui.Data_Object = Data_Object;
jsgui.Collection = Collection;

jsgui.Data_Value = Data_Value;
jsgui.Evented_Class = Evented_Class;

//var B_Plus_Tree = Data_Structures.B_Plus_Tree;
var Sorted_KVS = Data_Structures.Sorted_KVS;

var vectorify = function(n_fn) {
    // Creates a new polymorphic function around the original one.

    var fn_res = fp(function(a, sig) {
        //console.log('vectorified sig ' + sig);
        if (a.l > 2) {
            var res = a[0];
            for ( var c = 1, l = a.l; c < l; c++) {
                res = fn_res(res, a[c]);
                // console.log('res ' + res);
            }
            return res;
        } else {
            if (sig == '[n,n]') {
                return n_fn(a[0], a[1]);
            } else {
                // will need go through the first array, and the 2nd... but
                // will need to compare them.
                var ats = atof(a);
                //console.log('ats ' + stringify(ats));
                if (ats[0] == 'array') {
                    if (ats[1] == 'number') {
                        var res = [], n = a[1];
                        each(a[0], function(i, v) {
                            res.push(fn_res(v, n));
                        });
                        return res;
                    }
                    if (ats[1] == 'array') {
                        if (ats[0].length != ats[1].length) {
                            throw 'vector array lengths mismatch';
                        } else {
                            var res = [], arr2 = a[1];
                            each(a[0], function(i, v) {
                                res.push(fn_res(v, arr2[i]));
                            });
                            return res;
                        }
                    }
                }
            }
        }
    });
    return fn_res;
};

var n_add = function(n1, n2) {
    return n1 + n2;
}, n_subtract = function(n1, n2) {
    return n1 - n2;
}, n_multiply = function(n1, n2) {
    return n1 * n2;
}, n_divide = function(n1, n2) {
    return n1 / n2;
};

var v_add = vectorify(n_add), v_subtract = vectorify(n_subtract);

// these are not the standard, established vector or matrix operations. They
// can be used for scaling of arrays of vectors.
var v_multiply = vectorify(n_multiply), v_divide = vectorify(n_divide);

var vector_magnitude = function(vector) {
    // may calculate magnitudes of larger dimension vectors too.
    // alert(tof(vector[0]));
    // alert(vector[0] ^ 2);

    var res = Math.sqrt((Math.pow(vector[0], 2)) + (Math.pow(vector[1], 2)));
    return res;

};

var distance_between_points = function(points) {
    var offset = v_subtract(points[1], points[0]);
    console.log('offset ' + stringify(offset));
    return vector_magnitude(offset);
}

// Does this have a general use?
var remove_sig_from_arr_shell = function(sig) {
    // first and last characters?
    // use regex then regex to extract the middle?

    if (sig[0] == '[' && sig[sig.length - 1] == ']') {
        return sig.substring(1, sig.length - 1);
    }
    return sig;
    // but also do this to the arguments?
};

var execute_on_each_simple = function(items, fn) {
    // currently no arguments provided, there may be in the future / future
    // versions
    var res = [], that = this;
    each(items, function(i, v) {
        res.push(fn.call(that, v)); // function called with item as its only
                                    // parameter.
    });
    return res;
};

var filter_map_by_regex = function(map, regex) {
    var res = {};
    each(map, function(i, v) {
        // if (regex.match(i)) {
        if (i.match(regex)) {
            res[i] = v;
        }
    });
    return res;
}

// May be replaced by a more veristile replacement system, ie input transformation and parsing in schemas.
var npx = arrayify(function(value) {
    // don't think we can use arrayify?

    // good candidate for pf? but how it deals with array trees...
    // could have another one, like sf or spf that is simpler in terms of
    // treating an array in the signature as just one array?

    var res, a = arguments, t = tof(a[0]);

    // fn sigs??? performance?

    if (t == 'string') {
        res = a[0];
    } else if (t == 'number') {
        res = a[0] + 'px';
    }
    return res;
});

var no_px = arrayify(fp(function(a, sig) {
    // no_px - removes the 'px' if it ends with px
    // Generally returns a number.
    // value
    var re = /px$/, res;
    if (sig == '[s]' && re.test(a[0])) {
        res = parseInt(a[0]);
    } else {
        res = a[0];
    }
    ;
    return res;
}));

var arr_ltrb = [ 'left', 'top', 'right', 'bottom' ];

var str_arr_mapify = function(fn) {
    var res = fp(function(a, sig) {
        if (a.l == 1) {
            if (sig == '[s]') {
                var s_pn = a[0].split(' ');
                // console.log('s_pn ' + s_pn.length);

                if (s_pn.length > 1) {
                    return res.call(this, s_pn);
                } else {
                    return fn.call(this, a[0]);
                }
            }

            if (tof(a[0]) == 'array') {
                var res2 = {}, that = this;

                each(a[0], function(i, v) {
                    res2[v] = fn.call(that, v);
                });
                return res2;
            }
        }
    });
    return res;
};

// Lower level functions
// For the moment not exposed

// These two do deal with nested data... but the purpose of the nested
// module is to put the complicated nested stuff there.
// This one looks quite useful and it is limited in what it does, easy to
// understand. Keep here.


var arr_hex_chars = [ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
        'A', 'B', 'C', 'D', 'E', 'F' ];
var dict_hex_to_bin = {
    '0' : 0,
    '1' : 1,
    '2' : 2,
    '3' : 3,
    '4' : 4,
    '5' : 5,
    '6' : 6,
    '7' : 7,
    '8' : 8,
    '9' : 9,
    'A' : 10,
    'B' : 11,
    'C' : 12,
    'D' : 13,
    'E' : 14,
    'F' : 15
};
var str_hex_to_int = function(str_hex) {
    str_hex = str_hex.toUpperCase();
    var i = str_hex.length; // or 10
    var res = 0, exp = 1;
    while (i--) {
        var i_part = dict_hex_to_bin[str_hex.charAt(i)];
        var ip2 = i_part * exp;
        res = res + ip2;
        exp = exp * 16;
        // ...
    }
    ;
    return res;
};
var byte_int_to_str_hex_2 = function(byte_int) {
    var a = Math.floor(byte_int / 16), b = byte_int % 16, sa = arr_hex_chars[a], sb = arr_hex_chars[b], res = sa
            + sb;
    return res;
};
var arr_rgb_to_str_hex_6 = function(arr_rgb) {
    var r = byte_int_to_str_hex_2(arr_rgb[0]);
    var res = r + byte_int_to_str_hex_2(arr_rgb[1])
            + byte_int_to_str_hex_2(arr_rgb[2]);
    return res;
};
var arr_rgb_to_css_hex_6 = function(arr_rgb) {
    // a / b // divide a by b
    // a % b // find the remainder of division of a by b
    return '#' + arr_rgb_to_str_hex_6(arr_rgb);
};
/*
 * Consider the following:
 *
 *
 * var arr_multi_set_item = function(arr, iBegin, iEnd, item_name, value) {
 * var c = iBegin; while (c <= iEnd) { arr[item_name][c] = value; }; return
 * arr; }; var item_cond_set_multi_values = function(target, source,
 * value_names) { each(value_names, function(i, v) { if (typeof source[v] !=
 * 'undefined') { target[v] = source[v]; } }); return target; }; var
 * arr_item_cond_set_multi_values = function(arr_target, arr_source, iMin,
 * iMax, value_names) { for (var c = iMin; c <= iMax; c++) {
 * item_cond_set_multi_values(arr_target[c], arr_source[c], value_names); }; };
 *
 */

// information about data types such as 'int'?
// Perhaps some number data types could be re-implemented, like Decimal.

var input_processors = {};

var output_processors = {};

var validators = {
    'number' : function(value) {
        return tof(value) == 'number';
    }
};

// create data type instance from info

// Code will be better organized using this, but it will still be quite a
// large amount of logic.
// Will make reference to special cases (directives) to control the flow.

// I think the recursion inherant in the data types will be enough for this
// to work (hope so).
// The logic here looks at two layers sometimes, I hope it does not need
// recursion there, but rather that one directive may reference other
// things.
// Those other things could be their own data types that can be referenced.

var referred_object_is_defined = function(object_reference) {
    return is_defined(object_reference[0][object_reference[1]]);
}

// This code is really big now.
// Without WS and logging it will be smaller.

// The HTML module will give it HTML and CSS-like properties it will use for
// its internal representation and translations to and from
// DOM representations.

// The B (or B+?) tree coming up. It's quite a big one....
// There will be some other, simpler classes that use it.

// KSVS, Keys and Values store
// May want something that stores only a single value for a key.
// Likely to want to specify this, in how an index is used.
// Don't want to impose an extra requirement on there being unique values
// for indexed fields.
// That's why more complex data types may fit the data better than dicts.

// Will make a new B+ tree structure.
//  I'll want to know what it does anyway - and I'll see that this one is optimized as well as useful for various operations that would get performed on the tree.

// Quite a few data types will wind up here, in this bit of the library.
//  I don't think they will take up all that much space.

// Could have Data_Structures before util?
//  I don't think they'll be making use of functionality such as Collection or Data_Object. Collection will use these data structures for its index.
//   May be good having them really compatable too?

//  Perhaps there will be a lang 'essentials' set?
//   Before data structures, core tools such as polymorphism, stringify, each, tof
//    That would be a really good toolkit in a few KB of code.
//    I think those things won't change so much.
//     Other parts of lang are developing, but are taking far more code to do.




// Data_Object and Collection are not data structures - they are more than that.
//  They provide a utility, and use the appropriate data structures to do so. They also deal with events and have/enable MVC patterns.
//  That means that data structures won't use them.

// There will be a data structures part of the system that will be used as building blocks for this part.
//  The data structures will use jsgui-lang-essentials.






//var Doubly_Linked_List =


// var BTree = function() {

// BTree is fairly big.
// It can be shrunk a bit further... but not massively
// May find this is an integral part of code to well functioning data
// systems on the client.
// May only be useful when there is a more significant amount of data to
// deal with?

// Makes things possible though.

var set_vals = function(obj, map) {
    each(map, function(i, v) {
        obj[i] = v;
    });
};

// its functions may get proxied.

// OK, so looks like it's working so far.

// indexed collection. keeps track of the index of each item in it.

// Will use this within the typed data I think.

// every item needs an id, need an index too.

// Need to be able to access controls in a collection using a nice interface
// at different levels.

// items in the collection have got index() and id() functions for access to
// the variables.
// index is the position in the collection.

// Think this one is quite specific for when items have ids.

// Should be made much more general, or given specific name.

// Will be phased out.
// Will have Collection.

// That will be a Data_Object.
// It will have an array
// It will have index capabilities.
// Perhaps it could even be able to handle larger datasets with efficient
// indexing capabilities.

// As an abstract class?

// Indexed by position in another index?
// Or ordered by it...

// And that order could change, too.
// have it respond automatically for that...
// Would like to get this to be easy to express.

// collection 1 not particularly ordered
// collection 2 ordered by items' positions in collection 1.
// don't want lots of code specifically for this - but should be possible
// using a fairly general system.
// so each object will have its collection1_index value available.
// Need to think about where to hook up the listeners to listen for a change
// in collection1 so order could be updated in collection 2.
// Probably not for any single item that changes position
// Could maybe be given a list of all items that change position...
// Or it could be an event on the object.
// May re-index that.

// Also, need to look out for property changes on indexed items.
// Need to update the index in that situation.

// Seems like quite a lot of work to get this all going - but I think it
// will be worth it when the indexed collection system is working.
// Will need to refer to the index record when the property value changes.
// Perhaps update all relevant indexes.
// But then don't want to proceed with other things until this is done.

// The system gets somewhat complicated, but this is something which could
// be an integral component that could be reused a lot, if it is done right.

// A collection of collections could be a lot like a database.
// May want more examples about dealing with such collections.

// Don't want to spend a long time making and testing various things that
// have this collection and ordering functionality...
// However need to do what is necessary. Some of them may not seem that
// useful in the abstract - like having something that is indexed by the
// position within another control.
// Indexed by the position in another control or ordered by it? Same thing?
// May require quite a bit behind the scenes to get everything working
// right.
// It won't be a very large amount of code... but it needs to be right.
// Really don't want to make the download too large. May change the b+
// implementation and experiment with it, get a smaller b+ tree size.
// Could perhaps be loaded after lang, as a separate module, but using lang.
// Lang could start with the indexing system set up, but not all the types
// of indexes. Maybe just the dict index?
// Other indexes will then be easier to work on separately.
// But b+ could be so essential to the library working smoothly in the GUI.
// Won't be impossible to make a micro-b+ implementation.
// So could still get by id with the dict index
// Maintaining another collection ordered by the position in another
// collection does seem like a good objective.
// Position in collection = position within the normal array...
// Not the position within some kind of index.

// index_by(other_collection)
// only if items are in the other collection...

// item position in collection... collection is always an array as well.
// could that make things inefficient there?
// moving items around the array, changing the array index of items.
// may not be worth so much indexing with those inherant limitations?

// could make different collections with different internal storage?
// linked list? something that maintains an order?

// at the moment, controls are stored in an array, other indexing is done
// too.

// A single index.


/*
var DataCollection = Class.extend({
    'init' : function(spec) {
        this._id_map = {};
        this._arr = [];
        this.length = 0;
    },

    // function reference - add functions to that?

    // much like fn_call. Perhaps DataObject could have fn_call - the same
    // as this. But this one deals with an empty sig, maybe that's the
    // default function which can be assigned.
    'action' : fp(function(a, sig) {
        // what about calling this with more parameters?

        // console.log('action sig ' + sig);

        if (sig == '[]') {
            // console.log('1) this._arr ' + tof(this._arr));
            // console.log(this._arr.length);
            return this._arr;
        } else {
            var action_name = a[0];

            // console.log('action_name ' + action_name);

            // then call the relevant function... eg add(a[1])

            // and then make it so that more parameters can be given.

            var params = a.slice(1);

            // return this[action_name](a[1]);

            return this[action_name].apply(this, params);

        }

    }),

    'add' : fp(function(a, sig) {
        // item
        console.log('add sig ' + sig);

        if (sig == '[o]' || sig == '[c]') {
            // if ()
            var i = this._arr.length;
            this._arr.push(a[0]);
            this.length++;
            // console.log('2) this._arr ' + (this._arr));
            // console.log('2) this._arr ' + stringify(this._arr));

            // circular references with controls?

            // but could index be a read-only property?
            if (tof(a[0].index) == 'function') {
                a[0].index(i);
            }

            if (tof(a[0].id) == 'function') {
                var id = a[0].id();
                this._id_map[id] = a[0];
            }

        }

    }),
    'get' : fp(function(a, sig) {
        // string, it's an id
        if (sig == '[s]') {
            return this._id_map[a[0]];
        } else if (sig == '[n]') {
            return this._arr[a[0]];
        }

        // number it's an index

    }),
    'insert' : fp(function(a, sig) {
        // can be given one object to insert, can be given an array of items
        // to insert?
        // not for actually inserting an array though. For use with controls
        // really, could be used with other objects.
        // Could maybe turn this off as an object in the construction.
        // maybe told to insert(control, position)

        console.log('insert sig ' + sig);
        // if (sig == '[')
        // checking for an array in the sig is tricky.

        if (sig == '[o,n]') {
            // will need to move the index of items above forward.

            this._arr.splice(a[1], 0, a[0]);
            for ( var c = a[1], l = this._arr.length; c < l; c++) {
                var item = this._arr[c];
                if (item.index) {
                    item._.index = c;
                }
            }
            this.length++;

        } else {

            if (tof(a[0]) == 'array') {

            } else if (tof(a[0]) == 'object' || tof(a[0]) == 'control') {
                // will need to move the ones after it up as well.

            }

        }

    })
});
var p = DataCollection.prototype;
*/
// Functionality for the control's IDs - that seems like its page_context,
// which could be part of html.

var _data_generators = {
    //'Ordered_String_List' : function() {
    //	// console.log('dg Ordered_String_List');
    //	return new Ordered_String_List();
    //}
}

// This could be useful for a few things, like storing tables in a DB
// schema.
// Maybe quite a few more things.

// Uses private variables.

// Different to sorted string list.
//  Indexed by the string too...



var truth = function(value) {
    return value === true;
}

// will put functions into the jsgui object.

// with the functions listed like this it will be easier to document them.

var extend = jsgui.extend, fp = jsgui.fp, stringify = jsgui.stringify, tof = jsgui.tof;


// Connecting these input processors in this instance to the Enhanced_Data_Object?



extend(jsgui.data_types_info, {

    'color': ['indexed_array', [
        ['red', 'number'],
        ['green', 'number'],
        ['blue', 'number']
    ]],
    'oltrb': ['optional_array', ['left', 'top', 'right', 'bottom']]
});

var create_input_function_from_data_type_info = function (data_type_info) {
    console.log('create_input_function_from_data_type_info data_type_info ' + stringify(data_type_info));

    if (tof(data_type_info) == 'array') {
        var secondary_instruction = data_type_info[0];
        var arr_items = data_type_info[1];
        //console.log('secondary_instruction ' + secondary_instruction);
        //console.log('tof(arr_items) ' + tof(arr_items));

        if (tof(arr_items) == 'string') {
            // the distance.
            // console.log('arr_items ' + arr_items);


            if (jsgui.data_types_info[secondary_instruction]) {
                // process it with that instruction, but need to have it operating with the data type given here,
                //  'distance'.

                // seems quite hard to do, may be a recursive process.
                //  optional array being the example here.

                // otlrb.

                // call a new procedure for otlrb?
                //  may need to automatically jump through some indirection.
                //   really, want to be layering functional processors.

                if (jsgui.data_types_info[arr_items]) {
                    // process it with that instruction, but need to have it operating with the data type given here,
                    //  'distance'.

                    // seems quite hard to do, may be a recursive process.
                    //  optional array being the example here.

                    // otlrb.

                    // call a new procedure for otlrb?
                    //  may need to automatically jump through some indirection.
                    //   really, want to be layering functional processors.

                    //console.log('processing ' + arr_items + ' according to ' + secondary_instruction);

                    // load up the oltrb item...
                    //  I think we need a reader for that.

                    // A constructor / a function that is an input processor for oltrb.
                    //  Test that, then use it here.


                }
            }
        }

        if (tof(arr_items) == 'array') {
            // process the secondary instruction...
            if (secondary_instruction == 'indexed_array') {

                var res = fp(function (a, sig) {

                    // check the arguments given... do they match what is expected?

                    // or if it is an object, put them into place in the correct position.

                    // data_types_info could have associated maps, attached to the data_types_info.

                    //console.log('input processor for dti ' + stringify(data_type_info));
                    //console.log('sig ' + sig);
                    // with an indexed array, there should be a dti.position_map

                    if (sig == '[[[n,n,n]]]') {
                        res = a[0][0];
                        return res;
                    }

                    // The preprocessor is dealing with these.
                    /*
                    if (sig == '[[s]]') {
                        // likely to best use some regex color matches.
                        //  could have a pre-input?
                        //  specifific formatting for color anyway, could use a preprocessor.

                    }
                    */

                    if (!data_type_info.map_pos) {
                        data_type_info.map_pos = {};

                        each(arr_items, function (i, v) {
                            console.log('i ' + i);
                            console.log('v ' + v);
                            data_type_info.map_pos[v[0]] = i;
                        });
                    }

                    if (sig == '[[o]]') {
                        // put the items from that object into an array.

                        var dtimp = data_type_info.map_pos;
                        var o = a[0][0];

                        var res = [];

                        each(o, function (i, v) {
                            var pos = dtimp[i];
                            console.log('pos ' + pos);
                            console.log('v ' + v);
                            res[pos] = v;
                        });
                        //console.log('res ' + stringify(res));
                        return res;
                    }

                    // also use regular expression identifiers for parsing from a string?

                    //throw '3) stop';
                    // then use data_type_info.map_pos

                    //console.log('data_type_info.map_pos ' + stringify(data_type_info.map_pos));

                });
                return res;
            }
        }
    }
}

// or just .extend('control');
//  Data_Object('control'); (not a constructor).

//var Control = Data_Object.extend({'data_type': 'control'});
//var Control = Data_Object.extend('control');


// could have an input preprocessor as well.
//  so that generalized functionality gets used too.

// Is really a CSS hex string -> [r, g, b] converter

// color parser...
//  want to parse the input
// color preprocessor_parser

var color_preprocessor_parser = fp(function(a, sig) {
    console.log('color_preprocessor_parser a ' + stringify(a));
    console.log('color_preprocessor_parser sig ' + sig);
    if (sig == '[s]') {
        var input = a[0];
        var rx_hex = /(#([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2}))/;
        var m = input.match(rx_hex);
        //console.log('m ' + stringify(m));

        if (m) {
            // Could use arrayify or something to make the conversion quicker... will do that in more places, mainly want to get the code working now.

            var r = jsgui.str_hex_to_int(m[2]);
            var g = jsgui.str_hex_to_int(m[3]);
            var b = jsgui.str_hex_to_int(m[4]);

            var res = [r, g, b];
            return res;
        }
    }

})


var color_preprocessor = (function (fn_color_processor) {
    var that = this;
    //throw '!stop';
    var res = fp(function (a, sig) {

        //console.log('color_preprocessor sig ' + sig);

        if (sig == '[[s]]') {
            //var new_input =
            // use regexes to detect / read the string.

            //var rx_hex = /^#?[a-fA-F0-9][a-fA-F0-9][a-fA-F0-9]$/;
            var rx_hex = /(#([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2}))/;
            //var rx_hex = /(#(([0-9A-Fa-f]{2}){3}))/;
            //var rx_hex = /(#([0-9A-Fa-f]{2}){3})/;
            var input = a[0][0];

            //var m = rx_hex.match(input);
            var m = input.match(rx_hex);
            //console.log('m ' + stringify(m));

            if (m) {
                // Could use arrayify or something to make the conversion quicker... will do that in more places, mainly want to get the code working now.

                var r = jsgui.str_hex_to_int(m[2]);
                var g = jsgui.str_hex_to_int(m[3]);
                var b = jsgui.str_hex_to_int(m[4]);

                var res = [r, g, b];
                return res;
            }

        } else {
            // call with the same arguments.
            //console.log('calling normal...');
            return fn_color_processor.apply(that, a);

        }
    });
    return res;
});

// In previous modules, it won't keep the same input_processors.
//  Is there a way of retrieving that from the most inner modules?
//test_Color();

// And inputting an indexed array.
//  Will need to accept 2d size inputs.
// Size could possibly be 3d, maybe 1d? A line has a size, which is also its length (though in the world of GUI it could also have
//  a thickness).

// Optional array looks more like a language feature (enhancement).
//  Or even a core language feature?


// There will be different types of optional arrays, will have different input parameters.
jsgui.input_processors['optional_array'] = fp(function (a, sig) {
    // would need to take in objects with the names of the properties as well.
    //  populate a sparse array with them.
    //   will make a very flexible HTML interface.
    //   controls will be able to have their properties changed in a flexible way, and output seamlessly to a wide variety of browsers.

    // the items in the index could be a bit more complicated, but we are going to say they are just strings for the moment.
    //  items_data_type_name...
    //   is the params an array of strings?
    // oa_params, input
    if (a.l == 2) {
        var oa_params = a[0],
            input = a[1];
        if (tof(input) == 'array') {
            // check it is within the right number.
            if (input.length <= oa_params.length) {
                return input;
            }
        } else {
            return input;
        }
    }
    if (a.l == 3) {
        var oa_params = a[0],
            items_data_type_name = a[1],
            input = a[2];
        // now need to get every item in the array or the item to conform to the given type.
        var input_processor_for_items = jsgui.input_processors[items_data_type_name];
        //console.log('input_processor_for_items ' + input_processor_for_items);
        //console.log('tof(input) ' + tof(input));
        if (tof(input) == 'array') {
            // check it is within the right number.
            if (input.length <= oa_params.length) {
                var res = [];
                each(input, function (i, v) {
                    res.push(input_processor_for_items(v));
                });
                return res;
            }
        } else {
            return input_processor_for_items(input);
        }
    }
    //console.log('oa_params ' + stringify(oa_params));
});

jsgui.input_processors['indexed_array'] = fp(function (a, sig) {
    // it may be taking some kind of data type that things need to be applied to.
    // eg 'size': ['indexed_array', ['distance', ['width', 'height']]],
    // would need to take in objects with the names of the properties as well.
    if (a.l == 2) {
        var ia_params = a[0],
            input = a[1];
        //console.log('ia_params ' + stringify(ia_params));

        if (tof(input) == 'array') {
            if (input.length <= ia_params.length) {
                return input;
            }
        }
    }
    if (a.l == 3) {
        var ia_params = a[0],
            items_data_type_name = a[1],
            input = a[2];
        var input_processor_for_items = jsgui.input_processors[items_data_type_name];
        if (tof(input) == 'array') {
            // check it is within the right number.
            if (input.length <= ia_params.length) {
                var res = [];
                each(input, function (i, v) {
                    res.push(input_processor_for_items(v));
                });
                return res;
            }
        }
    }
});

jsgui.input_processors['n_units'] = function (str_units, input) {
    // this will change things to have both the number of units and a string with the unit in an array.
    //  will make it easier to do maths on the distances.

    if (tof(input) == 'number') {
        return [input, str_units];
    }
    if (tof(input) == 'string') {
        //var rx_n_units = /^(?:(\d+)(\w+))|(?:(\d*)\.(\d+)(\w+))$/;
        var rx_n_units = /^(\d+)(\w+)$/;
        // then match it, should be multiple parts to the match.

        // Do want to get the various pieces working for the Control system.
        //  Then will be very nice indeed when compacted for a mobile-client.

        var match = input.match(rx_n_units);
        //console.log('match ' + stringify(match));

        if (match) {
            return [parseInt(match[1]), match[2]];
        }

        rx_n_units = /^(\d*\.\d+)(\w+)$/;
        match = input.match(rx_n_units);
        //console.log('match ' + stringify(match));
        if (match) {
            return [parseFloat(match[1]), match[2]];
        }
        //throw('stop');
    }
};
jsgui.map_data_type_data_object_constructors = jsgui.map_data_type_data_object_constructors || {};


var ensure_data_type_data_object_constructor = function (data_type_name) {
    //console.log('');
    //console.log('');
    //console.log('jsgui.map_data_type_data_object_constructors[data_type_name] ' + stringify(jsgui.map_data_type_data_object_constructors[data_type_name]));
    //console.log('');
    //console.log('');

    if (!jsgui.map_data_type_data_object_constructors[data_type_name]) {
        //console.log('html module: creating new Data_Object constructor for data_type: ' + data_type_name)
        //throw 'stop';
        // Need to get the variable back through the modules...
        //  Missing global variables?
        //  Move this function somewhere else?
        //  Maybe we could have some storage available in jsgui-lang-essentials through a closure.
        //  That way the code could be sent back... but do we still have different instances running?

        // Could just be different execution contexts... co can't feed back this information about other objects.
        //  But can feed functionality forards.

        // May need to have things more independant.

        //var dti = jsgui.get('dti');
        //console.log('dti ' + dti);
        //throw 'stop';
        var dto = jsgui.data_types_info[data_type_name];
       //console.log('dto ' + stringify(dto));
        //console.log()
        //throw 'stop';
        var dtc = Data_Object.extend({
            'fields': dto
        })
        dtc.prototype._data_type_name = data_type_name;
        jsgui.map_data_type_data_object_constructors[data_type_name] = dtc;
    }
    return jsgui.map_data_type_data_object_constructors[data_type_name];
}
jsgui.ensure_data_type_data_object_constructor = ensure_data_type_data_object_constructor;
//console.log('jsgui.input_processors ' + stringify(Object.keys(jsgui.input_processors)));
var dti_color = jsgui.data_types_info['color'];

jsgui.input_processors['color'] = function(input) {
    console.log('processing color input: ' + stringify(input));

    var input_sig = get_item_sig(input, 2);
    //console.log('input_sig ' + input_sig);

    if (input_sig == '[s]') input = input[0];

    var res = color_preprocessor_parser(input);
    // not sure that using the preprocessor is right...
    //  it returns a function, I think it applies to a function.
    throw '!!stop';
    //console.log('res ' + stringify(res));
    return res;
}

//color_preprocessor(create_input_function_from_data_type_info(dti_color));
jsgui.ensure_data_type_data_object_constructor('color');

jsgui.output_processors['color'] = function (jsgui_color) {
    var res = jsgui.arr_rgb_to_css_hex_6(jsgui_color);
    return res;
};

// collection needs a context...
//  can get the context from the first object.

// Grouping not working so well so far...
//  Maybe a less reflective way of making the group function?



var group = function() {

    // Hope this grouping system is not too slow.
    //  May be able to optimize / selectively make the grouping functions.

    var a = arguments;

    if (a.length == 1 && tof(a[0]) == 'array') {
        return group.apply(this, a[0]);
    }

    //var res = new Collection();
    var res;
    for (var c = 0, l = a.length; c < l; c++) {
        var item = a[c];

        if (c == 0) {
            res = new Collection({'context': item._context});

        }
        res.push(item);

    }

    var C = a[0].constructor;
    var p = C.prototype;

    //console.log('C ' + C);
    //console.log('p ' + p);

    for (i in p) {

        var tpi = tof(p[i]);
        //console.log('tpi ' + tpi);

        // if tpi is a function, then we can make a version for the collection.

        // need this to remember the function name... maybe with another closure.



        if (tpi == 'function') {
            // make a group version.

            (function(i) {
                //console.log('i ' + i);

                if (i != 'each' && i != 'get' && i != 'add_event_listener') {
                    res[i] = function() {
                        //console.log(i + ' called');
                        //console.log('called');
                        //throw 'stop';

                        // then for each of the items in the collection we call with the same parameters.
                        // But with which context?
                        //  Can we have a group context?

                        // this - will be the collection?

                        // then we need to call the collective function ...
                        //  on each of them?
                        var a = arguments;

                        res.each(function(i2, v) {
                            //console.log('i ' + i);


                            //v[i].apply(res, a);

                            // adding an event listener...

                            // do it differently?
                            //  have it so that the context is the object.
                            //   it needs to be that for the function to work.

                            // can that be changed so we give it another context?
                            //  so that it when the event happens, its triggered context is the group?
                            // group events will be very useful. then applying changes to a group.
                            v[i].apply(v, a);

                        })


                    }
                }
            })(i)



        }

    }

    //throw 'stop';


    // but the group methods...
    //  Collective methods.
    //   Could get the type of the first object.



    return res;

}

var true_vals = function(map) {
    var res = [];
    for (var i in map) {
        if (map[i]) res.push(map[i]);
    }
    return res;
}



var jsgui = extend(jsgui, {
//var jsgui = {
    'vectorify' : vectorify,
    'v_add' : v_add,
    'v_subtract' : v_subtract,
    'v_multiply' : v_multiply,
    'v_divide' : v_divide,
    'vector_magnitude' : vector_magnitude,
    'distance_between_points' : distance_between_points,
    //'arr_trim_undefined' : arr_trim_undefined,
    // 'remove_sig_from_arr_shell': remove_sig_from_arr_shell
    //'ll_set' : ll_set,
    //'ll_get' : ll_get,
    'execute_on_each_simple' : execute_on_each_simple,
    'mapify' : mapify,
    'filter_map_by_regex' : filter_map_by_regex,
    'atof' : atof,
    'npx' : npx,
    'no_px' : no_px,
    'str_arr_mapify' : str_arr_mapify,
    'arr_ltrb' : arr_ltrb,
    'true_vals': true_vals,

    // 'data_type_instance': data_type_instance,

    // 'data_types_info': data_types_info,

    //'input_processors' : input_processors,
    //'output_processors' : output_processors,

    // This is going to do a bit more to do with validation.
    //  Will validate according to types
    //  Will validate according to other specified requirements
    //   Type validation will be fairly easy... but do need to know what types are expected.
    //    Would be different ways of checking types, particularly with a class inheritance structure.
    //    'IS' type check.

    // Want to do checks I like I think is expressed in the HTML section.
    //  This will be integrated with form validation.
    // Will bring that functionality out of 'nested'.

    // Want to specify the requirements so that it can know to check for a property value.

    'validators' : validators,

    //'DataObject' : DataObject,
    //'Data_Object' : DataObject,

    // In some cases the wrapper will add difficulty / slowness.
    //  In others it could be useful for some precise number operations.

    //'KSVS': KSVS,
    //'KSVS_Cursor': KSVS_Cursor,

    //  DataValues could perhaps be addressable within a resource abstraction.

    //'Data_Value': Data_Value,
    //'Collection' : Collection,

    '__data_id_method' : 'lazy',
    // '__data_id_method': 'init',

    // 'DataCollection': DataCollection,

    'str_hex_to_int' : str_hex_to_int,
    'arr_rgb_to_css_hex_6' : arr_rgb_to_css_hex_6,

    // These are likely to be deprecated in favour of having lang handle
    // these internally and exposing add_data_type, which will be mapified.

    /*
     * 'populate_any_maps': populate_any_maps,
     * 'populate_optional_array_pos_maps': populate_optional_array_pos_maps,
     * 'populate_indexed_array_pos_maps': populate_indexed_array_pos_maps
     */
    // 'populate_all_dt_maps': populate_all_dt_maps,
    '_data_generators' : _data_generators,

    'group': group

    //'Ordered_String_List' : Ordered_String_List,

});
//console.log('jsgui.input_processors ' + stringify(jsgui.input_processors));
// var jsgui = {};
// alert('returning jsgui from jsgui-lang');
//return jsgui;
module.exports = jsgui;
//});

},{"./collection":25,"./data-object":28,"./data-value":29,"./evented-class":31,"./jsgui-data-structures":35,"./jsgui-lang-essentials":37}],39:[function(require,module,exports){

/*
define(['../../web/jsgui-html', './client-resource', './pool'],

	function(jsgui, Resource, Resource_Pool) {
*/

var jsgui = require('../../web/jsgui-html');
var Resource = require('./client-resource');
var Resource_Pool = require('./pool');


	// Client_Resource?
	//  I think that makes sense, so that we have something specific which has the URL attached.
	//   It is able to make HTTP requests to the server resource.



	
	var stringify = jsgui.stringify, each = jsgui.each, arrayify = jsgui.arrayify, tof = jsgui.tof;
	var filter_map_by_regex = jsgui.filter_map_by_regex;
	var Class = jsgui.Class, Data_Object = jsgui.Data_Object, Enhanced_Data_Object = jsgui.Enhanced_Data_Object;
	var fp = jsgui.fp, is_defined = jsgui.is_defined;
	var Collection = jsgui.Collection;
	
	//var exec = require('child_process').exec;

	// Perhaps this will have HTTP endpoints as well?
	//  Maybe we can access it through url/resources/

	// Perhaps a resource publisher, or a few of them could be useful.
	//  HTTP_Resource_Publisher?
	//  Generally publishes a resource over HTTP.
	//   Will have some authorization and authentication properties, hooked up with the proper providers.

	// This may be the place in which remote access to the resources is given.
	//  It would make sense.
	//  Perhaps it is worth using a resource publisher? Then is that a resource?
	//  I think the resource pool may be the sensible point of access.
	
	var Client_Resource_Pool = Resource_Pool.extend({
		'fields': {
			'url': String
		},
		'init': function(spec) {
			this._super(spec);



			
			// will add the Resource_Local_Server_Information
			
			
			// Will be nice to set them with an object.
			//  Not just the normal spec.
			//  Maybe can see if the spec matches fields?
			//  Or copy fields from the spec?

			// Have remote server info
			//  Allow for info on a number of different remote servers.
			//   (0 will be the one it got served from or the equivalent jsgui service provider)
			// Have local browser info
			// Other local info as necessary



			/*
			var lsi = new Local_Server_Info({
				'meta': {
					'name': 'Local Server Info'
				},
				'startup_type': 'auto',
				'access': {
					'full': ['server_admin']
				}
			});
			
			this.add(lsi);
			*/

			// And a resource publisher resource.
			//  It goes in the pool, and it publishes other resources (over HTTP)
			//   The resource pool contains its own publisher.

			/*
			var publisher = new Resource_Publisher_HTTP({
				'meta': {
					'name': 'HTTP Resource Publisher'
				},
				'startup_type': 'auto',
				'access': {
					'full': ['server_admin']
				}
			});
			
			this.add(publisher);

			*/
			
			
		},
		'start': function(callback) {

			// download the resource information from the server...
			//  http request.

			// Think that will be in jsgui-client.
			//  It's worth making the jsgui-client bundle

			// Maybe some other jsgui client bundles, like jsgui-client-platform
			//  including all platform client components. Then there could be some other builds that include more thigns still,
			//  like bunches of controls / components for different customers / websites.

			//console.log('Client_Resource_Pool start, window.location ' + window.location);

			// need to get the resources url...


			var _request_resources = function() {
				var loc = window.location.toString();
				var pos1 = loc.indexOf('//');
				var pos2 = loc.indexOf('/', pos1 + 2);
				var part1 = loc.substr(0, pos2 + 1);
				//console.log('part1 ' + part1);

				var that = this;

				// carry out the HTTP request.
				//  Use the result to initialize the various resource objects in a collection...
				//  or using the pool really.

				// Perhaps the client pool will have been told what resources are there.
				//  Also, the client pool could be used to access a single resource on the server, and have a bunch of resources available on the client.
				//  These resources will be a bit like global variables with an asyncronous interface.

				// Not sure about assuming the server will provide the resources list a /resources

				// We don't want that default, it makes an extra requirement for the server to fulfill.

				
				this.set('url', urlResources);

				var urlResources = part1 + 'resources';
				console.log('urlResources', urlResources);

				// An http abstraction may be good for older browsers, or polyfill elsewhere.
				var oReq = new XMLHttpRequest();
				oReq.onload = function(res) {
					console.log('oReq.responseText ' + oReq.responseText);

					var objResponse = JSON.parse(oReq.responseText);

					// Then for each of them we create an object.

					if (tof(objResponse) == 'array') {
						each(objResponse, function(i, v) {
							var tv = tof(v);

							if (tv == 'string') {
								// it's the name of the Resource.

								var resource = new Resource({
									'meta': {
										'name': v,
										'pool': that,
										'url': urlResources + '/' + v
									}
								});
								that.add(resource);
								//console.log('resource', resource);
							}
							if (tv == 'object') {
								//console.log('v', v);
								var resource = new Resource({
									'meta': {
										'name': v.name,
										'pool': that,
										'url': urlResources + '/' + v.name,
										'type_levels': v.type_levels
									}
								});
								that.add(resource);

							}
						})
					}

				};
				oReq.open("get", urlResources, true);
				oReq.send();
			}

			callback(null, true);


			



			/* From resource_pool init.



			this._resources = new Collection({
				'index': {
					//'sorted': [['name']] // similar to above, but literally it's a single index in a list of indexes, that index just has one field, in a list of fields
					
					// The syntax for specifying a (sorted) index is for an attached field.
					//  It gets the data for the attached object.
					// {'attached': {'meta': 'name'}}
					'sorted': [[{'attached': {'meta': 'name'}}]]
					//sorted: [[['attached', 'meta', 'name']]]
				}
			});

			*/





			// http://192.168.1.14:5009/resources
			//  not so sure it needs to make an HTTP request.
			//  Perhaps it can find out about the resource types?

			// Though, the resource pool having the basic information about the resources makes a lot of sense.
			// Perhaps have some more information about the resource, metadata about what they do?
			//  Their API versions?

			// Some resource type info would help.
			//  There could be published APIs on how to access particular resources, maybe call them interfaces.

			// ["Local Server Info","HTTP Resource Publisher","Login HTML Resource","Application Router","Local File System","Web Admin","Info","Site JavaScript","Site CSS","Site Images","Authentication","metabench"]

			// Local Server Info
			//  See a bit of info about the local server
			// HTTP Resource Publisher
			//  Determine how HTTP resources get published? Will see what would be good to administer here, but
			//  we want many of the settings to be open.
			// Web Admin
			//  Would be a good resource to interact with. Through resource mechanisms we will be able to alter the
			//  content of the website.
			// Local File System
			//  Having access to the server file system.
			//   Could modify the site files as they are running.
			// Info
			//  This is a particular database table I think.
			// metabench
			//  This is a database.

			// Identifying the types of resources when /resources is called would be useful. A bit more metadata too
			//  if appropriate.





		}
		
	})
module.exports = Client_Resource_Pool;
	
	
	//return Client_Resource_Pool;
	
	
//});
},{"../../web/jsgui-html":50,"./client-resource":40,"./pool":41}],40:[function(require,module,exports){
// But is this part of the html client, or it uses the html client.

// The client has page context.
//  Page context has the resource pool.

// So, client-resource will need html-enh I think, but not the client system.


/*
define(['../../web/jsgui-html-enh', './resource'],
	function(jsgui, Resource) {
*/
var jsgui = require('../../web/jsgui-html-enh');
var Resource = require('./resource');

var stringify = jsgui.stringify, each = jsgui.each, arrayify = jsgui.arrayify, tof = jsgui.tof;
var filter_map_by_regex = jsgui.filter_map_by_regex;
var Class = jsgui.Class, Data_Object = jsgui.Data_Object, Enhanced_Data_Object = jsgui.Enhanced_Data_Object;
var fp = jsgui.fp, is_defined = jsgui.is_defined;
var Collection = jsgui.Collection;

// Extends AutoStart_Resource?

// May need to change around a fair few references to make it workable.
// May need some more complicated logic to change it to the path for service.

// There can be a client app that's specifically for a resource.
//  That's a special case.
// Other client side apps will access multiple resources.
//  They can do this through a Resource_Pool.
//  There could be client-side resources that make use of information sharing between these client and server side resources.




// This client resource could reference a remote resource.

// Will have client-remote-reference resource
//  maybe just client-remote
//  will work in a similar way to remote or node-remote in terms of API, but internally it will do HTTP calls differently.
//  Possibly could just use jsgui though, have it expose the same API for node and the client.

// This one is still fairly abstract.
//  It will be the client-remote-link resource which will have the functionality.
//  client-remote-link will connect with websockets to get events
//  it will do get with http.


// A resource control will recieve events from the client resource.
//  It may also ensure it has been set up.

// Also a Resource_Client file that sets up a resource connection with a particular resource?
//  Maybe don't set up such abstract resource linking for the moment?

// With the Resource-Client architure, we could define the back-end in terms of a Resource, and not need to write various pieces of boilerplate for them
//  to communicate with each other.


// Resource_Client may be a necessary JS file.
//  Would be JavaScript that runs on a page that's for when it's the client for a single resource?

// With the clock resource, would want it to have a resource control.
//  That control could possibly speak to the resource directly.
//  It could possibly speak to a client-side resource / aggregator that then speaks to the server resource.

// Serving a page with a component that connects back to the resource...
//  I think a lot of the activity will be in the user control,
//  however, it may be that the user control will just be making use of the client-side resources or client-side resource pool.


var ends_with = function(str, suffix) {
    return str.indexOf(suffix, str.length - suffix.length) !== -1;
}

var Client_Resource = Resource.extend({
    //'fields': {
    //	'url': String
    //},

    'init': function(spec) {
        this._super(spec);

        if (spec.meta) {
            var meta = spec.meta;
            console.log('1) meta.url', meta.url);
            if (meta.url) this.meta.set('url', meta.url);
            if (meta.type_levels) this.meta.set('type_levels', meta.type_levels);


            //console.log('meta.name ' + meta.name);
        }

        this.data = new Data_Object();

        var that = this;


        // both in one parameter here?


        // Why not listen to the resource's data directly?
        //  Should not be a problem when doing it on the client?


        this.data.on('change', function(property_name, property_value) {
            //console.log('');
            //console.log('resource data change property_name', property_name);
            //console.log('property_value', property_value);

            that.trigger('change', property_name, property_value);

        })


        //this.meta.set('custom_paths', new Data_Object({}));
        // Those are custom file paths.

        // could have a collection of directories, indexed by name, that get served.

        // Index the collection by string value?
        //this.meta.set('served_directories', new Collection({'index_by': 'name'}));

        // Will also have a URL.
        //  The client resource pool will have a base url.
        //   Maybe default base URL, it's set up to communicate with the server that served the HTML document.

        // could have a variety of server URLs, but let's deal with one for the moment.


    },
    'get': fp(function(a, sig) {
        var url, callback;
        var url_path;
        if (a.l === 1) {
            url = this.meta.get('url').value();
            callback = a[0];
        }
        if (a.l === 2) {
            url_path = a[0];
            callback = a[1];

            //console.log('url_path', url_path);

            url = this.meta.get('url').value() + url_path;
        }

        // should be able to supply the url

        //var

        // jsgui lang essentials ends function
        //  test if a string ends with something.

        var ends_dot_json = ends_with(url, '.json');
        //console.log('ends_dot_json', ends_dot_json);

        var json_url;

        if (!ends_dot_json) {
            json_url = url + '.json';
        } else {
            json_url = url;
        }

        //console.log('json_url', json_url);
        jsgui.http(json_url, function(err, res) {
            if (err) {
                callback(err);
            } else {
                //console.log('res', res);
                callback(null, res);
            }
        })
    }),

    // We don't notify it this way.
    //  Thinking of making a serparate Resource that uses websockets or sockjs. Should continue to have the normal non-sock client-side resource as well.
    ///  Will not make its own HTTP connections.




    // Not that clear how this type of resource will receive these change notifications.
    //  Seems less likely that we will need this function here.
    //  06/06/2015 - about to make the socks resource connection for the client, it's going to allow for real-time updates, while using generally RESTful addressing.

    'notify_change_from_server': function(property_name, property_value) {
        // needs to do some kind of silent set.

        //console.log('client resource notify_change_from_server');

        var data = this.data;

        //console.log('data', this.data);

        // may need to do a set with options, such as {silent: true};
        //  may need to define message propagation in more detail.
        // Will need to have it working by default, but various things explicitly set in the messages to determine where the message gets
        //  sent to, and presented in which way, including messages acknowlwdging that a previous message has been processed.

        // Don't want this to be too complicated.
        //  I think without much more code we will have the functionality.

        // Could do more detail in some areas later on.




        this.data._[property_name] = property_value;

        // also different ways of raising events or options for the events that are raised.
        //  May need to include more change event metadata.
        //   Such as what initiated the event. Perhaps a user.
        //    Maybe info on the event processing chain. Such as user,data_object
        //    or remote,data_object

        // So the system can tell where the change came from, it can know how to propagate the change and how and whether to acknowledge it.

        // It may be worth having message IDs.
        //  Also aggregating messages that get sent from the server.
        //  Could have submessages within an original one.

        // Want a simple enough core to this.
        //  Easy to understand and powerful, and then more complexity can be built on top of that.

        // I think more properties in change events could be helpful.
        //  The change events could be used in processing the events in some cases, and want to avioud ambiguity and infinite loops.
        // Sending a few extra string codes such as it's initiator, possibly a message id that is the change notification, will help the app process
        //  the changes as they take place in different places.

        // Resource changes on the server. Message sent to clients. Clients change the data in corresponding client-side resource. Client components
        //  listen for changes to the local resource and respond accordingly.

        // Will be using different types of change binding.
        //  There will be some complexity there.
        //  It's going to work easily with default configurations.
        //   Will be very fast to set something up as a resource, and the defaults will make sense.

        // There will be a few different information lifecycles, with changes initiating in various places and being propagated to
        //  various other places.

        //  Could be a place for security to validate that whatever is making the change has got the authority to do so.

        // The change event handling in the Data_Objects probably require more work to them.
        //  Making it so that with different types of changes they notify different things about it.

        // A resource publisher could be listening for changes in a data_object on a server.
        //  The changes originate from the server, and are to be viewed as the 'correct' version of the information.

        // There could be some read-only data sources, like a clock on the internet.
        //  Or setting its time would involve setting the computer's system time. Possibly, but something that may need higher security.

        // The simple clock example will just send data fro mthe server. That data is read-only.
        //  It will be good to make enough detail about the data is sent.
        //  Will be interesting to use this clock example for some other types of data transmission, such as peer-to-peer, with the peers running
        //  node.js and being coordinated by a central server. The central server would send its updates to only some of the clients, and
        //  those clients would send it on. Could maybe have a central system defining where the clients are, and what hops of the chain it is.
        // Could also have the central system maintain keys. Public key encryption. Communication between clients could be encrypted. They could be encrypted
        //  so that other clients would not understand them, and so they need to speak to the client they are assigned by the central server.






        // When a client-resource changes, it may send it's info to the server?
        //  Or only when set is called?


        this.data.trigger('change', property_name, property_value);

        // Or the resource listens to data changes, triggers change on itself when the data changes.

        // Or change on the resource itself I think.







    }
    //'start': function(callback) {
    //	callback(null, true);
    //}
});

module.exports = Client_Resource;
},{"../../web/jsgui-html-enh":48,"./resource":42}],41:[function(require,module,exports){
// Maybe it has different requirements in node.
//  Could possibly load these ones seperately if it's a node environment.

// This seems a lot to do with the server-side resource pool.
//  However, it may be worth having a client-side resource pool operate fairly similarly.

// Having some specific JSON and HTML interfaces to some resources would be nice
//  as well as having the system be able to explain such resources.
//   maybe resource/meta

// This could possibly get published by a resource publisher.

/*
if (typeof define !== 'function') {
    var define = require('amdefine')(module);
}


define(['../../web/jsgui-html', './resource'], 

	function(jsgui, Resource) {
*/
var jsgui = require('../../web/jsgui-html');
var Resource = require('./resource');
	
	var stringify = jsgui.stringify, each = jsgui.each, arrayify = jsgui.arrayify, tof = jsgui.tof;
	var filter_map_by_regex = jsgui.filter_map_by_regex;
	var Class = jsgui.Class, Data_Object = jsgui.Data_Object, Enhanced_Data_Object = jsgui.Enhanced_Data_Object;
	var fp = jsgui.fp, is_defined = jsgui.is_defined;
	var Collection = jsgui.Collection;

	// Should work to get this closer to the desired get/set resource interface.
	//  That would help with administering it.
	//  Also would make subresources available, these would have their own interfaces.

	// Not sure if the Resource_Pool should have an HTTP endpoint... maybe Server_Resource_Pool?



	// Keeps track of resources available within JavaScript process (browser or node.js).
	var Resource_Pool = Resource.extend({

		'init': function(spec) {
			this._super(spec);
			
			// Sorting them by a Data_Object's.meta name?
			//  need an easy way of expressing this.
			//  meta('name')?
			//  attached('meta', 'name')

			// I think indexing by attached Data_Object properties makes sense.
			//  That would mean defining an index as applying to an attached object.
			//   in this case 'meta'

			// sorted: [['attached', 'meta', 'name']]
			//  does not look nice, but it gets the point accross.
			//  hopefully would not be confused.
			//  One sorted index by its meta.name
			// I think the attached keyword makes sense here as meta is attached to the object rather
			//  than really a component of the object itself.

			// I think registering object attachments makes sense.
			//  That is more core-level work and I want to draw an end to that for the moment.
			// Object attachments being another interesting part which will be worthwhile.


			this._resources = new Collection({
				'index': {
					//'sorted': [['name']] // similar to above, but literally it's a single index in a list of indexes, that index just has one field, in a list of fields
					
					// The syntax for specifying a (sorted) index is for an attached field.
					//  It gets the data for the attached object.
					// {'attached': {'meta': 'name'}}
					'sorted': [[{'attached': {'meta': 'name'}}]]
					//sorted: [[['attached', 'meta', 'name']]]
				}
			});
			
		},

		'resources': fp(function(a, sig) {
			if (sig == '[]') {
				return this._resources;
			}
		}),
		
		'_get_resources_by_interface': function(i_name) {
			var res = [];
			
			this._resources.each(function(i, resource) {
				console.log('resource ' + resource);

				// Not so sure we should treat 'get' like that for the resource.
				//  The resource may be a list of items, one of which is called 'interface'

				// Need that one on a lower level.
				//  Like resource.interface



				var i = resource.get('interface');
				if (tof(i) == 'string') {
					if (i == i_name) res.push(resource);
				} else if (tof(i) == 'array') {
					var done = true;
					each(i, function(i2, v) {
						if (!done) {
							if (i == i_name) res.push(resource);
							done = true;
						}
					})
				}
				
			})
			
			if (res.length > 1) return res;
			return res[0];
			
		},
		
		'index_resource': function(obj) {
			// will get some metadata from the resource.
			
			// resource will be indexed by its location and its type.
			//  so will be able to find the local postgres dataabase that way
			
			// There will be different levels of locality
			//  May be a shorthand for the time and difficulty in communicating between two locations
			
			// in-process
			// same machine
			// lan (same data centre)
			// internet, same region
			// internet
			// stellar (could have more variations perhaps but will not be necessary for most applications)
			
			// to begin with, there will likely be some in-process resources.
			//  some of these resources could be resource connectors.
			
			
		},
		
		'receive_resource_event': fp(function(a, sig) {
			//console.log('receive_resource_event sig ' + sig);
			
			if (sig == '[D,s,[s,s]]') {
				var data_object = a[0];
				//console.log('data_object ' + stringify(data_object));
				
				//console.log('a[1] ' + a[1]);
				//console.log('a[2] ' + stringify(a[2]));
				
			}
			
			if (sig == '[D,s]') {
				var data_object = a[0];
				//console.log('data_object ' + stringify(data_object));
				//console.log('a[1] ' + a[1]);
				
				var event_name = a[1];
				//console.log('event_name ' + event_name);
				// could be that it has started?
				
				
				// then need to raise this event.
				
				
				
				
				// so if an resource has started, could have a particular handler for that.
				
				// There will be groups of resources that are needed for other ones to start.
				//  When one of these resources has loaded, it will check to see if others have also loaded.
				// This should be done with fairly fast algorithms, we don't want the system to slow down as it is getting going.
				
				
				
				
				
				
				
			}
			
		}),
		
		'add': function(obj) {
			// adds the resource obj to the pool.
			
			// Each resource will have its own individual name within the pool.
			//  There may be resources that get put into groups too.
			var that = this;
			
			//console.log('obj ' + stringify(obj));

			var obj_name = obj.meta.get('name');
			
			//console.log('** obj_name ' + obj_name);
			
			if (this.has_resource(obj_name)) {
				throw 'Resource pool already has resource with name ' + obj_name;
			} else {
				
				//this._dict_resources[obj_name] = obj;
				
				// raise an event saying that the resource was added.
				
				this._resources.add(obj);
				//obj.parent(this);

				// don't think we can do it like that.
				//  obj.set('pool', this);
				//  the resource could have a 'pool' object of its own, the resource could hold sports results
				//   for example.

				obj.meta.set('pool', this);
				


				this.raise_event('added', obj);
				// listen to events from that resource.

				// Do we want just a general listener for events?
				//  So we listen to any event from it?
				//obj.add_event_listener(that.receive_resource_event);
				
			}
			
			
		},
		'push': function(obj) {
			return this.add(obj);
		},
		'has_resource': fp(function(a, sig) {
			
			
			//return is_defined(this._dict_resources[resource_name]);
			
			//return 
			
			if (sig == '[s]') {
				// one string value, that will be the value of the unique primary index
				
				var obj_lookup_val = a[0];
				
				return this._resources.has(obj_lookup_val);
				
			}
			
			
			
		}),
		
		// Likely to just be 'get', with it returning resources inside.
		//  And perhaps going through an adapter.

		// Can not get the actual resource as a programming object if it is remote.
		//  In that case, we need to use a transport mechanism.

		// Need to be able to access the resources' data with a convenient interface, not having to write repeated HTTP plumbing.

		


		'get_resource': fp(function(a, sig) {
			//console.log('get_resource sig ' + sig);
			
			//return is_defined(this._dict_resources[resource_name]);
			//return 
			
			if (sig == '[s]') {
				// one string value, that will be the value of the unique primary index
				
				var obj_lookup_val = a[0];
				//console.log('this._resources ' + stringify(this._resources));
				//throw 'stop';
				//console.log('obj_lookup_val ' + obj_lookup_val);

				//console.log('this._resources ' + stringify(this._resources));

				// needs to check ['meta'].name
				//  meta is not accessed through the normal interface.
				//   perhaps we could have a .meta for dealing with properties like name
				//   the resource's get and set should be an unobstructed interface to the resource
				//   itself.

				// Indexing a Data_Object not by it's normal contents, but by metadata or 
				//  other attached objects.

				// I think Data_Object and Resource meta(data) indexing makes the most sense.

				// Data_Object.meta could make a lot of sense.
				//  We could possibly have the same name field in some cases.
				//  Meta makes the most sense for resources. Perhaps only use them there as they enable the
				//   direct object interface.

				// However, the collection of resources in a pool may need indexing by the name field
				//  which is within 'meta'.

				//var res = this._resources.find('name', obj_lookup_val)[0];
				//console.log('obj_lookup_val ' + obj_lookup_val);
				//var res = this._resources.find('["attached", "meta", "name"]', obj_lookup_val)[0];

				// Need to say it's finding a single attached field.
				//  don't want this to be misunderstood for three fields to look for.
				// Perhaps need to think about and formalise the API a bit more.
				//  But getting it to work will be a great help!

				// Collection.find syntax.

				// Find requests... perhaps they could take more work to make a fully flexible and 
				//  intuitive format.
				// ["attached", "meta", "name"] basically being one field in this context.

				// This could quite possibly do with more specification work done outside of the Resource_Pool.

				// .findInAttched('meta', 'name') would search the attached fields.

				// Indexing within the attached fields.

				// Treating the attached fields as just one field name within the index?
				//  But can we tell the difference between ["attached", "meta", "name"] and a collection / array
				//   of fields?

				// {'attached': 'meta.name'}
				//  That may be better for attached fields.
				//  The field is held by an object, which would not get confused with a plural.

				// {'attached': {'meta': 'name'}} - would work for multi-level attachments
				//  Multi-level attachments?

				// {'attached': {'meta': {'attached': {'secondAttachment': 'fieldName'}}}}
				//  That could work for multi-level attachments

				// Attached fields as object makes a lot of sense.



				// we can have a look at the index in the find function




				//var res = this._resources.find(["attached", "meta", "name"], obj_lookup_val)[0];
				//console.log('pre find resource');

				// Not sure it's being indexed properly by attached properties.



				var res = this._resources.find({'attached': {'meta': 'name'}}, obj_lookup_val)[0];
				//console.log('post find resource');

				//var res = this._resources.find(stringify(["attached", "meta", "name"]), obj_lookup_val)[0];
				//console.log('this._resources.length() ' + this._resources.length());
				//console.log('res ' + stringify(res));
				
				return res;
				
			}
			
			
			
		}),
		
		// have resources as a field?
		//  Means no need for the boilerplate code when it is linked.
		//'resources'
		
		
		// May be useful to have a callback parameter here rather than just publish / subscribe.
		
		'start': function(callback) {

			//console.log('resource pool start');

			// needs to look at the various resources in the pool.
			//  start each of them if they are supposed to start automatically.
			
			
			var arr_resources_meeting_requirements = [];
			
			//console.log('this._resources.length() ' + this._resources.length());
			
			this._resources.each(function(i, v) {
				//console.log('i ' + i);
				//console.log('v ' + stringify(v));
				
				// if it has all its requirements met, start it.
				
				// requirments - there may be conditional requirements in the future (like email address is not required when a Facebook profile URL is given), but for the moment each requirement is required
				//  could still be similar, with OR composite requirements.
				
				// check if the resource meets the requirements...
				//console.log('pre meets_requirements');
				var mr = v.meets_requirements();
				//console.log('post meets_requirements');
				
				// and need a callback for when they all have started.
				
				//  I think doing the requirements network planning before starting will be the best way.
				//   That could get things to start very efficiently.
				
				//console.log('meets_requirements ' + mr);
				if (mr) {
					//v.start();
					arr_resources_meeting_requirements.push(v);
				}
			});
			
			//console.log('arr_resources_meeting_requirements.length ' + arr_resources_meeting_requirements.length);
			var l_resources = this._resources.length();
			//console.log('l_resources ' + l_resources);


			
			if (arr_resources_meeting_requirements.length == l_resources) {
				
				var fns = [];
				
				// can do this without call_multi - though I would prefer to use call_multi and have it work by a long way.
				
				var num_to_start = arr_resources_meeting_requirements.length;
				
				//console.log('num_to_start ' + num_to_start);
				//throw 'stop';
				
				var num_starting = 0, num_started = 0;
				var cb = function(err, start_res) {
				    num_starting--;
				    num_started++;
				    //console.log('cb');
				    //console.log('num_started ' + num_started);
				    
				    if (num_started == num_to_start) {
				        callback(null, true);
				    }
				}
				
				each(arr_resources_meeting_requirements, function(i, resource_ready_to_start) {
				    //console.log('');
				    //console.log('');
				    //console.log('resource_ready_to_start ', resource_ready_to_start);
				    //throw 'stop';
				    // should give the context OK.
					//fns.push([resource_ready_to_start, resource_ready_to_start.start, []]);
					//console.log('pre resource start');

					// But starting with the wrong context???
					resource_ready_to_start.start(cb);
					//console.log('post resource start');
					
					num_starting++;
					// but the callback...
					
					//fns.push([function(callback) {
					//    resource_ready_to_start.start(callback);
					//}, []])
					
				});
			}
			
			
		}
	});
	
module.exports = Resource_Pool;
	//return Resource_Pool;
	
	
//});
},{"../../web/jsgui-html":50,"./resource":42}],42:[function(require,module,exports){
// Want to get the core resources working and tested.
//  Want to run a clock website / service to start with.
//  The server could have a clock, while clients could connect to it and share the information.
//  Could also experiment with P2P distribution of the data.
//  A clock is also useful because it contains time signals so we can see how long it takes for data to reach various machines.


// Intersted in having a remote Linux computer.
//  Ability to SSH into it and run commands.

// Want to be able to remotely configure and access a Raspberry Pi as a Resource.





var jsgui = require('../../core/jsgui-lang-util');

var Class = jsgui.Class, Data_Object = jsgui.Data_Object, Collection = jsgui.Collection;
var is_defined = jsgui.is_defined, fp = jsgui.fp, stringify = jsgui.stringify, tof = jsgui.tof;
var call_multiple_callback_functions = jsgui.call_multiple_callback_functions, call_multi = jsgui.call_multi;
var each = jsgui.each;

// Status to see if a resource has started or not?
//  I think resource status is important.
//  However status may entail more things.
//   status.phase
//   phase

// meta.phase

// A resource's context matters.
//  It will be the server rather than a page context.



// Resources can have events as well.
//  Look into how the publisher deals with them.


var Resource = Data_Object.extend({
    // The link between the abstract resource and the resource on the internet / network / computer.
    //'fields': {
    //	//'meta': Data_Object
    //	'meta': 'data_object'
    //},

    'init': function(spec) {
        //
        if (!is_defined(spec)) spec = {};

        this._super(spec);

        if (is_defined(spec.name)) {
            // Need to deal with both resource properties and inner properties.
            //  Not sure about having resource.set('name') naming the resource.
            //   Sounds OK normally, but Resource needs to be flexible, eg a resource could provide
            //   translations of a work to a different language, so get('name') needs to just be calling
            //   the resource with that value.

            // Perhaps some kind of inner get and set?
            // Or inner is the normal.
            //  An object to represent a resource's external properties?

            // Could have .name for it's name
            //  or .self for a Data_Object that refers to itself.
            //  or .inner or .resource for the Data_Object that is the resource's inner data?
            //  .data

            // I like having .get and .set for dealing with the resource's data.
            //  and different ways for indexing the resource.

            // .metadata

            // and name is part of the metadata.

            // this.set('meta.name')

            // This way there is a .meta object which holds the name




            //this.set('meta.name', spec.name);
        }
        this.meta = new Data_Object({
            'fields': {
                name: 'string'
            }
        });

        // But give the resource name in the spec?
        //  That may be the best way of doing it, but it's not the API for now.


        if (spec.meta) {
            var meta = spec.meta;
            if (meta.name) this.meta.set('name', meta.name);
            //console.log('meta.name ' + meta.name);
        }
        // Set the meta url in the client side resource.

        if (is_defined(spec.startup_type)) {
            this.set('startup_type', spec.startup_type);
        }

    },

    'start': function(callback) {
        // check the requirements

        //  check requirements recursive - checks the requirements of everything required, and if they have the check_requirements function, it uses that.
        //   I think using the system of names APIs will help here.

        // I think the base class should raise the event.

        //this.trigger('start');

        //console.log(new Error().stack);
        //throw 'no start function defined for resource (subclass)'

    },

    // meets_requirements
    //  check if all the prerequisite resources are active
    //  maybe check for login status if applicable.

    'meets_requirements': function() {
        // Likely will be part of Status

        //return false;

        return true;
    },

    // 'get' will be the function to use.

    // may have toJson / to_json.
    'get_abstract': function() {

        // Abstract_Resource - would be a description of a resource?
        //  Perhaps we'll only need json and json schema.
        //  Making the data_object and collection conform to json schema would be nice.
        //  Would have something very nice to do with creating a gui for forms.
        /*


        var res = new AR.Abstract_Resource({

        })
        */
    },

    // the last item in the signature is the callback

    'set': fp(function(a, sig) {

        //console.log('Resource.set sig ' + sig);
        //console.log('Resource.set a ' + stringify(a));
        var last_param = a[a.l - 1];
        var callback;

        if (tof(last_param) == 'function') {
            callback = last_param;
            var arr_params = a.slice(0, a.l - 1);
            var res = this._super.apply(this, arr_params);
            callback(null, res);

        } else {
            // but why is a callback still needed?
            //  because in super, it requires a callback when it calls 'get', which is the newer get.

            var res = this._super.apply(this, a);
            return res;
        }




    }),

    // Can we expect a Resource to return its data as a Resource?
    //  Maybe not always




    'get': fp(function(a, sig) {

        //console.log('Resource get sig', sig);

        // if it does not have a function in the sig, it's syncronous

        var is_async = sig.indexOf('f') > 0;

        if (is_async) {
            var callback;
            var last_param = a[a.l - 1];
            if (tof(last_param) == 'function') {
                callback = last_param;
            }
            if (callback) {
                var arr_params = a.slice(0, a.l - 1);
                //console.log('arr_params.length ' + arr_params.length);
                // _super with fp?

                // context with fp?
                // Need to sort out super with fp!
                //  Though super may well use fp anyway.


                //console.log('this._super ' + this._super);
                //console.log('resource arr_params ' + stringify(arr_params));
                //var res = this._super.apply(this, arr_params);

                // We can apply a collection resource's get asyncronously?
                //  Possibly upgrade collection and data_object to handle async operations (though it's not async code)

                // if it is a resource?
                //  have an indicator on a function to see if it is async or not?
                //  asyncify?

                //



                var res = this._super.apply(this, a);
                return res;



                //console.log('res ' + stringify(res));
                //callback(null, res);
            }
        } else {
            //var stack = new Error().stack;
            //var message = 'Resource.get requires a callback (err, result) as its last parameter';
            //console.log(message);
            //console.log(stack);

            //throw

            var res = this._super.apply(this, a);
            return res;
        }




    })

});

/*
var Web_Resource = Resource.extend({
    'init': function(spec) {
        this._super(spec);
    },
    'respond': function(res, req) {

    }

})

var Html_Resource = Web_Resource.extend({
    'init': function(spec) {
        this._super(spec);
    }
})


var Resource_Error = Data_Object.extend({
    'init': function(spec) {
        this._super(spec);

        if (spec.text) {
            this.set('text', spec.text);
        }
    }
});

var res = {
        'Resource_Error': Resource_Error,
        //'Resource_Connector': Resource_Connector,
        'Resource': Resource,
        'Web': Web_Resource,
        'Html': Html_Resource
}

return res;
*/

module.exports = Resource;
	//return Resource;
//});

},{"../../core/jsgui-lang-util":38}],43:[function(require,module,exports){

// will also use the client-resource-pool.
//  This is going to be an interesting class that enables the client to connect to various resources on the server.
//  It may have an interface to browse / connect to the resources on the server that served it.

// Maybe it will do a get request, with its authentication, perhaps a key that was sent for that specific request.
//  We want to fins a way to expose resources on the server for the client to access.

// And this is going to include a client-side resource pool.

// Another problem with circular references here.

// I think the page context should be part of html-enh
//  html-enh including client-side enhancements.



var jsgui = require('./jsgui-html');

var stringify = jsgui.stringify, each = jsgui.each, arrayify = jsgui.arrayify, tof = jsgui.tof;
var filter_map_by_regex = jsgui.filter_map_by_regex;
var Class = jsgui.Class, Data_Object = jsgui.Data_Object, Enhanced_Data_Object = jsgui.Enhanced_Data_Object;
var fp = jsgui.fp, is_defined = jsgui.is_defined;
var Collection = jsgui.Collection;

// The client page context should be able to generate selection scopes.
//  We ask the context for selection scopes, and the selection scopes have IDs that are individual to the context.

// Now thinking that the Client_Page_Context should also hold the Client_Resource_Pool.
//  That client-side resource pool would hold resources that are usable client-side. They would likely involve interacting with a server.
//  They would be client-side proxies of the server-side resource, which goes through a Resource_Publisher to get it out over the network.

var Client_Resource_Pool = require('../resource/core/client-pool');

// Also should have the means to send socks messages to the server.

// Want there to be a client socks resource, which proxies all socks connections???

// Or particularly set up a socks router.


// On the client, may want to set a task for the server resource.
//  Though task setting seems like a roundabout way of using constrained verbs here. Fits in with grammar OK.



// Let's write some code on the client that would set a task for a resource.
//  Need a Resource that can accept tasks too.

// Linux System resource for the moment.
//  Will have it capable of getting / setting Linux system information.
//  Will include the capability to set it tasks.

// Let's keep things (specific resources) within the 'Resource' directory, as it's an abstraction that makes use of other parts of the jsgui platform.











var Selection_Scope = require('./selection-scope');


//console.log('jsgui.Page_Context', jsgui.Page_Context);
var Client_Page_Context = jsgui.Page_Context.extend({
    'init': function(spec) {
        spec = spec || {};


        this._super(spec);
        //this.set('document', spec.document);
        this.document = spec.document || document;

        // Not so sure about creating the resource pool or requiring the resources.
        //  Could have problems with dependencies.


        // map_controls

        // map_els

        // The context will have a map of elements by their jsgui ids.
        //  This will be needed for activation in some places.
        //   It seems not to be needed (so far) on the server.







        //var resource_pool = new Client_Resource_Pool();
        //this.pool = resource_pool;

        //resource_pool.start();
        // so the pool probably won't have loaded when controls get activated.

        // Add the resource_pool into the page context at a later occasion.
        //  The basic html client will not need resource.
        //  Resource requires some html functionality though.
        this.resource_pool = new Client_Resource_Pool({});

        this.map_els = {};


        // The item IDs could be handled here... use the local variable closure here.
        this.selection_scopes = {};

        this.selection_scope_id_counter = 0;

    },
    'new_selection_scope': function() {
        // create the selection scope, with an assigned id

        var res = new Selection_Scope({
            'context': this,
            'id': this.selection_scope_id_counter++
        })

        return res;

    },

    'get_selection_scope_by_id': function(id) {
        if (!this.selection_scopes[id]) {
            this.selection_scopes[id] = new Selection_Scope({
                'context': this,
                'id': id
            });
        }
        return this.selection_scopes[id];
    },


    'body': function() {
        var doc = this.document;
        //console.log('doc', doc);
        var bod = doc.childNodes[0].childNodes[1];
        //var bod = doc.body;
        //console.log('bod', bod);

        var bod_id = bod.getAttribute('data-jsgui-id');
        //console.log('bod_id', bod_id);
        var res = this.map_controls[bod_id];
        //console.log('res', res);
        return res;
    }

    //get id's of particular types of items...

});
// Also want a File_Server.
//  Want files to be served from a particular path, as a resource in the URL system.
//  Will be able to post files there with the right permission.
module.exports = Client_Page_Context;
	/*
	return Client_Page_Context;


});

*/

},{"../resource/core/client-pool":39,"./jsgui-html":50,"./selection-scope":51}],44:[function(require,module,exports){
// object viewer


//if (typeof define !== 'function') { var define = require('amdefine')(module) }

// html-enh depending on Context_Menu?
	


//define(["../../jsgui-html", "./menu-node"],
	//function(jsgui, Menu_Node) {

        var jsgui = require('../../jsgui-html');
        var Menu_Node = require('./menu-node');
		
		var stringify = jsgui.stringify, each = jsgui.eac, tof = jsgui.tof, is_defined = jsgui.is_defined;
		var Control = jsgui.Control;

		var group = jsgui.group;

		var Context_Menu = Control.extend({

			// could have a title field.
			//'fields': {
			//	'title': String
			//},

            // Need to call the right events when the item gets chosen / clicked on.




			// maybe add before make would be better. add will probably be used more.
			'init': function(spec, add, make) {
				this._super(spec);

				this.__type_name = 'context_menu';

				this.set('dom.attributes.class', 'context menu');
				console.log('Context_Menu init spec.el', spec.el);

				// Then inside the menu we want a variety of menu nodes.



				// Need to deal with different construction stages better.
				//  Construct and render...
				//  For the moment will stick with whether there is an element given in the spec.

				// May be given the menu object, and need to create the menu nodes from that.

				//if (!spec.abstract && !spec.el) {
				if (!spec.abstract) {
					// the bar at the top.

					// It's going to act as a drag handle for this.
					//  The drag system will integrate with various bands / window positions.

					// Maybe a property to say that it's dockable.
					

					//var top_bar = new Control({
					//	'context': this._context
					//})
					//top_bar.set('dom.attributes.class', 'title bar');
					//this.add(top_bar);

					// 

					var obj = spec.value;

					console.log('menu obj', obj);

					// Create the menu nodes from it.
					var that = this;

					var tobj = tof(obj);
					console.log('tobj', tobj);
					if (tobj == 'object') {
						each(obj, function(v, key) {
							var menu_node = make(Menu_Node({
								'text': key,
								'value': v,
								'menu': that
							}))
							that.add(menu_node);

						})

					}
					if (tobj == 'array') {
						each(obj, function(v, index) {

							var tv = tof(v);
							console.log('tv', tv);

							// then if it's string and function...

							var vsig = jsgui.get_item_sig(v, 1);
							console.log('vsig', vsig);

							if (vsig == '[s,f]') {
								var text = v[0];
								var item_callback = v[1];

								var menu_node = make(Menu_Node({
									'text': text,
									'value': text,
									'menu': that
								}))
								that.add(menu_node);
							}


							/*
							var menu_node = make(Menu_Node({
								'text': key,
								'value': v,
								'menu': that
							}))
							that.add(menu_node);
							*/
							console.log('v', v);
						})
						//throw 'stop';

					}

                    console.log('end init Context_Menu', this);

                    console.log('this._.content._arr.length ' + this._.content._arr.length);


                    //throw 'stop';

                    // If we stop here, the menu seems to have the right number of nodes.
                    // However, when it gets added into the active document, it seems as though content of the context_menu gets duplicated
                    //  There is a sequence of events when it gets added to the document.
                    //   It correctly seems to add it to the DOM and render the initial content.
                    //   However, it then seems to duplicate the internal content.
                    //    It has got the same items listed more than once.
                    //    May be able to help track this down by making an error if you try to add an item that's already there.
                    //     Possibly would require maintaining a map of what the child elements are called.
                    //      That would be possible with the Collection system, where it gets their IDs as they are added.

                    // Maybe track the adding of content better with console logging?












					// then with the menu obj we construct the menu

					// Menu dealt with as objects or arrays?
					//  Possibly as it has more explicit ordering?
					//var exobj = [
					//	['File', ['Open', 'Close']]
					//]

					// Done with keys could be easier?
					//  Maybe arrays are clearer though.



					//throw 'stop';

					

					
				}

			},
			'activate': function() {

                console.log('pre super this._.content._arr.length ' + this._.content._arr.length);

                // So it seems the problem lies within the activate function.

				this._super();

                console.log('post super this._.content._arr.length ' + this._.content._arr.length);

                // If possible, this should be automatically activated when it's put into the document.
                //  But does that break something else?

				console.log('activate Context_Menu');

				// While it is open, clicking outside of the menu should close it.

				// Respond to clicking anywhere.
				//  If it's not a leaf node of the tree, will open further nested menu.

				//var ctrl_html_root = this._context.ctrl_document;
	        	var body = this._context.body();

	        	var that = this;

                // Listen for select events on the nodes.
                //  The menu has a publish/subscribe system for the menu nodes' events.

                // create event listeners on the nodes.
                //  need a way of getting all of the nodes.

                // heirichical iteration, like .ancestor
                // .find (like jquery)
                // .descendants
                // .desc

                var nodes = this.descendants('menu_node');

                console.log('nodes', nodes);










	        	// this.one_mousedown_anywhere

	        	






				// 

			},
			'close_all': function() {
				console.log('menu close_all');

				// need to do this recursively I think.
				//  could call this recursively on all nodes.

				this.get('content').each(function(i, v) {
					//console.log('i', i);
					//console.log('v', v);

					v.close_all();
				});


			}
		})



		//return Context_Menu;

        // but then it would need to be browserified in the client?

        module.exports = Context_Menu;
	//}
//);
},{"../../jsgui-html":50,"./menu-node":45}],45:[function(require,module,exports){

var jsgui = require('../../jsgui-html');

var stringify = jsgui.stringify, each = jsgui.eac, tof = jsgui.tof;
var Control = jsgui.Control;

var Menu_Node = Control.extend({
    // fields... text, value, type?
    //  type could specify some kind of validation, or also 'password'.

    // single field?

    // Actually having a different content?
    //  Or use inner_content.

    // Menu node having expanded and contracted states.

    // Menu Node has an image and some text, and a contrainer control for othe Menu nodes.
    //  Can be collapsed so that the internal items don't show

    //'fields': [
        //['text', String]


    //],

    //'fields': {
    //	'img_src': 'string',
    //	'text': 'string'
    //},

    //  and can have other fields possibly.


    'init': function(spec, add, make) {
        // Wont fields have been set?

        this._super(spec);

        // Can take an image
        // Can take some text.
        //  That's all I'll have in the Menu node for now.
        this.__type_name = 'menu_node';
        var that = this;
        if (!this._abstract) {
            if (!spec.el) {
                this.set('dom.attributes.class', 'menu-node');
                var spec_state = spec.state, state;

                var main_control = make(Control({ 'class': 'main' }));
                this.add(main_control);
                //console.log('**** spec.img_src', spec.img_src);
                if (spec.img_src) {
                    var img_src = this.get('img_src');
                }
                if (spec.text) {
                    this.set('text', spec.text);

                    var span = make(jsgui.span({}));

                    //var text = this.get('text');
                    //console.log('text', text);
                    //console.log('tof text', tof(text));

                    span.add(spec.text);
                    main_control.add(span);
                }
                var menu = spec.menu;
                if (menu) {
                    this.set('menu', menu);
                }

                var inner_control = make(Control({ 'class': 'inner hidden' }));
                this.add(inner_control);

                // Inner may not just be the title.

                this.set('inner_control', inner_control);

                //inner_control.hide();

                //var inner_control_content = inner_control.get('content');
                // reference to a menu control.
                // maybe take 'value' here
                if (spec.value) {
                    // depending on the type of obj, work differently.
                    //  array of strings, just make those menu items.

                    var obj_menu = spec.value;
                    var t_obj_menu = tof(obj_menu);
                    console.log('t_obj_menu', t_obj_menu);

                    if (t_obj_menu == 'array') {
                        each(obj_menu, function(v) {
                            // make a new menu node with that as the value?

                            var tv = tof(v);
                            if (tv == 'string') {
                                // new node with text, no inner nodes.

                                var nested_menu_node = make(Menu_Node({
                                    'text': v,
                                    'menu': menu
                                }));
                                inner_control.add(nested_menu_node);
                            }
                        })
                    }
                }

                var ctrl_fields = {
                    'inner_control': inner_control._id(),
                    'main_control': main_control._id(),
                    'menu': spec.menu._id()
                }

                // use different quotes...

                this.set('dom.attributes.data-jsgui-ctrl-fields', stringify(ctrl_fields).replace(/"/g, "'"));

                if (spec_state) {

                    // open and closed
                    if (spec_state == 'open' || spec_state == 'closed') {
                        state = this.set('state', spec_state);
                    } else {
                        throw 'spec.state expects "open" or "closed".';
                    }
                } else {
                    state = this.set('state', 'open');
                }
            }
        }
    },
    'activate': function() {

if (!this.__active) {
  this._super();

        var inner_control = this.get('inner_control');
        var main_control = this.get('main_control');
        var menu = this.get('menu');

        var that = this;

        // raise a select event on the menu.
        // and if there are other nodes inside,

        // Upon activation, we may not have the body node though.
        //  Perhaps delay this?
        // May be good to have the context get the body control earlier, with the body control specifically made & activated earlier on.


        // Can't have each node check for a mousedown anywhere.
        //  Better to have the context menu itself do the checking.


        setTimeout(function() {

            /*
            that.one_mousedown_anywhere(function(e_mousedown) {
                console.log('omda', e_mousedown);

                var within_this = e_mousedown.within_this;
                console.log('within_this', within_this);

                if (within_this) {
                    // Would be nice to have a target_control as part of the mouse event.


                } else {
                    //that.close_all();
                    that.remove();
                }


            });
            */
        }, 0);


        /*

        main_control.on('click', function(e_click) {
            console.log('inner_control', inner_control);

            var icc = inner_control.get('content');


            var iccl = icc.length();

            if (iccl > 0) {
                // Maybe not, if it's nested.
                //  Could close other branches.
                menu.close_all();


                inner_control.show();
            } else {
                console.log('inner leaf node clicked');

                // means we close all open nodes, and register item as being selected.

                // raise a selected or item-selected? event.

                // or change event? prob not.

                // raise select event.
                menu.close_all();
                menu.raise('select', that);

            }

        })
        */

        // then when the main part is clicked, show the inner control.
}





    },
    'close_all': function() {
        console.log('menu-node close_all');

        // need to do this recursively I think.
        //  could call this recursively on all nodes.

        //

        var inner_control = this.get('inner_control');

        inner_control.get('content').each(function(i, v) {
            console.log('i', i);
            console.log('v', v);



            var tn = v.__type_name;
            console.log('tn', tn);

            if (tn == 'menu_node') {
                v.close_all();
            }



            //v.close_all();
        });

        inner_control.hide();
        this.set('state', 'closed');


    },
    'close': function() {
        var inner_control = this.get('inner_control');
        inner_control.hide();
        this.set('state', 'closed');
    },
    'open': function() {
        var inner_control = this.get('inner_control');
        inner_control.show();
        this.set('state', 'open');
    }


});
module.exports = Menu_Node;

},{"../../jsgui-html":50}],46:[function(require,module,exports){
// jsgui-client

// require a whole bunch of things


// need to have the extra information to initialize the various objects.
//  part of the server-side rendering would be identifying objects and relevant properties to send to the client.
//  for example, that something is a particular control.

//  identify ids by control.
// then there is separate client-side code...
//  or controls (perhaps advanced ones) have got various events on them that respond to client-side io, but can get used on the server as well,
//   perhaps with these client-side events called for testing.
// Application code would likely build views both on the server and the client, and have the interacton done on the client, while also using the
//  for its API, dealing with larger amounts of data than in the initial view.

// Will use particular client files...
//  Maybe have all the logic in one component.
//  Will have different means of loading and activation as well.
//   May be easier when the whole jsgui is in one file, or at least a large core.

// Likely to include a client-side component.
//  Like load a particular file which will include some particular jsgui client code.

// Needs a Client_Page_Context

// Perhaps we need a Resource_Client as well.

// Want the html client to be able to access resources.
// Want the client to have the right resource pool on the client.

// Want to be able to code client apps relatively simply, using the client-side resource system to access resources on the server / on servers.

// Should maybe send over resource info from the server.
// Resource manifest or description.

// Resources could also share a description.

// However, don't want this to get too complicated.
//  With the page, can serve a set of resources for it to use.
//  That would be an inline script, but then maybe we need to serve the app's JS alongside it.

// Will need to have the resource client access the resource for its own URL.
//  (or tell it which URL to look for the resource(s) at)

// Sending a resource-client would enable the resource to be accessed.

// For the simple case of the clock resource, we want it to display the resource's data.

// Important to avoid boilerplate while coding, making it easy to serve some data.

// Though the client side resource system will be there as code, it would be good to have things automatically instantiated.

// Need a resource client control.

// jsgui-html-resource-client
//  That would also have resources, and would start up the resource pool and client page context.
//  Not sure how useful the client code would be without the resource pool, but it's better to keep things more modular.



// The normal chiend should have a page_context at least...

// jsgui-html-resource-client
//  That would be a page that connects back to the .json for the page it was served from.
//  Also would connect to the websocket connection.

// May have jsgui-html-pooled-resources-client as well at some point.
//  Want it so that the resources which are on the server can be subscribed to using a single websocket connection.

// The resource client would connect back with a websocket connection.
//  Need to make sure that resources are published that way.

// Will be possible to have a single connection per resource.
//  That's how it will start.

// When connecting to multiple resources over websockets, will do so through the server's resource pool.
//  The server will notify the client of resource events that it has subscribed to.

// Need to get the real-time transfer of info working soon on a basic level, sharing clock data.

// Will then have it sharing more complex and varied data at some point soon after.








/*

if (typeof define !== 'function') {
    var define = require('amdefine')(module);
};

*/

// Rather than just jsgui-html-enh, it would be good to load a jsgui module that has got a lot of controls
//  and possibly resources built in.

// jsgui.Window
// jsgui.Calendar
// jsgui.Date_Range_Editor

// I think making a general purpose set of tools would be quite a good idea



//  so that's available



// jsgui-html-toolkit
// jsgui-html-with-controls

// Want a fairly large set of controls to come in the bundle.




/*

define(["./jsgui-html-enh", "./client-page-context", "../resource/core/client-pool"],
//define(["./jsgui-html"],
function (jsgui, Client_Page_Context, Client_Resource_Pool) {

    */
var jsgui = require('./jsgui-html-enh');
var Client_Page_Context = require('./client-page-context');
var Client_Resource_Pool = require('../resource/core/client-pool');

var fp = jsgui.fp;
//jQuery, canvas and the app/sub module are all
//loaded and can be used here now.

//console.log('running client function.');

// At this point could do various things to activate the document.

// However, we could have a part of the file that gets replaced with local variables.
//  They could be written here as JSON before the file gets served - with the file being given a special URL?

// I think including the local variables in the page itself may be mest. No need for dealing with another JavaSvipt file.
//  Could possibly compress them in a neat way, like base64.

// Controls will do a fair bit with their client-side code...
//  But it will be important to get properties over to the client.
//  Data attributes would be a possibility too.

// Client side resources too? Don't think so, client side resource needs this.

//  Also capability for doing HTTP request easily.
//  jsgui.http('post', url, callback);

var makeHttpObject = function() {
    try {return new XMLHttpRequest();}
    catch (error) {}
    try {return new ActiveXObject("Msxml2.XMLHTTP");}
    catch (error) {}
    try {return new ActiveXObject("Microsoft.XMLHTTP");}
    catch (error) {}

    throw new Error("Could not create HTTP request object.");
}



jsgui.http = fp(function(a, sig) {

    // we may want to do an HTTP post instead, perhaps posting a document.

    var method = 'GET';
    var url, callback, body = null;
    if (sig == '[s,f]') {
        url = a[0];
        callback = a[1];
    }
    if (sig == '[s,s,f]') {
        url = a[0];
        method = a[1].toUpperCase();
        callback = a[2];
    }
    if (sig == '[s,s,s,f]') {
        url = a[0];
        method = a[1].toUpperCase();
        body = a[2];
        callback = a[3];
    }
    if (sig == '[s,s,a,f]') {
        url = a[0];
        method = a[1].toUpperCase();
        body = JSON.stringify(a[2]);
        callback = a[3];
    }
    if (sig == '[s,s,o,f]') {
        url = a[0];
        method = a[1].toUpperCase();
        body = JSON.stringify(a[2]);
        callback = a[3];
    }
    var request = makeHttpObject();

    request.open(method, url, true);

    if (method.toUpperCase() == 'POST' && body) {
        //console.log('body', body);
        request.send(body);
    } else {
        request.send(null);
    }

    request.onreadystatechange = function() {
        if (request.readyState == 4) {
            // Perhaps parse that...
            //console.log('request', request);

            var content_type = request.getResponseHeader('Content-Type');
            //console.log('content_type', content_type);

            if (content_type == 'application/json') {
                callback(null, JSON.parse(request.responseText));
            } else {
                callback(null, request.responseText);
            }

        }

    };
});

// The page needs to get activated.

console.log('Running jsgui-html-client');

jsgui.Client_Page_Context = Client_Page_Context;

var client_page_context = new Client_Page_Context();

var resource_pool = client_page_context.resource_pool = new Client_Resource_Pool();

resource_pool.start(function() {
    console.log('client-side resource pool started');
});

// No automatic activation here, the client app.js may want to load im references.
//jsgui.activate(client_page_context);
console.log('jsgui-html-client post activate');





// Also want this to access resources.

// Think we will have a client side resource pool (by default?)



// Possibly this should automatically activate on the client.



//jsgui.Client_Page_Context = Client_Page_Context;

//return jsgui;

module.exports = jsgui;




//});

},{"../resource/core/client-pool":39,"./client-page-context":43,"./jsgui-html-enh":48}],47:[function(require,module,exports){

var jsgui = require('../core/jsgui-lang-enh');
//This function is called when scripts/helper/util.js is loaded.

// HTML will benefit from a big tidy-up.
//  HTML core.
//   Then various enhancements.
//   Page_Context being a major feature.
//    It ties everything together.
//     So as well as an annoyance with controls requiring it, it seems useful.
//      Maybe make it so that controls default to that Page_Context.






var stringify = jsgui.stringify,
    fp = jsgui.fp,
    tof = jsgui.tof,
    extend = jsgui.extend,
    is_defined = jsgui.is_defined,
    str_arr_mapify = jsgui.str_arr_mapify;
var clone = jsgui.clone,
    each = jsgui.eac,
    data_type_instance = jsgui.data_type_instance;

var str_hex_to_int = jsgui.str_hex_to_int,
    hex_rgb_6_match = jsgui.hex_rgb_6_match,
    arr_rgb_to_css_hex_6 = jsgui.arr_rgb_to_css_hex_6;

var Data_Value = jsgui.Data_Value,
    Data_Object = jsgui.Data_Object,
    Collection = jsgui.Collection;

var Class = jsgui.Class;

var ensure_data_type_data_object_constructor = jsgui.ensure_data_type_data_object_constructor;

var Enhanced_Data_Object = jsgui.Enhanced_Data_Object;

extend(jsgui.data_types_info, {
    'border_style': ['any', ['solid', 'dotted', 'dashed']],
    'distance': ['n_units', 'px'],
    'single_border': ['indexed_array', [
        ['width', 'distance'],
        ['style', 'border_style'],
        ['color', 'color']
    ]],
    'border': ['oltrb', 'single_border'],
    'margin': ['oltrb', 'distance'],
    'size': ['indexed_array', ['distance', ['width', 'height']]],
    'control_collection': ['DataCollection', 'control'],

    // Defining the types that things will get automatically created as.
    'dom_attributes': 'ordered_string_list',

    //'dom_attributes': {
        //'class': 'Ordered_String_List'
    //    'class': 'ordered_string_list'

    //},
    // these are its fields.
    //  should be able to build a control_dom constructor function.
    'control_dom': {
        'node': 'object',
        'attributes': 'dom_attributes',
        'tagName': 'string'
    },
    'control': {

        // Another type of style inside here?
        'style': 'style',
        // that may be automatically done from its relationship to its parent.
        //'index': 'int',
        // It maybe has an ID anyway as a jsgui Data_Object.
        //  But I think this signifies it? Not sure.
        'id': 'context_id',
        //'controls': 'control_collection',
        // content collection.
        'dom': 'control_dom',
        'class_name': 'string'
        // css_class in the dom attributes. style is inline style-like thing.
        //  style will also be used for building and modifying actual css files or setups.

    },
    'style': {
        // an object declaration, not array. can have various things inside
        //'border': ['oltrb', 'single_border'],
        // top, left etc

        // Want CSS to work by default, but will have some overrides / parsing / reinterpretation.



        'border': 'border',
        'margin': 'margin',
        // when dealing with 'any': there may need to be a map that says if a value is contained.
        //  could even store these maps in a tree. would use something like 'ensure'
        'cursor': ['any', ['auto', 'crosshair', 'default', 'e-resize', 'help', 'move', 'n-resize', 'ne-resize', 'nw-resize', 'pointer', 'progress', 's-resize', 'se-resize', 'sw-resize', 'text', 'w-resize', 'wait', 'inherit']]
    }
});

// Want an underlying system that represents CSS well.
//  Making it a lot easier to work with CSS, as it is in the browser.
//  On top of that we have another style layer. Maybe jsgui-style? A different way of interacting with the style system.
//  It may be that some .style instructions will be interpreted to go through the jsgui style layer.
//   When setting border-radius in a Page_Context that does not support it.

Enhanced_Data_Object.register_data_type('control_dom', jsgui.data_types_info['control_dom']);
Enhanced_Data_Object.register_data_type('dom_attributes', jsgui.data_types_info['dom_attributes']);
//jsgui.populate_all_dt_maps();
//  data type maps
//   likely to have maps created as needed and cached.

// May have a Data_Type_System that encloses these Data_Types.
ensure_data_type_data_object_constructor('control_dom');


// also a processor for distance?
//  a curried function for n_units basically?

jsgui.input_processors['distance'] = function (input) {
    // use the n_units processor, but with 'px'
    return jsgui.input_processors['n_units']('px', input);
};
// not sure about using oltrb right now. Could compress by having a single arr_ltrb variable.
jsgui.input_processors['margin'] = function (input) {
    return jsgui.input_processors['optional_array'](['left', 'top', 'right', 'bottom'], 'distance', input);
};

jsgui.input_processors['size'] = function (input) {
    // use the n_units processor, but with 'px'
    return jsgui.input_processors['indexed_array'](['width', 'height'], 'distance', input);
};


//console.log("jsgui.input_processors['color'] " + jsgui.input_processors['color']);

// just a string in the constructor - looks fine for the type.
//  likely to be using some namespaced type system eventually, but this is my namespace for the moment.

// and output the color to HTML.

// and may have the various output processors for margin (oltrbs?) and other things, outputting to HTML.
//  Some of them may output to other shim controls, or similar.
/// Will eventually output to HTML.

// Need the lower level style system working.
//  On top of that, the jsgui style system will be built.



jsgui.output_processors['string'] = function (value) {
    // need to escapr it
    return value;
}

// Will require other code as well.

var get_inline_css_dict_from_style = function (style, page_context) {
    //console.log('get_inline_css_dict_from_style ' + stringify(style));

    var style_info = jsgui.data_types_info['style'];


    // should have the style data type info
    //  then for each property we get the data type info for that, and then use its output mechanism.

    var css_style_dict = {};
    each(style, function (i, v) {
        //console.log('style i ' + i);

        // TODO - May not just be a name but could directly be the info. Could use a loader function perhaps.
        var dt_info_style_item_name = style_info[i];
        //console.log('dt_info_style_item_name ' + stringify(dt_info_style_item_name));

        var dti_style_item = data_type_instance(dt_info_style_item_name);

        //console.log('*v ' + stringify(v));

        var style_rule = dti_style_item.output(v);

        //console.log('style_rule ' + stringify(style_rule));
        //console.log('tof(style_rule) ' + tof(style_rule));
        if (tof(style_rule) == 'string') {
            css_style_dict[i] = style_rule;
        } else {

            // could probably use extend here.

            each(style_rule, function (subrule_name, subrule_value) {
                css_style_dict[subrule_name] = subrule_value;
            });

        }

        //apply_jsgui_style_rule_to_css_style(css_style_dict, i, v);
    });
    return css_style_dict;
};

var apply_jsgui_style_rule_to_css_style = function (style, style_rule_name, style_rule_value) {
    //console.log('apply_jsgui_style_rule_to_css_style style_rule_name ' + style_rule_name);

    // it's probably going to use dti and output.

    // Will be changing the way that styles get calculated.
    // Going to create some new functions that get used in the rendering.
    //  Will get help from data_types_info.

    //console.log('fns_jsgui_style_item_to_inline_css_item[style_rule_name] ' + fns_jsgui_style_item_to_inline_css_item[style_rule_name]);

    // this way of doing things will change.
    //  going to do some kind of get_style.

    // More of it will be computed through lang and the data_types system.

    if (fns_jsgui_style_item_to_inline_css_item[style_rule_name]) {
        var inline_style_dict = fns_jsgui_style_item_to_inline_css_item[style_rule_name](style_rule_value);
        //  but could we get more than one style item in the dict?

        each(inline_style_dict, function (i2, v2) {

            style[i2] = v2;
        });
    }
};

var styles_dict_to_string = function (styles_dict) {

    // OK... some improvements will need to be made.
    //  will need to upgrade the styles / size / pos setting code.
    //console.log('styles_dict ' + jsgui.stringify(styles_dict));

    var res = '',
        first = true;
    each(styles_dict, function (i, v) {

        if (typeof v == 'number') {
            v = v + '';
        }

        if (typeof (v) != 'string') {
            //var stack = new Error().stack;
            //console.log('stack ' + stack);
            //console.log('i ' + i);
            //console.log('v ' + v);
            //console.log('typeof v ' + typeof v);
            throw 'jsgui: styles_dict_to_string: Only string css styles supported. Jsgui styles must be translated to css before use here.';
        } else {
            res = res + i + ': ' + v + ';';
        }
    });
    return res;
};

// JSGUI event binding functions.

var _bind_dom_event = function (dom_node, event_name, fn) {

    // return unbind function. ???

    var unbind = _unbind_dom_event(dom_node, event_name, fn);
    return unbind;
}

var _unbind_dom_event = function (dom_node, event_name, fn) {

}







// And Core, of course
//  Likely to rename this 'Control' or 'control' - probably 'Control'.

// Now it is in this file it will be easier to modify by itself.
// More rendering to be handled through the Data_Object capabilities.
//  Could be the output type of various different things.

// Maybe we need more testing of controls, there seems to be a problem which I need to fix to do
//  with fields not being found in the file system control.

// Perhaps I could investigate that control outside of a server.

// This needs more work on its style system.
//  Need to quickly and easily change conformant style rules.
//   There will be a CSS overrides system, but generally the CSS and styling of the Control should follow normal CSS.
//    In some cases the output CSS will not match the input styling rules,
//     there may be shortcuts for convenience, and it will accept more expressive language than CSS (hopefully)
//  But do want full css support.

// control.style('background-image', 'url(...)');
//  but will have input filters in case a url is not given in that format?


// I think this will take quite a lot more work to fully make the CSS / style API.
//  However, we most want to be able to set the style property of an object to give it styles.

// It needs to work with a variety of styles.
//  Needs to access the local CSS inline dict...
//   though could possibly work with a Collection?

// dom.attributes.style
//  I think it makes sense to have that available as a string to set...
//   however, I think dom.attributes._style makes sense.

// want to access the inline style dict.

//  will also apply input transformations in some cases.
//  may apply output transformations when rendering.

// Possibly the style system could do with some separate work and testing.
//  We want it so that in old IE rounded edges can be emulated with VML.


// dom.attributes.style is literally the style attribute as a string?
//  no special case there?
//   however, there will be a system of dynamically creating this in as its needed in some cases.

var edo_init = Enhanced_Data_Object.prototype.init;
var do_init = Data_Object.prototype.init;
//var do_init_call = Data_Object.prototype.init.call;

// Will also use reusable local variables.
//  May be a bit experimental! Should do less assignment & garbage collection.

var that, dom, flags, css_flags, spec_content, tsc, arr, res, dom_attrs;

// Link tag needs to have no closing tag.

// This should have more for the client side.
//

// For drag and drop:
//  Best to use the existing API. Have a layer on top of that.
// Then for mobile (iOS, Blackberry? Android) have an implementation that is a bit like the HTML implementation.
// Then have a nice, convenient layer on top of both.

// Drag, rearranging seems really useful.
// May need to interact with server objects when doing the rearrangement, need a clear division between rearrangement
//  UI and the actions it carries out.

// Basically say something is draggable
// Don't assume it drags itself, there may be a handle
// Allow the drag item to be something representing some data in terms of model
// Allow the drag item to be a ghost view of the item being dragged
// Work so that example with the separate items grouping together works.




// Perhaps have some kind of html enhancements module?




// Control could benefit from composition methods and definitions.
//  They define the composition of controls.
//   May contain inner controls. These get created when necessary.


// Also need a good system for drag and drop events.
//  Need to recognise drag starts at first.

// Dragging something that is already selected.

// Selecting something on the beginning of the drag.



// Also want to be able to make shallow copies / clones of controls.
//  Probably won't have connection to data.
//   For short term use in dragging.

// will copy all the dom attributes and tags, nodes.
//  could be a control?
//   including subcontrols... could make a bunch of new controls as the copy.
//    That may be best to have the same effects / to enable effects.


var parse_style_attribute_to_map = function(str_style) {
    str_style = str_style.replace(/; /g, ';');
    str_style = str_style.replace(/: /g, ':');
    var rules = str_style.split(';');
    var rule_nvps = [];
    var map_rules = {};
    each(rules, function(i, rule) {
        if (rule) {
            var sRule = rule.split(':');

            rule_nvps.push(sRule)
            map_rules[sRule[0]] = sRule[1]
        }

    })

    //console.log('rule_nvps ' + stringify(rule_nvps));

    //console.log('map_rules ' + stringify(map_rules));

    return map_rules;
}

var style_attribute_map_to_string = function(map_style) {
    var arr_res = [];
    var first = true;
    each(map_style, function(i, v) {
        if (!first) {
            arr_res.push(';');
        }

        arr_res.push(i);
        arr_res.push(':');
        arr_res.push(v);


        first = false;
    })
    return arr_res.join('');
}

// Deferred rendering is going to be a fairly major feature.


var getStyle = function (el, property_name) {

    if (el.currentStyle)
        var y = el.currentStyle[property_name];
    else if (window.getComputedStyle);
        var y = document.defaultView.getComputedStyle(el, null).getPropertyValue(property_name);
    return y;
}


// Making it so a Control needs to be initialised with a context every time?



var Control = jsgui.Enhanced_Data_Object.extend({

    'fields': [
    // This may be a good way of expressing collections, works in JSON.
    //['content', ['collection', 'control']]

    // need to make sure that the fields makes these with the right contexts.

    // Say it's a collection of controls?
        // Could possibly have an inner content?
        //  Inner control?
        //  And that inner control's content is the inner content.
        //  Not all will have an inner control.
        //   Could check a control to see if it has it.
        //   Add will add to the inner control.

        // May have active fields as well.
        //  There will be references to other controls - that's handled with data-jsgui-ctrl-fields.
        //  The non-control fields are transferred with data-jsgui-fields
        //   However, we don't want to confuse them with the fields that are a standard part of the control in a different part of the lifecycle.

        // May be worth explicitly breaking out the Composition part of the Control lifecycle again.
        //  When a Control is initialized on the client, being given a DOM element, it does not need to be composed.
        //   (I think)

        ['content', 'collection'],
        ['dom', 'control_dom']//,

        // What are the CSS flags?
        //  Should this use the flag system?
        //  We will have flags that determine CSS styling.
        //   But do we have flags that directly are CSS properties / configurations, either on or off?

        //['css_flags', Collection(String)]
        // context as a field?
        //  or is context handled by Data_Object?

    ],

    // Set up a field with type Control.
    //  Then it will be sent to the client as a control field, and the reference re-obtained.


    // Connect all fields? Just some of them?
    //  Want to make it easy for the necessary fields / control references to be sent to the client.
    'connect_fields': true,

    // Don't want to use this much. Should probably override functions instead. ??? Or find a way not to use it.
    'mod_link': function () {
        return jsgui;
    },

    // Style does Data_Object.set('style')
    //  so need to be careful about this style object.
    //   Will need to refer to it when rendering.

    // There will be the jsgui-style, but I think having normal style as the default is best, and that will get
    //  overridden in some circumstances.


    // We are likely to need a better style function in HTML.

    // may be good in some ways having it work as a field.

    // Keep dom.style.attributes as it is, but modify that when changing inline styles.

    'init': function (spec) {

        // but process / normalize the spec here?

        spec = spec || {};
        //spec.nodeType = spec.nodeType || 1;
        //console.log('pre super init');
        //this._super(spec);

        //do_init_call(this, spec);
        this.mapListeners = {};
        do_init.call(this, spec);


        //console.log('post super init');

        this.__type_name = 'control';
        this.__type = 'control';

        if (!this._abstract) {


            /*
            this.add_event_listener('set', fp(function (a, sig) {
                //console.log('control event set sig ' + sig);
                //throw 'stop';
                // a flag could have been set.
            }));
            */

            // need to listen for changes in the flags and maybe some other properties.
            //  css classes will be added and removed using these flags.

            // will also have this responding to the addition and removal of css flags.
            //  css flags will correspond to a normal flag, so setting a css flag creates the normal flag too
            //  removing the normal flag removes the css flag if there is one.
            //  removing the css flag removes the normal flag if there is one.

            //  could have a list of css_enabled_flags so that whenever the normal flag version is switched on, it switches on
            //   the css flag as well.

            // may have a fairly convenient interface for receiving these flags (for instances ans for classes)
            //  and have some complexity inside, but making it as simple for the end developer as possible, while also
            //  enabling event responses to work as well.

            //flags = this.get('flags');
            //css_flags = this.get('css_flags');

            //var flags = this.get('flags');
            //var css_flags = this.get('css_flags');


            //var that = this;
            //that = this;

            //console.log('pre get dom');

            // abstract controls don't have the field instances.
            //  but they could have settings or a spec.
            // Maybe abstract Data_objects could retain their spec,
            //  then not do the normal constructor.

            //console.log('this.fields() ' + stringify(this.fields()));
            // the chained fields?
            //  have the fields not been initialised properly?
            //var chained_fields = jsgui.get_chained_fields(this.constructor);
            //console.log('chained_fields ' + stringify(chained_fields));
            //console.log('pre get dom');
            //var dom = this.get('dom');

            //dom = this.get('dom');
            //dom.set('tagName', 'div'); // Though may depend on spec...

            var tagName = spec.tagName || spec.tag_name || 'div';

            this.set('dom.tagName', tagName);

            // this.set_s_s;
            //  different versions of set, one of which will just set using 2 string params.



            //  using two strings.
            //  a version of the function

            // could have inline creation of the dom Data_Object.

            //var dom = this._.dom = this._.dom || new Data_Object({'context': this.context});
            //var tag_name = dom._.tagName = new Data_Value({'value': tagName});
            //tag_name.parent(dom);

            this._icss = {};
            //this._.dom = {'tagName': 'div'};

            // Abstract controls won't have

            //console.log('dom ' + stringify(dom));

            // The DOM is a field that it should be getting from the control.
            spec_content = spec.content;
            if (spec_content) {
                tsc = tof(spec_content);
                if (tsc == 'array') {
                    throw 'Content array not yet supported here.'
                } else if (tsc == 'string' || tsc == 'control') {
                    this.content().add(spec_content);
                }

            }

            if (spec.el) {
                this.set('dom.el', spec.el);
            }

            var that = this;

            if (spec.size) {
                var size = spec.size;
                var t_size = tof(size);
                if (t_size == 'array') {
                    var width = size[0];
                    var height = size[1];

                    // far from ideal
                    //  Really should set inline styles separately.
                    //  I had lost some of the JSGUI style system before because I redid control based on Data_Object, it may have got too complicated before though.
                    //

                    // Want to be able to access css styles.
                    //  Want to be able to access styles on a different level though - things which may not be supported by CSS directly.
                    //  Will do things more based on the CSS standard where possible, and shifting to use other methods when not possible.

                    this.set('dom.attributes.style', 'width: ' + width + 'px; height: ' + height + 'px;');

                    // Needs to set inline styles.
                }
            }

            if (spec['class']) {
                //this.set('dom.attributes.class', spec['class']);
                this.add_class(spec['class']);
            }

            var context = this._context;
            if (context) {
                if (context.register_control) context.register_control(this);
            } else {
                //console.trace('');
                //throw 'Control requires context'

                // I think the very first Control object's prototype or something that inherits from it does not have
                //  a context at some stage.
            }




            // When content gets added, need to update the relationships.

            // Perhaps change is the better event to use.

            //  And then within the change event there are more details.
            //  Fewer event listeners to add.

            //

            var content = this.get('content');
            content._parent = this;

            // Want to have the list of fields
            //var cc = 0;

            // Want to listen to changes in fields.
            //  Change gets triggered so frequently!

            // Why is the event getting bound too many times?
            //  Have a strange problem, where this event is firing more than expected and more appear bound on the control.

            // Are change events being bubbled?

            // Why is on change setting up so many event handlers?


            // A change event here seems to be creating lots of event handlers on one control.




            // Need to work out why event binding here causes problems, with it seeming to bind lots of events to one control.

            // It will probably be best to do smaller test cases to do with event binding and bubbling,
            //  possibly also browser based cases that will be easier to follow.


            // Onchange here makes it go drastically wrong.
            //  Between page views, event handlers are building up on a control.
            //  Seems like some Data_Objects or Controls may not have contexts applied.



            // The control's onchange event is not working.
            //  It seems like onchange for the content is working though.

            //  On change any of the control fields...
            //   Could create onchange events for each of the control fields automatically.




            /*
            this.on('change', function(e_change) {

                // Change takes place in the collection?
                //  So when an item gets added, it's added to the collection, and the collection changes.
                //  Does the collection have the right context? The collection is initialised as a field.



                //console.log('e_change', e_change);

                // There are very many changes...
                //  It seems like too many change events get reported.
                //   Need to tell the difference between a change of something, and a change to something.
                //   Like an inner control gets replaced with something different, or an inner control has a change happen to it.


                // It looks like changes are bubbling, need to find a way of tracking the initiator of a change event.



                if (e_change.name) {
                    //console.log('e_change.name', e_change.name);


                    if (e_change.name == 'inner_control') {
                        console.log('e_change.bubbled ' + e_change.bubbled);

                        //console.log('that', that);
                        //var my_ctrl_id = that._id();
                        // Controls may not have contexts yet?

                        //console.log('my_ctrl_id', my_ctrl_id);

                        //console.log('e_change', e_change);
                        //console.trace("Here I am!")
                        //cc++;
                    }
                }

                //console.log('change sig ' , jsgui.get_item_sig(e_change));
            })
            */



        }

    },


    'post_init': function (spec) {
        //throw 'stop';
        if (spec && spec.id === true) {
            // get the id from the context.
            //if (t)
            this.set('dom.attributes.id', this._id());

        }
    },

    // Not so sure that css flags will be used.
    //  We have css classes which get manipulated.
    //  Other types of properties won't depend on CSS quite yet.
    //  Will have control fields improved to be more flexible and to carry from the server to the client parameters and behavioural rules.

    /*
    'add_css_flag': function (flag_name) {
        var css_flags = this.get('css_flags');
        //console.log('css_flags ' + stringify(css_flags));

        // Flags that appear in CSS.
        //  Also have some other effect, most likely.

        if (!css_flags.has(flag_name)) {
            css_flags.add(flag_name);
        }


    },
    'remove_css_flag': function (flag_name) {
        var css_flags = this.get('css_flags');
        if (css_flags.has(flag_name)) {
            css_flags.remove(flag_name);
        }

    },
    'has_css_flag': function (flag_name) {
        var css_flags = this.get('css_flags');
        return css_flags.has(flag_name);
    },

    */

    // Maybe consider these part of rendering, move them.
    '_get_amalgamated_style': function (arr_contexts) {
        //console.log('this._.style ' + stringify(this._.style));

        // Do we have style as a field that uses data objects?

        //res = clone(this._.style);
        //that = this;




        // needs to be substantially redone.
        //  I want to keep it simple, and close to the HTML API by default.
        //  There will need to be overrides in various places.

        // Sometimes new elements would need to be put in (maybe into the background)

        //console.log('res ' + stringify(res));
        // OK, needs the style object.

        // Likely to have the style() function.

        /*
    	 * not using contexts at the moment anyway
    	 *
    	$.eac(arr_contexts, function(i, v) {
    		//var cs = that._.cs[v];
    		if (global.page_context && global.page_context.context_style[v]) {
    			//console.log('a) get_amalgamated_style res ' + jsgui.stringify(res));
    			apply_style_to_style(res, global.page_context.context_style[v]);
    			//console.log('b) get_amalgamated_style res ' + jsgui.stringify(res));
    		}
    	});
    	*/
        //return res;

        // Not going to use this._.style.
        //  will have this._icss for inline css




        return clone(this._.style);
    },

    '_get_rendered_inline_css_dict': function () {

        // and does setting the style work right?

        // will refer to an object, will return this._.inline_css_dict.
        //  will render that dict when necessary ---?
        //  amalgamting the styles

        // when changing the style of something - may be overwritten by amalgamated styles?
        //  have an amalgamated style override?

        //var contexts = this.getContexts(),

        var ast = this.get_amalgamated_style()


        //console.log('ast ' + stringify(ast));
        var inline_css_dict = get_inline_css_dict_from_style(ast);

        //console.log('inline_css_dict ' + jsgui.stringify(inline_css_dict));

        return inline_css_dict;
    },


    // Will use less inline style rendering, will make more stylesheet components.
    //  Will also work on tools for making stylesheets and styles.

    // may be how style gets output - could use an output system that makes reference to the page_context.
    //  it is just dom.attributes.style
    /*
    '_get_rendered_inline_css': function () {
        var css_dict = this.get_rendered_inline_css_dict(),
            str_css = '';

        // renders the jsgui styles that have been set to the inline style
        // then renders/copies the CSS inline styles to the inline style

        // will already have a style dict.


    	//if (typeof this.dom.attributes != 'undefined' && typeof this.dom.attributes.style != 'undefined') {
    	//	var da_style_dict = str_get_styles_dict(this.dom.attributes.style);
      //	var nsd = {};
      //	$.extend(true, nsd, da_style_dict,  css_dict);
      //	str_css = styles_dict_to_string(nsd);
    	//};


        // will be a data type that supports ordering / reordering soon.
        var h = this.has('this.dom.attributes._.dict_style');
        // maybe does not have that attribute?
        // they are inline styles (that have been set)

        //console.log('h ' + h);

        if (h) {
            var da_style_dict = h;
            var nsd = {};
            extend(true, nsd, da_style_dict, css_dict);

            //console.log('nsd ' + jsgui.stringify(nsd));

            str_css = styles_dict_to_string(nsd);
        } else {
            //console.log('css_dict ' + jsgui.stringify(css_dict));
            str_css = styles_dict_to_string(css_dict);
        }

        return str_css;
    },
    */

    // likely to be done with an alias
    //  And will be done using the data type system.

    'property_css_transition_duration': function (style_property_name) {
        // this._.s

        // will refer to style properties differently

        if (this.has('_.s.transition')) {
            // look up the css transition in the jsgui style
            //if(this._.s.transition) {
            var tr = this._.s.transition;
            if (tr[style_property_name]) {
                // anything about duration etc?
                var dur = tr[style_property_name][0];
                return dur;
            }
            //}
        }
    },

    // 'ret' function - gets something if possible.
    'has': function (item_name) {
        var arr = item_name.split('.');
        //console.log('arr ' + arr);
        var c = 0,
            l = arr.length;
        var i = this;
        var s;
        while (c < l) {
            s = arr[c];
            //console.log('s ' + s);
            if (typeof i[s] == 'undefined') {
                return false;
            }
            i = i[s];
            c++;
        };
        return i;
    },

    // The Dom attributes could count as fields, and wind up rendering themselves using Get.
    //  Dom attributes likely to be a collection as well, perhaps automatically sorted by name.
    // Could use collection rendering.
    'renderDomAttributes': function () {
        //console.log('renderDomAttributes');

        // Pre-render dom attributes?
        //  To set the dom attributes programmatically according to properties.

        if (this.beforeRenderDomAttributes) {
            this.beforeRenderDomAttributes();
        }

        // Need to set up the data-jsgui-ctrl-fields attribute.
        //  Probably should not be setting it directly.
        //  It's just a string property.
        // The code that I'm currently using is messy and would be better if it were encapsulated.
        //  Just setting a property of a control with another control, on the server, should be enough to get this mechanism operating.
        //  It will be available as a field on the client-side.

        var dom_attrs = this.get('dom.attributes');

        if (!dom_attrs) {
          throw 'expecting dom_attrs';
        } else {
          if (this._ctrl_fields) {
            // go through the control fields, putting together the data attribute that will be persited to the client.

            // need to compose the string.

            var obj_ctrl_fields = {};

            var keys = Object.keys(this._ctrl_fields);
            var key;
            for (var c = 0, l = keys.length; c < l; c++) {
              key = keys[c];
              obj_ctrl_fields[key] = this._ctrl_fields[key]._id();
            }

            //each(this._ctrl_fields, function(ctrl_field, name) {
            //  obj_ctrl_fields[name] = ctrl_field._id();
            //});


            //this.set('dom.attributes.data-jsgui-ctrl-fields', stringify(obj_ctrl_fields).replace(/"/g, "'"));
            // lower level set here?
            dom_attrs.set('data-jsgui-ctrl-fields', stringify(obj_ctrl_fields).replace(/"/g, "'"))


          }

          if (this._fields) {
            // go through the control fields, putting together the data attribute that will be persited to the client.

            // need to compose the string.

            //var obj_fields = {};
            //each(this._ctrl_fields, function(ctrl_field, name) {
            //  obj_ctrl_fields[name] = ctrl_field._id();
            //});

            //this.set('dom.attributes.data-jsgui-fields', stringify({
            //    'num_days': num_days
            //}).replace(/"/g, "[DBL_QT]").replace(/'/g, "[SNG_QT]"));


            //this.set('dom.attributes.data-jsgui-fields', stringify(this._fields).replace(/"/g, "[DBL_QT]").replace(/'/g, "[SNG_QT]"));
            dom_attrs.set('data-jsgui-fields', stringify(this._fields).replace(/"/g, "[DBL_QT]").replace(/'/g, "[SNG_QT]"))

          }
          var arr = [];
          //var arr_dom = dom_attrs._arr;

          //for (var c = 0, l = arr_dom.length; c < l; c++) {
          //  arr.push(' ', c, '="', arr_dom[c], '"');
          //}
          var _ = dom_attrs._;
          var dom_attrs_keys = Object.keys(_);
          //console.log('dom_attrs_keys', dom_attrs_keys);
          //throw 'stop';

          var key, item;
          for (var c = 0, l = dom_attrs_keys.length; c < l; c++) {
            key = dom_attrs_keys[c];
            item = _[key];
            arr.push(' ', key, '="', item, '"');
          }



          //dom_attrs.each(function (i, v) {
          //    arr.push(' ', i, '="', v, '"');
          //});
          return arr.join('');
        }


        // Maintaining a dict, or some data structure of the inline styles will help.






        //res = arr.join('');
        //return res;

    },
    'renderBeginTagToHtml': function () {

        // will be in _.dom.tagName
        //  I think that's why we need the further level properties.

        // dom.style.transform3d.translate3d
        //  these property levels could go quite deep. Want a convenient way of using them without having to manually code lots of
        //  iterations, nested existance checks. Could have shortcuts so it knows what dom.translate3d means.
        // do we have 'get'?
        //var dom = this.get('dom');
        //var tagName = this.get('dom.tagName'),
        var tagName = this._.dom._.tagName;
        //console.log('this._.dom', this._.dom._.attributes);

        //console.log('tagName', tagName);
            res;

        if (tagName === false) {
            res = '';
        } else {

            //var dom_attributes = this.renderDomAttributes();
            res = ['<', tagName, this.renderDomAttributes(), '>'].join('');
        }
        //var res = ['<', this._.tagName, this.renderDomAttributes(), '>'].join('');

        //console.log('renderBeginTagToHtml res ' + res);
        return res;
    },
    'renderEndTagToHtml': function () {
        // will have different way of referring to the tagName, but that could be a shortcut.
        // dom.tagName();
        //  through the fields system.
        var dom = this.get('dom');
        var tagName = dom.get('tagName'),
            res;

        var noClosingTag = dom.get('noClosingTag');

        //console.log(tof(noClosingTag));
        //throw 'stop';

        if (tagName === false || noClosingTag) {
            res = '';
        } else {
            res = ['</', tagName, '>'].join('');
        }

        //console.log('renderBeginTagToHtml res ' + res);
        return res;
    },
    'renderHtmlAppendment': function () {
        return this.htmlAppendment || '';
    },

    // not rendering a jQuery object....
    // content including the tags? Not for the moment. Tags being false means there are no tags, and this tagless control acts as a container for other
    //  controls or content.
    // That will be useful for having different insertion points in controls without having to have them enclosed by an HTML element.

    'renderEmptyNodeJqo': function () {
        return [this.renderBeginTagToHtml(), this.renderEndTagToHtml(), this.renderHtmlAppendment()].join('');
    },

    // Need to implement deferred rendering.
    //  Some controls will ge ttheir data from a Resource / from Resources.
    //  This means the data is available to them asyncronously.
    //  The control will not be ready to render immediately.

    // For example, a control shows the records in a DB table. This is done through accessing a Resource.
    //  The control will not be ready to render until it has loaded the data from the Resource.

    // I think some kind of 'status' in the Control would make sense.
    //  Assumed to be ready, but could have .__status = 'waiting'
    // Could hold more info about waiting and timing?

    // For the moment, just need to be able to delay rendering a control until all subcontrols are ready.

    // Will go through the control tree like with rendering, noting down any that are not ready, and subscribing to their ready events.
    //  We count down the number yet to be ready, when that is 0 we do the rendering like normal, except returning the result asyncronously.


    'iterate_this_and_subcontrols': function(ctrl_callback) {
        ctrl_callback(this);

        var content = this.get('content');
        var that = this;

        content.each(function(i, v) {
            //console.log('v', v);

            tv = tof(v);
            if (tv == 'string') {
                // escape the string.

                //var output = jsgui.output_processors['string'](n);
                //res.push(output);
                //res.push(jsgui.output_processors['string'](n));

            }
            /*
            if (tof(n) == 'string') {
                // escape the string.

                var output = jsgui.output_processors['string'](n);
                res.push(output);

            }
            */
            if (tv == 'data_value') {
                //var output = jsgui.output_processors['string'](n.get());
                //res.push(jsgui.output_processors['string'](n.get()));
            } else {
                //htm = n.all_html_render();
                //res.push(n.all_html_render());

                // it should not be null, but can ignore it for the moment / forever

                if (v && v.iterate_this_and_subcontrols) {
                    v.iterate_this_and_subcontrols.call(v, ctrl_callback);
                }


            }



        });


    },

    // Should now include deferred rendering.

    'all_html_render': function(callback) {

        //console.log('all render callback', tof(callback));
        if (callback) {

            //console.log('deferred rendering');
            //throw 'stop';

            // Get the map of any controls that have __status == 'waiting'.
            var that = this;
            // want to recursively iterate through controls and subconstrols.
            var arr_waiting_controls = [];

            // Worth setting up the listener on this loop?



            this.iterate_this_and_subcontrols(function(control) {
                if (control.__status == 'waiting') arr_waiting_controls.push(control);
            });

            // then if we are waiting on any of them we listen for them to complete.

            //console.log('arr_waiting_controls.length', arr_waiting_controls.length);

            if (arr_waiting_controls.length == 0) {
                var html = this.all_html_render();
                callback(null, html);
            } else {
                var c = arr_waiting_controls.length;

                var complete = function() {
                    //console.log('complete');
                    that.pre_all_html_render();

                    var dom = that.get('dom');
                    //console.log('dom', dom);

                    if (dom) {
                        // does it have innerHTML?
                        //  I think that will just be a content item that gets rendered anyway.
                        //console.log('has dom');

                        /*

                        var beginning = this.renderBeginTagToHtml();
                        var middle = this.all_html_render_internal_controls();
                        var end = this.renderEndTagToHtml();
                        var appendment = this.renderHtmlAppendment();

                        res = [beginning, middle, end, appendment].join('');
                        */
                        //return [that.renderBeginTagToHtml(), that.all_html_render_internal_controls(), that.renderEndTagToHtml(), that.renderHtmlAppendment()].join('');
                        var html = [that.renderBeginTagToHtml(), that.all_html_render_internal_controls(), that.renderEndTagToHtml(), that.renderHtmlAppendment()].join('');
                        //console.log('html', html);
                        callback(null, html);
                        //throw ('stop');
                    }
                }

                each(arr_waiting_controls, function(control, i) {


                    control.on('ready', function(e_ready) {
                        //console.log('control ready');
                        c--;
                        //console.log('c');
                        if (c == 0) {
                            complete();
                        }

                    });
                });


            }
        } else {
            this.pre_all_html_render();

            var dom = this.get('dom');

            if (dom) {
                // does it have innerHTML?
                //  I think that will just be a content item that gets rendered anyway.
                //console.log('has dom');

                /*

                var beginning = this.renderBeginTagToHtml();
                var middle = this.all_html_render_internal_controls();
                var end = this.renderEndTagToHtml();
                var appendment = this.renderHtmlAppendment();

                res = [beginning, middle, end, appendment].join('');
                */
                return [this.renderBeginTagToHtml(), this.all_html_render_internal_controls(), this.renderEndTagToHtml(), this.renderHtmlAppendment()].join('');
                //throw ('stop');
            }
        }

        //console.log('all_html_render ');
        //if (this.pre_all_html_render) {
        //
        //}


        //return res;
    },



    'render_content': function () {

        //console.log('render_content');

        // it's controls() now, gets the collection of controls.
        //each(this._.controls, function(i, n) {

        //var fields = this.fields();
        //console.log('fields ' + stringify(fields));

        // Some kind of full content?
        //  Content shortcuts?

        // Or have an internal_content property?
        //  Possibility of different places for internal content?
        //   Or not right now?

        // I think an internal_content reference would be best.
        //  or just .internal


        // should be able to get the content... it's a field.
        //  but complications because it's a collection.

        // When adding a string to the collection...

        var content = this.get('content');

        // Does not have content?
        //  That's very strange.

        if (!content.length) {
            console.log('!!!no content length!!!');
            console.log('');
            console.log(this);
            console.log('');
            console.trace();
            console.log('content', content);
            console.log('tof(content) ' + tof(content));
            throw 'stop';
        }

        //console.log('content', content);
        //console.log('tof(content) ' + tof(content));

        // The content should not be a control.
        //  Can't call a part of a control its 'content', as that already exists.
        //  Should be considered a protected word.

        var contentLength = content.length();

        // var res = [];

        var res = new Array(contentLength);

        //console.log('-------------------------');
        //console.log('content ' + stringify(content));
        //console.log('tof(content) ' + tof(content));
        //throw('8) stop');

        /*
    	each(controls._arr, function(i, n) {
            htm = n.all_html_render();
            res.push(htm);
        });
    	*/
        var tn, output;
        //console.log('content', content);

        // content._arr

        var arr = content._arr;
        var c, l = arr.length, n;

        for (c = 0; c < l; c++) {
          n = arr[c];
          // Could use faster duck typing here.
          tn = tof(n);
          if (tn == 'string') {
              // escape the string.
              //var output = jsgui.output_processors['string'](n);
              //res.push(output);
              res.push(jsgui.output_processors['string'](n));
          }
          /*
          if (tof(n) == 'string') {
              // escape the string.

              var output = jsgui.output_processors['string'](n);
              res.push(output);

          }
          */
          if (tn == 'data_value') {
              //var output = jsgui.output_processors['string'](n.get());
              res.push(jsgui.output_processors['string'](n._));
          } else {
              if (tn == 'data_object') {
                  //console.log('n', n);
                  //
                  throw 'stop';
              } else {
                  res.push(n.all_html_render());
              }
              //htm = n.all_html_render();
          }
        }

        /*
        content.each(function (i, n) {
            //console.log('-------------------------');
            //console.log('tof(n) ' + tof(n));
            //console.log('(n) ' + stringify(n));
            //throw 'stop';
            tn = tof(n);
            if (tn == 'string') {
                // escape the string.
                //var output = jsgui.output_processors['string'](n);
                //res.push(output);
                res.push(jsgui.output_processors['string'](n));
            }
            if (tn == 'data_value') {
                //var output = jsgui.output_processors['string'](n.get());
                res.push(jsgui.output_processors['string'](n.get()));
            } else {
                if (tn == 'data_object') {
                    console.log('n', n);
                    //
                    throw 'stop';
                } else {
                    res.push(n.all_html_render());
                }
                //htm = n.all_html_render();
            }
        });
        */

        //console.log('res', res);
        return res.join('');
    },

    'all_html_render_internal_controls': function () {
        //var controls = this.controls, res = [];
        return this.render_content();
    },
    'pre_all_html_render': function () {

    },

    // May happen through Data_Object events as well.

    // bind dom event to normal events?
    //  Be quite explicit in which ones get bound for the moment.

    // Want it so that the dom attributes style gets changed with the css_flags.
    /*

    'bind_dom_event': function (evt_name, evt_handler) {

        // but make this raise a jsgui event too
        var n = this.domNode();

        // this._el?
        if (n) {
            n.addEventListener(evt_name, evt_handler, false);
        }
    },

    'unbind_dom_event': function (evt_name, evt_handler) {

        //jsgui._dom_removeEventListener(dom_node, evt_name, evt_handler, false);
        // jsgui._dom_unbind_event(dom_node, evt_name, evt_handler) - phase assumed, no boolean here, different API.
        // a (jsgui) api outside of the controls.

        var n = this.domNode();
        if (n) {
            n.removeEventListener(evt_name, evt_handler, false);
        }
    },

    // event handling - likely to be moved to DataObject. Controls will still handle events!

    'bind_ctrl_event': function (evt_name, evt_handler) {

        // could use a ll_ensure function...
        //  clearer naming that it's simple.
        //  will compress better.

        //var ceen = this.ensure('_.bound_ctrl_events.' + evt_name, []);
        var ceen = ll_ensure(this, '_.bound_ctrl_events.' + evt_name, []);

        ceen.push(evt_handler);
    },

    'trigger_ctrl_event': function (evt_name) {
        //console.log('trigger_ctrl_event ' + evt_name);

        var a = arr_like_to_arr(arguments),
            p = [];
        if (a.length > 1) {
            p = a.slice(1);
        };
        var ce = this._.bound_ctrl_events,
            that = this;
        //console.log('ce ' + ce);
        if (ce) {
            //console.log('ce[evt_name] ' + ce[evt_name]);
            if (ce[evt_name]) {
                each(ce[evt_name], function (i, v) {
                    v.apply(that, p);
                });
            };
        };
    },
    */

    'compose': function () {

        // I think having this avoids a recursion problem with _super calling itself.
    },

    'wait': function (callback) {
        //console.log('wait');
        setTimeout(function () {
            callback();
        }, 0);
    },
    // could use aliases for style properties.

    'visible': function (callback) {

        //console.log('vis');

        //return this.style('display', 'block', callback);
        this.style('display', 'block', callback);
    },

    // These kind of functions, that set a property to a value, could be made in a more efficient way.

    // have this in a function chain?
    'transparent': function (callback) {
        // make block or inline display, maybe depending on what it was before being made hidden
        //console.log('transp');
        // if display is none then display it.
        //  may have the previous display value stored.
        //return this.style({'opacity': 0}, callback);
        this.style('opacity', 0, callback);
        /*

	this.style({
		'display': 'block',
		'opacity': 0
	});

	if (callback) {
		setTimeout(function() {
			callback();
		}, 0);
	} else {
		return this;
	}
	*/
    },
    'opaque': function (callback) {
        return this.style({
            'opacity': 1
        }, callback);

    },

    // possibly change name
    'chain': function (arr_chain, callback) {
        // each item in the array is a function call (reference) that needs to be executed.
        // assuming the last param in each function is the callback.

        var pos_in_chain = 0;

        //setTimeout()
        var that = this;
        var process_chain = function () {
            //console.log('process_chain arr_chain.length ' + arr_chain.length + ', pos_in_chain ' + pos_in_chain);
            //console.log('arr_chain.length ' + arr_chain.length);
            if (pos_in_chain < arr_chain.length) {
                var item = arr_chain[pos_in_chain];

                // what types can item be
                // an array... that means more than one thing gets applied at this point in the chain.

                var t_item = tof(item);

                //console.log('t_item ' + t_item);
                if (t_item == 'array') {
                    // do more than one item at once.

                    // will wait for them all to be complete too.
                    var count = item.length;
                    var cb = function () {
                        count--;
                        if (count == 0) {
                            //if (callback) {
                            //	callback();
                            //}
                            pos_in_chain++;
                            process_chain();
                        }
                    };
                    each(item, function (i, v) {
                        that.fn_call(v, function () {
                            cb();
                        });
                    });
                    //console.log('arr item ' + stringify(item));
                } else {
                    // for a string I think.
                    // could be a map, and need to call the item(s) in the map.
                    that.fn_call(item, function () {
                        //console.log('cb1');
                        pos_in_chain++;
                        process_chain();
                    });
                }
            } else {
                if (callback) {
                    callback.call(that);
                }
            }
        }
        process_chain();
    },
    'fn_call': function (call, callback) {
        // and callbacks within the right way?
        //console.log('fn_call ' + call);
        var t = tof(call);
        //console.log('t ' + t);
        // but call may be an object...
        var fn, params, that = this;
        if (t == 'string') {
            fn = this[call];
            params = [];
            //console.log('callback ' + callback);
            if (callback) {
                return fn.call(this, callback);
            } else {
                return fn.call(this);
            }
        };
        if (t == 'array') {
            // the 0th item in the arr should be the function name, the rest the params
            // but does the function have a 'callback' param that we know about here? not now.
            fn = this[call[0]];
            params = call.slice(1);
            if (callback) params.push(callback);
            return fn.apply(this, params);
        }
        if (t == 'object') {
            // how many?
            var count = 0;
            each(call, function (i, v) {
                count++;
            });

            each(call, function (i, v) {
                var cb = function () {
                    count--;
                    if (count == 0) {
                        callback.call(that);
                    }
                };
                that.fn_call([i, v], cb);
            });
        }
    },

    // I think .animate syntax would be very helpful.
    //  syntax similar to jQuery but likely to allow more possible options???
    //   more ways of expressing the options.






    // This could probably be defined as an alias.

    // transition -> style.transition
    //  Integrating callbacks with these property changes?
    //  Maybe should not do so much more on compressing & generalizing yet.

    // Horizontal_Carousel_Selector
    //  Or just show these various selectable items in the horizontal carousel.

    // Will maybe make the carousel continuous, so could go from December to January, and it would raise an event
    //  signifying the continuation and direction, so this could make the year change.
    // Would have a horizontal carousel selector for selecting the year, with it continuing.
    //  Could make it a combo selector so the value can be typed in as well. 'J' would bring up 'January', 'June' and 'July' as autoselect items.
    // Putting these GUI features in place will not take so long, and will help this to be a powerful toolkit.

    // May be worth doing more on databases and authentication though.



    'transition': function (value, callback) {
        //var i = {};
        //i[]

        // may include multiple transitions in an array.
        return this.style({
            'transition': value
        }, callback);
    },

    'transit': fp(function (a, sig) {

        // arr_duration_and_timing_function, map_values, callback
        // transit, callback
        //console.log('transit sig ' + sig);
        // [[n,s],o]  a duration with timing function, then a transit map. no callback
        //  what about extracting from the most inner array, so also responding to [[[n,s],o]].
        // seeing that the required thing is inside an array shell.

        // extract_sig_from_array_shell
        var that = this;
        //  [[[n,s],o,],f] including callback function

        // [[[n,s],o]]
        var unshelled_sig = remove_sig_from_arr_shell(sig);
        //if (remove_sig_from_arr_shell(sig))
        //console.log('unshelled_sig ' + unshelled_sig);
        if (unshelled_sig == '[[n,s],o]') {
            return this.transit(a[0][0], a[0][1]);
        }

        if (sig == '[[[n,s],o],f]') {

            var transit = a[0];
            var callback = a[1];

            var duration_and_tf = transit[0];
            var map_values = transit[1];

            this.transit(duration_and_tf, map_values, callback);

        } else if (sig == '[[n,s],o,f]') {
            var duration_and_tf = a[0];
            var map_values = a[1];
            var callback = a[2];
            var transition = {};
            each(map_values, function (i, v) {
                // set the transition style
                transition[i] = duration_and_tf;
            });
            that.transition(transition);

            each(map_values, function (i, v) {
                // set the transition style
                //transition[i] = arr_duration_and_timing_function;

                // use the style function to set the value
                // and use a callback system here for when they are all done.

                that.style(i, v);
            });

            //this.transit(duration_and_tf, map_values, callback);
        } else if (a.length == 2) {
            var duration_and_tf = a[0];
            //console.log('a ' + stringify(a));

            // transit includes the map values

            var duration_and_tf = a[0];
            var map_values = a[1];
            //var transit_map = a[1];
            var transition = {};

            each(map_values, function (i, v) {
                // set the transition style
                transition[i] = duration_and_tf;


            });
            that.transition(transition);

            each(map_values, function (i, v) {
                // set the transition style
                //transition[i] = arr_duration_and_timing_function;

                // use the style function to set the value
                // and use a callback system here for when they are all done.

                that.style(i, v);

            });
            //console.log('transit_map ' + stringify(transit_map));
            //this.transit(duration_and_tf, transit_map);
            //that.transition()
        } // else if (a.length == 3) {
        //	var arr_duration_and_timing_function = a[0], map_values = a[1], callback = a[2];
        //	console.log('a ' + stringify(a));


        //}

    }),

    // and also want to be able to output the property.

    'out': function (property_name) {
        var dti_control = data_type_instance('control');

        //var prop_ref = get_property_reference(this, property_name, false);
        var prop_ref = dti_control.nested_get_property_reference([this, '_'], property_name, true);

        var item_type = prop_ref[2];
        var dti_item = data_type_instance(item_type);

        var out_val = dti_item.output(prop_ref[0][prop_ref[1]]);

        //console.log('out prop_ref ' + stringify(prop_ref));
        //console.log('out out_val ' + stringify(out_val));

        return out_val;
    },

    'page_context': function (val) {
        if (typeof val == 'undefined') {
            // _.page_context should not be a function.

            // how frequently does it need to be called?
            //  is it being called too much?
            //console.log('� this._.page_context ' + this._.page_context);
            if (is_defined(this._.page_context)) {
                return this._.page_context;
            } else {
                if (jsgui.page_context) {
                    return jsgui.page_context;
                }
            }
        } else {
            this._.page_context = val;
        }
    },

    // may change the controls access functions, but seems simple and OK for the moment to wrap them like this.

    // will just be adding to the content.

    'add_control': function (new_content) {
        //var content = this.get('content');


        // The controls array being an ID'd and indexed collection.
        //  Everything in there has an ID.
        //  So needs a page_context.
        //  Seems a little inconvenient.
        //  But will solve the problem for the moment.



        //return content.add(new_content);
        return this.get('content').add(new_content);
    },
    'add': function(new_content) {

        // Will also turn XML strings describing jsgui controls/content into controls/content.

        var tnc = tof(new_content);
        //console.log('control add content tnc', tnc);

        if (tnc == 'array') {
            var res = [], that = this;
            each(new_content, function(i, v) {
                res.push(that.add(v));
            });
            return res;
        } else {
            if (!new_content._context) {
                if (this._context) {
                    new_content._context = this._context;
                }
            }

            /*
            console.log('add context: ' + this._context);
            if (this._context) {
                if (tof(new_content) == 'string') {

                } else {
                    new_content._context = this._context;
                }
            }
            */

            //console.log('pre content add');
            //return content.add(new_content);

            // also, want to set the index of the new_content.
            //  The content could be a string...
            //   no need to set the index then.

            //  If the content is a control, we want to set a property for that control.
            //   Control should know what its parent control is.



            // OK, but does puttint it into that collection automatically set its parent in some way?

            // Maybe listen out for content being added.
            //  So we can do content.add rather than just .add, and it updates the parent and index values.

            // Could check for an inner control.

            // Also could instantiate the content if it is abstract.
            // Also could express content as JSON in some cases.
            //  Possibly could add XML.




            var inner_control = this.get('inner_control');
            //console.log('inner_control', inner_control);

            // Does it add a Data_Object successfully?

            // Could adding this cause content inside the content that's being added to duplicate?

            if (inner_control) {
                return inner_control.get('content').add(new_content);
            } else {
                return this.get('content').add(new_content);
            }



            // then it should know it's been added, and update the DOM.
            //  should render the control to the DOM too.


        }

        //var content = this.get('content');

        // but the context of the new control should be set.

        // Carousel Button
        //  Carousel button Selector
        //  In horizontal mode.

        //throw 'stop';

        // won't need to apply the context automatically... but maybe if the object does not already have one.


        //console.log('post content add');
    },

    'insert_before': function(target) {
        //console.log('target', target);

        //console.log('pre find parent');
        //throw 'stop';

        // The parent of a content Collection being a Control?
        //  Probably makes sense.


        var target_parent = target.parent().parent();

        //console.log('target_parent', target_parent);

        var target_index = target._index;

        //console.log('target_index', target_index);

        // insert into the content collection.

        var content = target_parent.get('content');

        content.insert(this, target_index);

        // An enhanced / activated control needs to listen for content change in particular.





        //console.log('');
        //console.log('target', target);

        // Controls need to better keep track of their index within the parent, and what their parent control is.
        //  Adds a bit of effort to keep track of what the indexes are.
        //  It's worth having the controls stay aware of what their index is where possible.

        // This 'parent' and relationship info could be integral to Data_Objects and Collections, not just Controls.

        //throw 'stop';
    },

    'stringify': function () {
        var res = [];
        res.push('Control(' + stringify(this._) + ')');
        return res.join('');
    },
    'style': fp(function(a, sig) {
        // For the moment, this should be a convenient way of updating the dom attributes style.

        //  This could do the document update or not....

        var style_name, style_value, modify_dom = true;

        if (sig == '[s]') {

            // Best not to refer to the computed styles probably?
            //  Really want to interact with inline styles here.

            // maybe have some syntax for computed styles, such as .style('computed', style_name);
            //  Or just don't have it, get it from the element if needed.




            // Want to get a style value.
            //  This could get fairly complicated when getComputedStyle is not around, in older browsers.

            // May have a system to read through a stylesheet and work out what would get applied to an element

            // For the moment, will look at style of control property (need to develop that more).

            var styleName = a[0];
            console.log('get style ' + styleName);

            var el = this.get('dom.el');

            // Should probably return a copy of the style, not read from the DOM.

            var res = getComputedStyle(el)[styleName];
            return res;


        }


        //console.log('style sig ' + sig);

        if (sig == '[s,s,b]') {
            var styleName = a[0];
            var styleValue = a[1];

            // Modify dom by default if there is a DOM.


            var modifyDom = a[2];

        };

        if (sig == '[s,s]' || sig == '[s,n]') {
            var styleName = a[0];
            var styleValue = a[1];

            // rebuild the css style???
            //  May just be in the dom attributes as well.

            //var das = this._.dom_attributes._.style;
            //console.log('das', das);

            //var da = this._.dom._.attributes;
            //console.log('da', da);




            // Modify dom by default if there is a DOM.
            //var modifyDom = a[2];

        };




        /*
        if (sig == '[s,s,b]') {
            var styleName = a[0];
            var styleValue = a[1];

            // Modify dom by default if there is a DOM.


            var modifyDom = a[2];

            var style = this.get('dom.attributes.style');


           // console.log('style ' + style);

            if (!style) {
                this.set('dom.attributes.style', styleName + ':' + styleValue + ';');
            } else {
                // parse the style attribute

                // can't do such a simple split, need to split in a way that avoids semicolons such as in a url?

                // try semicolon split.

                if (tof(style) == 'data_value') style = style.value();

                var map_style = parse_style_attribute_to_map(style);
                //console.log('map_style ' + stringify(map_style));


                map_style[styleName] = styleValue;

                var str_style = style_attribute_map_to_string(map_style);

                this.set('dom.attributes.style', str_style);


                //throw 'stop';
            }

            // Should modigy the DOM by default I think.
            if (modifyDom) {
                var style = this.get('dom.attributes.style');
                var el = this.get('dom.el');

                if (el) {
                    el.style.cssText = style;
                }
            }

        }
        */

        if (styleName && typeof styleValue !== 'undefined') {
            //var styleName = a[0];
            //var styleValue = a[1];

            // dom.attributes.style - as a normal data_object?
            //  Or a particular type of attribute that is dealt with differently?


            // Need to set the inline css dict

            // will update the dom attributes string from the style?
            //  will set an item in the inline_css_dict

            this._icss[styleName] = styleValue;

            // then rebuild the dom attributes style from that one.

            // produce the inline css from that dict...

            //console.log('styleName', styleName);

            var str_css = '';
            //var first = true;
            each(this._icss, function(item_style_value, item_style_name) {
                //if (!first) {
                //    str_css = str_css + '';
                //}
                str_css = str_css + item_style_name + ':' + item_style_value + ';';
            })
            //console.log('str_css', str_css);


            if (modify_dom) {
                this.set('dom.attributes.style', str_css);
            }

        }
        var that = this;


        if (sig == '[o]') {

            // could recompute the whole style string in a more optimized way.
            //  there could also be a style map, that would help in storing and checking particular styles.



            each(a[0], function(v, i) {
                that.style(i, v, false);
            });

            var style = this.get('dom.attributes.style');

            var el = this.get('dom.el');

            if (el) {
                el.style.cssText = style;
            }


        }


    }),
    'active': function() {
        // only on the server.
        //  Not necessarily!
        //  Perhaps client-side rendering should render the jsgui id. That is really necessary.
        //  However, perhaps should not use active to do this.


        //console.log('');
        //console.log('active');
        var id = this._id();

        //var domAttributes = this.get('dom.attributes');

        //domAttributes.set('data-jsgui-id', id);
        //domAttributes.set('data-jsgui-type', this.__type_name);


        // Longer code version...
        var dom = this._.dom;


        //console.log('this', this);

        var dom_attributes = this._.dom._.attributes;
        if (!dom_attributes) {
          dom_attributes = dom.get('attributes');
          //dom_attributes.set('data-jsgui-id', id);
          //dom_attributes.set('data-jsgui-type', this.__type_name);
          //console.log('dom_attributes', dom_attributes);
          //dom_attributes._['data-jsgui-id'] = new Data_Value({'value': id});
          //dom_attributes._['data-jsgui-type'] = new Data_Value({'value': this.__type_name});
        } else {

        }
        //console.log('dom_attributes', dom_attributes);
        //throw 'stop';
        dom_attributes._['data-jsgui-id'] = new Data_Value({'value': id});
        dom_attributes._['data-jsgui-type'] = new Data_Value({'value': this.__type_name});
        //var el = this._.el || dom._.el;
        var el = dom._.el;
        if (el) {
          //console.log('el', el);
          el.setAttribute('data-jsgui-id', id);
          el.setAttribute('data-jsgui-type', this.__type_name);
        }






        // Then update the DOM?




        // Calls active on the inner controls.

        //

        this.get('content').each(function(i, ctrl) {
            //console.log('active i', i);

            var tCtrl = tof(ctrl);
            //console.log('tCtrl', tCtrl);
            if (tCtrl === 'control') {
                ctrl.active();
            }
        });

        // need to listen to content change.


    },

    // So I think the resource-pool will have a selection scope.
    'find_selection_scope': function() {
        //console.log('find_selection_scope');

        var res = this.get('selection_scope');
        if (res) return res;

        // look at the ancestor...

        var parent = this.get('parent');
        //console.log('parent ' + tof(parent));


        if (parent) return parent.find_selection_scope();

    },


    // This should not just add the listener to the DOM event.
    //  This should listen to the relevant DOM event, and then apply the superclass's function
    //   (meaning it gets raised as a control event).

    // It gets raised as a control event anyway.
    //  If it matches a dom event then it gets raised as a control event when that dom event happens.

    /*

    'add_event_listener': function(event_name, handler) {
        var el = this.get('dom.el');
        if (el) {

            // Check if the element has that event listener...
            //  Maybe maintain a map within the control of which DOM functions have been bound to the element.



            el.addEventListener(event_name, handler, false);
        }
    },
    */



    /*
    '_add_event_listener': fp(function(a, sig) {

        // depending on what the event is, we also bind it to the DOM.
        //  can use addEventListener.

        if (sig == '[s,f]') {
            var event_name = a[0];

            var listener = this.mapListeners[event_name];
            var that = this;

            var el = this.get('dom.el');


            //if (el) {

                // Check if the element has that event listener...
                //  Maybe maintain a map within the control of which DOM functions have been bound to the element.

            //    if (!listener) {
                    // a single listener called when a bound dom event fires.
                    //  this will then split up the event calls to everything that is listening to this.
                    // for the DOM event on the object, we raise the event on the control.

            //        listener = this.mapListeners[event_name] = function(e) {
            //            that.raise(event_name, e);
            //        };
            //        el.addEventListener(event_name, listener, false);

            //    }


                //el.addEventListener(event_name, handler, false);
            //}


            // This causes an infinite loop for some reason.
            //  Maybe when the event takes place....

            Enhanced_Data_Object.prototype.add_event_listener.apply(this, a);


            //this._super.apply(this, a);


            //console.log('html core add_event_listener event_name', event_name);

            // And the base event listener as well?
            //  Does it make an infinite recursive loop when I try?

            //

        }

    }),
    */

    'click': function(handler) {
        // Adding the click event listener... does that add it to the DOM?

        this.add_event_listener('click', handler);
    },
    'hover': function(fn_in, fn_out) {
        this.add_event_listener('mouseover', function(e) {
            //console.log('hover mouseover');
            fn_in();
        })

        this.add_event_listener('mouseout', function(e) {
            //console.log('hover mouseout');
            fn_out();
        })
    },



    'add_class': function(class_name) {
        // Should have already set these up on activation.
        //console.log('Control add_class ' + class_name);
        var cls = this.get('dom.attributes.class');
        //console.log('cls ' + cls);
        var el = this.get('dom.el');

        //console.log('add_class el ' + el);
        if (!cls) {

            this.set('dom.attributes.class', class_name);


            // as well as that, need to have the class in the doc respond to this chaging.
            //  event listener listening for dom changes will update this.

            //if (el) el.className = class_name;

        } else {
            var tCls = tof(cls);
            //console.log('tCls ' + tCls);
            if (tCls == 'object') {
                //cls
                cls[class_name] = true;
                // then get the classes from the obj

                var arr_class = [];
                each(cls, function(i, v) {
                    if (v) arr_class.push(i);
                })
                var str_class = arr_class.join(' ');
                el.className = str_class;
            } else if (tCls == 'data_value') {
                var val = cls.value();

                var arr_classes = val.split(' ');
                var already_has_class = false, l = arr_classes.length, c = 0;
                while (c < l &! already_has_class) {
                    if (arr_classes[c] == class_name) {
                        already_has_class = true;
                    }
                    c++;
                }
                if (!already_has_class) {
                    arr_classes.push(class_name);
                }
                var str_cls = arr_classes.join(' ');
                //console.log('str_cls', str_cls);
                this.set('dom.attributes.class', str_cls);

               //this.add_class(val);
                // And the DOM should update itself when one of these 'model' objects gets changed - depending on if its activated or not.


            } else if (tCls == 'string') {
                var arr_classes = cls.split(' ');
                var already_has_class = false, l = arr_classes.length, c = 0;
                while (c < l &! already_has_class) {
                    if (arr_classes[c] == class_name) {
                        already_has_class = true;
                    }
                    c++;
                }
                if (!already_has_class) {
                    arr_classes.push(class_name);
                }
                var str_cls = arr_classes.join(' ');
                //console.log('str_cls', str_cls);
                this.set('dom.attributes.class', str_cls);
                // And the DOM should update itself when one of these 'model' objects gets changed - depending on if its activated or not.


            }
        }
        //throw 'stop';

    },

    'remove_class': function(class_name) {
        //console.log('remove_class ' + class_name);


        var cls = this.get('dom.attributes.class');
        //console.log('cls ' + stringify(cls));
        var el = this.get('dom.el');
        //console.log('el', el);
        if (cls) {
            var tCls = tof(cls);
            //console.log('tCls', tCls);
            //throw 'stop';
            if (tCls == 'object') {
                //el.

                // go through it again, building the class string...
                var arr_class = [];
                each(cls, function(i, v) {
                    //if (v) arr_class.push(i);
                    if (i == class_name) cls[i] = false;
                    if (cls[i]) arr_class.push(i);
                })
                var str_class = arr_class.join(' ');
                this.set('dom.attributes.class', str_cls);
                //el.className = str_class;

                //console.log('str_class ' + str_class);
            }
            if (tCls == 'string') {
                //console.log('cls', cls);
                var arr_classes = cls.split(' ');
                var arr_res = [];
                var l = arr_classes.length, c = 0;
                //console.log('arr_classes', arr_classes);
                while (c < l) {
                    if (arr_classes[c] != class_name) {
                        //already_has_class = true;
                        arr_res.push(arr_classes[c]);
                    }
                    c++;
                }
                //console.log('arr_res', arr_res);
                var str_cls = arr_res.join(' ');
                //console.log('str_cls ', str_cls);
                this.set('dom.attributes.class', str_cls);

                //console.log('str_cls ' + str_cls);
                //throw 'stop';
            }

            // and if it's a data value, do similar...

            if (tCls == 'data_value') {
                var cls2 = cls.value();

                var arr_classes = cls2.split(' ');
                var arr_res = [];
                var l = arr_classes.length, c = 0;
                //console.log('arr_classes', arr_classes);
                while (c < l) {
                    if (arr_classes[c] != class_name) {
                        //already_has_class = true;
                        arr_res.push(arr_classes[c]);
                    }
                    c++;
                }
                //console.log('arr_res', arr_res);
                var str_cls = arr_res.join(' ');
                //console.log('str_cls ', str_cls);
                this.set('dom.attributes.class', str_cls);

                //console.log('str_cls ' + str_cls);
            }

        }
    },

    'hover_class': function(class_name) {
        // Though this is a behaviour...
        //  could make this work through the behaviour system?
        //  could make the behaviour system work with this.
        //   This one seems fairly simple, lower level than behaviour system.

        // but in the group... when hover_class gets called for the group, it needs to be active on the group....

        // When targeting a group as well...
        //  May need to give groups a bit more thought.

        // But hover_class seems useful at least.


        var that = this;
        that.hover(function(e_in) {
            that.add_class(class_name);
            //ctrl_key_close_quote.add_class(hover_class);
        }, function(e_out) {
            that.remove_class(class_name);
            //ctrl_key_close_quote.remove_class(hover_class);
        })


    },

    'find': function(selector) {

    },
    'children': fp(function(a, sig) {
        var selector;

        if (sig == '[s]') {
            selector = a[0];
        }




    }),

    'matches_selector': function(selector) {

    },

    // Want to see if an element (or control) is a descendant of this.
    //  If this is an ancestor of element or control. is_ancestor_of
    // will go through DOM parent nodes or control parents.

    'is_ancestor_of': function(target) {
        var t_target = tof(target);
        console.log('t_target', t_target);

        var el = this.get('dom.el');

        var inner = function(target2) {

            if (target2 == el) {
                return true;
            }
            var parent = target2.parentNode;
            if (!parent) {
                return false;
            }  else {
                return inner(parent);
            }

        }

        if (t_target == 'object') {
            if (el != target) {
                var parent = target.parentNode;
                if (parent) {
                    return inner(parent);
                }
            }

        }
    },

    'find_selected_ancestor_in_scope': function() {
        // same selection scope
        // is this one already selected?
        // best not to check....

        var s = this.get('selection_scope');


        var parent = this.get('parent');
        //console.log('parent ' + parent);

        var ps = parent.get('selection_scope');

        if (s == ps) {
            // Probably would be much more convenient to get a data value just as its value,
            //  or have a more convenient data value idiom.
            var psel = parent.get('selected');
            if (psel && psel.value && psel.value() == true) {
                //throw 'stop';

                return parent;
            } else {
                return parent.find_selected_ancestor_in_scope();
            }
        }


        //throw 'stop';


    },

    'remove': function() {
        var el = this.get('dom.el');
        if (el) {
            if (el.parentNode) {
                el.parentNode.removeChild(el);
            }
        }
    },

    'shallow_copy': function() {
        console.log('Control shallow_copy');

        var res = new Control({
            'context': this._context
        });


        // need to get setting of one data object to another correct.
        //  That looks like a lower level piece of functionality that needs attention.

        // For the moment, want to get some kind of shallow copy working.

        //res.set('dom.attributes', this.get('dom.attributes'));

        var da = this.get('dom.attributes');
        var cl = da.get('class');

        console.log('cl ' + stringify(cl));
        console.log('cl ' + tof(cl));

        var map_class_exclude = {
            'bg-light-yellow': true,
            'selected': true
        }

        each(cl, function(i, v) {
            if (i && !map_class_exclude[i]) res.add_class(i);
        })

        var res_content = res.get('content');

        this.get('content').each(function(i, v) {
            console.log('v ' + v);
            //console.log('v ' + stringify(v));
            console.log('tof v ' + tof(v));

            if (tof(v) == 'data_value') {
                res_content.add(v.value());
            } else {
                res_content.add(v.shallow_copy());
            }


        })

        return res;
    },

    // May be good having _size
    //  or _measuredSize
    //  want to measure the control at a suitable time.

    // Should probably be in html-enh instead.

    'size': fp(function(a, sig) {
        //console.log('sig', sig);
        if (sig == '[]') {
            var el = this.get('dom.el');

            var w = parseInt(getStyle(el, 'width'), 10);
            var h = parseInt(getStyle(el, 'height'), 10);
            var res = [w, h];
            return res;
        }
        if (sig == '[a]') {
            // set the size.
            //  will be done through CSS height and width.
            //console.log('a[0]', a[0]);
            this.style({
                'width': a[0][0] + 'px',
                'height': a[0][1] + 'px'
            })

        }

    }),

    'offset': fp(function(a, sig) {
        if (sig == '[]') {
            var el = this.get('dom.el');
            var res = [el.offsetLeft, el.offsetTop];
            return res;
        }
        if (sig == '[a]') {
            this.style({
                'left': a[0] + 'px',
                'top': a[1] + 'px'
            })
        }
    }),

    'clear': function() {
        // clear all the contents.
        // ui should react to the change.

        return this.get('content').clear();

    },

    'activate': function() {
        // Do nothing for basic control I think.
        //  Possibly will be doing some things depending on discovered properties.

        // Need to work more on heirachy in activation.
        //  Want html documents (and pretty much everythin else) to use the enhanced activation.
        //  Should be OK having that in the dependency chain on the server, much of the code won't be called though.

        // Or, enhance the activations of the prototypes?
        //  I'd prefer to have the enhancements become higher up the chain.





    }

    // shallow_copy
    //  would make a copy of the controls and its contents.





    // add event listener...
    //  will be for the dom events.
    // dom.listeners?




    //





});


var p = Control.prototype;
//p._ = p._ || {};
//p._.type_name = 'control';

p._data_generators = {
    'context_id': function () {
        // this is the control
        //  the control should have access to a page_context?

        // Controls on the server are likely to need this for rendering right (different contexts).

        // On the client could refer to jsgui.page_context

        // could refer to jsgui.page_context, if it is there.
        //  Otherwise it would have to be a property of the control.
        //console.log('this.set ' + this.set);
        var page_context = this.page_context();
        var id = page_context.ensure_ctrl_id(this);
        return id;
    },
    'control_collection': function () {
        var res = new jsgui.DataCollection();
        return res;
    }
};

var initializing = false, fnTest = /xyz/.test(function() {
    xyz;
}) ? /\b_super\b/ : /.*/;

Control.prototype._module_jsgui = jsgui;

Control.extend = function(prop, post_init) {
    var _super = this.prototype;
    initializing = true;
    var prototype = new this();
    var for_class = {};
    initializing = false;
    if (typeof prop === 'string') {
        var data_type_name = prop;
        var dtis = jsgui.data_types_info;
        var data_type_info = dtis[data_type_name];
        for_class[data_type_name] = data_type_name;
        for_class[data_type_info] = data_type_info;
        prototype['__type_name'] = data_type_name;
        prototype['__data_type_info'] = data_type_info;
        prop = {};
    }
    var prop_item, t_prop_item, tmp, name, res;
    for (name in prop) {
        prop_item = prop[name];
        if (name.charAt(0) === '#') {
            prototype[name.substring(1)] = prototype[prop_item];
        } else {
            t_prop_item = typeof prop_item;
            if (t_prop_item === 'function') {
                prototype[name] = typeof _super[name] === 'function' && fnTest.test(prop_item) ?
                (function(name, fn) {
                    return function() {
                        tmp = this._super;
                        this._super = _super[name];
                        res = fn.apply(this, arguments);
                        this._super = tmp;
                        return res;
                    };
                })(name, prop[name]) : prop[name];
            } else if (t_prop_item === 'object' || t_prop_item === 'boolean') {
                if (name == 'class_name') {
                    for_class['_class_name'] = prop_item;
                } else if (name == 'fields') {
                    for_class['_fields'] = prop_item;
                } else if (name == 'connect_fields') {
                    for_class['_connect_fields'] = prop_item;
                } else {
                    prototype[name] = prop[name];
                }
            }  else {
                prototype[name] = prop[name];
            }
        };
    };
    var Class = function() {
        if (!initializing) {
            if (this.init) {
                var that = this;
                var the_make_function = function(abstract_control) {
                    // needs to create a real control out of an abstract one.
                   // var instance = new abstract_control

                   //console.log('the make function');
                   //console.log('abstract_control', abstract_control);
                   //console.log('abstract_control.constructor', abstract_control.constructor);

                   var spec = abstract_control._spec;
                   spec.abstract = null;
                   spec._abstract = null;
                   spec.context = that._context;
                   //console.log('that._context', that._context);
                   var instance = new abstract_control.constructor(spec);
                   //throw 'stop';

                   return instance;


                };

                var the_add_function = function(abstract_control) {
                    var instance = the_make_function(abstract_control);
                    return that.add(instance);
                }

                var l = arguments.length;
                var a2 = new Array(l + 2);
                for (var c = 0; c < l; c++) {
                    a2[c] = arguments[c];
                }
                a2[l] = the_add_function;
                a2[l + 1] = the_make_function;

                this.init.apply(this, a2);
                if (this.post_init) {
                    //this.post_init();
                    this.post_init.apply(this, arguments);
                }
                if (post_init) {
                    post_init.call(this);
                }
            } else {
                var spec = arguments[0] || {};
                spec.abstract = true;
                return new Class(spec);
            }
        }
    };
    Class.prototype = prototype;
    Class.prototype.constructor = Class;
    Class.extend = arguments.callee;
    for (i in for_class) {
        Class[i] = for_class[i];
    }
    if (Class['class_name']) {
        jsgui.map_classes[Class['class_name']] = Class;
    }
    Class._superclass = this;
    return Class;
};



// function to set up access functions on a prototype?
//  aliases?
//  access functions in particular here.

// Need to do more about rebuilding the framework with the new property system.
//  Will have encapsulated a lot into lang from html, making things easier here.

// lang/prototype_access

// Likely to be changed through use of the Data_Object

// Do we have a style variable?

var prototype_access = function (p, variable_name, fn_name) {

    p[fn_name] = fp(function (a) {

        //console.log('this. ' + stringify(this._));

        if (a.l == 1) {
            //var val = a[0];
            return this.set(variable_name, a[0]);
        } else {
            return this.get(variable_name);
        }
    });
}

var p = Control.prototype;

// This system works quite nicely now.
//  Allows simple functional access to these properties.

// prototype_access(p, 'index', 'index');
//prototype_access(p, 'id', 'id');
prototype_access(p, 'dom.tagName', 'tagName');
prototype_access(p, 'dom.attributes', 'domAttributes');
//prototype_access(p, 'controls', 'controls');


//prototype_access(p, 'style', 'style');

// access to the dom node as well.

// domAttributes

//p._tag_name = 'div';

var map_Controls = {};



//jsgui = {};
//jsgui.Core = Core;






// Own tof function for this section that checks instanceOf Control.

/*
var old_tof = jsgui.tof;

jsgui.tof = function (obj) {
    var res = old_tof(obj);
    if (obj instanceof Control) res = 'control';
    return res;

};
*/

// Also need to get this loading (automatically) as a client-side component.



// make it so that there is head.title(),
// also title() method for a basic HTML document.

// these should support text inside them.
// the 'text' property could do something different for different things.

// text_property('div span h1 h2')
// a property that represents a textNode inside.

// text property - will work as a property called text.
//  however, when the text has been set/changed, it changes text in a textNode.
// This text property should be a convenient interface to that text node.

// I think that means we need a textNode.

// Will have a dom.nodeType property.
//  Most things will be 1 (element)
//  Attribute node 2
//  Text node 3

// The properties indeed have greatly shortened this code.
//  Likely to put the new property system into the full library when more fully defined.
//  Or likely to put the full lib's capabilities into this, a new version of it?

// The new property system looks set to save on a lot of code. So much of the code is currently dealing with the mechanics of property values.

// Again, will change through use of the Data_Object
// and the control init function?
//  it's call

var ctrl_init = Control.prototype.init;
var ctrl_init_call = Control.prototype.init.call;

var escape_html_replacements = [
        [/&/g, '&amp;'],
        [/</g, '&lt;'],
        [/>/g, '&gt;'],
        [/"/g, '&quot;'], //"
        [/'/g, '&#x27;'], //'
        [/\//g, '&#x2F;']
    ];
//var single_replacement;

var escape_html = function (str) {

    //console.log('tof(str) ' + tof(str));

    //console.log('escape_html str ' + str);
    //console.log('tof str ' + tof(str));


    if (tof(str) === 'data_value') str = str.get();
    if (tof(str) === 'number') str = str + '';

    //console.log('tof(str)', tof(str));

    if (typeof str === 'undefined') {
      str = '';
    } else {
      var single_replacement;
      for (var c = 0, l = escape_html_replacements.length; c < l; c++) {
          single_replacement = escape_html_replacements[c]
          str = str.replace(single_replacement[0], single_replacement[1]);
      }
    }

    //

    // str.replace(/microsoft/gi, "W3Schools")
    /*
    var res = str.replace(/&/g, '&amp;');
    res = res.replace(/</g, '&lt;');
    res = res.replace(/>/g, '&gt;');
    res = res.replace(/"/g, '&quot;');
    res = res.replace(/'/g, '&#x27;');
    res = res.replace(/\//g, '&#x2F;');
    */

    //var replacements =

    //each(escape_html_replacements, function (i, v) {
    //    str = str.replace(v[0], v[1]);
    //});

    return str;
};


jsgui.textNode = Control.extend({
    'init': function (spec) {


        spec = spec || {};
        this._super(spec);

        if (typeof spec == 'string') {
            //this._.text = spec;
            //this.innerHtml = spec;
            spec = {
                'text': spec
            };
        }

        spec.nodeType = 3;
        //this.ensure('_');

        /*
  	if (spec.text) {
		this._.text = spec.text;
		//this.innerHtml = spec.text;
		spec = {};
	}
  	*/
        //this.no_escape = spec.no_escape || false;
        // another property from the spec? I think this property could fit in with an MVC (or MMVC) pattern where changes lead to updates in the HTML without
        // needing much programming for each change. 2/3 of this class could be removed if using different OO.

        /*
  	if (spec.no_escape) {
  		this.ensure('_');
  		this._.no_escape = spec.no_escape;
  	}
  	*/
        //ctrl_init_call(this, spec);

        //this._super(spec);

        if (typeof spec.text != 'undefined') {
            this._.text = spec.text;
        }

        //this.typeName = pr.typeName;
        //this.tagName = 'p';

    },
    // will use a no-escape property.
    /*
  'no_escape': fp(function(a, sig) {
  	if (a.l == 0) {
  		return this.ret('_.no_escape');
  	}
  	if (a.l == 1) {
  		this.ensure('_');
  		this._.no_escape = a[0];
  	}
  }),
  */
    'all_html_render': function () {
        // need to escape the HTML it outputs.



        //var text = this._.text || '';
        var text = this.get('text');
        // These get and set operations should not rely on the page_context.

        //console.log('text ' + text);

        var nx = this.get('no_escape');


        //console.log('nx ' + nx);

        if (nx) {
            res = text || '';
        } else {
            //console.log('text', text);
            res = escape_html(text || '') || '';
        }

        return res;
    }
    /*,

    // will have a text property.

    'text': function(text) {
    	// need to update the text in the dom.
    	this._.text = text;
    	// use jQuery for this?
    	// or DOM?
    	// not sure jQuery handles text nodes directly so well.

    	// is there this.$?

    	// do these text nodes get recreated?
    	//  they can't have the jsgui expando like elements.

    	// can not so easily get this text node activated on the client.

    	//  what about the ability to get / identify text nodes from their parent?
    	//  so that a parent could be told what active text node it contains.

    	// can tell a span control to change the text it contains.

    	//.text_nodes(0).text...
    	//  having a ctrl keep track of any text nodes inside them
    	//   modelling them, having controls.
    	//   however, don't want lots of complications.



    	// just innerHTML?

    }
    */
});



// And there is some client code that loads the necessary jsgui tools and then activates all the controls in the DOM.
//  Will do a DOM traverse, except start with the deepest nested elements.
//   Then it will be able to find controls inside controls.
//   A lot of elements will have JSGUI IDs.
//    But some things could be inferred to be controls because they follow a pattern.


// Page_Context needs a new_id method.


// I think some of this should be in Client_Page_Context
//  Perhaps Page_Context in its own module.

// Should this only be in enhanced?
//  So it creates enhanced controls?
//   Will that be OK for the server page context?


// Maybe should not need to get browser info yet? Keep it general???
// Perhaps there will be html-client.
//  Will have the ctrls_by_id? The page_context.
// Activating existing DOM nodes is easy enough without this activation system - just needs code to do it.
//  But having the nodes created on the server, then sent to the client - requires the JSGUI IDs or other reconstruction code.
// This does seem almost done for many uses - want to polish it though.
// Want to make a blog site fairly soon.

// Also a system for displaying content and programming snippets.
// Much of it would be server side, not needing client side activation.
//  Login could use it for enhancement.

// Can set the data_object constructor for boolean...
//  and it is a Data_Value.

// Seems like it should be within a client side page context.

// Do this within the Page_Context.
/*
var map_controls_by_type = {};


var update_ctrl_lookup = fp(function(a, sig) {
    console.log('update_ctrl_lookup sig ' + sig);
    var Module;
    if (a.l == 1) {
        Module = a[0];
        each(Module, function(ctrl_name, Ctrl) {
            console.log('ctrl_name ' + ctrl_name);
            var lName = ctrl_name.toLowerCase();
            map_controls_by_type[lName] = Ctrl;
            console.log('** map_controls_by_type ' + JSON.stringify(map_controls_by_type));
        })
    }

    if (sig == '[s,f]') {
        var name = a[0];
        var Ctrl = a[1];
        map_controls_by_type[name] = Ctrl;
    }
    console.log('* map_controls_by_type ' + JSON.stringify(map_controls_by_type));

});
*/


// Maybe the jsgui page context will be the key to getting this running on the client.
//  Could package some things as jquery plugins. Maybe have a standalone build of jsgui.



// Perhaps it will be context.activate?


// context.activate?
//  that may work better.

// Need more generalised recursive dom activation.
//  When activating a control recursively, need to go through all of the sub-elements
//   activate them from the inside.



var shallow_copy = fp(function(a, sig) {
    if (sig == '[a]') {
        var arr_ctrls = a[0];

        var res = [];
        each(arr_ctrls, function(i, v) {
            res.push(v.shallow_copy());
        });
        return res;
    }
});

var constructor_from_type = function(type) {
    console.log('constructor_from_type type ' + type);
    console.log('map_controls_by_type ' + stringify(map_controls_by_type));
}
//

jsgui = jsgui.extend(jsgui, {
    'get_inline_css_dict_from_style': get_inline_css_dict_from_style,
    'apply_jsgui_style_rule_to_css_style': apply_jsgui_style_rule_to_css_style,
    'styles_dict_to_string': styles_dict_to_string,
    'Control': Control,
    //'Page_Context': Page_Context,
    //'Blank_HTML_Document': Blank_HTML_Document,
    //'Client_HTML_Document': Client_HTML_Document,
    //'recursive_dom_iterate': recursive_dom_iterate,
    'map_Controls': map_Controls,
    //'update_ctrl_lookup': update_ctrl_lookup,
    //'activate': activate,
    'shallow_copy': shallow_copy
    //'constructor_from_type': constructor_from_type,
    //'map_controls_by_type': map_controls_by_type
});
//alert('2 ' + jsgui);
//return jsgui;
module.exports = jsgui;

},{"../core/jsgui-lang-enh":36}],48:[function(require,module,exports){
//if (typeof define !== 'function') {
//    var define = require('amdefine')(module);
//};

// Needs a general Page_Context

// so enh includes the page_context?

// Really not sure about where in the heirachy the Page_Context is. Many controls need it.

// May be easier if these enhancements did away with the page context. May need to work on the server too.

// However, this I think was intended only for the client anyway.

// Handle circular dependencies...


var jsgui = require('./jsgui-html-core');

// don't think this can have context menu so easily here.
//var Context_Menu = require('./controls/advanced/context-menu');

var stringify = jsgui.stringify, each = jsgui.eac, tof = jsgui.tof, is_defined = jsgui.is_defined;
var Control = jsgui.Control;
var Selection_Scope = require('./selection-scope');
var fp = jsgui.fp;
var group = jsgui.group;
var str_arr_mapify = jsgui.str_arr_mapify;
var map_Controls = jsgui.map_Controls;
var extend = jsgui.extend;
var is_ctrl = jsgui.is_ctrl;

//var Context_Menu;

// Don't include context-menu in enh...
//  Or find a different way to include it
//  Have different enh-levels, eg most of it is enh-1
//  then context-menu is in enh-2.
//  html-enh contains both 1 and 2, and future levels if they are made.


// Don't like what follows - it's tricky. May make it hard to recompile / build the code.
//  And would be unnecessary when the context menu has been localised.


var hover_class = fp(function(a, sig) {
    //console.log('hover_class sig ' + sig);
    if (sig == '[c,s]') {
        var ctrl = a[0];
        var hover_class = a[1];
        ctrl.hover(function(e_in) {
            ctrl.add_class(hover_class);
        }, function(e_out) {
            ctrl.remove_class(hover_class);
        });
    }
});

// this is the enhanced HTML module.

var group_hover_class = fp(function(a, sig) {
    // Could possibly recategorise into having an array if the sig as a bunch of objects of one type and then
    //  a string.

    //poly2(a, sig);

    if (sig == '[a,s]') {
        // An array of items to put into the group.

        var res = group(a[0]);
        //console.log('res ' + tof(res));

        var hover_class = a[1];
        res.hover(function(e_in) {
            res.add_class(hover_class);
        }, function(e_out) {
            res.remove_class(hover_class);
        })

        return res;
    }

});


var get_window_size = function() {
    var winW, winH;
    if (document.body && document.body.offsetWidth) {
        winW = document.body.offsetWidth;
        winH = document.body.offsetHeight;
    }
    if (document.compatMode=='CSS1Compat' && document.documentElement && document.documentElement.offsetWidth ) {
        winW = document.documentElement.offsetWidth;
        winH = document.documentElement.offsetHeight;
    }
    if (window.innerWidth && window.innerHeight) {
        winW = window.innerWidth;
        winH = window.innerHeight;
    }
    return [winW, winH];
}


var findPos = function(obj) {
    var curleft = curtop = 0;
    if (obj.offsetParent) {
        do {
            curleft += obj.offsetLeft;
            curtop += obj.offsetTop;
        } while (obj = obj.offsetParent);
        return [curleft,curtop];
    }
}




// Selection_Scope should possibly be in its own module.
//  It will be used by client-page-context as well.




// Some of these will need to get a bit more complex with options, but they will also generally be transferrable among jsgui controls.

// The outermost object will have selection scope
//  That means that within it when there is a deselect_all command it deselects within that scope.

// We could have an enhanced control too.

// Perhaps replace the basic control in this case, so an upgraded control is always used.
//  Would have more functionality to do with windows, setting up a control so that it's a window, with docking capability.

// Perhaps more client-side capabilities should be here, like activate.

var mapDomEventNames = {
    'change': true,

    'click': true,
    'mousedown': true,
    'mouseup': true,
    'mousemove': true,
    'mouseover': true,
    'mouseout': true,
    'blur': true,
    'focus': true,
    'keydown': true,
    'keyup': true,
    'keypress': true,
    'contextmenu': true,

    'touchstart': true,
    'touchmove': true,
    'touchend': true,

    'abort': true,
    'canplay': true,
    'canplaythrough': true,
    'durationchange': true,
    'emptied': true,
    'ended': true,
    'error': true,
    'loadeddata': true,
    'loadedmetadata': true,
    'loadstart': true,
    'pause': true,
    'play': true,
    'playing': true,
    'progress': true,
    'ratechange': true,
    'seeked': true,
    'seeking': true,
    'stalled': true,
    'suspend': true,
    'timeupdate': true,
    'volumechange': true,
    'waiting': true

};


//var t_content;
var desc = function(ctrl, callback) {
  if (ctrl.get) {


    var content = ctrl.get('content');
    //console.log('content', content);
    var t_content = typeof content;
    //console.log('t_content', t_content);

    if (t_content === 'string' || t_content === 'number') {

    } else {
      // it's a Collection

      var arr = content._arr;
      var c, l = arr.length;

      //console.log('l', l);
      var item, t_item;

      for (c = 0; c < l; c++) {
        item = arr[c];
        t_item = typeof item;
        if (t_item === 'string' || t_item === 'numbers') {

        } else {
          callback(arr[c]);
          desc(arr[c], callback);
        }



      }




    }


      /*
      var content = ctrl.get('content');
      console.log('content', content);
      each(content, function(v, i) {
          if (typeof i !== 'string') {
              callback(v);
              desc(v, callback);
          }
      });
      */

  }
}

var dom_desc = function(el, callback) {
  // Possibly need to look at the element's node type.

  //
  callback(el);

  var cns = el.childNodes;

  var l = cns.length;

  for (var c = 0; c < l; c++) {
    dom_desc(cns[c], callback);

  }


}


Control = jsgui.Control = jsgui.Control.extend({
    'fields': {
        'selection_scope': Object,
        'is_selectable': Boolean
    },

    'init': function(spec) {
        // The enhanced control can look at the element for data-jsgui-fields
        //  Those fields will be fed back into the initialization.


        if (spec.el) {
          var jgf = spec.el.getAttribute('data-jsgui-fields');

          if (jgf) {

            //console.log('str_ctrl_fields ' + str_ctrl_fields);
            //console.log('str_properties', str_properties);
            //var s_pre_parse = str_properties.replace(/'/g, '"').replace(/♥/g, '\'').replace(/☺/g, '"');
            var s_pre_parse = jgf.replace(/\[DBL_QT\]/g, '"').replace(/\[SNG_QT\]/g, '\'');
            s_pre_parse = s_pre_parse.replace(/\'/g, '"');

            // DBL_QT
            //console.log('s_pre_parse', s_pre_parse);

            //console.log('s_pre_parse', tof(s_pre_parse));

            var props = JSON.parse(s_pre_parse);

            extend(spec, props);
          }

        }


        this._super(spec);

        // Then there may be a selection scope specified.
        //  The selection scope may have been specified as a number

        //console.log('spec.selection_scope', spec.selection_scope);

        console.log('spec.selection_scope', spec.selection_scope);


        if (typeof spec.selection_scope !== 'undefined') {
          //console.log('spec.selection_scope', spec.selection_scope);

          var selection_scope = this._context.get_selection_scope_by_id(spec.selection_scope);
          //  Do we need to set the control of the selection scope?

          console.log('selection_scope', selection_scope);


          this.set('selection_scope', selection_scope);

          // then if we have the selection scope, we should set it up for the control.







        }

        if (spec.is_selectable) {
          this.selectable();
        }



    },

    'bcr': fp(function(a, sig) {
        //console.log('sig', sig);
        if (sig == '[]') {
            var el = this.get('dom.el');


            var bcr = el.getBoundingClientRect();
            var res = [[bcr.left, bcr.top], [bcr.right, bcr.bottom], [bcr.width, bcr.height]];

            return res;
        }

        // However, need to take account of the padding and the class.

        // instead of getting the bcr, we could ge the style('width')?
        //  which would actually get the width style value?

        // Or we could get the bcr, and then subtract the padding as well.

        // ctrl.padding
        //  seems like a useful enhancement syntax to have
        //  would be useful in keeping things in proportion and accounting for the padding.

        // Probably want to be getting the computed style from the browser.
        //  Some info is within CSS and effects things through that.
        //  Sometimes in the JS we need to read from the screen because values have been calculated by the css system.
        //  Want this to be somewhat responsive to the CSS that is written.

        if (sig == '[a]') {
            console.log('bcr sig arr');

            var bcr_def = a[0];
            var pos = bcr_def[0];
            var br_pos = bcr_def[1];
            var size = bcr_def[2];

            // then we actually want to set the css.

            this.style({
                'position': 'absolute',
                'left': pos[0] + 'px',
                'top': pos[1] + 'px',
                'width': size[0] + 'px',
                'height': size[1] + 'px'
            });
            //throw 'stop';
        }
    }),

    'computed_style': fp(function(a, sig) {
        if (sig == '[s]') {
            // Should only work on the client.
            var property_name = a[0];
            var x = this.get('dom.el');
            if (x.currentStyle)
                var y = x.currentStyle[styleProp];
            else if (window.getComputedStyle)
                var y = document.defaultView.getComputedStyle(x,null).getPropertyValue(property_name);
            return y;
        }
    }),

    'padding': fp(function(a, sig) {
        if (sig == '[]') {
            // read the padding.
            //  the computed style is probably what we are after.
            // Perhaps a computed_style function would help too, making the code clearer that this padding function uses that.
            // Perhaps just calling 'style' should get the computed style while it's in the browser.
            //  There would be both the computed properties and the set properties.
            // Perhaps we should always refer to computed style or cstyle
            //  Avoid confusion with the padding property that can be set
            //
            var left, top, right, bottom;

            var c_padding = this.computed_style('padding');
            console.log('c_padding', c_padding);

            var s_c_padding = c_padding.split(' ');
            console.log('s_c_padding.length', s_c_padding.length);

            if (s_c_padding.length == 3) {
                // top, right, bottom
                top = parseInt(s_c_padding[0], 10);
                right = parseInt(s_c_padding[1], 10);
                bottom = parseInt(s_c_padding[2], 10);
                return [0, top, right, bottom];
            }
        }
    }),

    'border': fp(function(a, sig) {
        if (sig == '[]') {
            // read the padding.
            //  the computed style is probably what we are after.

            // Perhaps a computed_style function would help too, making the code clearer that this padding function uses that.

            // Perhaps just calling 'style' should get the computed style while it's in the browser.
            //  There would be both the computed properties and the set properties.

            // Perhaps we should always refer to computed style or cstyle
            //  Avoid confusion with the padding property that can be set
            //

            var left, top, right, bottom;

            var c_border = this.computed_style('border');
            console.log('c_border', c_border);

            throw 'stop';

            /*

            var s_c_padding = c_padding.split(' ');
            console.log('s_c_padding.length', s_c_padding.length);

            if (s_c_padding.length == 3) {
                // top, right, bottom
                top = parseInt(s_c_padding[0], 10);
                right = parseInt(s_c_padding[1], 10);
                bottom = parseInt(s_c_padding[2], 10);

                // returns as l, t, r, b

                //return [0, top, right, bottom];

                return [0, top, right, bottom];

            }
            */





        }
    }),
    'border_thickness': fp(function(a, sig) {
        if (sig == '[]') {
            // read the padding.
            //  the computed style is probably what we are after.

            // Perhaps a computed_style function would help too, making the code clearer that this padding function uses that.

            // Perhaps just calling 'style' should get the computed style while it's in the browser.
            //  There would be both the computed properties and the set properties.

            // Perhaps we should always refer to computed style or cstyle
            //  Avoid confusion with the padding property that can be set
            //

            var left, top, right, bottom;

            var c_border = this.computed_style('border');
            console.log('c_border', c_border);

            //var s_c_border = c_border.split(' ');
            //console.log('s_c_border', s_c_border);

            // Can't really split it by space.
            //  some of the terms in the bracket include a space.
            //  could first do a regex to change ', ' to ','

            var b2 = c_border.split(', ').join('');
            var s_c_border = b2.split(' ');
            console.log('s_c_border', s_c_border);

            // then can get the thickness from the first one.

            var thickness = parseInt(s_c_border[0], 10);

            // the 4 different thicknesses?

            return thickness;


            //throw 'stop';

            /*

             var s_c_padding = c_padding.split(' ');
             console.log('s_c_padding.length', s_c_padding.length);

             if (s_c_padding.length == 3) {
             // top, right, bottom
             top = parseInt(s_c_padding[0], 10);
             right = parseInt(s_c_padding[1], 10);
             bottom = parseInt(s_c_padding[2], 10);

             // returns as l, t, r, b

             //return [0, top, right, bottom];

             return [0, top, right, bottom];

             }
             */





        }
    }),

    'cover': fp(function(a, sig) {
        // Makes a cover to this control.
        //  Relatively positioned div as first child (if it is not there already)
        //  Absolutely positioned within that relative div.

        // insert a new relative div?
        //  relative for layout?





    }),

    'ghost': fp(function(a, sig) {

    }),

    // absolute_ghost_clone
    'absolute_ghost_clone': function() {
        // find out what type the control is...

        // And would either have lower opacity - or be 'ghosted' out with a cover.
        //  Could have an internal cover that takes up the space.
        //  Absolute positioning, measured to take up the internal space.
        //  Would require a relative div inside?
        //  Could create a relative div as the first child.
        //   relative size 0, in the top left, then used for absolute positioning of the cover layer.


        // this.cover
        //  and would get access to the cover control as well.
        //  should be absolutely positioned, and above the other items in the control.

        // this.cover(false);

        // this.ghost()
        //  makes a ghost cover.











        var type_name = this.__type_name;
        var id = this._id();
        var context = this._context;

        // spin up a new control, using they type of controls.

        console.log('context', context);

        var ctrl_document = context.ctrl_document;

        console.log('ctrl_document', ctrl_document);
        console.log('type_name', type_name);

        var Cstr = context.map_Controls[type_name];
        console.log('Cstr', Cstr);

        // We can create a new one, with a new ID.

        var new_id = id + '_clone';
        var map_controls = context.map_controls;

        // Want the body control as well.



        if (!map_controls[new_id]) {
            // create it.

            var new_ctrl = new Cstr({
                'context': context,
                'id': new_id
            })

            console.log('new_ctrl', new_ctrl);

            //var body = ctrl_document.body();

            var body = ctrl_document.content().get(1);

            var css_class = this.get('dom.attributes.class');
            new_ctrl.set('dom.attributes.class', css_class);

            // Should copy the controls inside the one being cloned.
            var my_contents = this.get('content');

            // should be able to clone a Data_Value too.



            each(my_contents, function(v, i) {
                console.log('i', i);
                console.log('v', v);

                // Adding a Data_Value not working?

                var v_clone = v.clone();
                console.log('v_clone', v_clone);

                // could get the value if it's a Data_Value for the moment...
                //  Adding a Data_Value to a

                //if (v_clone.value) {
                if (v_clone instanceof jsgui.Data_Value) {
                    new_ctrl.add(v_clone.value());
                } else {
                    new_ctrl.add(v_clone);
                }



            })

            console.log('this', this);

            // could get the computed width?

            // computed padding too?



            var my_bcr = this.bcr();


            console.log('my_bcr', my_bcr);

            // and get the border thickness too.
            //  may be a bit more complex getting them all
            //  and making sure it works in all browsers.







            var my_padding = this.padding();
            console.log('my_padding', my_padding);

            my_bcr[2][0] = my_bcr[2][0] - my_padding[0];
            my_bcr[2][1] = my_bcr[2][1] - my_padding[1];
            my_bcr[2][0] = my_bcr[2][0] - my_padding[2];
            my_bcr[2][1] = my_bcr[2][1] - my_padding[3];



            //var my_border = this.border();
            //console.log('my_border', my_border);

            var my_border_thickness = this.border_thickness();

            console.log('my_border_thickness', my_border_thickness);


            var t_my_border_thickness = tof(my_border_thickness);

            if (t_my_border_thickness == 'number') {
                my_bcr[2][0] = my_bcr[2][0] - 2 * my_border_thickness;
                my_bcr[2][1] = my_bcr[2][1] - 2 * my_border_thickness;

            }

            // Not sure how the border would be reported in a bunch of different browsers or border values

            // could be '1px solid rgb(221, 221, 221)'
            // could have regexes testing for various borders and getting the values back from them.

            //  so we know the thickness of the individual left, top, right, bottom because we get them all at once.







            // and subtract the padding.



            // and use the bcr values to set the position and size of the new control.

            // .bounds?
            //   sets the position (screen location) and the size?
            //   gets the bounding client rect?



            new_ctrl.bcr(my_bcr);




            console.log('new_ctrl', new_ctrl);





            //throw 'stop';

            // need to make the new control absolute







            //ctrl_document.body().add(new_ctrl);
            body.add(new_ctrl);

            var new_el = new_ctrl.get('dom.el');
            console.log('new_el', new_el);


            //throw 'stop';

        }









        //throw 'stop';





    },

    /*

    'create_ghost_copy': function() {
        // Needs to clone the control, and put it into the body.

        // May need to do some in-depth work on cloning a control.
        //  Don't want to complicate the code too much though.
        //  Could just add the HTML from inside the other one.

        var ghost_copy = new Control({
            'context': this._context
        });

        var el = this.get('dom.el');

        // Can't reuse IDs
        //  I think we need a means of cloning controls (properly).
        //  Need to run a clone procedure on the Control and its subcontrols.
        //  Would make a clone within the same context but it would get a new ID.






        if (el) {
            //ghost_copy.add(el.innerHTML)

            var my_clone = this.clone();

            // then put the clone in the body.

            var body = this._context.body();
            body.add(my_clone);
        }


    },
    */

    // can have different monomorphic versions.

    'set': function(name, value) {
      // Used for setting controls, on the server, that get persisted to the client.

      // when the value is a control, we also want to set the ._jsgui_ctrl_fields



      if (typeof value !== 'undefined') {
          //var t_val = tof(value);
          //console.log('t_val', t_val);

          if (is_ctrl(value)) {
              var cf = this._ctrl_fields = this._ctrl_fields || {};

              //extend(cf, {
              //  'btn_single_bound': tb_single_bound,
              //  'btn_dual_bound': tb_dual_bound,
              //  'btn_ga': tb_genetic,
              //  'panel_single_bound': panel_single_bound,
              //  'panel_dual_bound': panel_dual_bound,
              //  'panel_ga': panel_ga
              //});

              cf[name] = value;
          }

        return this._super(name, value);
      } else {
        return this._super(name);
      }




      /*



      */


    },




    'one_mousedown_anywhere': function(callback) {
        //var ctrl_html_root = this._context.ctrl_document;
        //console.log('this._context', this._context);
        var body = this._context.body();

        var that = this;

        body.one('mousedown', function(e_mousedown) {
            // Maybe see if it's internal or external to the control

            // Would be good to have that in the event.

            var el = that.get('dom.el');

            var e_el = e_mousedown.srcElement || e_mousedown.target;





            console.log('one mousedown', e_mousedown);
            console.log('e_el', e_el);

            // Want to see if the element clicked on is a descendant of this's el.

            var iao = that.is_ancestor_of(e_el);
            //console.log('iao', iao);

            e_mousedown.within_this = iao;

            callback(e_mousedown);

        });
    },


    // This may need to search inside for controls to be activated.
    //  Need to get this to work with client-rendered content.


    'activate_recursive': function() {
        console.log('activate_recursive');
        var el = this.get('dom.el');

        var context = this._context;
        var map_controls = context.map_controls;

        var parent_control;

        // does the control have a DOM node?


        recursive_dom_iterate_depth(el, function(el2) {
            //console.log('el ' + el);
            var nt = el2.nodeType;
            //console.log('nt ' + nt);
            if (nt == 1) {
                var jsgui_id = el2.getAttribute('data-jsgui-id');





                //console.log('jsgui_id ' + jsgui_id);
                if (jsgui_id) {


                    // Not so sure the control will exist within a map of controls.
                    //  If we have activated the whole page, then they will exist.
                    //  However, we may just want to do activate on some controls.
                    //throw 'stop';


                    var ctrl = map_controls[jsgui_id];

                    /*
                    if (parent_control) {
                      console.log('setting ctrl parent');
                      ctrl.parent(parent_control);
                    }
                    */

                    //console.log('ctrl ' + ctrl);

                    // don't want to activate twice.

                    // specifically avoid activating twice?


                    //if (el2 != el) {
                    //    //ctrl.activate(el2);
                    //}

                    if (!ctrl.__active) ctrl.activate(el2);
                    //parent_control = ctrl;




                    //console.log('jsgui_type ' + jsgui_type);
                }
            }
        })
    },

    // fp removal candidate

    'add_event_listener': fp(function(a, sig) {

        /*
        var el = this.get('dom.el');
        if (el) {

            // Check if the element has that event listener...
            //  Maybe maintain a map within the control of which DOM functions have been bound to the element.



            el.addEventListener(event_name, handler, false);
        }
        */

        // In enh - with this only working post-activation?

        // see http://www.w3schools.com/tags/ref_av_dom.asp
        /*
        abort	Fires when the loading of an audio/video is aborted
        canplay	Fires when the browser can start playing the audio/video
        canplaythrough	Fires when the browser can play through the audio/video without stopping for buffering
        durationchange	Fires when the duration of the audio/video is changed
        emptied	Fires when the current playlist is empty
        ended	Fires when the current playlist is ended
        error	Fires when an error occurred during the loading of an audio/video
        loadeddata	Fires when the browser has loaded the current frame of the audio/video
        loadedmetadata	Fires when the browser has loaded meta data for the audio/video
        loadstart	Fires when the browser starts looking for the audio/video
        pause	Fires when the audio/video has been paused
        play	Fires when the audio/video has been started or is no longer paused
        playing	Fires when the audio/video is ready to play after having been paused or stopped for buffering
        progress	Fires when the browser is downloading the audio/video
        ratechange	Fires when the playing speed of the audio/video is changed
        seeked	Fires when the user is finished moving/skipping to a new position in the audio/video
        seeking	Fires when the user starts moving/skipping to a new position in the audio/video
        stalled	Fires when the browser is trying to get media data, but data is not available
        suspend	Fires when the browser is intentionally not getting media data
        timeupdate	Fires when the current playback position has changed
        volumechange	Fires when the volume has been changed
        waiting	Fires when the video stops because it needs to buffer the next frame

        abort
        canplay
        canplaythrough
        durationchange
        emptied
        ended
        error
        loadeddata
        loadedmetadata
        loadstart
        pause
        play
        playing
        progress
        ratechange
        seeked
        seeking
        stalled
        suspend
        timeupdate
        volumechange
        waiting
        */




        // So, it should also bind the event to the control, so a listener will hear that.

        // But does this apply itself???
        this._super.apply(this, a);

        // then if it appears in the dom events, attach it.

        if (sig == '[s,f]') {
            var event_name = a[0];

            // change is also a DOM event
            //  that's a tricky one.
            //  should make it easy to listen out for DOM changes.
            // let's include it for the moment.



            if (mapDomEventNames[a[0]]) {
                //console.log('we have a DOM event: ' + event_name);

                var listener = this.mapListeners[event_name];
                var that = this;
                var el = this.get('dom.el');

                //console.log('el' + el);

                if (el) {
                    if (!listener) {
                        // a single listener called when a bound dom event fires.
                        //  this will then split up the event calls to everything that is listening to this.
                        // for the DOM event on the object, we raise the event on the control.

                        listener = this.mapListeners[event_name] = function(e) {
                            //console.log('event_name heard ' + event_name);

                            // Raising an event, there could be multiple listeners.
                            //  would be good to get an array of what the listeners returned.
                            //  Return false here if any of them return false?



                            var res_raise = that.raise(event_name, e);
                            //console.log('res_raise', res_raise);

                            // then if any results are false, we return false.

                            var any_are_false = false;
                            var c = 0, l = res_raise.length;

                            while (!any_are_false && c < l) {
                                if (res_raise[c] === false) {
                                    any_are_false = true;
                                }

                                c++;
                            }

                            //console.log('any_are_false', any_are_false);

                            if (any_are_false) {
                                e.preventDefault();
                                return false;
                            }
                            // Would like to respond to the event.
                            //  Eg if the dom event handler returns false, it would be good to return false in the listener.



                        };
                        el.addEventListener(event_name, listener, false);

                    }
                }
            }
        }
    }),

    // not recursive
    //  maybe call activate_individual?

    //

    'activate': function(el) {

      // Need to prevent activation while it's activating already.
      // For the moment, it would take quite a lot of boilerplate.
      //  Perhaps some functional programming would solve that.

      // Or have an inner activate function. At each level, it calls the inner function if necessary.
      //  A simple function locking system, where it only runs if non-active?

      // could have a non-active function wrapper that only runs the function if the control is non-active.
      //  Only set active to be true on Control.




      //console.log('enh ctrl activate');

      if (!this.__active) {
        this.__active = true;
        if (el) {
            this.set('dom.el', el);
        }

        this.rec_desc_ensure_ctrl_el_refs();

        //console.log('activate ' + this._id());
        // activate content controls.
        //console.log('1) ' + this._.content._arr.length);

        // But have this done before initialization?
        //  Probably want to use some values that have been read in for initialization.
        //   May disable this later, once the data is being read on initialization.
        this.activate_dom_attributes();


        //console.log('2) ' + this._.content._arr.length);

        this.activate_content_controls();
        //console.log('3) ' + this._.content._arr.length);

        // then is there is a selection_scope as true, create a new Selection_Scope object, then set it so that subcontrols point
        //  to it with their selection_scope property.

        // so after the fields have been set up.

        this.activate_content_listen();
        //console.log('4) ' + this._.content._arr.length);

        // Activate style change listen?
        //  Or generally dom attributes change listen?

        this.activate_other_changes_listen();
        //console.log('5) ' + this._.content._arr.length);
      }




    },
    'activate_other_changes_listen': function() {

        /*
        var style = this.get('dom.attributes.style');

        console.log('style', style);

        style.on('change', function(e_change) {
            console.log('style change', e_change);
        })
        */
        var dom_attributes = this.get('dom.attributes');
        //console.log('dom_attributes', dom_attributes);

        var el = this.get('dom.el');

        dom_attributes.on('change', function(e_change) {
            var property_name = e_change.name, dval = e_change.value;

            //console.log('dom_attributes change', property_name, dval);

            /*
            if (property_name == 'style') {
                // need to update it on the element.

                if (tof(dval) == 'string') {
                    el.setAttribute('style', dval);
                } else {
                    el.setAttribute('style', dval.value());
                }
            } else if (property_name == 'class') {
                // need to update it on the element.

                if (tof(dval) == 'string') {
                    el.setAttribute('class', dval);
                } else {
                    el.setAttribute('class', dval.value());
                }
            }
            */

            // I think this works better, 02/05/14

            //console.log('tof(dval)', tof(dval));

            var t_dval = tof(dval);

            if (t_dval == 'string' || t_dval == 'number') {
                //el.setAttribute('style', dval);
            } else {
                //el.setAttribute('style', dval.value());

                dval = dval.value();
            }

            if (el) {
              el.setAttribute(property_name, dval);
            }


        });


    },
    'activate_content_listen': function() {
        //console.log('activate_content_listen');

        var content = this.get('content');

        //console.log('1) content.length()', content.length());

        var that = this;
        var context = this._context;
        var map_controls = context.map_controls;


        content.on('change', function(e_change) {
            //console.log('activated control content change');

            var el = that.get('dom.el');
            var type = e_change.type;

            if (type == 'insert') {
                var item = e_change.item;

                var itemDomEl = item.get('dom.el');

                // need to render the item ID in there too.
                //var id = item._id();

                if (!itemDomEl) {
                  if (context.map_els[item._id()]) {
                    itemDomEl = context.map_els[item._id()];
                  }

                }
                if (!itemDomEl) {
                    var item_tag_name = 'div';
                    var dv_tag_name = item.get('tag_name');
                    if (dv_tag_name) {
                      item_tag_name = dv_tag_name.value();
                    }
                    var temp_el;


                    if (item_tag_name == 'circle' || item_tag_name == 'line' || item_tag_name == 'polyline') {
                        // Can make SVG inside an element, with the right namespace.

                        var temp_svg_container = e_change.item._context.document.createElement('div');
                        temp_svg_container.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" version="1.1">' + e_change.item.all_html_render() + '</svg>';
                        itemDomEl = temp_svg_container.childNodes[0].childNodes[0];
                        //


                    } else {
                        temp_el = e_change.item._context.document.createElement('div');
                        temp_el.innerHTML = e_change.item.all_html_render();
                        itemDomEl = temp_el.childNodes[0];
                    }
                    item._.el = itemDomEl;
                    e_change.item.set('dom.el', itemDomEl);
                    item.active();
                };
                //console.log('itemDomEl', itemDomEl);
                var t_item_dom_el = tof(itemDomEl);

                if (t_item_dom_el === 'string') {
                  itemDomEl = document.createTextNode(itemDomEl);
                }

                //el.insertBefore(itemDomEl, el.childNodes[0]);

                //console.log('item', item);
                //console.log('that', that);


                if (!el) {
                  //console.log('*** that._id()', that._id());
                  that.parent().parent().rec_desc_ensure_ctrl_el_refs();
                  el = context.map_els[that._id()];
                  that.set('dom.el', el);
                  that._.el = el;
                  //console.log('* el', el);
                }


                el.appendChild(itemDomEl);

                // May not have actually gone into the DOM yet!

                //setTimeout(function() {
                //  that.rec_desc_ensure_ctrl_el_refs();
                //  if (item.activate) item.activate();
                //}, 0);




                //if (item.rec_desc_ensure_ctrl_el_refs) item.rec_desc_ensure_ctrl_el_refs(itemDomEl);





            }

            if (type == 'clear') {
                el.innerHTML = '';
            }


        });

        //console.log('2) content.length()', content.length());
    },

    'rec_desc_ensure_ctrl_el_refs': function(el) {
      el = el || this.get('dom.el') || this._.el;

      //if (!el) {
      //  el = this._context.map
      //}

      var context = this._context;


      if (el) {
        var c, l, cns;


        var jsgui_id;

        var map_els = {};

        dom_desc(el, function(el) {
          //console.log('dom_desc el', el);
          if (el.getAttribute) {
            jsgui_id = el.getAttribute('data-jsgui-id');
            //console.log('found jsgui_id', jsgui_id);

            if (jsgui_id) {

              //map_controls[jsgui_id] = el;

              // Make a map of elements...?
              map_els[jsgui_id] = el;
              context.map_els[jsgui_id] = el;

            }

          }

        });

        desc(this, function(ctrl) {
          // ensure the control is registered with the context.
          //console.log('desc ctrl', ctrl);

          var t_ctrl = tof(ctrl);
          //console.log('t_ctrl', t_ctrl);

          if (ctrl !== this && t_ctrl === 'control') {
            var id = ctrl._id();
            //console.log('id', id);

            // Seems like it's not in the map.

            if (map_els[id]) {
              //console.log('map_els[id]', map_els[id]);

              ctrl.set('dom.el', map_els[id]);
              ctrl._.el = map_els[id];
            }



            //ctrl.activate();

          }

        });



      }
    },

    'rec_desc_activate': function() {
      desc(this, function(ctrl) {
        // ensure the control is registered with the context.
        //console.log('desc ctrl', ctrl);

        var t_ctrl = tof(ctrl);

        if (t_ctrl === 'control') {


          ctrl.activate();

        }

      });
    },

    'activate_content_controls': function() {
      // This could do with some enhancement, so that it automatically does a recursive activation.
      // ensure content dom el refs
      //  recursively ensures the DOM node references for the elements inside.
      var el = this.get('dom.el');



      if (el) {
        var context = this._context;

        var ctrl_fields = {};
        var that = this;
        var c, l;

        var my_content = this.get('content');

        var str_ctrl_fields = el.getAttribute('data-jsgui-ctrl-fields');
        if (str_ctrl_fields) {
            //console.log('str_ctrl_fields ' + str_ctrl_fields);
            ctrl_fields = JSON.parse(str_ctrl_fields.replace(/'/g, '"'));
        }

        var ctrl_fields_keys = Object.keys(ctrl_fields);

        var l_ctrl_fields_keys = ctrl_fields_keys.length;
        var key, value;
        for (c = 0; c < l_ctrl_fields_keys; c++) {
          key = ctrl_fields_keys[c];
          value = ctrl_fields[key];

          var referred_to_control = context.map_controls[value];
          //console.log('referred_to_control', referred_to_control);
          that.set(key, referred_to_control);
        }

        //each(ctrl_fields, function(v, i) {
            //fields_ctrl.set(i, v);

            //fields_ctrl[v] = i;
        //    var referred_to_control = context.map_controls[v];
            //console.log('referred_to_control', referred_to_control);
        //    that.set(i, referred_to_control);
        //});


        var cns = el.childNodes;
        var content = this.get('content');
        // Adding the content again?
        //console.log('cns', cns);
        //console.log('cns.length', cns.length);
        for (c = 0, l = cns.length; c < l; c++) {
            var cn = cns[c];

            if (cn) {
              var nt = cn.nodeType;
              //console.log('* nt ' + nt);
              if (nt == 1) {
                  var cn_jsgui_id = cn.getAttribute('data-jsgui-id');
                  //console.log('cn_jsgui_id ' + cn_jsgui_id);
                  var cctrl = context.map_controls[cn_jsgui_id];
                  // quick check to see if the control is not already there.
                  var found = false;
                  if (cctrl) {
                      var ctrl_id = cctrl.__id;
                      //console.log('* ctrl_id', ctrl_id);
                      if (ctrl_id) {
                          content.each(function(v, i) {
                              if (v.__id) {
                                  if (v.__id == ctrl_id) found = true;
                              }
                          });
                      }

                      if (!found) {
                        my_content.add(cctrl);
                      }
                      //cctrl.activate();
                  }
              }
              if (nt == 3) {
                  // text
                  var val = cn.nodeValue;
                  //console.log('val ' + val);
                  content.push(val);

              }
            }

            //console.log('cn', cn);

            // we can get the ctrl reference

        }

      }
      this.rec_desc_activate();
    },

    'activate_dom_attributes': function() {

        // Needs to get the class out of the DOM properly.

        //console.log('activate_dom_attributes');

        var el = this.get('dom.el');

        // may not have el....?
        var that = this;
        var dom_attributes = this.get('dom.attributes');

        if (el) {
          for (var i = 0, attrs = el.attributes, l = attrs.length; i < l; i++){
              //arr.push(attrs.item(i).nodeName);
              var item = attrs.item(i);
              var name = item.name;
              var value = item.value;

              if (name == 'data-jsgui-id') {
                  // Handled elsewhere - not so sure it should be but won't change that right now.
              } else if (name == 'data-jsgui-type') {
                  // ^
              } else if (name == 'style') {

                  var map_inline_css = this._icss;

                  var arr_style_items = value.split(';');
                  //console.log('arr_style_items', arr_style_items);

                  //each(arr_style_items)
                  for (var c = 0, l2 = arr_style_items.length; c < l2; c++) {
                      //map_inline_css[]

                      var style_item = arr_style_items[c];
                      //var style_item_name =
                      var arr_style_item = style_item.split(':');

                      if (arr_style_item[0]) {
                          map_inline_css[arr_style_item[0]] = arr_style_item[1];
                      }
                  }
              //} else if (name == 'data-jsgui-fields') {
                // Should probably rely on using init a lot more now.


              //    var str_properties = value;

              //    if (str_properties) {

              //    }
              } else {
                  // set the dom attributes value... silent set?

                  dom_attributes.set(name, value);
              }
          }
        }
    },
    'hide': function() {
        // set the style to hidden.
        //  Could add a hidden class.

        //  I think a variety of tests on styling would make sense.

        // Want to set styles with easy syntax.

        // ctrl.style(style_name, value);
        //  I think the Control needs to maintain its own dict or data structure of its inline styles.
        //   These could get rendered differently to dom.attributes.style.

        // Or, the dom.sttributes.style gets producted from the jsgui styles that are set.
        //  These styles could also operate a bit differently, or be rendered differently to account for browser differeces.
        // Eg with rounded corners, could use a polyfill for earlier browsers.

        // Will interact with dom.attributes.style.

        // When active, needs to respond to changes in dom.attributes etc
        //  Will need to listen for those changes and re-render as appropriate.


        this.add_class('hidden');
        // Probably needs a lower level index / system of maintaining the classes - think it has one now apr 2014







    },
    'show': function() {
        //console.log('show');

        this.remove_class('hidden');

    },

    'descendants': function(search) {
        // assembles a list of the descendents that match the search
        //  (search by .__type_name)

        // eg get a list of menu_node objects.

        // basically need to recursively go through the descendents, with a callback in here, and see if they match the search.

        // recursive iteration of the control(s)

        var recursive_iterate = function(ctrl, item_callback) {
            // callback on all of the child controls, and then iterate those.
            //console.log('recursive_iterate');
            var content = ctrl.get('content');
            //console.log('content', content);

            var t_content = tof(content);

            //console.log('t_content', t_content);

            if (t_content == 'collection') {
                if (content.length() > 0) {

                    //console.log('content.length()', content.length());
                    // iterate through those child nodes as well.
                    content.each(function(item, i) {
                        //console.log('item', item);
                        item_callback(item);
                        recursive_iterate(item, item_callback);

                    })
                }
            }
        }

        var arr_matching = [];

        recursive_iterate(this, function(item) {
            // see if the item matches the search

            //console.log('cb item', item);
            var item_type = item.__type_name;
            //console.log('item_type', item_type);

            if (item_type == search) {
                arr_matching.push(item);
            } else {
                //return ctrl_parent.ancestor(search);
            }
        });
        //console.log('arr_matching', arr_matching);
        return arr_matching;

    },

    'ancestor': function(search) {
        // could maybe work when not activated too...
        // need to get the ancestor control matching the search (in type).

        if (this._parent) {
            var ctrl_parent = this._parent._parent;
            // the _parent is a Collection within the parent Control

            if (!ctrl_parent) {
                return false;
            } else {

                //console.log('ctrl_parent', ctrl_parent);
                // does the parent match the type?

                var parent_type = ctrl_parent.__type_name;
                //console.log('parent_type', parent_type);

                if (parent_type == search) {
                    return ctrl_parent;
                } else {
                    return ctrl_parent.ancestor(search);
                }



            }
        } else {
            return false;
        }

    },

    'context_menu': fp(function(a, sig) {

        // What to do here depends on the control lifecycle stage.
        //  On the server
        //   Want it to be sent to the client so that it automatically gets activated with that context menu.
        //    Would not be able to call callbacks that get given when the function gets set up.
        //    Would need to have UI responses handled on activation, but at least the menu itself could be set up at an earlier stage.
        //  On the client
        //   Pre-activation
        //    ??Won't do that for the moment. Could maybe raise an error
        //    Set properties so that when it gets activated it knows to activate it with the context menu.
        //   Post/during activation



        // So far, this seems to be for post-activation.
        //  On the server, we want it so that the properties get sent over to the client.
        //   I think that could do with more work.
        //   Making it so that properties in general, and behaviours, can be sent to the client and activated there.

        // It seems like some more generalization is needed in how data gets transferred to the client?
        // There are the fields which get sent, and there are ctrl-fields
        //  Fields get set, however they don't influence behaviours.

        // Mechanism for function calls upon activation.
        //  Possibly behaviours
        //  or jsgui-activate="context_menu(params)"
        //   So actually having function calls there.
        //    Calling functions on the controls upon activation, as specified by parameters on the server.

        // Also, better mechanism for setting fields and ctrl-fields.
        //  Need a bit of behind the scenes processing to make something work between both the server an the clients.
        //  Setting fields and behaviours on the server that determine how it gets activated on the client makes sense.

        // jQuery / CSS like selectors for selecting and finding controls within each other will also make sense.
        //  So for activating controls within another control, it will be fast to find the various controls to be activated.


        // data-jsgui-call-on-activate
        // data-jsgui-activate
        // data-jsgui-call
        //  Functions for it to call on the client.
        //   Interprets the functions, calls them.
        //   So a context menu that's specified on the server could be sent along to the client.

        // Control having extra functionality to add and remove the values that will get sent to the client.
        //  Will have various map objects of data sent to the client (maybe list/array instead?)

        // Dealing with maps of data to be sent to the client.
        //  Need something for rendering this?
        //  Just use the normal dom attributes?

        // Want ways of referring to JSON objects within the DOM attributes.
        //  It sounds like the data type and field systems should handle this where possible.

        //.set('active.context_menu', {...})
        //  So changes to the active field, on the server, cause changes to dom.attributes.jsgui-active

        //.active({'context_menu': {...}})


        var menu_def;
        if (sig == '[o]' || sig == '[a]') {
            menu_def = a[0];
        }

        var Context_Menu = Context_Menu || require('./controls/advanced/context-menu');

        var context_menu;
        var that = this;

        // Need it so that the context menu gets removed when it should.
        //  Any mouseup event causes it to vanish.

        var body = this._context.body();

        //var ctrl_html_root = this._context.ctrl_document;

        //console.log('ctrl_html_root', ctrl_html_root);

        //var body = ctrl_html_root.body();

        var show_context_menu = fp(function(a, sig) {


            var pos;


            if (sig == '[a]') {
                // A position?

                pos = a[0];

            }

            //console.log('show_context_menu pos:', pos);

            //console.log('show_context_menu');

            //console.log('Context_Menu', Context_Menu);
            //console.log('context_menu', context_menu);

            if (!context_menu) {
                //console.log('creating new context menu');

                //console.log('menu_def', menu_def);

                context_menu = new Context_Menu({
                    'context': that._context,
                    'value': menu_def
                });

                if (pos) {
                    context_menu.style({
                        'left': (pos[0] - 1) + 'px',
                        'top': (pos[1] - 1) + 'px'
                    });

                } else {
                    context_menu.style({
                        'left': '100px',
                        'top': '100px'
                    });

                }
                var context = that._context;
            } else {

                if (pos) {
                    context_menu.style({
                        'left': (pos[0] - 1) + 'px',
                        'top': (pos[1] - 1) + 'px'
                    });

                } else {
                    context_menu.style({
                        'left': '100px',
                        'top': '100px'
                    });
                }


            }

            setTimeout(function() {

                body.add(context_menu);

                //console.log('pre activate context_menu._.content._arr.length ' + context_menu._.content._arr.length);

                context_menu.activate();

                context_menu.one_mousedown_anywhere(function(e_mousedown) {
                    //console.log('e_mousedown.within_this ' + e_mousedown.within_this);

                    if (!e_mousedown.within_this) {
                        context_menu.remove();



                    } else {
                        // maybe open a new level.

                        // And need to call the relevant context menu function.

                        console.log('e_mousedown', e_mousedown);

                        var el_target = e_mousedown.target;

                        // the target control will have a jsgui id now.
                        //  we should be able to then go to its parent and get its menu node.

                        var context = that._context;
                        console.log('context', context);

                        var target_id = el_target.getAttribute('data-jsgui-id');
                        console.log('target_id', target_id);

                        var ctrl_target = context.map_controls[target_id];

                        console.log('ctrl_target', ctrl_target);

                        // want to be able to get an ancestor of type menu-node

                        var menu_node = ctrl_target.ancestor('menu_node');
                        console.log('menu_node', menu_node);

                        // and raise the menu_node select event.

                        menu_node.raise('select');

                        context_menu.remove();
                    }


                });

            }, 0);

        });



        // Respond to right clicks only.
        /*
        this.on('click', function(e_click) {
            console.log('e_click', e_click);
        })
        */

        this.on('contextmenu', function(e_contextmenu) {
            //console.log('e_contextmenu', e_contextmenu);
            return false;
            //console.log('e_click', e_click);
        })

        this.on('mousedown', function(e_mousedown) {
            //console.log('e_mousedown', e_mousedown);

            var int_button = e_mousedown.which;

            if (int_button == 3) {
                e_mousedown.preventDefault();
                window.event.returnValue = false;
                return false;
            }
        });

        this.on('mouseup', function(e_mouseup) {
            //console.log('e_mouseup', e_mouseup);

            var int_button = e_mouseup.which;

            if (int_button == 3) {
                console.log('right button');
                e_mouseup.preventDefault();
                window.event.returnValue = false;
                // Need to work out the position of the click.
                // pageX, pageY
                var pos = [e_mouseup.pageX, e_mouseup.pageY];
                show_context_menu(pos);

                return false;
            }
        })


    }),


    // make full height.
    //  makes the control take the rest of the height of the window.

    // Drag function as well...
    //  Could make this accept the same params as the drag function,
    //   but this version will be more flexible with more modes.
    // Drag and drop could also be set up with simpler parameters and acts in the default way that .drag would do.

    'draggable': fp(function(a, sig) {
        var that = this;
        //console.log('draggable sig', sig);

        //console.trace();

        var options = {}, mode, drag_start_distance = 4;

        // options could contain event handlers.
        //  Not sure about the publish / subscribe model.
        //   Maybe it would work well.

        // But allowing event handlers as specified in the options would be good as well.

        var fn_mousedown, fn_dragstart, fn_dragmove, fn_dragend;
        var handle_mousedown, handle_dragstart, handle_dragmove , handle_dragend;


        if (sig == '[o]') {
            options = a[0];
        }

        // fn_mousedown, fn_begin, fn_move, fn_end
        if (sig == '[f,f,f,f]') {
            handle_mousedown = a[0];
            handle_dragstart = a[1];
            handle_dragmove = a[2];
            handle_dragend = a[3];
        }


        if (options.mode) mode = options.mode;
        //if (options.fn_dragmove) fn_dragmove = options.fn_dragmove;
        if (options.move) handle_dragmove = options.move;
        //if (options.fn_dragstart) fn_dragstart = options.fn_dragstart;
        if (options.start) handle_dragstart = options.start;

        // could have a 'none' mode that does not implement drag behaviour itself, but just shows the events?
        //  or I think 'events' mode would be a better name because it's saying what it is.
        //  would be useful for moving objects around according to more specific rules.






        if (mode == 'ghost-copy') {
            // Drag a ghost copy of the original element.

            // call a create_ghost_copy function? It would make the ghost copy absolutely positioned and a child of the body.
            //  could automatically create it with a small offset.

            //  Need to be dragging the ghost copy around throughout the drag operation in this case.

            console.log('ghost-copy drag');




        }

        var body = that._context.body();

        // raise the events externally.

        var is_dragging;
        var pos_mousedown;

        var ghost_clone;





        var fn_mousemove = function(e_mousemove) {
            //console.log('e_mousemove', e_mousemove);

            var pos = [e_mousemove.pageX, e_mousemove.pageY];

            var pos_offset = [pos[0] - pos_mousedown[0], pos[1] - pos_mousedown[1]];



            //console.log('dist', dist);

            //console.log('is_dragging ' + is_dragging);

            if (!is_dragging) {
                var dist = Math.round(Math.sqrt(pos_offset[0] * pos_offset[0] + pos_offset[1] * pos_offset[1]));
                if (dist >= drag_start_distance) {
                    //console.log('starting drag');
                    is_dragging = true;

                    // in ghost copy mode create the ghost copy

                    if (mode == 'ghost-copy') {
                        ghost_clone = that.absolute_ghost_clone();

                    }


                    if (handle_dragstart) {
                        e_mousemove.control = that;

                        handle_dragstart(e_mousemove);
                    }
                }
            }

            if (is_dragging) {
                // raise the drag event.

                // could do some of the drag-drop activity depending on the drag mode.
                //  also want to provide other hooks for functionality.

                //console.log('fn_dragmove', fn_dragmove);

                if (handle_dragmove) {
                    e_mousemove.control = that;
                    handle_dragmove(e_mousemove);
                }

            }



            // Want the offset from the mousedown position.

        }
        var fn_mouseup = function(e_mouseup) {
            //console.log('e_mouseup', e_mouseup);

            //console.log('pre switch off mousemove, mouseup');

            // Seems the events are being added too many times.

            body.off('mousemove', fn_mousemove);
            body.off('mouseup', fn_mouseup);

            body.remove_class('no-text-select');
        }

        this.on('mousedown', function(e_mousedown) {
            //console.log('e_mousedown', e_mousedown);

            pos_mousedown = [e_mousedown.pageX, e_mousedown.pageY];

            // position within Control
            // position within window


            body.on('mousemove', fn_mousemove);
            body.on('mouseup', fn_mouseup);

            body.add_class('no-text-select');
            is_dragging = false;

            if (handle_mousedown) {
                handle_mousedown(e_mousedown);
            }

        })


    }),


    // As well as the 'draggable' function?
    //  Could keep this, and have it call draggable?
    //  Draggable makes more sense, perhaps drag could be an alias for draggable.


    /*
    'drag': function(fn_mousedown, fn_begin, fn_move, fn_end) {

        var screen_down_x, screen_down_y;

        // Want ways of restricting or cancelling a drag.
        var ctrl_html_root = this._context.ctrl_document;


        this.add_event_listener('mousedown', function(e) {
            //console.log('hover mouseover');

            //console.log('drag mousedown ', e);

            screen_down_x = e.screenX;
            screen_down_y = e.screenY;

            //var moved = false;
            var drag_initiated = false;

            fn_mousedown(e);

            var first = true;

            var handle_move = function(e) {

                console.log('handle_move');

                var screen_move_x = e.screenX;
                var screen_move_y = e.screenY;

                var screen_offset_x = screen_move_x - screen_down_x;
                var screen_offset_y = screen_move_y - screen_down_y;

                if (first) {
                    ctrl_html_root.add_class('cursor-default');
                    first = false;
                }

                // Screen movement offset.

                // Anyway, we need the position within the div / element where the mouse went down.
                //  We use that to calculate the position to move the control to, we need to take account of that inital offset.



                // could find the position of the srcElement.

                // that may be better.
                //  then we use the client x and client y properties to determine the offset into the item clicked.



                //console.log('screen_offset_x', screen_offset_x, 'screen_offset_y', screen_offset_y);

                // but we already have an offset property from the event.

                // maybe call our new one a movement offset.



                var e = {
                    'offsetX': screen_offset_x,
                    'offsetY': screen_offset_y,
                    'screenX': screen_move_x,
                    'screenY': screen_move_y,
                    'clientX': e.clientX,
                    'clientY': e.clientY,
                    'pageX': e.pageX,
                    'pageY': e.pageY
                }

                if (!drag_initiated) {

                    //see how far it is...

                    // want to use a function that calculates the magnitude of the distance.

                    var dbp = jsgui.distance_between_points([[0, 0], [screen_offset_x, screen_offset_y]]);

                    //console.log('dbp ' + dbp);

                    // drag_initiation_distance

                    var drag_initiation_distance = 16;
                    if (dbp >= 16) {
                        drag_initiated = true;
                        ctrl_html_root.add_class('dragging');
                        //ctrl_html_root.add_class('cursor-default');

                        fn_begin(e);

                    }


                    // can just use the magnitude of the offset.
                    //  dbp taking just 2 values...




                }

                if (drag_initiated) {
                    fn_move(e);
                }


            }

            var handle_mouseup = function(e) {
                //document.removeEventListener('mousemove', handle_move);
                //document.removeEventListener('mouseup', handle_mouseup);

                ctrl_html_root.off('mousemove', handle_move);
                ctrl_html_root.off('mouseup', handle_mouseup);

                ctrl_html_root.remove_class('dragging');
                ctrl_html_root.remove_class('cursor-default');

                var screen_mouseup_x = e.screenX;
                var screen_mouseup_y = e.screenY;

                var screen_offset_x = screen_mouseup_x - screen_down_x;
                var screen_offset_y = screen_mouseup_y - screen_down_y;

                console.log('screen_offset_x', screen_offset_x, 'screen_offset_y', screen_offset_y);

                var e = {
                    'offsetX': screen_offset_x,
                    'offsetY': screen_offset_y
                }
                fn_end(e);

            }

            ctrl_html_root.on('mousemove', handle_move);
            ctrl_html_root.on('mouseup', handle_mouseup);

            //document.addEventListener('mousemove', handle_move, false);
            //document.addEventListener('mouseup', handle_mouseup, false);


            //fn_in();
        })
    },
    */

    'drag_handle_to': function(ctrl) {
        // Also involved with drag and drop actions.

        // could use the lower level drag(3) function.
        //  would handle initializaing the drag, stopping it.

        // another piece of code deals with dragging something representing a copy, we don't want that here.
        //  want to move the window.

        // and can drag another control.

        // maybe want to make a few lower level drag functions?
        //console.log('drag_handle_to');
        var mousedown_offset_from_ctrl_lt;

        var ctrl_el = ctrl.get('dom.el');
        // could go in enhanced....

        //this.drag(function(e_mousedown) {
        this.draggable(function(e_mousedown) {
            //console.log('e_mousedown', e_mousedown);


            // This will need to be revised - making adjustment for when dragging from an anchored position.
            //  Should maintain some info about the drag so it knows if it starts/ends anchored anywhere.
            var target = e_mousedown.target;

            // want to get the position within the thing it's a handle to?

            // will need to do a bit of position calculation to get it to work.

            var targetPos = findPos(target);
            //console.log('targetPos ' + stringify(targetPos));

            var ctrl_el_pos = findPos(ctrl.get('dom.el'));

            // and use the client x, client y

            // or page x page y?

            var e_pos_on_page = [e_mousedown.pageX, e_mousedown.pageY];

            // then subtract the vectors.

            //var offset_within_target = jsgui.v_subtract(e_pos_on_page, targetPos);
            mousedown_offset_from_ctrl_lt = jsgui.v_subtract(e_pos_on_page, ctrl_el_pos);
            //console.log('mousedown_offset_from_ctrl_lt ' + stringify(mousedown_offset_from_ctrl_lt));

            // not bad...

            // notify the page context.
            //  Will notify the page context when control gets moved too.
            //   The page context could arrange other things, like tell a control with a drop zone to get ready?
            //    Or that control responds to the mouseover event because it is a drop zone?

            // The Page_Context may get told about a few things, but only then send on messages where necessary.





        }, function(e_begin) {
            // also want the position of mousedown.

            // we could get that with a mousedown event.


            // could get a measurement of the size height.
            //  also know if it is docked or not.

            var ctrlSize = ctrl.size();
            //console.log('ctrlSize', ctrlSize);

            var anchored_to = ctrl.get('anchored_to');
            //console.log('anchored_to', anchored_to);

            if (!anchored_to) {
                //ctrl.set('unanchored_size', ctrlSize);
            } else {
                // need to unanchor it.
                ctrl.unanchor();

                /*
                var unanchored_size = ctrl.get('unanchored_size');
                console.log('unanchored_size', unanchored_size);

                ctrl.size(unanchored_size);
                ctrl.style({
                    'position': 'absolute'
                })
                */
            }


            //console.log('drag handle to drag begin');


            //throw 'stop';

            // need to make it absolutely positioned, size it.



        }, function(e_move) {

            //console.log('move event');
            // need to reposition the control.
            //  will mean adjusting some inline style.

            // could do with more jsgui work on dealing with styles.
            //  both conventional styles
            //  and a style abstraction.

            // set the style on the control.

            // another style abstraction system would be quite useful, not called style....
            // .form? Seems confusing with html for.
            // .appearance - too long
            // .flair?

            // or just .style, but these are jsgui style abstractions.
            //  so we can have it put in the rounded edges within a DIV in IE6, but it does change the layout in general.

            // style polyfill? shim?

            // maybe want to specify corners in jsgui - that is a style abstraction.

            var clientX = e_move.clientX;
            var clientY = e_move.clientY;

            //var pageX = e_move.pageX;
            //var pageY = e_move.pageY;

            //console.log('pre set ctrl style');

            // the style within the dom attributes?

            // I think .form would be good instead of .style.
            //  .form would be like .style but the style abstraction.

            // Perhaps being able to access .style makes sense for controls though.

            // Need to deal properly with offsets.

            //

            // width of the control.

            // want ctrl.width() to produce the result, but that will need more work.



            // Also need to clamp it within page constraints.

            var window_size = get_window_size();


            var ctrl_pos = jsgui.v_subtract([clientX, clientY], mousedown_offset_from_ctrl_lt);

            // But then act differently if we are dragging from an anchored position.
            //  The mousedown offset within the control won't be so relevant -
            //   or won't be the only factor.

            // Take account of position_adjustment
            //  or offset_adjustment

            var offset_adjustment = ctrl.get('offset_adjustment');
            //console.log('offset_adjustment', offset_adjustment);

            if (offset_adjustment) {
                // want to find out what zone it is anchored in.

                ctrl_pos = jsgui.v_add(ctrl_pos, offset_adjustment);

                //
            }
            /*
            var unanchored_offset = ctrl.get('unanchored_offset');
            console.log('unanchored_offset', unanchored_offset);

            if (unanchored_offset) {
                // want to find out what zone it is anchored in.
                var anchored_to = ctrl.get('anchored_to');
                var zone = anchored_to[2];

                console.log('zone', zone);

                if (zone == 'left' || zone == 'top' || zone == 'bottom') {
                    ctrl_pos = jsgui.v_add(ctrl_pos, [unanchored_offset[0], 0]);
                }


                //
            }
            */


            if (ctrl_pos[0] < 0) ctrl_pos[0] = 0;
            if (ctrl_pos[1] < 0) ctrl_pos[1] = 0;

            // clamping it so the right does not go outside the screen is more difficult.
            // mousedown_offset_from_ctrl_lt

            //console.log(window_size[0] - mousedown_offset_from_ctrl_lt[0]);


            var ow = ctrl_el.offsetWidth;
            var oh = ctrl_el.offsetHeight;


            if (ctrl_pos[0] > window_size[0] - ow) ctrl_pos[0] = window_size[0] - ow;
            if (ctrl_pos[1] > window_size[1] - oh) ctrl_pos[1] = window_size[1] - oh;



            //ctrl.style({
            //    'left': pageX + 'px',
            //    'top': pageY + 'px'
            //});

            var style_vals = {
                'left': ctrl_pos[0] + 'px',
                'top': ctrl_pos[1] + 'px'
            };

            //console.log('style_vals', style_vals);


            ctrl.style(style_vals);


            // If the ctrl is anchored, we need to unanchor it.



            // as well as that, tell the control's context.
            //  That could do things like scan for it being in an outside border.

            ctrl._context.move_drag_ctrl(e_move, ctrl);

        }, function(e_end) {
            // tell the context that the drag has ended.
            var uo1 = ctrl.get('unanchored_offset');
            //console.log('uo1', uo1);

            ctrl._context.end_drag_ctrl(e_end, ctrl);

            var uo2 = ctrl.get('unanchored_offset');
            //console.log('uo2', uo2);

            if (uo1 && uo2) {
                ctrl.set('unanchored_offset', null);
            }

            ctrl.set('offset_adjustment', null);

            // and if it already has an unanchored_offset

        });

    },


    // Possibly put this back?
    //  But maybe don't want to be talking about click or touch too much, maybe talk about pointer actions.
    /*
    'click_to_select': function(ctrl) {
        ctrl = ctrl || this;

        this.click(function(e) {
            // is control held down?
            //console.log('e', e);
            var ctrl_key = e.ctrlKey;
            if (ctrl_key) {
                ctrl.action_select_toggle();
            } else {
                ctrl.action_select_only();
            }
        });
    },
    */

    'resize_handle_to': function(ctrl, handle_position) {
        // The control needs to be draggable normally?
        //  And then from the positions of where it is adjust the size of what it's a resize handle to?

        console.log('resize_handle_to');

        if (handle_position == 'right-bottom') {
            var fn_move = function(e_move) {
                console.log('e_move', e_move);
            }
            var fn_up = function(e_up) {
                console.log(e_up);
            }

            var doc = ctrl._context.ctrl_document;

            console.log('ctrl._context', ctrl._context);

            //var body = doc.get('content').get(1);
            //console.log('body', body);

            // The context should have access to the control_document.
            //throw 'stop';

            // Need to store the inital positions to work out differences between them.

            // pageX and PageY are reliable accross browsers.
            //  can be used to work out movement vector.

            // Maybe we use the original measured position of the window to work out the new size, along with the movement vector.




            var fn_move = function(e_move) {
                console.log('e_move', e_move);
            }

            var fn_up = function(e_up) {
                console.log('e_up', e_up);

                doc.off('mousemove', fn_move);
                doc.off('mouseup', fn_up);
            }

            ctrl.on('mousedown', function(e_mousedown) {


                console.log('e_mousedown', e_mousedown);


                doc.on('mousemove', fn_move);
                doc.on('mouseup', fn_up);
            })



        }

    },

    'selectable': function(ctrl) {

        //console.log('selectable ctrl', ctrl);
        //  Can click on this, select something else.

        // if this is on the server, want to mark this so that it gets activated as selectable on the client.
        //  perhaps write more of an abstraction for code scope shifting.

        // could use jsgui flags?
        //  need to work on the activation stage to read data out of the dom node.

        var that = this;
        ctrl = ctrl || this;

        if (typeof document === 'undefined') {
            // set the jsgui field

            // Should use a different version of jsgui data fields.
            // such as __fields
            // just _fields

            //  when the control renders the dom attributes, it treats that as a special case.
            //  it already has a few special cases, eg style, jsgui_ctrl_fields

            /*

            var jsf = that.get('dom.attributes.data-jsgui-fields');
            //console.log('jsf', jsf);



            if (jsf) {

                throw 'pre-existing jsgui fields, nyi'
            } else {
                var obj = {
                    'is_selectable': true
                }



                that.set('dom.attributes.data-jsgui-fields', JSON.stringify(obj).replace(/"/g, "[DBL_QT]").replace(/'/g, "[SNG_QT]"));

                //.replace(/"/g, "[DBL_QT]").replace(/'/g, "[SNG_QT]")
            }
            */
            that._fields = that._fields || {};
            that._fields['is_selectable'] = true;


        } else {
            // not making something selectable?
            //  This seems to be getting called when it should not.




            that.click(function(e) {

                // Or is the click event being bubbled?

                //console.log('that click, that:', that);

                // is control held down?
                //console.log('e', e);
                var ctrl_key = e.ctrlKey;
                var meta_key = e.metaKey;

                //console.log('metaKey ' + e.metaKey);

                if (ctrl_key || meta_key) {
                    ctrl.action_select_toggle();
                } else {
                    ctrl.action_select_only();
                }
            });
        }







    },


    'action_select_only': function() {
        // needs to see what is within the selection_scope.
        // this is a selection scope, or it refers to a control with that set to true that is an ancestor.
        //  it could find such a control.
        // not totally sure if the ancestor requirement is necessary, it may make sense and be best though.
        //console.log('action_select ');
        // I think a Selection_Scope object may make sense to hold the data.

        // this.selection_scope.select_only(this);

        //this.get('selection_scope').select_only(this);

        var ss = this.find_selection_scope();
        console.log('ss', ss);
        // The selection scope shouls be a Selection_Scope object.

        //  I think that it would make use of the B+ tree where needed.
        // Need algorithmically fast operations to:
        // Select or deselect an object
        // Get all objects that are selected in the order in which they are listed in another control.
        //  Though can get all objects that are selected quickly, then quickly get their indexes.
        //  Do that without going through whole selection.

        //console.log('this ', this);

        // is there a selection scope?
        //  Want to have selection scoped set up on the server OK.
        //  Would mean selection scopes need to be created upon activation.
        //   Perhaps any control that has its selection scope set should also send a selection scope id to the client.

        ss.select_only(this);
        //this.find_selection_scope().select_only(this);

    },

    'action_select_toggle': function() {
        this.find_selection_scope().select_toggle(this);
    },


    // So I think the resource-pool will have a selection scope.
    'find_selection_scope': function() {
        console.log('find_selection_scope');

        var res = this.get('selection_scope');
        if (res) return res;

        // look at the ancestor...

        //var parent = this.get('parent');
        // want an easy way to get the parent control.

        // .parent for a control should do this I think.

        var parent_control_collection = this.parent();
        // Not getting the parent controls.


        console.log('parent_control_collection', parent_control_collection);

        // In activation, it looks like we need to hook up the parent controls.



        if (parent_control_collection) {
            var parent_control = parent_control_collection.parent();

            //var parent = this.parent().parent();


            //console.log('parent_control ' + tof(parent_control));


            if (parent_control) return parent_control.find_selection_scope();
        } else {

        }



    },

    // Nice, this works. Not that efficiently yet.

    'make_full_height': function() {
        var el = this.get('dom.el');
        var viewportHeight = document.documentElement.clientHeight;


        var rect = el.getBoundingClientRect();
        console.log(rect.top, rect.right, rect.bottom, rect.left);

        var h = viewportHeight - rect.top;

        this.style('height', h + 'px', true);
    },
    'grid_9': function() {
        var res = this.get('grid_9');
        if (res) return res;

        res = new Grid_9({
            'context': this._context
        })
        //res.__type_name = 'control';
        res.set('dom.attributes.data-jsgui-type', 'control');
        // need to say it's a control too...

        var res_id = res._id();

        res.set('dom.attributes.data-jsgui-id', res_id);

        this._context.map_controls[res_id] = res;

        //res.set('')

        // transplant the content.


        var el = this.get('dom.el');
        // remove all child nodes???

        // can just insert the rendered grid9
        //console.log('pre res all_html_render')
        var html_grid_9 = res.all_html_render();
        var nel = document.createElement('div');

        //console.log('html_grid_9 ' + html_grid_9);

        nel.innerHTML = html_grid_9;

        var el_grid_9 = nel.childNodes[0];

        //console.log('el_grid_9 ' + el_grid_9);

        //console.log('el_grid_9.childNodes.length ' + el_grid_9.childNodes.length );



        el.insertBefore(el_grid_9, el.childNodes[0]);

        while (el.childNodes[1]) {
            el_grid_9.childNodes[1].childNodes[1].appendChild(el.childNodes[1]);
        }


        res.set('dom.el', el_grid_9);

        res.activate_recursive();
        // can't do it quite like that.
        //  maybe change for copying between collections.
        //  setting a collection, with a collection.
        //   should create a new copy?
        //    or reference it...
        //   reference is better if it works.


        // get content should get a collection...
        //  but need to work on the Data_Object's set for when it is dealing with a collection.


        var current_content = this.get('content');

        //console.log('1) current_content.length() ' + current_content.length());
        //throw 'stop';

        // need to copy it somehow....

        var res_middle = res.get('content').get(1).get('content').get(1);
        //console.log('res_middle ' + res_middle);




        res_middle.set('content', current_content);

        //console.log('1) res content .length() ' + res.get('content').length());
        //console.log('1) res_middle content .length() ' + res_middle.get('content').length());


        this.get('content').clear();
        this.get('content').add(res);


        this.set('grid_9', res);

        //var current_content = this.get('content');

        //console.log('2) current_content.length() ' + current_content.length());

        // recursive activate...
        //  needs to activate from inside to outside.

        // When something gets anchored into a position in the Grid_9, the Grid_9 needs to handle it.


        return res;


    },

    // Is getting a bit verbose.
    //  Some things could be expressed more efficiently.
    //  However, right now don't want to create overall abstraction for this.

    // There will be grid_9 and a few other layouts that are fairly intrinsic to the system.




    'ensure_dock_placeholder': function(pos) {
        //console.log('enh ctrl ensure_dock_placeholder pos ' + pos);

        // and then we keep track of the dock placeholder.

        // would likely be easier to get a string by default?
        //  or easily get the value.

        // a val function that gets the value of it, if it has a value function.



        //val(dock_placeholder_pos)


        // use the grid_9's dock placeholder position?


        //console.log('dock_placeholder_pos ' + stringify(dock_placeholder_pos));
        //console.log('tof dock_placeholder_pos ' + tof(dock_placeholder_pos));
        var grid_9 = this.get('grid_9');
        var g9el = grid_9.get('dom.el');
        if (grid_9) {
            var dock_placeholder_pos = grid_9.get('dock_placeholder_pos');

            var t_stripe = grid_9.get('content').get(0);
            var m_stripe = grid_9.get('content').get(1);
            var cell_4 = m_stripe.get('content').get(1);
            var cell4_el = cell_4.get('dom.el');

            //console.log('dock_placeholder_pos ' + dock_placeholder_pos);
            //console.log('dock_placeholder_pos ' + tof(dock_placeholder_pos));
            //throw 'stop';
            if (dock_placeholder_pos) {
                // if the pos we have is different.
                var dpp_val;
                if (dock_placeholder_pos.value) {
                    dpp_val = dock_placeholder_pos.value();
                } else {
                    dpp_val = dock_placeholder_pos;
                }

                //dpp_val = dock_placeholder_pos.value();
                //console.log('dpp_val ' + dpp_val);

                if (!pos) {
                    // remove it from wherever it is.
                    if (dpp_val == 'left') {
                        // need to set some styles, so that h_middle does not take the full width.
                        //  reduce its width so that the placeholder can be accommodated.

                        grid_9.close_placeholder();

                        /*

                        var g9w = g9el.offsetWidth;



                        var g9c = grid_9.get('content');
                        //console.log('g9c', g9c.length());

                        //console.log('m_stripe', m_stripe);

                        var cell_3 = m_stripe.get('content').get(0);

                        // need to measure and shrink the central cell.

                        //var w = cell4_el.offsetWidth;

                        //console.log('w ' + w);

                        // or remove that style declaration?
                        cell_4.style({
                            //'width': null
                            'width': '100%'
                        })



                        //console.log('cell_3', cell_3);
                        cell_3.remove_class('dock-placeholder');
                        this.set('dock_placeholder_pos', false);

                        */
                    }

                    if (dpp_val == 'top') {
                        //var g9c = grid_9.get('content');
                        //console.log('g9c', g9c.length());
                        //var m_stripe = grid_9.get('content').get(0);
                        //console.log('m_stripe', m_stripe);

                        grid_9.close_placeholder();

                        /*
                        var cell_1 = t_stripe.get('content').get(1);
                        //console.log('cell_3', cell_3);
                        cell_1.remove_class('dock-placeholder');
                        this.set('dock_placeholder_pos', false);
                        */

                    }

                    if (dpp_val == 'right') {
                        grid_9.close_placeholder();
                        /*
                        var cell_5 = grid_9.get('content').get(1).get('content').get(2);
                        //console.log('cell_3', cell_3);
                        cell_5.remove_class('dock-placeholder');
                        this.set('dock_placeholder_pos', false);

                        cell_4.style({
                            //'width': null
                            'width': '100%'
                        })
                        */
                    }

                    if (dpp_val == 'bottom') {
                        grid_9.close_placeholder();
                    }

                    // bottom 7
                    //  like with others, the central div will need to be made a bit smaller.


                }

                //throw 'stop';



            } else {
                // put the placeholder in the position...
                //console.log('pos ' + pos);
                //throw 'stop';
                if (!pos) {
                    // tell the grid9 to remove whichever class indicates its the placeholder.

                    //throw 'stop';

                }

                if (pos == 'left') {
                    //var g9c = grid_9.get('content');
                    //console.log('g9c', g9c.length());

                    grid_9.open_placeholder('left');

                    /*

                    var cw = document.documentElement.clientWidth;
                    grid_9.style({
                        'width': cw + 'px'
                    })



                    //console.log('m_stripe', m_stripe);
                    var cell_3 = m_stripe.get('content').get(0);

                    //var cell_4 = m_stripe.get('content').get(1);
                    var cell3_el = cell_3.get('dom.el');
                    //var cell4_el = cell_4.get('dom.el');
                    var c4w = cell4_el.offsetWidth;

                    //console.log('* c4w ' + c4w);

                    //throw 'stop';
                    //console.log('cell_3', cell_3);
                    // ensure class?
                    cell_3.add_class('dock-placeholder');

                    var c3w = cell3_el.offsetWidth;
                    var nw = c4w - c3w;
                    //console.log('nw ' + nw);



                    cell_4.style({
                        'width': (nw) + 'px'
                    })
                    //console.log('* c3w ' + c3w);


                    this.set('dock_placeholder_pos', 'left');

                    */
                }
                if (pos == 'top') {
                    //var g9c = grid_9.get('content');
                    //console.log('g9c', g9c.length());

                    /*
                    var m_stripe = grid_9.get('content').get(0);
                    //console.log('m_stripe', m_stripe);
                    var cell_1 = m_stripe.get('content').get(1);
                    //console.log('cell_3', cell_3);
                    // ensure class?
                    cell_1.add_class('dock-placeholder');
                    this.set('dock_placeholder_pos', 'top');
                    */

                    grid_9.open_placeholder('top');
                }
                if (pos == 'right') {

                    grid_9.open_placeholder('right');


                }

                //grid_9.open_placeholder('bottom');


                if (pos == 'bottom') {
                    grid_9.open_placeholder('bottom');
                }
            }
        }
    },

    'unanchor': function() {
        var anchored_to = this.get('anchored_to');
        anchored_to[0].unanchor_ctrl(this);

    }

})

var Grid_9 = jsgui.Control.extend({
    'init': function(spec) {
        this._super(spec);

        // composition...
        //  need to create 3 stripes: top, v_middle, bottom
        //   then within each of them we have left, h_middle, right

        // in an array. The center is number 4.

        // 0 1 2
        // 3 4 5
        // 6 7 8
        this.__type_name == 'grid_9';

        this.set('dom.attributes.class', 'grid_9');
        var context = this._context;

        // if being given the element when it is constructed...

        // putting this into another control.
        //  we need to re-render the control fully, I think.

        // Is there a better way to put this into an existing document?

        // Render the HTML of it and everything inside it...
        //  Would need to reactivate / reattach events.
        //   Memory leak?

        // could maybe activate to make access to subcontrols more convenient?



        // we can detach and reattach.
        //  could have a specific mechanism for putting this in.

        // compose its html
        // render create the element.
        //  remove the existing element
        // put the grid9 element in (or is it simply 9 elements?) grid_9 could take an outer div, though we could possibly remove that.
        //  then put the element within position 4 of the grid9.

        var arr_v_names = ['top', 'v-middle', 'bottom'];
        var arr_h_names = ['left', 'h-middle', 'right'];

        if (!spec.el) {
            var c = 0;
            var arr_ctrls = new Array(9);
            for (var y = 0; y < 3; y++) {
                var stripe = new jsgui.Control({
                    'context': context
                })
                stripe.set('dom.attributes.class', arr_v_names[y]);
                // could have the page context see what the free ids are, and then use them.
                //  would set the counter for each of them based on what has been found.

                stripe.set('dom.attributes.data-jsgui-type', stripe.__type_name);


                stripe.set('dom.attributes.data-jsgui-id', stripe._id());

                this.add(stripe);

                context.map_controls[stripe._id()] = stripe;

                for (var x = 0; x < 3; x++) {
                    arr_ctrls[c] = new jsgui.Control({
                        'context': context
                    })
                    arr_ctrls[c].set('dom.attributes.class', arr_h_names[x]);
                    arr_ctrls[c].set('dom.attributes.data-jsgui-id', arr_ctrls[c]._id());
                    arr_ctrls[c].set('dom.attributes.data-jsgui-type', arr_ctrls[c].__type_name);

                    stripe.add(arr_ctrls[c]);

                    context.map_controls[arr_ctrls[c]._id()] = arr_ctrls[c];
                    c++;
                }
            }
            //console.log(this.get('content').length());
            //throw 'stop';
        }


    },

    'unanchor_ctrl': function(ctrl) {
        var anchored_to = ctrl.get('anchored_to');
        var zone = anchored_to[2];
        console.log('unanchor_ctrl zone ' + zone);
        ctrl.remove_class('anchored');

        var unanchored_offset = ctrl.get('unanchored_offset');
        console.log('unanchored_offset', unanchored_offset);

        // But when unanchoring is done as part of a drag...
        //  need to recalculate the drag offset.

        //ctrl.offset(unanchored_offset);
        if (unanchored_offset) {
            if (zone !== 'right') {
                ctrl.set('offset_adjustment', [unanchored_offset[0], 0]);
            }


        }


        var t_stripe = this.get('content').get(0);
        var m_stripe = this.get('content').get(1);
        var cell_4 = m_stripe.get('content').get(1);
        var cell4_el = cell_4.get('dom.el');

        if (zone == 'left') {
            var cell_3 = m_stripe.get('content').get(0);

            //var cell_4 = m_stripe.get('content').get(1);
            var cell3_el = cell_3.get('dom.el');

            cell_3.remove_class('open');
        }

        if (zone == 'right') {
            //var c4w = document.documentElement.clientWidth;
            var cell_5 = this.get('content').get(1).get('content').get(2);
            cell_5.remove_class('dock-placeholder');

            /*
            this.set('open', 'right');
            var cell5_el = cell_5.get('dom.el');
            var c5w = cell5_el.offsetWidth;
            var nw = c4w - c5w;
            cell_4.style({
                'width': (nw) + 'px'
            })
            */
        }


        anchored_to[0].close_placeholder(zone);



        ctrl.set('anchored_to', null);
        ctrl.set('unanchored_offset', null);

    },

    'anchor_ctrl': function(ctrl, zone) {
        // need to find the right nested subcontrol

        var x, y, found;
        if (zone == 'left') {
            x = 0; y = 1;
            found = true;
        }
        if (zone == 'top') {
            x = 1; y = 0;
            found = true;
        }
        if (zone == 'right') {
            x = 2; y = 1;
            found = true;
        }
        if (zone == 'bottom') {
            x = 1; y = 2;
            found = true;
        }

        var t_stripe = this.get('content').get(0);
        var m_stripe = this.get('content').get(1);
        var cell_4 = m_stripe.get('content').get(1);
        var cell4_el = cell_4.get('dom.el');

        if (found) {
            var grid_section = this.get('content').get(y).get('content').get(x);

            //console.log('grid_section ', grid_section);

            // need a way of inserting a control.
            //  Adding to the content, and having the control react to this and update the DOM?

            // may have ctrl.append(ctrl)
            //  which adds it to the content (and updates the DOM)
            // could also have an activated control listen out for content changes.
            //  so when something gets added in the content, it gets appended in the DOM too.
            //   I think that makes sense in terms of convenience.

            // Will mean making that left bar bigger so that it fits the flexi board.
            // also need to add the class 'open' or something to show that the grid section is open.

            // open a part of the grid section...
            //  best to get the grid_9 to do this.
            //  also would be good to get the grid_9 to show placeholders using its own methods.




            // And this will change the formatting of the grid_9
            //  Don't want that section to appear and dissipear.
            //  Don't show it as a placeholder when something is there...

            // Need to open a section of the Grid_9 / reposition things.
            //  Like when the placeholder is shown.

            // We want to actually open that section of the grid_9.
            var unanchored_offset = ctrl.offset();
            ctrl.set('unanchored_offset', unanchored_offset);

            //console.log('unanchored_offset', unanchored_offset);

            ctrl.add_class('anchored');

            //console.log('');
            grid_section.add(ctrl);

            ctrl.set('anchored_to', [this, grid_section, zone]);
            var unanchored_size = ctrl.size();
            ctrl.set('unanchored_size', unanchored_size);
            // This is basically working now!
            //  Have automatic DOM append of added content.
            //   Need to get that working properly and tested in all cases though.

            if (zone == 'left') {
                console.log ('left zone');
                var cw = document.documentElement.clientWidth;
                this.style({
                    'width': cw + 'px'
                })
                //console.log('m_stripe', m_stripe);
                var cell_3 = m_stripe.get('content').get(0);

                //var cell_4 = m_stripe.get('content').get(1);
                var cell3_el = cell_3.get('dom.el');
                //var cell4_el = cell_4.get('dom.el');
                var c4w = cell4_el.offsetWidth;
                cell_3.add_class('open');

                var c3w = cell3_el.offsetWidth;
                var nw = c4w - c3w;
                cell_4.style({
                    'width': (nw) + 'px'
                })
            }

            if (zone == 'right') {
                var c4w = document.documentElement.clientWidth;
                var cell_5 = this.get('content').get(1).get('content').get(2);
                cell_5.add_class('dock-placeholder');
                this.set('open', 'right');
                var cell5_el = cell_5.get('dom.el');
                var c5w = cell5_el.offsetWidth;
                var nw = c4w - c5w;
                cell_4.style({
                    'width': (nw) + 'px'
                })
            }

            if (zone == 'bottom') {
                var c = document.documentElement.clientHeight;
                var cell_7 = this.get('content').get(2).get('content').get(1);
                cell_7.add_class('open');
                this.set('dock_placeholder_pos', 'bottom');
                var cell7_el = cell_7.get('dom.el');
                var c7h = cell7_el.offsetHeight;
                //console.log('c7h ' + c7h);
                var nh = c - c7h;
                //console.log('nh ' + nh);
                m_stripe.style({
                    'height': (nh) + 'px'
                })
            }
            //grid_section.anchor_ctrl(ctrl);
        }

    },
    'open_placeholder': function(zone) {
        //console.log('grid_9 open_placeholder ' + zone);

        var t_stripe = this.get('content').get(0);
        var m_stripe = this.get('content').get(1);
        var cell_4 = m_stripe.get('content').get(1);
        var cell4_el = cell_4.get('dom.el');

        if (zone == 'left') {
            var cw = document.documentElement.clientWidth;
            this.style({
                'width': cw + 'px'
            })
            //console.log('m_stripe', m_stripe);
            var cell_3 = m_stripe.get('content').get(0);

            //var cell_4 = m_stripe.get('content').get(1);
            var cell3_el = cell_3.get('dom.el');
            //var cell4_el = cell_4.get('dom.el');
            var c4w = cell4_el.offsetWidth;
            cell_3.add_class('dock-placeholder');

            var c3w = cell3_el.offsetWidth;
            var nw = c4w - c3w;
            cell_4.style({
                'width': (nw) + 'px'
            })
            this.set('dock_placeholder_pos', 'left');
        }

        if (zone == 'top') {
            //var m_stripe = grid_9.get('content').get(0);
                    //console.log('m_stripe', m_stripe);
            var cell_1 = t_stripe.get('content').get(1);
            //console.log('cell_3', cell_3);
            // ensure class?
            cell_1.add_class('dock-placeholder');
            this.set('dock_placeholder_pos', 'top');
        }

        if (zone == 'right') {
            var c4w = document.documentElement.clientWidth;
            var cell_5 = this.get('content').get(1).get('content').get(2);
            cell_5.add_class('dock-placeholder');
            this.set('dock_placeholder_pos', 'right');

            //var c4w = cell4_el.offsetWidth;
            //console.log('c4w ' + c4w);
            //cell_5.add_class('dock-placeholder');
            var cell5_el = cell_5.get('dom.el');
            // use the full page width.

            var c5w = cell5_el.offsetWidth;
            //console.log('c5w ' + c5w);
            var nw = c4w - c5w;
            //console.log('nw ' + nw);
            cell_4.style({
                'width': (nw) + 'px'
            })
        }

        if (zone == 'bottom') {
            var c = document.documentElement.clientHeight;
            var cell_7 = this.get('content').get(2).get('content').get(1);
            cell_7.add_class('dock-placeholder');
            this.set('dock_placeholder_pos', 'bottom');


            //var c4w = cell4_el.offsetWidth;

            //console.log('c4w ' + c4w);
            //cell_5.add_class('dock-placeholder');

            var cell7_el = cell_7.get('dom.el');


            // use the full page width.


            //var c4h = cell4_el.offsetHeight;
            // get the offset height of the middle stripe, that's the one who's height we should change.




            var c7h = cell7_el.offsetHeight;
            //console.log('c7h ' + c7h);
            var nh = c - c7h;
            //console.log('nh ' + nh);
            m_stripe.style({
                'height': (nh) + 'px'
            })
        }

    },
    'close_placeholder': function() {
        var dppos = this.get('dock_placeholder_pos');
        if (dppos && dppos.value) dppos = dppos.value();

        var t_stripe = this.get('content').get(0);

        var m_stripe = this.get('content').get(1);
        var cell_4 = m_stripe.get('content').get(1);

        if (dppos == 'left') {
            var el = this.get('dom.el');
            var g9w = el.offsetWidth;

            var g9c = this.get('content');
            //console.log('g9c', g9c.length());

            //console.log('m_stripe', m_stripe);

            var cell_3 = m_stripe.get('content').get(0);

            // need to measure and shrink the central cell.

            //var w = cell4_el.offsetWidth;

            //console.log('w ' + w);

            // or remove that style declaration?
            cell_4.style({
                //'width': null
                'width': '100%'
            })

            //console.log('cell_3', cell_3);
            cell_3.remove_class('dock-placeholder');
            this.set('dock_placeholder_pos', false);

        }

        if (dppos == 'top') {
            var cell_1 = t_stripe.get('content').get(1);
            //console.log('cell_3', cell_3);
            cell_1.remove_class('dock-placeholder');
            this.set('dock_placeholder_pos', false);
        }

        if (dppos == 'right') {
            var cell_5 = this.get('content').get(1).get('content').get(2);
            //console.log('cell_3', cell_3);
            cell_5.remove_class('dock-placeholder');
            this.set('dock_placeholder_pos', false);
            cell_4.style({
                //'width': null
                'width': '100%'
            })
        }

        if (dppos == 'bottom') {
            var cell_7 = this.get('content').get(2).get('content').get(1);
            //console.log('cell_3', cell_3);
            cell_7.remove_class('dock-placeholder');
            this.set('dock_placeholder_pos', false);

            m_stripe.style({
                'height': '100%'
            })
        }


        /*
        var g9w = g9el.offsetWidth;



                        var g9c = grid_9.get('content');
                        //console.log('g9c', g9c.length());

                        //console.log('m_stripe', m_stripe);

                        var cell_3 = m_stripe.get('content').get(0);

                        // need to measure and shrink the central cell.

                        //var w = cell4_el.offsetWidth;

                        //console.log('w ' + w);

                        // or remove that style declaration?
                        cell_4.style({
                            //'width': null
                            'width': '100%'
                        })



                        //console.log('cell_3', cell_3);
                        cell_3.remove_class('dock-placeholder');
                        this.set('dock_placeholder_pos', false);
        */
    }


    // the grid_9 also needs to be activated.
    //  the controls within it need attachments to their elements.
    //  maybe grid_9 does not need more code in itself... just needs activate to be called when it's in the DOM.



});
//jsgui.Control = Control;




// Selection scope...
//  Can select the whole thing, can select parts of it.

// Don't want too much code to do with selection in the UI control itself.



// Space saving measures?
//  Declaring a buch of subcontrols with properties?
//  Doing so as XML? As JSON?


// Movable
// Resizable
// Rotatable
// Deletable
// Editable
// Reorderable
// Creatable

// Actionable
//  (actionable behaviours)

// They will vary quite a lot and probably can't all fit into one way of doing things.

// Want a very easy way to set these up.

// Using groups too.

// Behaviours seem like a good way of expressing action-reaction.
//


var recursive_dom_iterate = function (el, callback) {
    //console.log('recursive_dom_iterate');
    callback(el);

    //console.log('tof(el.childNodes) ' + tof(el.childNodes));

    //each(el.childNodes, function(i, v) {
    //	console.log('v ' + v);
    //});

    //console.log('el.childNodes.length ' + el.childNodes.length);
    var cns = el.childNodes;
    //console.log('el', el);
    //console.log('cns.length', cns.length);
    for (var c = 0, l = cns.length; c < l; c++) {
        recursive_dom_iterate(cns[c], callback);
    }
}

var recursive_dom_iterate_depth = function (el, callback) {
    //console.log('recursive_dom_iterate');


    //console.log('tof(el.childNodes) ' + tof(el.childNodes));

    //each(el.childNodes, function(i, v) {
    //  console.log('v ' + v);
    //});

    //console.log('el.childNodes.length ' + el.childNodes.length);
    var cns = el.childNodes;
    for (var c = 0, l = cns.length; c < l; c++) {
        recursive_dom_iterate_depth(cns[c], callback);
    }
    callback(el);
}


// Want the document node to be linked with the context when activated (automatically)

// We find the html element control. That is the one that gets set to be the context's ctrl_document.




var activate = function(context) {
    // The context should already have the map of controls.

    // Not so sure we can have the client page context here - does it use resources?

    //ensure_Context_Menu_loaded(function(_Context_Menu) {
        //Context_Menu = _Context_Menu;
        if (!context) {
            throw 'jsgui-html-enh activate(context) - need to supply context parameter.';
        }
        //context = context || new Page_Context();
        //console.log('jsgui-html-enh activate context', context);

        var map_jsgui_els = {};
        var map_jsgui_types = {};
        //console.log('activate - beginning mapping');
        // Could put together the array of controls in order found.

        var arr_controls = [];
        // element registration
        // Recursive iteration where the innermost get called first....
        //  Would be useful here.
        // counting up the typed id numbers.

        var max_typed_ids = {};

        var id_before__ = function(id) {
            var pos1 = id.lastIndexOf('_');
            var res = id.substr(0, pos1);
            return res;
        }

        var num_after = function(id) {
            //var pos1 = id.lastIndexOf('_');
            //var res = parseInt(id.substr(pos1 + 1), 10);
            //return res;
            return parseInt(id.substr(id.lastIndexOf('_') + 1), 10);
        }

        recursive_dom_iterate(document, function(el) {
            //console.log('2) el.tagName ' + el.tagName);
            var nt = el.nodeType;
            //console.log('nt ' + nt);

            // So for the 'HTML' tag name...
            //  We should make a control for the HTML document - or it should get activated.



            if (nt == 1) {
                var jsgui_id = el.getAttribute('data-jsgui-id');
                // Give the HTML document an ID?


                //console.log('jsgui_id ' + jsgui_id);
                if (jsgui_id) {
                    var ib = id_before__(jsgui_id);
                    var num =  num_after(jsgui_id);
                    if (!max_typed_ids[ib]) {
                        max_typed_ids[ib] = num;
                    } else {
                        if (num > max_typed_ids[ib]) max_typed_ids[ib] = num;
                    }

                    map_jsgui_els[jsgui_id] = el;
                    var jsgui_type = el.getAttribute('data-jsgui-type');
                    //console.log('jsgui_type ' + jsgui_type);
                    map_jsgui_types[jsgui_id] = jsgui_type;
                    //console.log('jsgui_type ' + jsgui_type);
                }
            }
        });
        context.set_max_ids(max_typed_ids);
        //console.log('max_typed_ids ' + stringify(max_typed_ids));
        //throw 'stop';
        //console.log('activate - finished mapping');

        // Then activate
        //  (but an activation where it does not yet know the references to various necessary other controls)
        //  This is about creating the controls, within the page_context.

        // if the control does not have its own recursive activation...
        //  Do the control creation, then there should be various properties and behaviours that get set.

        // create the controls.
        //console.log('map_jsgui_types ' + stringify(map_jsgui_types));
        //console.log('map_jsgui_els ' + stringify(map_jsgui_els));

        //console.log('map_controls_by_type ' + stringify(map_controls_by_type));
        //throw 'stop';

        //console.log('context.map_controls', context.map_controls);
        //console.log('map_jsgui_types', map_jsgui_types);

        var map_controls = context.map_controls;
        // Control construction and registration
        each(map_jsgui_els, function(el, jsgui_id) {
            //console.log('jsgui_id ' + jsgui_id);
            //console.log('3) el.tagName ' + el.tagName);
            var l_tag_name = el.tagName.toLowerCase();
            if (jsgui_id) {
                var type = map_jsgui_types[jsgui_id];
                //console.log('type ' + type);
                //var cstr = jsgui.constructor_from_type(type);

                //var cstr = jsgui.constructor_from_type(type);

                //console.log('cstr ' + cstr);

                // use the context's map_Controls

                var Cstr = context.map_Controls[type];
                //console.log('Cstr ' + Cstr.prototype);

                // then we can construct the control, and put it within the map.
                //  A later stage of activation will recreate the relationships between the controls.

                // OK, but have we got variables to initialize the controls with?
                //  It would maybe be most efficient to take delivery of them as one object.
                //   With just the control types and the data contained in them we can do a lot of reconstruction of the actual controls.

                // With the object viewer, we can even reconstruct the initial object from the rendered view.
                //  Not sure quite how much point there is in doing that. May work out most efficient because 1st view is prerendered and
                //  it does not need to send the data twice.
                // Eg can hook up the key (viewer), the value (viewer) and the comma.

                // for the document element we specifically add the control to the context.

                // Also want to read fields out for use in initialization.
                //  Not the ctrl_fields (for the moment)
                //  Just the data-jsgui-fields.
                //   However, it's likely they could be used in the initialization.
                //    And merged with the spec.




                if (Cstr) {
                    var ctrl = new Cstr({
                        'context': context,
                        '_id': jsgui_id,
                        'el': el
                    })
                    map_controls[jsgui_id] = ctrl;
                    arr_controls.push(ctrl);

                    //console.log('el.tagName', el.tagName);

                    if (l_tag_name === 'html') {
                        //console.log('el is document root el');

                        // The html element represents the root of a document.
                        //throw '2) stop';

                        context.ctrl_document = ctrl;
                    }
                } else {
                    console.log('Missing context.map_Controls for type ' + type + ', using generic Control');
                    var ctrl = new Control({
                        'context': context,
                        '_id': jsgui_id,
                        'el': el
                    })
                    map_controls[jsgui_id] = ctrl;
                    arr_controls.push(ctrl);

                }


                //console.log('jsgui_id ' + jsgui_id);
                //console.log('ctrl._id() ' + ctrl._id());

            }
            // get the constructor from the id?
        });
        //console.log('arr_controls ' + stringify(arr_controls));
        // depth-first activation?
        //  But connecting up the activated subcontrols with the control getting activated?
        //   They could be the content.

        //console.log('pre recursive_dom_iterate_depth');
        recursive_dom_iterate_depth(document, function(el) {
            //console.log('el ' + el);
            var nt = el.nodeType;
            //console.log('nt ' + nt);
            if (nt == 1) {
                var jsgui_id = el.getAttribute('data-jsgui-id');
                //console.log('* jsgui_id ' + jsgui_id);
                if (jsgui_id) {

                    var ctrl = map_controls[jsgui_id];
                    ctrl.__activating == true;
                    //console.log('tof ctrl ' + tof(ctrl));
                    ctrl.activate();
                    ctrl.__activating == false;
                    //console.log('jsgui_type ' + jsgui_type);
                }
            }
        });

        // Image uploader seems not to be activating properly...

    //})

    //  constructors.

    // should activate with the context.



    //console.log('done activate rdi');

    /*

    each(arr_controls, function(i, ctrl) {
        // Call activate on the control...
        //  usually it's going to set up the contents.


        // activate_contents activate_control_contents

        ctrl.activate();
        // Activate from bottom up
        //  Most inwards, upwards?

        //  So inner controls are active by the time it reaches outside....



    });
    */

    // Then another rec dom it.
    //  When activating various controls, we'll be looking for specific subcontrols to get a reference to.
    //  Don't want to wrap the elements like with jQuery.

    // then wen need to find the constructor for various controls.
    //  possibly do it for all controls.
    //  for text spans, we read it and assign the properites.

    // Think we should activate everything.
    //  Create the controls
    //  Give them references to the page context

    // Then give the controls references to each other.
    //  Some of the controls will be fields of other controls.
    //  We can make sure these get sent from the server so they can be activated on the client.
    //   Could maybe have 'relationships' where various other controls are given by jsgui-id that do something on a control.
    //   They are really control fields.

    // So an object editor may have the open and close control fields.

}

var core_extension = str_arr_mapify(function (tagName) {
    jsgui[tagName] = Control.extend({
        'init': function (spec) {
            //spec.tagName = tagName;

            //console.log('core extension tagName ' + tagName);

            this._super(spec);

            this.get('dom').set('tagName', tagName);
            // dom.tagName?

        }
    });
    jsgui[tagName].prototype._tag_name = tagName;
    map_Controls[tagName] = jsgui[tagName];
});

var core_extension_no_closing_tag = str_arr_mapify(function (tagName) {
    jsgui[tagName] = Control.extend({
        'init': function (spec) {
            //spec.tagName = tagName;

            //console.log('core extension tagName ' + tagName);

            this._super(spec);

            this.get('dom').set('tagName', tagName);
            this.get('dom').set('noClosingTag', true);
            // dom.tagName?

        }
    });
    jsgui[tagName].prototype._tag_name = tagName;
    map_Controls[tagName] = jsgui[tagName];
});




core_extension('html head title body div span h1 h2 h3 h4 h5 label p a script button form img ul li audio video');
core_extension_no_closing_tag('link input');
// link tag needs to have no closing tag.
//  core_extension_no_closing_tag


// the jsgui.script object needs more fields.
//  the jsgui data system has become more restrictive, in that fields / attributes need to be specified.

// dom.attributes.type being part of script.

// jsgui.script.fields().add('dom.attributes.type')

//  It may be nice to have this more flexible again.

// but with label we want a bit more...

jsgui.Label = Control.extend({
    // a field for 'for'
    'fields': [
        ['for', 'control']
        // needs to be able to deal with fields of the type 'control'.


    ],

    'init': function (spec) {
        // for property, and it's tagName gets set too.
        this._super(spec);
        this.set('dom.tagName', 'label');


        //console.log(spec.for);
        //throw stop;
        // content rather than text.
    },
    'beforeRenderDomAttributes': function () {
        //this.set('dom.name')

        //var dom = this.get('dom');
        //console.log('');

        //console.log('');
        //var dom_attributes = this.get('dom.attributes');

        //console.log('dom ' + stringify(dom));
        //console.log('dom_attributes ' + dom_attributes);

        //throw 'stop';


        //console.log('domAttributes ' + stringify(domAttributes));
        //if (this.)
        //console.log('this._ ' + stringify(this._));
        var _for = this.get('for');



        //console.log('tof(_for) ' + tof(_for));
        //throw 'stop';

        if (tof(_for) == 'control') {
            // we use that control's _id() as thr for in the dom attributes.
            var domAttributes = this.get('dom.attributes');
            domAttributes.set('for', _for._id());
        }

        //console.log('_for ' + stringify(_for));
        //throw 'stop';
        /*
        var groupName = this.get('group_name').get();
        var checked = this.get('checked').get();
        var value = this.get('value').get();
        //console.log('checked ' + stringify(checked));
        //throw 'stop';
        if (groupName) {
            domAttributes.set('name', groupName);
        }
        if (checked) {
            domAttributes.set('checked', checked.toString());
        }
        if (is_defined(value)) {
            domAttributes.set('value', value);
        }
        */
    }
});

var HTML_Document = jsgui.html.extend({
    // no tag to render...
    //  but has dtd.

    'render_dtd': function () {
        return '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">\n';
    }


});

var Blank_HTML_Document = HTML_Document.extend({
    'init': function (spec) {
        this._super(spec);

        var context = this._context;
        //console.log('context ' + context);

        if (!spec.el) {
            var head = new jsgui.head({
                'context': context
            });
            this.get('content').add(head);

            var title = new jsgui.title({
                'context': context
            });
            head.get('content').add(title);

            var body = new jsgui.body({
                'context': context
            });
            this.get('content').add(body);

            // and have .head, .title, .body?

            // useful shortcuts?
            this.set('head', head);
            this.set('title', title);
            this.set('body', body);

            //this.head = head;
            //this.title = title;
            //this.body = body;

            // Maybe connecting control fields?
            this.connect_fields(['head', 'body', 'title']);
        }



        //console.log('content ' + stringify(this.get('content')));

        //throw 'stop';

        //console.log('');
        //console.log('end init Blank_HTML_Document this._ ' + stringify(this._));
    },
    'body': fp(function(a, sig) {
        console.log('body sig', sig);
        if (sig =='[]') {
            // find the body control.

            var content = this.get('content');
            //console.log('content', content);
            var body = content.get(1);
            //console.log('body', body);
            //throw 'stop';

            return body;
        }
    })
});

// Want a body function in other nodes, available throughout the document?



var Client_HTML_Document = Blank_HTML_Document.extend({
    'init': function (spec) {
        this._super(spec);

        //spec.context.ctrl_document = this;
        this.active();

    },

    'include_js': function(url) {
        var head = this.get('head');
        // create jsgui.script

        var script = new jsgui.script({
            //<script type="text/JavaScript" src="abc.js"></script>
            'context': this._context
        })
        // <script data-main="scripts/main" src="scripts/require.js"></script>
        var dom = script.get('dom');
        //console.log('* dom ' + stringify(dom));

        //var domAttributes = script.get('dom.attributes');
        var domAttributes = dom.get('attributes');
        //console.log('domAttributes ' + domAttributes);

        domAttributes.set('type', 'text/javascript');
        //domAttributes.set('src', '/js/require.js');
        domAttributes.set('src', url);
        head.content().add(script);
    },

    'include_css': function(url) {
        var head = this.get('head');
        // create jsgui.script

        // <link rel="stylesheet" type="text/css" href="theme.css">

        var link = new jsgui.link({
            //<script type="text/JavaScript" src="abc.js"></script>
            'context': this._context
        })
        // <script data-main="scripts/main" src="scripts/require.js"></script>
        var dom = link.get('dom');
        //console.log('* dom ' + stringify(dom));

        //var domAttributes = script.get('dom.attributes');
        var domAttributes = dom.get('attributes');
        //console.log('domAttributes ' + domAttributes);

        domAttributes.set('rel', 'stylesheet');
        domAttributes.set('type', 'text/css');
        //domAttributes.set('src', '/js/require.js');
        domAttributes.set('href', url);
        head.content().add(link);
    },


    'include_jsgui_client': function(js_file_require_data_main) {

        // Could add the default client file.

        // Or a specific client file with a control that also has client-side code.
        //  The client-side code won't get processed on the server.
        //  There will be a specific place where client side code gets called upon activation.

        // could include a specific parameter for js_file_require_data_main

        js_file_require_data_main = js_file_require_data_main || '/js/web/jsgui-html-client';

        // Needs to add various script references to the body.
        //  May just be one client.js file
        //  Then will work on having it build quickly
        //  Then will work on making it stay fast to build and be smaller.

        // include the script in the body?
        //  is there a way to keep it at the end of the body?
        //  could put it in the head for the moment.

        var head = this.get('head');
        // create jsgui.script

        var script = new jsgui.script({
            //<script type="text/JavaScript" src="abc.js"></script>
            'context': this._context
        })
        // <script data-main="scripts/main" src="scripts/require.js"></script>

        //var dom = script.get('dom');
        //console.log('* dom ' + stringify(dom));

        //var domAttributes = script.get('dom.attributes');
        //var domAttributes = dom.get('attributes');
        var domAttributes = script.get('dom.attributes');

        //console.log('domAttributes ' + domAttributes);



        //domAttributes.set('type', 'text/javascript');
        //domAttributes.set('src', '/js/require.js');
        //domAttributes.set('data-main', js_file_require_data_main);
        domAttributes.set({
            'type': 'text/javascript',
            'src': '/js/web/require.js',
            'data-main': js_file_require_data_main
        });


        //script.set('dom.attributes.type', 'text/javascript');
        //script.set('dom.attributes.src', 'js/jsgui-client.js');
        //script.set('dom.attributes.src', 'js/require.js');
        //script.set('dom.attributes.data-main', 'js/jsgui-client.js');
        //script.set('dom.attributes.data-main', js_file_require_data_main);


        head.add(script);
        //throw 'stop';

    },

    'include_jsgui_resource_client': function(path) {

        // Could add the default client file.

        // Or a specific client file with a control that also has client-side code.
        //  The client-side code won't get processed on the server.
        //  There will be a specific place where client side code gets called upon activation.

        // could include a specific parameter for js_file_require_data_main

        var js_file_require_data_main = path || '/js/web/jsgui-html-resource-client';
        this.include_jsgui_client(js_file_require_data_main);

    },
    'include_client_css': function() {
        var head = this.get('head');
        var link = new jsgui.link({
            //<script type="text/JavaScript" src="abc.js"></script>
            'context': this._context

        });
        //var lda = link.get('dom.attributes');
        //var dom = link.get('dom');
        //console.log('* dom ' + stringify(dom));

        //var domAttributes = script.get('dom.attributes');
        var domAttributes = link.get('dom.attributes');

        domAttributes.set('rel', 'stylesheet');
        domAttributes.set('type', 'text/css');
        domAttributes.set('href', '/css/basic.css');

        head.content().add(link);
        // <link rel="stylesheet" type="text/css" href="theme.css">
    }

    // also need to include jsgui client css



});




// Behaviours...
//  (May be like flags?)
//  Selectable
//  Dragable
//  Drop-Zone

// These need to be done in a way to make controls take less code.



jsgui.activate = activate;
jsgui.recursive_dom_iterate = recursive_dom_iterate;
jsgui.recursive_dom_iterate_depth = recursive_dom_iterate_depth;
jsgui.get_window_size = get_window_size;
jsgui.Client_HTML_Document = Client_HTML_Document;
jsgui.desc = desc;
//jsgui.Selection_Scope = Selection_Scope;

// And a Page_Control as well...





jsgui.hover_class = hover_class;
jsgui.group_hover_class = group_hover_class;

//return jsgui;

module.exports = jsgui;

	//}
//);

},{"./controls/advanced/context-menu":44,"./jsgui-html-core":47,"./selection-scope":51}],49:[function(require,module,exports){

/*
if (typeof define !== 'function') {
    var define = require('amdefine')(module);
}


define(["./jsgui-html-core"],
	function(jsgui) {
	    */

var jsgui = require('./jsgui-html-core');

var stringify = jsgui.stringify, each = jsgui.eac, tof = jsgui.tof, is_defined = jsgui.is_defined;
var Control = jsgui.Control, Class = jsgui.Class;

var fp = jsgui.fp;
var group = jsgui.group;

var get_window_size = jsgui.get_window_size;


// this is the enhanced HTML module.

var Page_Context = jsgui.Evented_Class.extend({
    'init': function (spec) {
        spec = spec || {};
        if (spec.browser_info) {
            this.browser_info = spec.browser_info;
        };

        if (spec.resource_pool) {
            this.resource_pool = spec.resource_pool;
        }

        /*
        this.itemIndex = function(obj, item) {
            var c = -1;
            $.each(obj, function(i, n) {
                if (n === obj) c = i;
            });
            return c;
        };
        */

        this.get_vector_methodology = function () {
            if (this.browser_info.ie) {
                return 'vml';
            } else {
                return 'svg';
            }
        };

        /*
        var qids = [],
            iQid = 1,
            qid = function () {
                var res = 'qid_' + iQid;
                iQid++;
                return res;
            }, typedIds = {}, iTypedIds = {}, typed_id = function (str_type) {
                if (typeof iTypedIds[str_type] === 'undefined') {
                    iTypedIds[str_type] = 1;
                }
                var res = iTypedIds[str_type];
                iTypedIds[str_type] = iTypedIds[str_type] + 1;
                return res;
            };
        this.qid = qid;
        */


        // Copied from Server.Page_Context

        var map_new_ids = {};
        // and have the objects registered within the context too.

        var map_objects = {};

        var _get_new_typed_object_id = function(type_name) {
            if (!is_defined(map_new_ids[type_name])) {
                map_new_ids[type_name] = 0;
            }
            //if (!is_defined(map_new_ids[type_name]) {
            //  map_new_ids[type_name] = 0;
            //}
            var res = type_name + '_' + map_new_ids[type_name];
            map_new_ids[type_name]++;
            return res;
        }

        this.new_id = _get_new_typed_object_id;

        this.set_max_ids = function(map_max_ids) {
            each(map_max_ids, function(i, v) {
                map_new_ids[i] = v + 1;
            })
        }


        /* teIds = {}, iteIds = {}, typed_enhancement_id = function(str_type) {
            return str_type + '_' + typed_enhancement_int(str_type);
        }; */

        //this.teIds = teIds;
        //this.ctrls_by_id = {};
        //this.cl_abs = {}; // abstract controls for the client

        // typed enhancements may be retired. Not actively using them late July 2011 but they could they be within the lower level workings?
        /*
        var typed_enhancement_int = function(str_type) {
            if (typeof iteIds[str_type] === 'undefined') {
                iteIds[str_type] = 0;
            };
            //console.log('');
            //console.log('** str_type ' + str_type);

            var res = iteIds[str_type];
            iteIds[str_type] = iteIds[str_type] + 1;
            return res;
        };

        this._advance_type_id = function(str_type, quantity) {
            if (typeof quantity == 'undefined') quantity = 1;
            iteIds[str_type] = iteIds[str_type] || 0;
            iteIds[str_type] = iteIds[str_type] + quantity;
        };
        */
        /*
        this.ensure_ctrl_id = function(ctrl) {
            ctrl._ = ctrl._ || {};

            //console.log('ensure_ctrl_id ctrl._ ' + stringify(ctrl._));

            if (typeof ctrl._.id == 'undefined') {
                // ctrl._.class_name


                var id = typed_enhancement_id(ctrl._.type_name);
                ctrl._.id = id;
            }
            return ctrl._.id;
        };
        // may be retired... could be behaviours / surfaces in specs.
        this.apply_enhancement_id_spec = function(spec, ctrl) {

            // specifically what does this do?

            // The control will have another DOM attribute set
            // This is only for when composing an enhanced control on the server?
            // jsgui_e_id

            spec.dom = spec.dom || {};
            spec.dom.attributes = spec.dom.attributes || {};
            var tName = ctrl.typeName || 'misc';
            var tei = typed_enhancement_int(tName);
            spec.dom.attributes['jsgui_e_id'] = String(tei);
            return [tName, tei];
        };
        */

        /*
        this.get_spec = function (spec) {
            spec = spec || {};
            spec.page_context = this;
            return spec;
        };
        */

        // Give it the abstract component to make?
        //  So the abstract constructor gets called, and then the abstract instance goes into the make function.

        // contextify - contextifies a recently made item.

        //this.make = function()

        var map_Controls = this.map_Controls = {};
        //  they are constructors

        var map_controls = this.map_controls = {};

        map_Controls['control'] = Control;

    },
    'make': function(abstract_object) {
        if (abstract_object._abstract) {
            //var res = new
            // we need the constructor function.

            var constructor = abstract_object.constructor;
            //console.log('constructor ' + constructor);


            //throw 'stop';

            var aos = abstract_object._spec;

            // could use 'delete?'
            aos.abstract = null;
            aos.context = this;

            //console.log('abstract_object._spec ' + stringify(abstract_object._spec));
            // Not sure it is creating the right constructor.


            var res = new constructor(abstract_object._spec);
            return res;
        } else {
            throw 'Object must be abstract, having ._abstract == true'
        }
    },
    'update_Controls': fp(function(a, sig) {
        //console.log('update_Controls sig ' + sig);
        if (sig == '[o]') {
            // a map of keys and constructors values.
            var o = a[0];
            var map_Controls = this.map_Controls;
            each(o, function(name, Constructor) {
                name = name.toLowerCase();
                //console.log('name ' + name);
                map_Controls[name] = Constructor;
            });

        }
        if (sig == '[s,f]') {
            var name = a[0];
            var Constructor = a[1];
            name = name.toLowerCase();
            //console.log('name ' + name);
            this.map_Controls[name] = Constructor;
        }
    }),

    'register_control': function(control) {
        // Put it into the map of IDs

        //console.log('register_control');

        // Not sure how useful registration of all controls will be.
        //  Probably would not be a problem, just it will take memory and CPU cycles.


        var id = control._id();
        //console.log('id', id);

        this.map_controls[id] = control;

    },

    'first_ctrl_matching_type': function(type_name) {
      // Want to iterate through the controls.
      var res;
      each(this.map_controls, function(ctrl, ctrl_id, fn_stop) {
        //console.log('fn_stop', fn_stop);

        //console.log('ctrl', ctrl);
        //console.log('ctrl.__type_name', ctrl.__type_name);

        if (ctrl.__type_name === type_name) {
          //console.log('have match');
          fn_stop();
          res = ctrl;
        }
      });
      return res;


    },



    //'set_max_ids': function(map_max_ids) {

    //},

    // begin_drag?

    // can this be plumbed into the recently created events?
    //  we tell it that the drag is starting.

    // Want to tell the page context about beginning different types of drags?

    // Want the page context to be notified whenever a drag begins.
    //  If there is a selection scope then it's dragging those items.

    // Otherwise it could be dragging a control.
    //  Want the control dragging to call events here, so the Page_Context knows where controls are being dragged from / to.




    // This is currently about beginning a drag with a selection scope, but we may just want to be dragging a single control
    //  or controls not to do with a selection_scope.

    // In the case of there being a selection scope, we want to drag around something that represents the selection.

    // With direct drag, or dragging a handle, we don't have this copy of the selection scope.

    // drag_selection_scope_shallow_copy

    // May want to refactror things to have more behaviours and drag abstractions.
    //  However, working more on the style properties first makes more sense.

    // I'll do some more without major further abstractions.
    //

    // Defining the repositioning...
    //  could have that extnedable.

    // then we have the dragging of a control.
    //  Moves the control, does not leave a placeholder.

    // Need to be notified of it?
    //  Control may be dockable.

    // (notify)
    'begin_drag_ctrl': function(e_begin, ctrl) {
        // Though the ctrl should probably go in the event object - maybe need to formalise an API.

        // Different types of drag could be made modular to make builds smaller.
        //  For the moment need to add functionality then work on build size later.





    },

    // Make this an Evented_Class?

    /*

    'raise': function(event_name) {
        // need to access the object's bound events.

        //this.__bound_events = this.__bound_events || {};

        // but which context?

        //  the context of the event raiser?

        var a = arguments;
        var a2 = [];
        if (a.length > 1) {
            for (var c = 1; c < a.length; c++) {
                a2.push(a[c]);
            }
        }

        if (this.__bound_events) {
            var corresponding_events = this.__bound_events[event_name];
            for (var c = 0, l = corresponding_events.length; c < l; c++) {
                if (a2.length > 0) {
                    corresponding_events[c].apply(this, a2);
                } else {
                    corresponding_events[c].apply(this);
                }

            }
        }

    },

    // listen function as well.
    //  to listen for an event, it's like add_event_handler.

    // may change that to listen.

    'listen': function(event_name, handler) {
        this.__bound_events = this.__bound_events || {};
        this.__bound_events[event_name] = this.__bound_events[event_name] || [];
        this.__bound_events[event_name].push(handler);
    },

    */


    'move_drag_ctrl': function(e_move, ctrl) {
        // Though the ctrl should probably go in the event object - maybe need to formalise an API.

        // Different types of drag could be made modular to make builds smaller.
        //  For the moment need to add functionality then work on build size later.

        //console.log('move_drag_ctrl ', e_move);

        // maybe tify up the params so there is a move_offset value.
        //  perhaps we dont need it and it makes unnecessary calculation.

        // anyway, use the clientx and client y

        // should maybe measure the client area?
        //  or do that once and do it again on resize?

        // Should be able to get the client size from the Page_Context.
        //  Page_Context is turning out to be very versitile on the client too, nice that it's got similarities on the server
        //  but used very differently.


        // find out where we are within the client window.

        // get_window_size



        var window_size = get_window_size();



        //console.log('Window width = ' + winW);
        //console.log('Window height = ' + winH);

        // find how close the clientX / clientY is to the sides

        // could even have two different distances / ranges for
        //  1) anchor to position
        //  2) anchor to poisition and hide, only showing with mouseover of small region.

        // find how close to edges...

        var from_left, from_top, from_right, from_bottom;



        var clientX = e_move.clientX;
        var clientY = e_move.clientY;

        // see if it's at the top or bottom...
        //  would be nice to have different distances, so halfway to the margin anchors it in a way that it hides itself.



        var margin = 64;

        var is_left = clientX <= margin;
        var is_top = clientY <= margin;

        var is_right = clientX >= window_size[0] - margin;
        var is_bottom = clientY >= window_size[1] - margin;

        // need more generic event binding for objects.

        // listen
        // raise




        // then for the combinations...
        //console.log('is_top ' + is_top);
        if (is_top) {
            // raise the event...

            // then some things will listen for it.
            this.raise('drag-ctrl-top');

        } else if (is_bottom) {
            // raise the event...

            // then some things will listen for it.
            this.raise('drag-ctrl-bottom');

        } else if (is_left) {
            // raise the event...

            // then some things will listen for it.
            this.raise('drag-ctrl-left');

        } else if (is_right) {
            // raise the event...

            // then some things will listen for it.
            this.raise('drag-ctrl-right');

        } else {
            this.raise('drag-ctrl-no-zone');

        }


    },

    'end_drag_ctrl': function(e_end, ctrl) {
        // raise the event...
        this.raise('drag-ctrl-end', e_end, ctrl);


    },

    'drop_ctrl': function(ctrl, zone) {
        //console.log('page context drop control ctrl ' + ctrl);
        //console.log('zone ' + zone);

        if (this.full_window) {
            // anchor the control in that zone.

            this.anchor(ctrl, zone);

            // Basically we need to anchor one control inside another.
            //  The anchor zone will be a part of the grid_9 (or other mechanism)


        }
    },

    'anchor': function(ctrl, zone) {
        console.log('page context anchor ');

        if (this.full_window) {
            var fw = this.full_window;

            // and then does the full window control have a grid_9?

            var g9 = fw.get('grid_9');
            //console.log('g9 ' + g9);

            if (g9) {

                // Then the control will know its anchored.
                //  Dragging that control will unanchor it.

                // anchor the control to a position within that g9.
                //  Basically just put the control in place.
                //  Could do ctrl.anchor(g9, zone);

                // Generally won't be anchoring g9s to other things, but don't want to imply that in the fn name.
                //  g9.anchor_ctrl()

                // may have ctrl.anchor_ctrl, and anchoring is basically putting inside, but it sets it as being
                //  'anchored'.

                g9.anchor_ctrl(ctrl, zone);


            }

            var fwtn = fw.__type_name;
            //console.log('fwtn ' + fwtn);

        }
    },

    // Ending a control drag.
    //  If we are to dock the control somewhere, we have some docking code that does this that can be called separately from the
    //  event.


    // more than notify, this does some UI too.
    'begin_drag_selection_scope': function(e_begin, selection_scope) {

        // drag begin event, then what we are dragging.
        //  we could be dragging a selection scope
        //  just a single control
        //  a copy of a control.

        // going for some specific names to begin with may help.

        // rename this begin_selection_scope_drag





        // different drag modes...

        //  drag-shallow-copy
        //  drag-ctrl

        // drag-shallow-copy-begin

        // I think awareness of the drag mode will help.

        // The selection scope may not be relevant when dragging a window.
        //  However, we could count one item as being selected in the drag?








        console.log('page context drag selection_scope ' + selection_scope);

        var map_selected_controls = selection_scope.map_selected_controls;
        //console.log('map_selected_controls ' + stringify(map_selected_controls));

        // true keys...

        var arr_selected = jsgui.true_vals(map_selected_controls);
        console.log('arr_selected.length ' + arr_selected.length);

        // make shallow copies of these selected controls.

        var shallow_copies_selected = jsgui.shallow_copy(arr_selected);


        this.drag_selected = arr_selected;

        var ctrl_abs = this.make(Control({

        }));

        ctrl_abs.add(shallow_copies_selected);

        var screenX = e_begin.screenX;

        //console.log('screenX ' + screenX);
        var screenY = e_begin.screenY;

        var clientX = e_begin.clientX;
        var clientY = e_begin.clientY;


        //ctrl_abs.set('dom.attributes.style.position', 'absolute');
        //ctrl_abs.set('dom.attributes.style.height', '200px');
        //ctrl_abs.set('dom.attributes.style.width', '320px');
        //ctrl_abs.set('dom.attributes.style.background-color', '#ABCDEF');

        // Could set its class or have better way of doing an inline style.

        ctrl_abs.set('dom.attributes.style', 'position: absolute; left: ' + clientX + 'px; top:' + clientY + 'px; height: 200px; width: 320px; background-color: #EEEEEE');
        var html = ctrl_abs.all_html_render();

        var el_ctr = document.createElement('div');
        el_ctr.innerHTML = html;

        var el_abs = el_ctr.childNodes[0];

        document.body.appendChild(el_abs);

        ctrl_abs.set('el', el_abs);

        // within the context, we can make new controls and put them in the document.
        // an absolutely positioned div.

        this.ctrl_abs = ctrl_abs;


        //throw 'stop';
    },



    'move_drag_selection_scope': function(e_move) {
        console.log('page context move_drag_selection_scope');

        // Don't want this to be the case with all drag moves...
        //  We may be moving the actual item.




        var clientX = e_move.clientX;
        var clientY = e_move.clientY;

        // definitely would be useful to have the abstraction that covers individual style properties.
        var style = 'position: absolute; left: ' + clientX + 'px; top:' + clientY + 'px; height: 200px; width: 320px; background-color: #EEEEEE'
        //console.log('style ' + style);
        var el = this.ctrl_abs.get('el');
        //console.log('el ' + el);
        el.style.cssText = style;


    },
    'end_drag_selection_scope': function(e_end) {
        if (this.ctrl_abs) {
            this.ctrl_abs.remove();
            this.ctrl_abs = null;
        }
    },

    'ensure_dock_placeholder': function(pos) {
        //console.log('Page Context ensure_dock_placeholder ' + pos);

        var fw = this.full_window;

        if (fw) {
            fw.ensure_dock_placeholder(pos);
        }
    }

});

module.exports = Page_Context;
		//return Page_Context;
	//}
//);

},{"./jsgui-html-core":47}],50:[function(require,module,exports){
// object viewer

/*
if (typeof define !== 'function') {
    var define = require('amdefine')(module);
}
*/


// Need to sort out how the dependencies link.


// Does html require resource?
// html-enh require resource?

// Resource should be a part of the html client, but not the html system in general.

//throw 'stop';

// May be a circular reference here.
//  Within one of the modules that gets loaded.


// not so sure this needs to incluse the page context.

var jsgui = require('./jsgui-html-enh');

//console.log('jsgui', jsgui);
//throw 'stop2';
var Page_Context = require('./jsgui-html-page-context');

// Not using the old Page_Control at the moment.
//  It seems as if the docking behaviour would better be made some kind of addin / mixin.



//var Page_Control = require('./controls/page/page-control');


//define(["./jsgui-html-enh", "./jsgui-html-page-context", "./controls/page/page-control"],
	//function(jsgui, Page_Context, Page_Control) {
		
var stringify = jsgui.stringify, each = jsgui.each, tof = jsgui.tof, is_defined = jsgui.is_defined;
var Control = jsgui.Control;

var fp = jsgui.fp;
var group = jsgui.group;

// Client-side resource pool...
//  That would be very useful for accessing resources on the server.
//   Would have the server's URL, and a map (maybe) of what resources are on the server.

// This would be some kind of request broker.
//  It may ask the server what resources are on it, but the server could send this info (maybe just basic info)
//  along when the client-side resource pool is started up.

// Deliver that to jsgui-html-client?


//console.log('Page_Context', Page_Context);
//throw 'stop';
//throw 'stop';

jsgui.Page_Context = Page_Context;
//jsgui.Page_Control = Page_Control;
// this is the enhanced HTML module.


//return jsgui;

module.exports = jsgui;
	//}
//);
},{"./jsgui-html-enh":48,"./jsgui-html-page-context":49}],51:[function(require,module,exports){
/**
 * Created by James on 07/02/2015.
 */

var jsgui = require('./jsgui-html-core');
var each = jsgui.eac;
var tof = jsgui.tof;

var Selection_Scope = jsgui.Data_Object.extend({
//var Selection_Scope = jsgui.Class.extend({
    'init': function(spec) {
        // A selection scope belongs to a context
        //  should do
        // has its control.
        // various controls point to it.
        // has various methods to do with selecting and selecting objects


        // Could probably do these as fields.

        // Selection scope should also keep track of its context and its id.
        if (spec.context) this.context = spec.context;
        if (typeof spec.id !== 'undefined') this.is = spec.id;


        if (spec.control) this.control = spec.control;
        // Needs to be a list / map of all controls that are selected.
        // map of selected controls by id?
        //  also need to be able to go through the list of controls.
        this.map_selected_controls = {};
        // set the items by their id to point to the control.
        //  the control will know its index within its parent, can look up more info there.
    },
    'select_only': function(ctrl) {
        //console.log('Selection_Scope select_only ' + ctrl._id());

        // remove the selected class from all that are currently selected (except the target ctrl).
        //console.log('this.map_selected_controls ', this.map_selected_controls);


        // And need to trigger deselect where appropriate.

        // But not if the control was previously selected.
        var currently_selected;
        var count_deselected = 0;

        var selected;
        each(this.map_selected_controls, function(v, i) {

            if (v && v !== ctrl) {
                selected = v.get('selected').value();
                //console.log('selected', selected);
                //console.log('tof selected', tof(selected));

                if (selected) {
                    v.set('selected', false);
                    v.remove_class('selected');
                    v.trigger('deselect');
                    count_deselected++;
                }

                //console.log('should have deselcted ' + v._id())
            }
            if (v === ctrl) {
              currently_selected = v.get('selected').value();
            }

        });

        this.map_selected_controls = {};

        this.map_selected_controls[ctrl._id()] = ctrl;

        // and then tell the control that it's selected.

        // could possibly set a CSS flag.

        if (!currently_selected) {
          ctrl.set('selected', true);
          ctrl.trigger('select');

          ctrl.add_class('selected');
        }


        if (count_deselected > 0 &! currently_selected) {
          this.trigger('change');
        }





    },

    // deselect controls internal to a control.

    // When selecting a control, we want to make it so that controls inside it, in the same selection context are not selected.
    //  The Selection Scope does a fair bit of the management of the selections.

    'deselect_ctrl_content': function(ctrl) {
        var cs = ctrl.get('selection_scope');
        var msc = this.map_selected_controls;
        var that = this;
        ctrl.get('content').each(function(i, v) {
            var tv = tof(v);
            //console.log('tv ' + tv);

            if (tv == 'control') {

                // TODO: Trigger 'deselect' events when selection changes to negitive

                v.remove_class('selected');
                v.set('selected', false);

                var id = v._id();
                if (msc[id]) msc[id] = false;

                that.deselect_ctrl_content(v);
            }
        })
        //console.log('msc ', msc);
        this.trigger('change');
        //throw 'stop';
    },



    'select_toggle': function(ctrl) {
        //console.log('');
        //console.log('select_toggle');
        var sel = ctrl.get('selected').value();
        //console.log('tof(sel) ' + tof(sel));

        var msc = this.map_selected_controls;
        var id = ctrl._id();
        if (!sel) {


            var sel_anc = ctrl.find_selected_ancestor_in_scope();

            if (sel_anc) {
                console.log('1) not selecting because a selected ancestor in the selection scope has been found.');
            } else {


                ctrl.set('selected', true);
                // Check for a selected ancestor control in the scope.

                this.deselect_ctrl_content(ctrl);

                //  can try an iterate_ancestors function.

                //  iterate_ancestors_in_selection_scope
                //   looking for selected ancestor.

                // find_selected_ancestor_in_scope

                ctrl.add_class('selected');
                msc[id] = ctrl;
            }


        } else {
            var tsel = tof(sel);
            //console.log('tsel ' + (tsel))
            if (tsel == 'data_value') {
                var val = sel.get();
                //console.log('val ' + val);
                if (val) {
                    ctrl.remove_class('selected');
                    ctrl.set('selected', false);
                    msc[id] = false;
                } else {
                    var sel_anc = ctrl.find_selected_ancestor_in_scope();

                    if (sel_anc) {
                        console.log('2) not selecting because a selected ancestor in the selection scope has been found.');
                    } else {
                        ctrl.set('selected', true);
                        // Check for a selected ancestor control in the scope.
                        this.deselect_ctrl_content(ctrl);
                        //  can try an iterate_ancestors function.

                        //  iterate_ancestors_in_selection_scope
                        //   looking for selected ancestor.

                        // find_selected_ancestor_in_scope

                        ctrl.add_class('selected');
                        msc[id] = ctrl;
                    }
                }
                //
            }
            if (tsel == 'boolean') {

                if (sel) {
                    ctrl.remove_class('selected');
                    ctrl.set('selected', false);
                    msc[id] = false;
                } else {
                    var sel_anc = ctrl.find_selected_ancestor_in_scope();

                    if (sel_anc) {
                        console.log('2) not selecting because a selected ancestor in the selection scope has been found.');
                    } else {
                        this.deselect_ctrl_content(ctrl);
                        ctrl.set('selected', true);

                        // Check for a selected ancestor control in the scope.

                        //  can try an iterate_ancestors function.

                        //  iterate_ancestors_in_selection_scope
                        //   looking for selected ancestor.

                        // find_selected_ancestor_in_scope

                        ctrl.add_class('selected');
                        msc[id] = ctrl;
                    }
                }

            }
        }
        this.trigger('change');
        //throw 'stop';

    }
});

module.exports = Selection_Scope;

},{"./jsgui-html-core":47}]},{},[23])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uXFwuLlxcLi5cXC4uXFwuLlxcLi5cXC4uXFwuLlxcLi5cXC4uXFxBcHBEYXRhXFxSb2FtaW5nXFxucG1cXG5vZGVfbW9kdWxlc1xcYnJvd3NlcmlmeVxcbm9kZV9tb2R1bGVzXFxicm93c2VyLXBhY2tcXF9wcmVsdWRlLmpzIiwiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vQXBwRGF0YS9Sb2FtaW5nL25wbS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3Nlci1yZXNvbHZlL2VtcHR5LmpzIiwiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vQXBwRGF0YS9Sb2FtaW5nL25wbS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnVmZmVyL2luZGV4LmpzIiwiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vQXBwRGF0YS9Sb2FtaW5nL25wbS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnVmZmVyL25vZGVfbW9kdWxlcy9iYXNlNjQtanMvbGliL2I2NC5qcyIsIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL0FwcERhdGEvUm9hbWluZy9ucG0vbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2J1ZmZlci9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL0FwcERhdGEvUm9hbWluZy9ucG0vbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2J1ZmZlci9ub2RlX21vZHVsZXMvaXMtYXJyYXkvaW5kZXguanMiLCIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9BcHBEYXRhL1JvYW1pbmcvbnBtL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9ldmVudHMvZXZlbnRzLmpzIiwiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vQXBwRGF0YS9Sb2FtaW5nL25wbS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qcyIsIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL0FwcERhdGEvUm9hbWluZy9ucG0vbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2lzYXJyYXkvaW5kZXguanMiLCIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9BcHBEYXRhL1JvYW1pbmcvbnBtL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9BcHBEYXRhL1JvYW1pbmcvbnBtL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vZHVwbGV4LmpzIiwiLi5cXC4uXFwuLlxcLi5cXC4uXFwuLlxcLi5cXC4uXFwuLlxcLi5cXEFwcERhdGFcXFJvYW1pbmdcXG5wbVxcbm9kZV9tb2R1bGVzXFxicm93c2VyaWZ5XFxub2RlX21vZHVsZXNcXHJlYWRhYmxlLXN0cmVhbVxcbGliXFxfc3RyZWFtX2R1cGxleC5qcyIsIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL0FwcERhdGEvUm9hbWluZy9ucG0vbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qcyIsIi4uXFwuLlxcLi5cXC4uXFwuLlxcLi5cXC4uXFwuLlxcLi5cXC4uXFxBcHBEYXRhXFxSb2FtaW5nXFxucG1cXG5vZGVfbW9kdWxlc1xcYnJvd3NlcmlmeVxcbm9kZV9tb2R1bGVzXFxyZWFkYWJsZS1zdHJlYW1cXGxpYlxcX3N0cmVhbV9yZWFkYWJsZS5qcyIsIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL0FwcERhdGEvUm9hbWluZy9ucG0vbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanMiLCIuLlxcLi5cXC4uXFwuLlxcLi5cXC4uXFwuLlxcLi5cXC4uXFwuLlxcQXBwRGF0YVxcUm9hbWluZ1xcbnBtXFxub2RlX21vZHVsZXNcXGJyb3dzZXJpZnlcXG5vZGVfbW9kdWxlc1xccmVhZGFibGUtc3RyZWFtXFxsaWJcXF9zdHJlYW1fd3JpdGFibGUuanMiLCIuLlxcLi5cXC4uXFwuLlxcLi5cXC4uXFwuLlxcLi5cXC4uXFwuLlxcQXBwRGF0YVxcUm9hbWluZ1xcbnBtXFxub2RlX21vZHVsZXNcXGJyb3dzZXJpZnlcXG5vZGVfbW9kdWxlc1xccmVhZGFibGUtc3RyZWFtXFxub2RlX21vZHVsZXNcXGNvcmUtdXRpbC1pc1xcbGliXFx1dGlsLmpzIiwiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vQXBwRGF0YS9Sb2FtaW5nL25wbS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3Bhc3N0aHJvdWdoLmpzIiwiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vQXBwRGF0YS9Sb2FtaW5nL25wbS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3JlYWRhYmxlLmpzIiwiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vQXBwRGF0YS9Sb2FtaW5nL25wbS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3RyYW5zZm9ybS5qcyIsIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL0FwcERhdGEvUm9hbWluZy9ucG0vbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS93cml0YWJsZS5qcyIsIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL0FwcERhdGEvUm9hbWluZy9ucG0vbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3N0cmVhbS1icm93c2VyaWZ5L2luZGV4LmpzIiwiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vQXBwRGF0YS9Sb2FtaW5nL25wbS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvc3RyaW5nX2RlY29kZXIvaW5kZXguanMiLCJhcHAuanMiLCIuLi8uLi8uLi8uLi8uLi9qcy9jb3JlL2NvbGxlY3Rpb24taW5kZXguanMiLCIuLi8uLi8uLi8uLi8uLi9qcy9jb3JlL2NvbGxlY3Rpb24uanMiLCIuLi8uLi8uLi8uLi8uLi9qcy9jb3JlL2NvbnN0cmFpbnQuanMiLCIuLi8uLi8uLi8uLi8uLi9qcy9jb3JlL2RhdGEtb2JqZWN0LWZpZWxkcy1jb2xsZWN0aW9uLmpzIiwiLi4vLi4vLi4vLi4vLi4vanMvY29yZS9kYXRhLW9iamVjdC5qcyIsIi4uLy4uLy4uLy4uLy4uL2pzL2NvcmUvZGF0YS12YWx1ZS5qcyIsIi4uLy4uLy4uLy4uLy4uL2pzL2NvcmUvZW5oYW5jZWQtZGF0YS1vYmplY3QuanMiLCIuLi8uLi8uLi8uLi8uLi9qcy9jb3JlL2V2ZW50ZWQtY2xhc3MuanMiLCIuLi8uLi8uLi8uLi8uLi9qcy9jb3JlL2pzZ3VpLWRhdGEtc3RydWN0dXJlcy1iLXBsdXMtdHJlZS5qcyIsIi4uLy4uLy4uLy4uLy4uL2pzL2NvcmUvanNndWktZGF0YS1zdHJ1Y3R1cmVzLWRvdWJseS1saW5rZWQtbGlzdC5qcyIsIi4uLy4uLy4uLy4uLy4uL2pzL2NvcmUvanNndWktZGF0YS1zdHJ1Y3R1cmVzLXN0aWZmYXJyYXkuanMiLCIuLi8uLi8uLi8uLi8uLi9qcy9jb3JlL2pzZ3VpLWRhdGEtc3RydWN0dXJlcy5qcyIsIi4uLy4uLy4uLy4uLy4uL2pzL2NvcmUvanNndWktbGFuZy1lbmguanMiLCIuLlxcLi5cXC4uXFwuLlxcLi5cXGpzXFxjb3JlXFxqc2d1aS1sYW5nLWVzc2VudGlhbHMuanMiLCIuLi8uLi8uLi8uLi8uLi9qcy9jb3JlL2pzZ3VpLWxhbmctdXRpbC5qcyIsIi4uLy4uLy4uLy4uLy4uL2pzL3Jlc291cmNlL2NvcmUvY2xpZW50LXBvb2wuanMiLCIuLi8uLi8uLi8uLi8uLi9qcy9yZXNvdXJjZS9jb3JlL2NsaWVudC1yZXNvdXJjZS5qcyIsIi4uLy4uLy4uLy4uLy4uL2pzL3Jlc291cmNlL2NvcmUvcG9vbC5qcyIsIi4uLy4uLy4uLy4uLy4uL2pzL3Jlc291cmNlL2NvcmUvcmVzb3VyY2UuanMiLCIuLi8uLi8uLi8uLi8uLi9qcy93ZWIvY2xpZW50LXBhZ2UtY29udGV4dC5qcyIsIi4uLy4uLy4uLy4uLy4uL2pzL3dlYi9jb250cm9scy9hZHZhbmNlZC9jb250ZXh0LW1lbnUuanMiLCIuLi8uLi8uLi8uLi8uLi9qcy93ZWIvY29udHJvbHMvYWR2YW5jZWQvbWVudS1ub2RlLmpzIiwiLi4vLi4vLi4vLi4vLi4vanMvd2ViL2pzZ3VpLWh0bWwtY2xpZW50LmpzIiwiLi4vLi4vLi4vLi4vLi4vanMvd2ViL2pzZ3VpLWh0bWwtY29yZS5qcyIsIi4uLy4uLy4uLy4uLy4uL2pzL3dlYi9qc2d1aS1odG1sLWVuaC5qcyIsIi4uLy4uLy4uLy4uLy4uL2pzL3dlYi9qc2d1aS1odG1sLXBhZ2UtY29udGV4dC5qcyIsIi4uLy4uLy4uLy4uLy4uL2pzL3dlYi9qc2d1aS1odG1sLmpzIiwiLi4vLi4vLi4vLi4vLi4vanMvd2ViL3NlbGVjdGlvbi1zY29wZS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5eENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6REE7QUFDQTs7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDekZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3Y3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNqTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDN2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMxR0E7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7O0FDREE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9IQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbHVFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaDNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9xREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeDZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzExSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2puQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNXVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3ZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdmdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDN3BHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9RQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzF6R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMveUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9xQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLG51bGwsIi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cblxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpcy1hcnJheScpXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTIgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuXG52YXIga01heExlbmd0aCA9IDB4M2ZmZmZmZmZcbnZhciByb290UGFyZW50ID0ge31cblxuLyoqXG4gKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgVXNlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNilcbiAqXG4gKiBCcm93c2VycyB0aGF0IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssIENocm9tZSA3KywgU2FmYXJpIDUuMSssXG4gKiBPcGVyYSAxMS42KywgaU9TIDQuMisuXG4gKlxuICogTm90ZTpcbiAqXG4gKiAtIEltcGxlbWVudGF0aW9uIG11c3Qgc3VwcG9ydCBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgIGluc3RhbmNlcy5cbiAqICAgRmlyZWZveCA0LTI5IGxhY2tlZCBzdXBwb3J0LCBmaXhlZCBpbiBGaXJlZm94IDMwKy5cbiAqICAgU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzguXG4gKlxuICogIC0gQ2hyb21lIDktMTAgaXMgbWlzc2luZyB0aGUgYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbi5cbiAqXG4gKiAgLSBJRTEwIGhhcyBhIGJyb2tlbiBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYXJyYXlzIG9mXG4gKiAgICBpbmNvcnJlY3QgbGVuZ3RoIGluIHNvbWUgc2l0dWF0aW9ucy5cbiAqXG4gKiBXZSBkZXRlY3QgdGhlc2UgYnVnZ3kgYnJvd3NlcnMgYW5kIHNldCBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgIHRvIGBmYWxzZWAgc28gdGhleSB3aWxsXG4gKiBnZXQgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggaXMgc2xvd2VyIGJ1dCB3aWxsIHdvcmsgY29ycmVjdGx5LlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IChmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgdmFyIGJ1ZiA9IG5ldyBBcnJheUJ1ZmZlcigwKVxuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheShidWYpXG4gICAgYXJyLmZvbyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH1cbiAgICByZXR1cm4gYXJyLmZvbygpID09PSA0MiAmJiAvLyB0eXBlZCBhcnJheSBpbnN0YW5jZXMgY2FuIGJlIGF1Z21lbnRlZFxuICAgICAgICB0eXBlb2YgYXJyLnN1YmFycmF5ID09PSAnZnVuY3Rpb24nICYmIC8vIGNocm9tZSA5LTEwIGxhY2sgYHN1YmFycmF5YFxuICAgICAgICBuZXcgVWludDhBcnJheSgxKS5zdWJhcnJheSgxLCAxKS5ieXRlTGVuZ3RoID09PSAwIC8vIGllMTAgaGFzIGJyb2tlbiBgc3ViYXJyYXlgXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufSkoKVxuXG4vKipcbiAqIENsYXNzOiBCdWZmZXJcbiAqID09PT09PT09PT09PT1cbiAqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGFyZSBhdWdtZW50ZWRcbiAqIHdpdGggZnVuY3Rpb24gcHJvcGVydGllcyBmb3IgYWxsIHRoZSBub2RlIGBCdWZmZXJgIEFQSSBmdW5jdGlvbnMuIFdlIHVzZVxuICogYFVpbnQ4QXJyYXlgIHNvIHRoYXQgc3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXQgcmV0dXJuc1xuICogYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogQnkgYXVnbWVudGluZyB0aGUgaW5zdGFuY2VzLCB3ZSBjYW4gYXZvaWQgbW9kaWZ5aW5nIHRoZSBgVWludDhBcnJheWBcbiAqIHByb3RvdHlwZS5cbiAqL1xuZnVuY3Rpb24gQnVmZmVyIChzdWJqZWN0LCBlbmNvZGluZywgbm9aZXJvKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXIpKVxuICAgIHJldHVybiBuZXcgQnVmZmVyKHN1YmplY3QsIGVuY29kaW5nLCBub1plcm8pXG5cbiAgdmFyIHR5cGUgPSB0eXBlb2Ygc3ViamVjdFxuXG4gIC8vIEZpbmQgdGhlIGxlbmd0aFxuICB2YXIgbGVuZ3RoXG4gIGlmICh0eXBlID09PSAnbnVtYmVyJykge1xuICAgIGxlbmd0aCA9ICtzdWJqZWN0XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICBsZW5ndGggPSBCdWZmZXIuYnl0ZUxlbmd0aChzdWJqZWN0LCBlbmNvZGluZylcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnb2JqZWN0JyAmJiBzdWJqZWN0ICE9PSBudWxsKSB7IC8vIGFzc3VtZSBvYmplY3QgaXMgYXJyYXktbGlrZVxuICAgIGlmIChzdWJqZWN0LnR5cGUgPT09ICdCdWZmZXInICYmIGlzQXJyYXkoc3ViamVjdC5kYXRhKSlcbiAgICAgIHN1YmplY3QgPSBzdWJqZWN0LmRhdGFcbiAgICBsZW5ndGggPSArc3ViamVjdC5sZW5ndGhcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtdXN0IHN0YXJ0IHdpdGggbnVtYmVyLCBidWZmZXIsIGFycmF5IG9yIHN0cmluZycpXG4gIH1cblxuICBpZiAobGVuZ3RoID4ga01heExlbmd0aClcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcbiAgICAgICdzaXplOiAweCcgKyBrTWF4TGVuZ3RoLnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuXG4gIGlmIChsZW5ndGggPCAwKVxuICAgIGxlbmd0aCA9IDBcbiAgZWxzZVxuICAgIGxlbmd0aCA+Pj49IDAgLy8gQ29lcmNlIHRvIHVpbnQzMi5cblxuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUHJlZmVycmVkOiBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIC8qZXNsaW50LWRpc2FibGUgY29uc2lzdGVudC10aGlzICovXG4gICAgc2VsZiA9IEJ1ZmZlci5fYXVnbWVudChuZXcgVWludDhBcnJheShsZW5ndGgpKVxuICAgIC8qZXNsaW50LWVuYWJsZSBjb25zaXN0ZW50LXRoaXMgKi9cbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIFRISVMgaW5zdGFuY2Ugb2YgQnVmZmVyIChjcmVhdGVkIGJ5IGBuZXdgKVxuICAgIHNlbGYubGVuZ3RoID0gbGVuZ3RoXG4gICAgc2VsZi5faXNCdWZmZXIgPSB0cnVlXG4gIH1cblxuICB2YXIgaVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgdHlwZW9mIHN1YmplY3QuYnl0ZUxlbmd0aCA9PT0gJ251bWJlcicpIHtcbiAgICAvLyBTcGVlZCBvcHRpbWl6YXRpb24gLS0gdXNlIHNldCBpZiB3ZSdyZSBjb3B5aW5nIGZyb20gYSB0eXBlZCBhcnJheVxuICAgIHNlbGYuX3NldChzdWJqZWN0KVxuICB9IGVsc2UgaWYgKGlzQXJyYXlpc2goc3ViamVjdCkpIHtcbiAgICAvLyBUcmVhdCBhcnJheS1pc2ggb2JqZWN0cyBhcyBhIGJ5dGUgYXJyYXlcbiAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKHN1YmplY3QpKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspXG4gICAgICAgIHNlbGZbaV0gPSBzdWJqZWN0LnJlYWRVSW50OChpKVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspXG4gICAgICAgIHNlbGZbaV0gPSAoKHN1YmplY3RbaV0gJSAyNTYpICsgMjU2KSAlIDI1NlxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHNlbGYud3JpdGUoc3ViamVjdCwgMCwgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicgJiYgIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmICFub1plcm8pIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHNlbGZbaV0gPSAwXG4gICAgfVxuICB9XG5cbiAgaWYgKGxlbmd0aCA+IDAgJiYgbGVuZ3RoIDw9IEJ1ZmZlci5wb29sU2l6ZSlcbiAgICBzZWxmLnBhcmVudCA9IHJvb3RQYXJlbnRcblxuICByZXR1cm4gc2VsZlxufVxuXG5mdW5jdGlvbiBTbG93QnVmZmVyIChzdWJqZWN0LCBlbmNvZGluZywgbm9aZXJvKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTbG93QnVmZmVyKSlcbiAgICByZXR1cm4gbmV3IFNsb3dCdWZmZXIoc3ViamVjdCwgZW5jb2RpbmcsIG5vWmVybylcblxuICB2YXIgYnVmID0gbmV3IEJ1ZmZlcihzdWJqZWN0LCBlbmNvZGluZywgbm9aZXJvKVxuICBkZWxldGUgYnVmLnBhcmVudFxuICByZXR1cm4gYnVmXG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIChiKSB7XG4gIHJldHVybiAhIShiICE9IG51bGwgJiYgYi5faXNCdWZmZXIpXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSlcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgbXVzdCBiZSBCdWZmZXJzJylcblxuICBpZiAoYSA9PT0gYikgcmV0dXJuIDBcblxuICB2YXIgeCA9IGEubGVuZ3RoXG4gIHZhciB5ID0gYi5sZW5ndGhcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuICYmIGFbaV0gPT09IGJbaV07IGkrKykge31cbiAgaWYgKGkgIT09IGxlbikge1xuICAgIHggPSBhW2ldXG4gICAgeSA9IGJbaV1cbiAgfVxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICdyYXcnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gKGxpc3QsIHRvdGFsTGVuZ3RoKSB7XG4gIGlmICghaXNBcnJheShsaXN0KSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVXNhZ2U6IEJ1ZmZlci5jb25jYXQobGlzdFssIGxlbmd0aF0pJylcblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcigwKVxuICB9IGVsc2UgaWYgKGxpc3QubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGxpc3RbMF1cbiAgfVxuXG4gIHZhciBpXG4gIGlmICh0b3RhbExlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdG90YWxMZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRvdGFsTGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZiA9IG5ldyBCdWZmZXIodG90YWxMZW5ndGgpXG4gIHZhciBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBsaXN0W2ldXG4gICAgaXRlbS5jb3B5KGJ1ZiwgcG9zKVxuICAgIHBvcyArPSBpdGVtLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZcbn1cblxuQnVmZmVyLmJ5dGVMZW5ndGggPSBmdW5jdGlvbiAoc3RyLCBlbmNvZGluZykge1xuICB2YXIgcmV0XG4gIHN0ciA9IHN0ciArICcnXG4gIHN3aXRjaCAoZW5jb2RpbmcgfHwgJ3V0ZjgnKSB7XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAncmF3JzpcbiAgICAgIHJldCA9IHN0ci5sZW5ndGhcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldCA9IHN0ci5sZW5ndGggKiAyXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2hleCc6XG4gICAgICByZXQgPSBzdHIubGVuZ3RoID4+PiAxXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIHJldCA9IHV0ZjhUb0J5dGVzKHN0cikubGVuZ3RoXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICByZXQgPSBiYXNlNjRUb0J5dGVzKHN0cikubGVuZ3RoXG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXQgPSBzdHIubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG4vLyBwcmUtc2V0IGZvciB2YWx1ZXMgdGhhdCBtYXkgZXhpc3QgaW4gdGhlIGZ1dHVyZVxuQnVmZmVyLnByb3RvdHlwZS5sZW5ndGggPSB1bmRlZmluZWRcbkJ1ZmZlci5wcm90b3R5cGUucGFyZW50ID0gdW5kZWZpbmVkXG5cbi8vIHRvU3RyaW5nKGVuY29kaW5nLCBzdGFydD0wLCBlbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcblxuICBzdGFydCA9IHN0YXJ0ID4+PiAwXG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA9PT0gSW5maW5pdHkgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMFxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG4gIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmIChlbmQgPD0gc3RhcnQpIHJldHVybiAnJ1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGJpbmFyeVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSlcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0ciA9ICcnXG4gIHZhciBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTXG4gIGlmICh0aGlzLmxlbmd0aCA+IDApIHtcbiAgICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLm1hdGNoKC8uezJ9L2cpLmpvaW4oJyAnKVxuICAgIGlmICh0aGlzLmxlbmd0aCA+IG1heClcbiAgICAgIHN0ciArPSAnIC4uLiAnXG4gIH1cbiAgcmV0dXJuICc8QnVmZmVyICcgKyBzdHIgKyAnPidcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIDBcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpXG59XG5cbi8vIGBnZXRgIHdpbGwgYmUgcmVtb3ZlZCBpbiBOb2RlIDAuMTMrXG5CdWZmZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgY29uc29sZS5sb2coJy5nZXQoKSBpcyBkZXByZWNhdGVkLiBBY2Nlc3MgdXNpbmcgYXJyYXkgaW5kZXhlcyBpbnN0ZWFkLicpXG4gIHJldHVybiB0aGlzLnJlYWRVSW50OChvZmZzZXQpXG59XG5cbi8vIGBzZXRgIHdpbGwgYmUgcmVtb3ZlZCBpbiBOb2RlIDAuMTMrXG5CdWZmZXIucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh2LCBvZmZzZXQpIHtcbiAgY29uc29sZS5sb2coJy5zZXQoKSBpcyBkZXByZWNhdGVkLiBBY2Nlc3MgdXNpbmcgYXJyYXkgaW5kZXhlcyBpbnN0ZWFkLicpXG4gIHJldHVybiB0aGlzLndyaXRlVUludDgodiwgb2Zmc2V0KVxufVxuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIC8vIG11c3QgYmUgYW4gZXZlbiBudW1iZXIgb2YgZGlnaXRzXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChzdHJMZW4gJSAyICE9PSAwKSB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIHZhciBieXRlID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGlmIChpc05hTihieXRlKSkgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmcnKVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IGJ5dGVcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgY2hhcnNXcml0dGVuID0gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxuICByZXR1cm4gY2hhcnNXcml0dGVuXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgY2hhcnNXcml0dGVuID0gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbiAgcmV0dXJuIGNoYXJzV3JpdHRlblxufVxuXG5mdW5jdGlvbiBiaW5hcnlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgY2hhcnNXcml0dGVuID0gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG4gIHJldHVybiBjaGFyc1dyaXR0ZW5cbn1cblxuZnVuY3Rpb24gdXRmMTZsZVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGNoYXJzV3JpdHRlbiA9IGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbiAgcmV0dXJuIGNoYXJzV3JpdHRlblxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIFN1cHBvcnQgYm90aCAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpXG4gIC8vIGFuZCB0aGUgbGVnYWN5IChzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBpZiAoIWlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIH0gZWxzZSB7ICAvLyBsZWdhY3lcbiAgICB2YXIgc3dhcCA9IGVuY29kaW5nXG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBvZmZzZXQgPSBsZW5ndGhcbiAgICBsZW5ndGggPSBzd2FwXG4gIH1cblxuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG5cbiAgaWYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aClcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignYXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnKVxuXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG4gIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nIHx8ICd1dGY4JykudG9Mb3dlckNhc2UoKVxuXG4gIHZhciByZXRcbiAgc3dpdGNoIChlbmNvZGluZykge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgICByZXQgPSBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgICByZXQgPSB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYXNjaWknOlxuICAgICAgcmV0ID0gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdiaW5hcnknOlxuICAgICAgcmV0ID0gYmluYXJ5V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIHJldCA9IGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXQgPSB1dGYxNmxlV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmVzID0gJydcbiAgdmFyIHRtcCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIGlmIChidWZbaV0gPD0gMHg3Rikge1xuICAgICAgcmVzICs9IGRlY29kZVV0ZjhDaGFyKHRtcCkgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgICAgIHRtcCA9ICcnXG4gICAgfSBlbHNlIHtcbiAgICAgIHRtcCArPSAnJScgKyBidWZbaV0udG9TdHJpbmcoMTYpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlcyArIGRlY29kZVV0ZjhDaGFyKHRtcClcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gYmluYXJ5U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIHZhciBvdXQgPSAnJ1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIG91dCArPSB0b0hleChidWZbaV0pXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgdmFyIHJlcyA9ICcnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIGJ5dGVzW2kgKyAxXSAqIDI1NilcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSB+fnN0YXJ0XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuXG4gICAgaWYgKHN0YXJ0IDwgMClcbiAgICAgIHN0YXJ0ID0gMFxuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlblxuICAgIGlmIChlbmQgPCAwKVxuICAgICAgZW5kID0gMFxuICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xuICAgIGVuZCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KVxuICAgIGVuZCA9IHN0YXJ0XG5cbiAgdmFyIG5ld0J1ZlxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBuZXdCdWYgPSBCdWZmZXIuX2F1Z21lbnQodGhpcy5zdWJhcnJheShzdGFydCwgZW5kKSlcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xpY2VMZW4gPSBlbmQgLSBzdGFydFxuICAgIG5ld0J1ZiA9IG5ldyBCdWZmZXIoc2xpY2VMZW4sIHVuZGVmaW5lZCwgdHJ1ZSlcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsaWNlTGVuOyBpKyspIHtcbiAgICAgIG5ld0J1ZltpXSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfVxuXG4gIGlmIChuZXdCdWYubGVuZ3RoKVxuICAgIG5ld0J1Zi5wYXJlbnQgPSB0aGlzLnBhcmVudCB8fCB0aGlzXG5cbiAgcmV0dXJuIG5ld0J1ZlxufVxuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMClcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aClcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpXG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXVxuICB2YXIgbXVsID0gMVxuICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpXG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXSAqIG11bFxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArXG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICAgdGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKVxuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpXG4gICAgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aFxuICB2YXIgbXVsID0gMVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWldXG4gIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSlcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpXG4gICAgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpXG4gICAgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdidWZmZXIgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3ZhbHVlIGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpLCAwKVxuXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpXG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgPj4+IDAgJiAweEZGXG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCksIDApXG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSlcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSA+Pj4gMCAmIDB4RkZcblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICB0aGlzW29mZnNldF0gPSB2YWx1ZVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQxNiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCAyKTsgaSA8IGo7IGkrKykge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSAmICgweGZmIDw8ICg4ICogKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkpKSkgPj4+XG4gICAgICAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSAqIDhcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSB2YWx1ZVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9IHZhbHVlXG4gIH0gZWxzZSBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MzIgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDQpOyBpIDwgajsgaSsrKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlID4+PiAobGl0dGxlRW5kaWFuID8gaSA6IDMgLSBpKSAqIDgpICYgMHhmZlxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlXG4gIH0gZWxzZSBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSB2YWx1ZVxuICB9IGVsc2Ugb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSW50KHRoaXMsXG4gICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgb2Zmc2V0LFxuICAgICAgICAgICAgIGJ5dGVMZW5ndGgsXG4gICAgICAgICAgICAgTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKSAtIDEsXG4gICAgICAgICAgICAgLU1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSkpXG4gIH1cblxuICB2YXIgaSA9IDBcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IHZhbHVlIDwgMCA/IDEgOiAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSlcbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJbnQodGhpcyxcbiAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICBvZmZzZXQsXG4gICAgICAgICAgICAgYnl0ZUxlbmd0aCxcbiAgICAgICAgICAgICBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpIC0gMSxcbiAgICAgICAgICAgICAtTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKSlcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IHZhbHVlIDwgMCA/IDEgOiAwXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWVcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSB2YWx1ZVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gdmFsdWVcbiAgfSBlbHNlIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gdmFsdWVcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB9IGVsc2Ugb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9IHZhbHVlXG4gIH0gZWxzZSBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndmFsdWUgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignaW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdpbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0LCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOClcbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA4LCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICh0YXJnZXQsIHRhcmdldF9zdGFydCwgc3RhcnQsIGVuZCkge1xuICB2YXIgc2VsZiA9IHRoaXMgLy8gc291cmNlXG5cbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldF9zdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRfc3RhcnQgPSB0YXJnZXQubGVuZ3RoXG4gIGlmICghdGFyZ2V0X3N0YXJ0KSB0YXJnZXRfc3RhcnQgPSAwXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgc2VsZi5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0X3N0YXJ0IDwgMClcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gc2VsZi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKVxuICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0X3N0YXJ0IDwgZW5kIC0gc3RhcnQpXG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldF9zdGFydCArIHN0YXJ0XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XG5cbiAgaWYgKGxlbiA8IDEwMDAgfHwgIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRfc3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRhcmdldC5fc2V0KHRoaXMuc3ViYXJyYXkoc3RhcnQsIHN0YXJ0ICsgbGVuKSwgdGFyZ2V0X3N0YXJ0KVxuICB9XG5cbiAgcmV0dXJuIGxlblxufVxuXG4vLyBmaWxsKHZhbHVlLCBzdGFydD0wLCBlbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uICh2YWx1ZSwgc3RhcnQsIGVuZCkge1xuICBpZiAoIXZhbHVlKSB2YWx1ZSA9IDBcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kKSBlbmQgPSB0aGlzLmxlbmd0aFxuXG4gIGlmIChlbmQgPCBzdGFydCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2VuZCA8IHN0YXJ0JylcblxuICAvLyBGaWxsIDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVyblxuICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVyblxuXG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdzdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKGVuZCA8IDAgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdlbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICB0aGlzW2ldID0gdmFsdWVcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJ5dGVzID0gdXRmOFRvQnl0ZXModmFsdWUudG9TdHJpbmcoKSlcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgdGhpc1tpXSA9IGJ5dGVzW2kgJSBsZW5dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGBBcnJheUJ1ZmZlcmAgd2l0aCB0aGUgKmNvcGllZCogbWVtb3J5IG9mIHRoZSBidWZmZXIgaW5zdGFuY2UuXG4gKiBBZGRlZCBpbiBOb2RlIDAuMTIuIE9ubHkgYXZhaWxhYmxlIGluIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBBcnJheUJ1ZmZlci5cbiAqL1xuQnVmZmVyLnByb3RvdHlwZS50b0FycmF5QnVmZmVyID0gZnVuY3Rpb24gKCkge1xuICBpZiAodHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgICByZXR1cm4gKG5ldyBCdWZmZXIodGhpcykpLmJ1ZmZlclxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYnVmID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5sZW5ndGgpXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYnVmLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIGJ1ZltpXSA9IHRoaXNbaV1cbiAgICAgIH1cbiAgICAgIHJldHVybiBidWYuYnVmZmVyXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0J1ZmZlci50b0FycmF5QnVmZmVyIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyJylcbiAgfVxufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbnZhciBCUCA9IEJ1ZmZlci5wcm90b3R5cGVcblxuLyoqXG4gKiBBdWdtZW50IGEgVWludDhBcnJheSAqaW5zdGFuY2UqIChub3QgdGhlIFVpbnQ4QXJyYXkgY2xhc3MhKSB3aXRoIEJ1ZmZlciBtZXRob2RzXG4gKi9cbkJ1ZmZlci5fYXVnbWVudCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgYXJyLmNvbnN0cnVjdG9yID0gQnVmZmVyXG4gIGFyci5faXNCdWZmZXIgPSB0cnVlXG5cbiAgLy8gc2F2ZSByZWZlcmVuY2UgdG8gb3JpZ2luYWwgVWludDhBcnJheSBnZXQvc2V0IG1ldGhvZHMgYmVmb3JlIG92ZXJ3cml0aW5nXG4gIGFyci5fZ2V0ID0gYXJyLmdldFxuICBhcnIuX3NldCA9IGFyci5zZXRcblxuICAvLyBkZXByZWNhdGVkLCB3aWxsIGJlIHJlbW92ZWQgaW4gbm9kZSAwLjEzK1xuICBhcnIuZ2V0ID0gQlAuZ2V0XG4gIGFyci5zZXQgPSBCUC5zZXRcblxuICBhcnIud3JpdGUgPSBCUC53cml0ZVxuICBhcnIudG9TdHJpbmcgPSBCUC50b1N0cmluZ1xuICBhcnIudG9Mb2NhbGVTdHJpbmcgPSBCUC50b1N0cmluZ1xuICBhcnIudG9KU09OID0gQlAudG9KU09OXG4gIGFyci5lcXVhbHMgPSBCUC5lcXVhbHNcbiAgYXJyLmNvbXBhcmUgPSBCUC5jb21wYXJlXG4gIGFyci5jb3B5ID0gQlAuY29weVxuICBhcnIuc2xpY2UgPSBCUC5zbGljZVxuICBhcnIucmVhZFVJbnRMRSA9IEJQLnJlYWRVSW50TEVcbiAgYXJyLnJlYWRVSW50QkUgPSBCUC5yZWFkVUludEJFXG4gIGFyci5yZWFkVUludDggPSBCUC5yZWFkVUludDhcbiAgYXJyLnJlYWRVSW50MTZMRSA9IEJQLnJlYWRVSW50MTZMRVxuICBhcnIucmVhZFVJbnQxNkJFID0gQlAucmVhZFVJbnQxNkJFXG4gIGFyci5yZWFkVUludDMyTEUgPSBCUC5yZWFkVUludDMyTEVcbiAgYXJyLnJlYWRVSW50MzJCRSA9IEJQLnJlYWRVSW50MzJCRVxuICBhcnIucmVhZEludExFID0gQlAucmVhZEludExFXG4gIGFyci5yZWFkSW50QkUgPSBCUC5yZWFkSW50QkVcbiAgYXJyLnJlYWRJbnQ4ID0gQlAucmVhZEludDhcbiAgYXJyLnJlYWRJbnQxNkxFID0gQlAucmVhZEludDE2TEVcbiAgYXJyLnJlYWRJbnQxNkJFID0gQlAucmVhZEludDE2QkVcbiAgYXJyLnJlYWRJbnQzMkxFID0gQlAucmVhZEludDMyTEVcbiAgYXJyLnJlYWRJbnQzMkJFID0gQlAucmVhZEludDMyQkVcbiAgYXJyLnJlYWRGbG9hdExFID0gQlAucmVhZEZsb2F0TEVcbiAgYXJyLnJlYWRGbG9hdEJFID0gQlAucmVhZEZsb2F0QkVcbiAgYXJyLnJlYWREb3VibGVMRSA9IEJQLnJlYWREb3VibGVMRVxuICBhcnIucmVhZERvdWJsZUJFID0gQlAucmVhZERvdWJsZUJFXG4gIGFyci53cml0ZVVJbnQ4ID0gQlAud3JpdGVVSW50OFxuICBhcnIud3JpdGVVSW50TEUgPSBCUC53cml0ZVVJbnRMRVxuICBhcnIud3JpdGVVSW50QkUgPSBCUC53cml0ZVVJbnRCRVxuICBhcnIud3JpdGVVSW50MTZMRSA9IEJQLndyaXRlVUludDE2TEVcbiAgYXJyLndyaXRlVUludDE2QkUgPSBCUC53cml0ZVVJbnQxNkJFXG4gIGFyci53cml0ZVVJbnQzMkxFID0gQlAud3JpdGVVSW50MzJMRVxuICBhcnIud3JpdGVVSW50MzJCRSA9IEJQLndyaXRlVUludDMyQkVcbiAgYXJyLndyaXRlSW50TEUgPSBCUC53cml0ZUludExFXG4gIGFyci53cml0ZUludEJFID0gQlAud3JpdGVJbnRCRVxuICBhcnIud3JpdGVJbnQ4ID0gQlAud3JpdGVJbnQ4XG4gIGFyci53cml0ZUludDE2TEUgPSBCUC53cml0ZUludDE2TEVcbiAgYXJyLndyaXRlSW50MTZCRSA9IEJQLndyaXRlSW50MTZCRVxuICBhcnIud3JpdGVJbnQzMkxFID0gQlAud3JpdGVJbnQzMkxFXG4gIGFyci53cml0ZUludDMyQkUgPSBCUC53cml0ZUludDMyQkVcbiAgYXJyLndyaXRlRmxvYXRMRSA9IEJQLndyaXRlRmxvYXRMRVxuICBhcnIud3JpdGVGbG9hdEJFID0gQlAud3JpdGVGbG9hdEJFXG4gIGFyci53cml0ZURvdWJsZUxFID0gQlAud3JpdGVEb3VibGVMRVxuICBhcnIud3JpdGVEb3VibGVCRSA9IEJQLndyaXRlRG91YmxlQkVcbiAgYXJyLmZpbGwgPSBCUC5maWxsXG4gIGFyci5pbnNwZWN0ID0gQlAuaW5zcGVjdFxuICBhcnIudG9BcnJheUJ1ZmZlciA9IEJQLnRvQXJyYXlCdWZmZXJcblxuICByZXR1cm4gYXJyXG59XG5cbnZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXitcXC8wLTlBLXpcXC1dL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyaW5ndHJpbShzdHIpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHN0cmluZ3RyaW0gKHN0cikge1xuICBpZiAoc3RyLnRyaW0pIHJldHVybiBzdHIudHJpbSgpXG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpXG59XG5cbmZ1bmN0aW9uIGlzQXJyYXlpc2ggKHN1YmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXkoc3ViamVjdCkgfHwgQnVmZmVyLmlzQnVmZmVyKHN1YmplY3QpIHx8XG4gICAgICBzdWJqZWN0ICYmIHR5cGVvZiBzdWJqZWN0ID09PSAnb2JqZWN0JyAmJlxuICAgICAgdHlwZW9mIHN1YmplY3QubGVuZ3RoID09PSAnbnVtYmVyJ1xufVxuXG5mdW5jdGlvbiB0b0hleCAobikge1xuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNilcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHJpbmcsIHVuaXRzKSB7XG4gIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHlcbiAgdmFyIGNvZGVQb2ludFxuICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aFxuICB2YXIgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcbiAgdmFyIGJ5dGVzID0gW11cbiAgdmFyIGkgPSAwXG5cbiAgZm9yICg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpXG5cbiAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG4gICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcbiAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAobGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB2YWxpZCBzdXJyb2dhdGUgcGFpclxuICAgICAgICAgIGNvZGVQb2ludCA9IGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDAgfCAweDEwMDAwXG4gICAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbm8gbGVhZCB5ZXRcblxuICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG4gICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIC8vIHVucGFpcmVkIGxlYWRcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHZhbGlkIGxlYWRcbiAgICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICAgIH1cblxuICAgIC8vIGVuY29kZSB1dGY4XG4gICAgaWYgKGNvZGVQb2ludCA8IDB4ODApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMSkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQpXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2IHwgMHhDMCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyB8IDB4RTAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MjAwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDEyIHwgMHhGMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2RlIHBvaW50JylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnl0ZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0ciwgdW5pdHMpIHtcbiAgdmFyIGMsIGhpLCBsb1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcblxuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGhpID0gYyA+PiA4XG4gICAgbG8gPSBjICUgMjU2XG4gICAgYnl0ZUFycmF5LnB1c2gobG8pXG4gICAgYnl0ZUFycmF5LnB1c2goaGkpXG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKHN0cikpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKVxuICAgICAgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiBkZWNvZGVVdGY4Q2hhciAoc3RyKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChzdHIpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RkZGRCkgLy8gVVRGIDggaW52YWxpZCBjaGFyXG4gIH1cbn1cbiIsInZhciBsb29rdXAgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyc7XG5cbjsoZnVuY3Rpb24gKGV4cG9ydHMpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG4gIHZhciBBcnIgPSAodHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnKVxuICAgID8gVWludDhBcnJheVxuICAgIDogQXJyYXlcblxuXHR2YXIgUExVUyAgID0gJysnLmNoYXJDb2RlQXQoMClcblx0dmFyIFNMQVNIICA9ICcvJy5jaGFyQ29kZUF0KDApXG5cdHZhciBOVU1CRVIgPSAnMCcuY2hhckNvZGVBdCgwKVxuXHR2YXIgTE9XRVIgID0gJ2EnLmNoYXJDb2RlQXQoMClcblx0dmFyIFVQUEVSICA9ICdBJy5jaGFyQ29kZUF0KDApXG5cdHZhciBQTFVTX1VSTF9TQUZFID0gJy0nLmNoYXJDb2RlQXQoMClcblx0dmFyIFNMQVNIX1VSTF9TQUZFID0gJ18nLmNoYXJDb2RlQXQoMClcblxuXHRmdW5jdGlvbiBkZWNvZGUgKGVsdCkge1xuXHRcdHZhciBjb2RlID0gZWx0LmNoYXJDb2RlQXQoMClcblx0XHRpZiAoY29kZSA9PT0gUExVUyB8fFxuXHRcdCAgICBjb2RlID09PSBQTFVTX1VSTF9TQUZFKVxuXHRcdFx0cmV0dXJuIDYyIC8vICcrJ1xuXHRcdGlmIChjb2RlID09PSBTTEFTSCB8fFxuXHRcdCAgICBjb2RlID09PSBTTEFTSF9VUkxfU0FGRSlcblx0XHRcdHJldHVybiA2MyAvLyAnLydcblx0XHRpZiAoY29kZSA8IE5VTUJFUilcblx0XHRcdHJldHVybiAtMSAvL25vIG1hdGNoXG5cdFx0aWYgKGNvZGUgPCBOVU1CRVIgKyAxMClcblx0XHRcdHJldHVybiBjb2RlIC0gTlVNQkVSICsgMjYgKyAyNlxuXHRcdGlmIChjb2RlIDwgVVBQRVIgKyAyNilcblx0XHRcdHJldHVybiBjb2RlIC0gVVBQRVJcblx0XHRpZiAoY29kZSA8IExPV0VSICsgMjYpXG5cdFx0XHRyZXR1cm4gY29kZSAtIExPV0VSICsgMjZcblx0fVxuXG5cdGZ1bmN0aW9uIGI2NFRvQnl0ZUFycmF5IChiNjQpIHtcblx0XHR2YXIgaSwgaiwgbCwgdG1wLCBwbGFjZUhvbGRlcnMsIGFyclxuXG5cdFx0aWYgKGI2NC5sZW5ndGggJSA0ID4gMCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0Jylcblx0XHR9XG5cblx0XHQvLyB0aGUgbnVtYmVyIG9mIGVxdWFsIHNpZ25zIChwbGFjZSBob2xkZXJzKVxuXHRcdC8vIGlmIHRoZXJlIGFyZSB0d28gcGxhY2Vob2xkZXJzLCB0aGFuIHRoZSB0d28gY2hhcmFjdGVycyBiZWZvcmUgaXRcblx0XHQvLyByZXByZXNlbnQgb25lIGJ5dGVcblx0XHQvLyBpZiB0aGVyZSBpcyBvbmx5IG9uZSwgdGhlbiB0aGUgdGhyZWUgY2hhcmFjdGVycyBiZWZvcmUgaXQgcmVwcmVzZW50IDIgYnl0ZXNcblx0XHQvLyB0aGlzIGlzIGp1c3QgYSBjaGVhcCBoYWNrIHRvIG5vdCBkbyBpbmRleE9mIHR3aWNlXG5cdFx0dmFyIGxlbiA9IGI2NC5sZW5ndGhcblx0XHRwbGFjZUhvbGRlcnMgPSAnPScgPT09IGI2NC5jaGFyQXQobGVuIC0gMikgPyAyIDogJz0nID09PSBiNjQuY2hhckF0KGxlbiAtIDEpID8gMSA6IDBcblxuXHRcdC8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuXHRcdGFyciA9IG5ldyBBcnIoYjY0Lmxlbmd0aCAqIDMgLyA0IC0gcGxhY2VIb2xkZXJzKVxuXG5cdFx0Ly8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuXHRcdGwgPSBwbGFjZUhvbGRlcnMgPiAwID8gYjY0Lmxlbmd0aCAtIDQgOiBiNjQubGVuZ3RoXG5cblx0XHR2YXIgTCA9IDBcblxuXHRcdGZ1bmN0aW9uIHB1c2ggKHYpIHtcblx0XHRcdGFycltMKytdID0gdlxuXHRcdH1cblxuXHRcdGZvciAoaSA9IDAsIGogPSAwOyBpIDwgbDsgaSArPSA0LCBqICs9IDMpIHtcblx0XHRcdHRtcCA9IChkZWNvZGUoYjY0LmNoYXJBdChpKSkgPDwgMTgpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAxKSkgPDwgMTIpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAyKSkgPDwgNikgfCBkZWNvZGUoYjY0LmNoYXJBdChpICsgMykpXG5cdFx0XHRwdXNoKCh0bXAgJiAweEZGMDAwMCkgPj4gMTYpXG5cdFx0XHRwdXNoKCh0bXAgJiAweEZGMDApID4+IDgpXG5cdFx0XHRwdXNoKHRtcCAmIDB4RkYpXG5cdFx0fVxuXG5cdFx0aWYgKHBsYWNlSG9sZGVycyA9PT0gMikge1xuXHRcdFx0dG1wID0gKGRlY29kZShiNjQuY2hhckF0KGkpKSA8PCAyKSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMSkpID4+IDQpXG5cdFx0XHRwdXNoKHRtcCAmIDB4RkYpXG5cdFx0fSBlbHNlIGlmIChwbGFjZUhvbGRlcnMgPT09IDEpIHtcblx0XHRcdHRtcCA9IChkZWNvZGUoYjY0LmNoYXJBdChpKSkgPDwgMTApIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAxKSkgPDwgNCkgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDIpKSA+PiAyKVxuXHRcdFx0cHVzaCgodG1wID4+IDgpICYgMHhGRilcblx0XHRcdHB1c2godG1wICYgMHhGRilcblx0XHR9XG5cblx0XHRyZXR1cm4gYXJyXG5cdH1cblxuXHRmdW5jdGlvbiB1aW50OFRvQmFzZTY0ICh1aW50OCkge1xuXHRcdHZhciBpLFxuXHRcdFx0ZXh0cmFCeXRlcyA9IHVpbnQ4Lmxlbmd0aCAlIDMsIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG5cdFx0XHRvdXRwdXQgPSBcIlwiLFxuXHRcdFx0dGVtcCwgbGVuZ3RoXG5cblx0XHRmdW5jdGlvbiBlbmNvZGUgKG51bSkge1xuXHRcdFx0cmV0dXJuIGxvb2t1cC5jaGFyQXQobnVtKVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG5cdFx0XHRyZXR1cm4gZW5jb2RlKG51bSA+PiAxOCAmIDB4M0YpICsgZW5jb2RlKG51bSA+PiAxMiAmIDB4M0YpICsgZW5jb2RlKG51bSA+PiA2ICYgMHgzRikgKyBlbmNvZGUobnVtICYgMHgzRilcblx0XHR9XG5cblx0XHQvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG5cdFx0Zm9yIChpID0gMCwgbGVuZ3RoID0gdWludDgubGVuZ3RoIC0gZXh0cmFCeXRlczsgaSA8IGxlbmd0aDsgaSArPSAzKSB7XG5cdFx0XHR0ZW1wID0gKHVpbnQ4W2ldIDw8IDE2KSArICh1aW50OFtpICsgMV0gPDwgOCkgKyAodWludDhbaSArIDJdKVxuXHRcdFx0b3V0cHV0ICs9IHRyaXBsZXRUb0Jhc2U2NCh0ZW1wKVxuXHRcdH1cblxuXHRcdC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcblx0XHRzd2l0Y2ggKGV4dHJhQnl0ZXMpIHtcblx0XHRcdGNhc2UgMTpcblx0XHRcdFx0dGVtcCA9IHVpbnQ4W3VpbnQ4Lmxlbmd0aCAtIDFdXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUodGVtcCA+PiAyKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKCh0ZW1wIDw8IDQpICYgMHgzRilcblx0XHRcdFx0b3V0cHV0ICs9ICc9PSdcblx0XHRcdFx0YnJlYWtcblx0XHRcdGNhc2UgMjpcblx0XHRcdFx0dGVtcCA9ICh1aW50OFt1aW50OC5sZW5ndGggLSAyXSA8PCA4KSArICh1aW50OFt1aW50OC5sZW5ndGggLSAxXSlcblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSh0ZW1wID4+IDEwKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKCh0ZW1wID4+IDQpICYgMHgzRilcblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSgodGVtcCA8PCAyKSAmIDB4M0YpXG5cdFx0XHRcdG91dHB1dCArPSAnPSdcblx0XHRcdFx0YnJlYWtcblx0XHR9XG5cblx0XHRyZXR1cm4gb3V0cHV0XG5cdH1cblxuXHRleHBvcnRzLnRvQnl0ZUFycmF5ID0gYjY0VG9CeXRlQXJyYXlcblx0ZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gdWludDhUb0Jhc2U2NFxufSh0eXBlb2YgZXhwb3J0cyA9PT0gJ3VuZGVmaW5lZCcgPyAodGhpcy5iYXNlNjRqcyA9IHt9KSA6IGV4cG9ydHMpKVxuIiwiZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24oYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSxcbiAgICAgIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDEsXG4gICAgICBlTWF4ID0gKDEgPDwgZUxlbikgLSAxLFxuICAgICAgZUJpYXMgPSBlTWF4ID4+IDEsXG4gICAgICBuQml0cyA9IC03LFxuICAgICAgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwLFxuICAgICAgZCA9IGlzTEUgPyAtMSA6IDEsXG4gICAgICBzID0gYnVmZmVyW29mZnNldCArIGldO1xuXG4gIGkgKz0gZDtcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKTtcbiAgcyA+Pj0gKC1uQml0cyk7XG4gIG5CaXRzICs9IGVMZW47XG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpO1xuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpO1xuICBlID4+PSAoLW5CaXRzKTtcbiAgbkJpdHMgKz0gbUxlbjtcbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IG0gKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCk7XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzO1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSk7XG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKTtcbiAgICBlID0gZSAtIGVCaWFzO1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pO1xufTtcblxuZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjLFxuICAgICAgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMSxcbiAgICAgIGVNYXggPSAoMSA8PCBlTGVuKSAtIDEsXG4gICAgICBlQmlhcyA9IGVNYXggPj4gMSxcbiAgICAgIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKSxcbiAgICAgIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKSxcbiAgICAgIGQgPSBpc0xFID8gMSA6IC0xLFxuICAgICAgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMDtcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKTtcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMDtcbiAgICBlID0gZU1heDtcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMik7XG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tO1xuICAgICAgYyAqPSAyO1xuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gYztcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrKztcbiAgICAgIGMgLz0gMjtcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwO1xuICAgICAgZSA9IGVNYXg7XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICh2YWx1ZSAqIGMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pO1xuICAgICAgZSA9IGUgKyBlQmlhcztcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pO1xuICAgICAgZSA9IDA7XG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCk7XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbTtcbiAgZUxlbiArPSBtTGVuO1xuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpO1xuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyODtcbn07XG4iLCJcbi8qKlxuICogaXNBcnJheVxuICovXG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxuLyoqXG4gKiB0b1N0cmluZ1xuICovXG5cbnZhciBzdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKipcbiAqIFdoZXRoZXIgb3Igbm90IHRoZSBnaXZlbiBgdmFsYFxuICogaXMgYW4gYXJyYXkuXG4gKlxuICogZXhhbXBsZTpcbiAqXG4gKiAgICAgICAgaXNBcnJheShbXSk7XG4gKiAgICAgICAgLy8gPiB0cnVlXG4gKiAgICAgICAgaXNBcnJheShhcmd1bWVudHMpO1xuICogICAgICAgIC8vID4gZmFsc2VcbiAqICAgICAgICBpc0FycmF5KCcnKTtcbiAqICAgICAgICAvLyA+IGZhbHNlXG4gKlxuICogQHBhcmFtIHttaXhlZH0gdmFsXG4gKiBAcmV0dXJuIHtib29sfVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcnJheSB8fCBmdW5jdGlvbiAodmFsKSB7XG4gIHJldHVybiAhISB2YWwgJiYgJ1tvYmplY3QgQXJyYXldJyA9PSBzdHIuY2FsbCh2YWwpO1xufTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cyB8fCB7fTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn1cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxuRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24obikge1xuICBpZiAoIWlzTnVtYmVyKG4pIHx8IG4gPCAwIHx8IGlzTmFOKG4pKVxuICAgIHRocm93IFR5cGVFcnJvcignbiBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJyk7XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgZXIsIGhhbmRsZXIsIGxlbiwgYXJncywgaSwgbGlzdGVuZXJzO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKHR5cGUgPT09ICdlcnJvcicpIHtcbiAgICBpZiAoIXRoaXMuX2V2ZW50cy5lcnJvciB8fFxuICAgICAgICAoaXNPYmplY3QodGhpcy5fZXZlbnRzLmVycm9yKSAmJiAhdGhpcy5fZXZlbnRzLmVycm9yLmxlbmd0aCkpIHtcbiAgICAgIGVyID0gYXJndW1lbnRzWzFdO1xuICAgICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgICB9XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ1VuY2F1Z2h0LCB1bnNwZWNpZmllZCBcImVycm9yXCIgZXZlbnQuJyk7XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNVbmRlZmluZWQoaGFuZGxlcikpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGhhbmRsZXIpKSB7XG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAvLyBmYXN0IGNhc2VzXG4gICAgICBjYXNlIDE6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBzbG93ZXJcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0gMSk7XG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCBsZW47IGkrKylcbiAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgaGFuZGxlci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QoaGFuZGxlcikpIHtcbiAgICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0gMSk7XG4gICAgZm9yIChpID0gMTsgaSA8IGxlbjsgaSsrKVxuICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG5cbiAgICBsaXN0ZW5lcnMgPSBoYW5kbGVyLnNsaWNlKCk7XG4gICAgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICBsaXN0ZW5lcnNbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgbTtcblxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcbiAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICBpZiAodGhpcy5fZXZlbnRzLm5ld0xpc3RlbmVyKVxuICAgIHRoaXMuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxuICAgICAgICAgICAgICBpc0Z1bmN0aW9uKGxpc3RlbmVyLmxpc3RlbmVyKSA/XG4gICAgICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICBlbHNlIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pKVxuICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0ucHVzaChsaXN0ZW5lcik7XG4gIGVsc2VcbiAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBbdGhpcy5fZXZlbnRzW3R5cGVdLCBsaXN0ZW5lcl07XG5cbiAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkgJiYgIXRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQpIHtcbiAgICB2YXIgbTtcbiAgICBpZiAoIWlzVW5kZWZpbmVkKHRoaXMuX21heExpc3RlbmVycykpIHtcbiAgICAgIG0gPSB0aGlzLl9tYXhMaXN0ZW5lcnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgICB9XG5cbiAgICBpZiAobSAmJiBtID4gMCAmJiB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoID4gbSkge1xuICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCA9IHRydWU7XG4gICAgICBjb25zb2xlLmVycm9yKCcobm9kZSkgd2FybmluZzogcG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2xlYWsgZGV0ZWN0ZWQuICVkIGxpc3RlbmVycyBhZGRlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICdVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byBpbmNyZWFzZSBsaW1pdC4nLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoKTtcbiAgICAgIGlmICh0eXBlb2YgY29uc29sZS50cmFjZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBub3Qgc3VwcG9ydGVkIGluIElFIDEwXG4gICAgICAgIGNvbnNvbGUudHJhY2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgdmFyIGZpcmVkID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gZygpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGcpO1xuXG4gICAgaWYgKCFmaXJlZCkge1xuICAgICAgZmlyZWQgPSB0cnVlO1xuICAgICAgbGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cblxuICBnLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gIHRoaXMub24odHlwZSwgZyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBlbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWZmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBsaXN0LCBwb3NpdGlvbiwgbGVuZ3RoLCBpO1xuXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIGxpc3QgPSB0aGlzLl9ldmVudHNbdHlwZV07XG4gIGxlbmd0aCA9IGxpc3QubGVuZ3RoO1xuICBwb3NpdGlvbiA9IC0xO1xuXG4gIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fFxuICAgICAgKGlzRnVuY3Rpb24obGlzdC5saXN0ZW5lcikgJiYgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcblxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGxpc3QpKSB7XG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gPiAwOykge1xuICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8XG4gICAgICAgICAgKGxpc3RbaV0ubGlzdGVuZXIgJiYgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBvc2l0aW9uIDwgMClcbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKSB7XG4gICAgICBsaXN0Lmxlbmd0aCA9IDA7XG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaXN0LnNwbGljZShwb3NpdGlvbiwgMSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIga2V5LCBsaXN0ZW5lcnM7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxuICBpZiAoIXRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxuICAgICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgZWxzZSBpZiAodGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIGZvciAoa2V5IGluIHRoaXMuX2V2ZW50cykge1xuICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgIH1cbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNGdW5jdGlvbihsaXN0ZW5lcnMpKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICB9IGVsc2Uge1xuICAgIC8vIExJRk8gb3JkZXJcbiAgICB3aGlsZSAobGlzdGVuZXJzLmxlbmd0aClcbiAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2xpc3RlbmVycy5sZW5ndGggLSAxXSk7XG4gIH1cbiAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgcmV0O1xuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIHJldCA9IFtdO1xuICBlbHNlIGlmIChpc0Z1bmN0aW9uKHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgcmV0ID0gW3RoaXMuX2V2ZW50c1t0eXBlXV07XG4gIGVsc2VcbiAgICByZXQgPSB0aGlzLl9ldmVudHNbdHlwZV0uc2xpY2UoKTtcbiAgcmV0dXJuIHJldDtcbn07XG5cbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICB2YXIgcmV0O1xuICBpZiAoIWVtaXR0ZXIuX2V2ZW50cyB8fCAhZW1pdHRlci5fZXZlbnRzW3R5cGVdKVxuICAgIHJldCA9IDA7XG4gIGVsc2UgaWYgKGlzRnVuY3Rpb24oZW1pdHRlci5fZXZlbnRzW3R5cGVdKSlcbiAgICByZXQgPSAxO1xuICBlbHNlXG4gICAgcmV0ID0gZW1pdHRlci5fZXZlbnRzW3R5cGVdLmxlbmd0aDtcbiAgcmV0dXJuIHJldDtcbn07XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbiIsImlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcbiAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICB9O1xufSBlbHNlIHtcbiAgLy8gb2xkIHNjaG9vbCBzaGltIGZvciBvbGQgYnJvd3NlcnNcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9XG4gICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZVxuICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKClcbiAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3JcbiAgfVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG5cbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuICAgIHZhciBjdXJyZW50UXVldWU7XG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHZhciBpID0gLTE7XG4gICAgICAgIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtpXSgpO1xuICAgICAgICB9XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbn1cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgcXVldWUucHVzaChmdW4pO1xuICAgIGlmICghZHJhaW5pbmcpIHtcbiAgICAgICAgc2V0VGltZW91dChkcmFpblF1ZXVlLCAwKTtcbiAgICB9XG59O1xuXG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxuLy8gVE9ETyhzaHR5bG1hbilcbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vbGliL19zdHJlYW1fZHVwbGV4LmpzXCIpXG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gYSBkdXBsZXggc3RyZWFtIGlzIGp1c3QgYSBzdHJlYW0gdGhhdCBpcyBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZS5cbi8vIFNpbmNlIEpTIGRvZXNuJ3QgaGF2ZSBtdWx0aXBsZSBwcm90b3R5cGFsIGluaGVyaXRhbmNlLCB0aGlzIGNsYXNzXG4vLyBwcm90b3R5cGFsbHkgaW5oZXJpdHMgZnJvbSBSZWFkYWJsZSwgYW5kIHRoZW4gcGFyYXNpdGljYWxseSBmcm9tXG4vLyBXcml0YWJsZS5cblxubW9kdWxlLmV4cG9ydHMgPSBEdXBsZXg7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIGtleXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikga2V5cy5wdXNoKGtleSk7XG4gIHJldHVybiBrZXlzO1xufVxuLyo8L3JlcGxhY2VtZW50PiovXG5cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgUmVhZGFibGUgPSByZXF1aXJlKCcuL19zdHJlYW1fcmVhZGFibGUnKTtcbnZhciBXcml0YWJsZSA9IHJlcXVpcmUoJy4vX3N0cmVhbV93cml0YWJsZScpO1xuXG51dGlsLmluaGVyaXRzKER1cGxleCwgUmVhZGFibGUpO1xuXG5mb3JFYWNoKG9iamVjdEtleXMoV3JpdGFibGUucHJvdG90eXBlKSwgZnVuY3Rpb24obWV0aG9kKSB7XG4gIGlmICghRHVwbGV4LnByb3RvdHlwZVttZXRob2RdKVxuICAgIER1cGxleC5wcm90b3R5cGVbbWV0aG9kXSA9IFdyaXRhYmxlLnByb3RvdHlwZVttZXRob2RdO1xufSk7XG5cbmZ1bmN0aW9uIER1cGxleChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKVxuICAgIHJldHVybiBuZXcgRHVwbGV4KG9wdGlvbnMpO1xuXG4gIFJlYWRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIFdyaXRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5yZWFkYWJsZSA9PT0gZmFsc2UpXG4gICAgdGhpcy5yZWFkYWJsZSA9IGZhbHNlO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMud3JpdGFibGUgPT09IGZhbHNlKVxuICAgIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcblxuICB0aGlzLmFsbG93SGFsZk9wZW4gPSB0cnVlO1xuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmFsbG93SGFsZk9wZW4gPT09IGZhbHNlKVxuICAgIHRoaXMuYWxsb3dIYWxmT3BlbiA9IGZhbHNlO1xuXG4gIHRoaXMub25jZSgnZW5kJywgb25lbmQpO1xufVxuXG4vLyB0aGUgbm8taGFsZi1vcGVuIGVuZm9yY2VyXG5mdW5jdGlvbiBvbmVuZCgpIHtcbiAgLy8gaWYgd2UgYWxsb3cgaGFsZi1vcGVuIHN0YXRlLCBvciBpZiB0aGUgd3JpdGFibGUgc2lkZSBlbmRlZCxcbiAgLy8gdGhlbiB3ZSdyZSBvay5cbiAgaWYgKHRoaXMuYWxsb3dIYWxmT3BlbiB8fCB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkKVxuICAgIHJldHVybjtcblxuICAvLyBubyBtb3JlIGRhdGEgY2FuIGJlIHdyaXR0ZW4uXG4gIC8vIEJ1dCBhbGxvdyBtb3JlIHdyaXRlcyB0byBoYXBwZW4gaW4gdGhpcyB0aWNrLlxuICBwcm9jZXNzLm5leHRUaWNrKHRoaXMuZW5kLmJpbmQodGhpcykpO1xufVxuXG5mdW5jdGlvbiBmb3JFYWNoICh4cywgZikge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGYoeHNbaV0sIGkpO1xuICB9XG59XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gYSBwYXNzdGhyb3VnaCBzdHJlYW0uXG4vLyBiYXNpY2FsbHkganVzdCB0aGUgbW9zdCBtaW5pbWFsIHNvcnQgb2YgVHJhbnNmb3JtIHN0cmVhbS5cbi8vIEV2ZXJ5IHdyaXR0ZW4gY2h1bmsgZ2V0cyBvdXRwdXQgYXMtaXMuXG5cbm1vZHVsZS5leHBvcnRzID0gUGFzc1Rocm91Z2g7XG5cbnZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL19zdHJlYW1fdHJhbnNmb3JtJyk7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudXRpbC5pbmhlcml0cyhQYXNzVGhyb3VnaCwgVHJhbnNmb3JtKTtcblxuZnVuY3Rpb24gUGFzc1Rocm91Z2gob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUGFzc1Rocm91Z2gpKVxuICAgIHJldHVybiBuZXcgUGFzc1Rocm91Z2gob3B0aW9ucyk7XG5cbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgb3B0aW9ucyk7XG59XG5cblBhc3NUaHJvdWdoLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjYihudWxsLCBjaHVuayk7XG59O1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbm1vZHVsZS5leHBvcnRzID0gUmVhZGFibGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cblJlYWRhYmxlLlJlYWRhYmxlU3RhdGUgPSBSZWFkYWJsZVN0YXRlO1xuXG52YXIgRUUgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5pZiAoIUVFLmxpc3RlbmVyQ291bnQpIEVFLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIHJldHVybiBlbWl0dGVyLmxpc3RlbmVycyh0eXBlKS5sZW5ndGg7XG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgU3RyaW5nRGVjb2RlcjtcblxuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGRlYnVnID0gcmVxdWlyZSgndXRpbCcpO1xuaWYgKGRlYnVnICYmIGRlYnVnLmRlYnVnbG9nKSB7XG4gIGRlYnVnID0gZGVidWcuZGVidWdsb2coJ3N0cmVhbScpO1xufSBlbHNlIHtcbiAgZGVidWcgPSBmdW5jdGlvbiAoKSB7fTtcbn1cbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5cbnV0aWwuaW5oZXJpdHMoUmVhZGFibGUsIFN0cmVhbSk7XG5cbmZ1bmN0aW9uIFJlYWRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtKSB7XG4gIHZhciBEdXBsZXggPSByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gdGhlIHBvaW50IGF0IHdoaWNoIGl0IHN0b3BzIGNhbGxpbmcgX3JlYWQoKSB0byBmaWxsIHRoZSBidWZmZXJcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyBcImRvbid0IGNhbGwgX3JlYWQgcHJlZW1wdGl2ZWx5IGV2ZXJcIlxuICB2YXIgaHdtID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrO1xuICB2YXIgZGVmYXVsdEh3bSA9IG9wdGlvbnMub2JqZWN0TW9kZSA/IDE2IDogMTYgKiAxMDI0O1xuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSAoaHdtIHx8IGh3bSA9PT0gMCkgPyBod20gOiBkZWZhdWx0SHdtO1xuXG4gIC8vIGNhc3QgdG8gaW50cy5cbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gfn50aGlzLmhpZ2hXYXRlck1hcms7XG5cbiAgdGhpcy5idWZmZXIgPSBbXTtcbiAgdGhpcy5sZW5ndGggPSAwO1xuICB0aGlzLnBpcGVzID0gbnVsbDtcbiAgdGhpcy5waXBlc0NvdW50ID0gMDtcbiAgdGhpcy5mbG93aW5nID0gbnVsbDtcbiAgdGhpcy5lbmRlZCA9IGZhbHNlO1xuICB0aGlzLmVuZEVtaXR0ZWQgPSBmYWxzZTtcbiAgdGhpcy5yZWFkaW5nID0gZmFsc2U7XG5cbiAgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgb253cml0ZSBjYiBpcyBjYWxsZWQgaW1tZWRpYXRlbHksXG4gIC8vIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2UgYW55XG4gIC8vIGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHdyaXRlIGNhbGwuXG4gIHRoaXMuc3luYyA9IHRydWU7XG5cbiAgLy8gd2hlbmV2ZXIgd2UgcmV0dXJuIG51bGwsIHRoZW4gd2Ugc2V0IGEgZmxhZyB0byBzYXlcbiAgLy8gdGhhdCB3ZSdyZSBhd2FpdGluZyBhICdyZWFkYWJsZScgZXZlbnQgZW1pc3Npb24uXG4gIHRoaXMubmVlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMucmVhZGFibGVMaXN0ZW5pbmcgPSBmYWxzZTtcblxuXG4gIC8vIG9iamVjdCBzdHJlYW0gZmxhZy4gVXNlZCB0byBtYWtlIHJlYWQobikgaWdub3JlIG4gYW5kIHRvXG4gIC8vIG1ha2UgYWxsIHRoZSBidWZmZXIgbWVyZ2luZyBhbmQgbGVuZ3RoIGNoZWNrcyBnbyBhd2F5XG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuXG4gIGlmIChzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXgpXG4gICAgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy5yZWFkYWJsZU9iamVjdE1vZGU7XG5cbiAgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7XG5cbiAgLy8gd2hlbiBwaXBpbmcsIHdlIG9ubHkgY2FyZSBhYm91dCAncmVhZGFibGUnIGV2ZW50cyB0aGF0IGhhcHBlblxuICAvLyBhZnRlciByZWFkKClpbmcgYWxsIHRoZSBieXRlcyBhbmQgbm90IGdldHRpbmcgYW55IHB1c2hiYWNrLlxuICB0aGlzLnJhbk91dCA9IGZhbHNlO1xuXG4gIC8vIHRoZSBudW1iZXIgb2Ygd3JpdGVycyB0aGF0IGFyZSBhd2FpdGluZyBhIGRyYWluIGV2ZW50IGluIC5waXBlKClzXG4gIHRoaXMuYXdhaXREcmFpbiA9IDA7XG5cbiAgLy8gaWYgdHJ1ZSwgYSBtYXliZVJlYWRNb3JlIGhhcyBiZWVuIHNjaGVkdWxlZFxuICB0aGlzLnJlYWRpbmdNb3JlID0gZmFsc2U7XG5cbiAgdGhpcy5kZWNvZGVyID0gbnVsbDtcbiAgdGhpcy5lbmNvZGluZyA9IG51bGw7XG4gIGlmIChvcHRpb25zLmVuY29kaW5nKSB7XG4gICAgaWYgKCFTdHJpbmdEZWNvZGVyKVxuICAgICAgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gICAgdGhpcy5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIob3B0aW9ucy5lbmNvZGluZyk7XG4gICAgdGhpcy5lbmNvZGluZyA9IG9wdGlvbnMuZW5jb2Rpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gUmVhZGFibGUob3B0aW9ucykge1xuICB2YXIgRHVwbGV4ID0gcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZWFkYWJsZSkpXG4gICAgcmV0dXJuIG5ldyBSZWFkYWJsZShvcHRpb25zKTtcblxuICB0aGlzLl9yZWFkYWJsZVN0YXRlID0gbmV3IFJlYWRhYmxlU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gbGVnYWN5XG4gIHRoaXMucmVhZGFibGUgPSB0cnVlO1xuXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xufVxuXG4vLyBNYW51YWxseSBzaG92ZSBzb21ldGhpbmcgaW50byB0aGUgcmVhZCgpIGJ1ZmZlci5cbi8vIFRoaXMgcmV0dXJucyB0cnVlIGlmIHRoZSBoaWdoV2F0ZXJNYXJrIGhhcyBub3QgYmVlbiBoaXQgeWV0LFxuLy8gc2ltaWxhciB0byBob3cgV3JpdGFibGUud3JpdGUoKSByZXR1cm5zIHRydWUgaWYgeW91IHNob3VsZFxuLy8gd3JpdGUoKSBzb21lIG1vcmUuXG5SZWFkYWJsZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZykge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIGlmICh1dGlsLmlzU3RyaW5nKGNodW5rKSAmJiAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGVuY29kaW5nID0gZW5jb2RpbmcgfHwgc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuICAgIGlmIChlbmNvZGluZyAhPT0gc3RhdGUuZW5jb2RpbmcpIHtcbiAgICAgIGNodW5rID0gbmV3IEJ1ZmZlcihjaHVuaywgZW5jb2RpbmcpO1xuICAgICAgZW5jb2RpbmcgPSAnJztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBmYWxzZSk7XG59O1xuXG4vLyBVbnNoaWZ0IHNob3VsZCAqYWx3YXlzKiBiZSBzb21ldGhpbmcgZGlyZWN0bHkgb3V0IG9mIHJlYWQoKVxuUmVhZGFibGUucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbihjaHVuaykge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssICcnLCB0cnVlKTtcbn07XG5cbmZ1bmN0aW9uIHJlYWRhYmxlQWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBhZGRUb0Zyb250KSB7XG4gIHZhciBlciA9IGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspO1xuICBpZiAoZXIpIHtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gIH0gZWxzZSBpZiAodXRpbC5pc051bGxPclVuZGVmaW5lZChjaHVuaykpIHtcbiAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgaWYgKCFzdGF0ZS5lbmRlZClcbiAgICAgIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSk7XG4gIH0gZWxzZSBpZiAoc3RhdGUub2JqZWN0TW9kZSB8fCBjaHVuayAmJiBjaHVuay5sZW5ndGggPiAwKSB7XG4gICAgaWYgKHN0YXRlLmVuZGVkICYmICFhZGRUb0Zyb250KSB7XG4gICAgICB2YXIgZSA9IG5ldyBFcnJvcignc3RyZWFtLnB1c2goKSBhZnRlciBFT0YnKTtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGUpO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUuZW5kRW1pdHRlZCAmJiBhZGRUb0Zyb250KSB7XG4gICAgICB2YXIgZSA9IG5ldyBFcnJvcignc3RyZWFtLnVuc2hpZnQoKSBhZnRlciBlbmQgZXZlbnQnKTtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhYWRkVG9Gcm9udCAmJiAhZW5jb2RpbmcpXG4gICAgICAgIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XG5cbiAgICAgIGlmICghYWRkVG9Gcm9udClcbiAgICAgICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuXG4gICAgICAvLyBpZiB3ZSB3YW50IHRoZSBkYXRhIG5vdywganVzdCBlbWl0IGl0LlxuICAgICAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmICFzdGF0ZS5zeW5jKSB7XG4gICAgICAgIHN0cmVhbS5lbWl0KCdkYXRhJywgY2h1bmspO1xuICAgICAgICBzdHJlYW0ucmVhZCgwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgYnVmZmVyIGluZm8uXG4gICAgICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICAgICAgaWYgKGFkZFRvRnJvbnQpXG4gICAgICAgICAgc3RhdGUuYnVmZmVyLnVuc2hpZnQoY2h1bmspO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xuXG4gICAgICAgIGlmIChzdGF0ZS5uZWVkUmVhZGFibGUpXG4gICAgICAgICAgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG4gICAgICB9XG5cbiAgICAgIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKCFhZGRUb0Zyb250KSB7XG4gICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIG5lZWRNb3JlRGF0YShzdGF0ZSk7XG59XG5cblxuXG4vLyBpZiBpdCdzIHBhc3QgdGhlIGhpZ2ggd2F0ZXIgbWFyaywgd2UgY2FuIHB1c2ggaW4gc29tZSBtb3JlLlxuLy8gQWxzbywgaWYgd2UgaGF2ZSBubyBkYXRhIHlldCwgd2UgY2FuIHN0YW5kIHNvbWVcbi8vIG1vcmUgYnl0ZXMuICBUaGlzIGlzIHRvIHdvcmsgYXJvdW5kIGNhc2VzIHdoZXJlIGh3bT0wLFxuLy8gc3VjaCBhcyB0aGUgcmVwbC4gIEFsc28sIGlmIHRoZSBwdXNoKCkgdHJpZ2dlcmVkIGFcbi8vIHJlYWRhYmxlIGV2ZW50LCBhbmQgdGhlIHVzZXIgY2FsbGVkIHJlYWQobGFyZ2VOdW1iZXIpIHN1Y2ggdGhhdFxuLy8gbmVlZFJlYWRhYmxlIHdhcyBzZXQsIHRoZW4gd2Ugb3VnaHQgdG8gcHVzaCBtb3JlLCBzbyB0aGF0IGFub3RoZXJcbi8vICdyZWFkYWJsZScgZXZlbnQgd2lsbCBiZSB0cmlnZ2VyZWQuXG5mdW5jdGlvbiBuZWVkTW9yZURhdGEoc3RhdGUpIHtcbiAgcmV0dXJuICFzdGF0ZS5lbmRlZCAmJlxuICAgICAgICAgKHN0YXRlLm5lZWRSZWFkYWJsZSB8fFxuICAgICAgICAgIHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHxcbiAgICAgICAgICBzdGF0ZS5sZW5ndGggPT09IDApO1xufVxuXG4vLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cblJlYWRhYmxlLnByb3RvdHlwZS5zZXRFbmNvZGluZyA9IGZ1bmN0aW9uKGVuYykge1xuICBpZiAoIVN0cmluZ0RlY29kZXIpXG4gICAgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKGVuYyk7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5jb2RpbmcgPSBlbmM7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gRG9uJ3QgcmFpc2UgdGhlIGh3bSA+IDEyOE1CXG52YXIgTUFYX0hXTSA9IDB4ODAwMDAwO1xuZnVuY3Rpb24gcm91bmRVcFRvTmV4dFBvd2VyT2YyKG4pIHtcbiAgaWYgKG4gPj0gTUFYX0hXTSkge1xuICAgIG4gPSBNQVhfSFdNO1xuICB9IGVsc2Uge1xuICAgIC8vIEdldCB0aGUgbmV4dCBoaWdoZXN0IHBvd2VyIG9mIDJcbiAgICBuLS07XG4gICAgZm9yICh2YXIgcCA9IDE7IHAgPCAzMjsgcCA8PD0gMSkgbiB8PSBuID4+IHA7XG4gICAgbisrO1xuICB9XG4gIHJldHVybiBuO1xufVxuXG5mdW5jdGlvbiBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpXG4gICAgcmV0dXJuIDA7XG5cbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpXG4gICAgcmV0dXJuIG4gPT09IDAgPyAwIDogMTtcblxuICBpZiAoaXNOYU4obikgfHwgdXRpbC5pc051bGwobikpIHtcbiAgICAvLyBvbmx5IGZsb3cgb25lIGJ1ZmZlciBhdCBhIHRpbWVcbiAgICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5idWZmZXIubGVuZ3RoKVxuICAgICAgcmV0dXJuIHN0YXRlLmJ1ZmZlclswXS5sZW5ndGg7XG4gICAgZWxzZVxuICAgICAgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbiAgfVxuXG4gIGlmIChuIDw9IDApXG4gICAgcmV0dXJuIDA7XG5cbiAgLy8gSWYgd2UncmUgYXNraW5nIGZvciBtb3JlIHRoYW4gdGhlIHRhcmdldCBidWZmZXIgbGV2ZWwsXG4gIC8vIHRoZW4gcmFpc2UgdGhlIHdhdGVyIG1hcmsuICBCdW1wIHVwIHRvIHRoZSBuZXh0IGhpZ2hlc3RcbiAgLy8gcG93ZXIgb2YgMiwgdG8gcHJldmVudCBpbmNyZWFzaW5nIGl0IGV4Y2Vzc2l2ZWx5IGluIHRpbnlcbiAgLy8gYW1vdW50cy5cbiAgaWYgKG4gPiBzdGF0ZS5oaWdoV2F0ZXJNYXJrKVxuICAgIHN0YXRlLmhpZ2hXYXRlck1hcmsgPSByb3VuZFVwVG9OZXh0UG93ZXJPZjIobik7XG5cbiAgLy8gZG9uJ3QgaGF2ZSB0aGF0IG11Y2guICByZXR1cm4gbnVsbCwgdW5sZXNzIHdlJ3ZlIGVuZGVkLlxuICBpZiAobiA+IHN0YXRlLmxlbmd0aCkge1xuICAgIGlmICghc3RhdGUuZW5kZWQpIHtcbiAgICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgICByZXR1cm4gMDtcbiAgICB9IGVsc2VcbiAgICAgIHJldHVybiBzdGF0ZS5sZW5ndGg7XG4gIH1cblxuICByZXR1cm4gbjtcbn1cblxuLy8geW91IGNhbiBvdmVycmlkZSBlaXRoZXIgdGhpcyBtZXRob2QsIG9yIHRoZSBhc3luYyBfcmVhZChuKSBiZWxvdy5cblJlYWRhYmxlLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24obikge1xuICBkZWJ1ZygncmVhZCcsIG4pO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgbk9yaWcgPSBuO1xuXG4gIGlmICghdXRpbC5pc051bWJlcihuKSB8fCBuID4gMClcbiAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcblxuICAvLyBpZiB3ZSdyZSBkb2luZyByZWFkKDApIHRvIHRyaWdnZXIgYSByZWFkYWJsZSBldmVudCwgYnV0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhIGJ1bmNoIG9mIGRhdGEgaW4gdGhlIGJ1ZmZlciwgdGhlbiBqdXN0IHRyaWdnZXJcbiAgLy8gdGhlICdyZWFkYWJsZScgZXZlbnQgYW5kIG1vdmUgb24uXG4gIGlmIChuID09PSAwICYmXG4gICAgICBzdGF0ZS5uZWVkUmVhZGFibGUgJiZcbiAgICAgIChzdGF0ZS5sZW5ndGggPj0gc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5lbmRlZCkpIHtcbiAgICBkZWJ1ZygncmVhZDogZW1pdFJlYWRhYmxlJywgc3RhdGUubGVuZ3RoLCBzdGF0ZS5lbmRlZCk7XG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZClcbiAgICAgIGVuZFJlYWRhYmxlKHRoaXMpO1xuICAgIGVsc2VcbiAgICAgIGVtaXRSZWFkYWJsZSh0aGlzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIG4gPSBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKTtcblxuICAvLyBpZiB3ZSd2ZSBlbmRlZCwgYW5kIHdlJ3JlIG5vdyBjbGVhciwgdGhlbiBmaW5pc2ggaXQgdXAuXG4gIGlmIChuID09PSAwICYmIHN0YXRlLmVuZGVkKSB7XG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMClcbiAgICAgIGVuZFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gQWxsIHRoZSBhY3R1YWwgY2h1bmsgZ2VuZXJhdGlvbiBsb2dpYyBuZWVkcyB0byBiZVxuICAvLyAqYmVsb3cqIHRoZSBjYWxsIHRvIF9yZWFkLiAgVGhlIHJlYXNvbiBpcyB0aGF0IGluIGNlcnRhaW5cbiAgLy8gc3ludGhldGljIHN0cmVhbSBjYXNlcywgc3VjaCBhcyBwYXNzdGhyb3VnaCBzdHJlYW1zLCBfcmVhZFxuICAvLyBtYXkgYmUgYSBjb21wbGV0ZWx5IHN5bmNocm9ub3VzIG9wZXJhdGlvbiB3aGljaCBtYXkgY2hhbmdlXG4gIC8vIHRoZSBzdGF0ZSBvZiB0aGUgcmVhZCBidWZmZXIsIHByb3ZpZGluZyBlbm91Z2ggZGF0YSB3aGVuXG4gIC8vIGJlZm9yZSB0aGVyZSB3YXMgKm5vdCogZW5vdWdoLlxuICAvL1xuICAvLyBTbywgdGhlIHN0ZXBzIGFyZTpcbiAgLy8gMS4gRmlndXJlIG91dCB3aGF0IHRoZSBzdGF0ZSBvZiB0aGluZ3Mgd2lsbCBiZSBhZnRlciB3ZSBkb1xuICAvLyBhIHJlYWQgZnJvbSB0aGUgYnVmZmVyLlxuICAvL1xuICAvLyAyLiBJZiB0aGF0IHJlc3VsdGluZyBzdGF0ZSB3aWxsIHRyaWdnZXIgYSBfcmVhZCwgdGhlbiBjYWxsIF9yZWFkLlxuICAvLyBOb3RlIHRoYXQgdGhpcyBtYXkgYmUgYXN5bmNocm9ub3VzLCBvciBzeW5jaHJvbm91cy4gIFllcywgaXQgaXNcbiAgLy8gZGVlcGx5IHVnbHkgdG8gd3JpdGUgQVBJcyB0aGlzIHdheSwgYnV0IHRoYXQgc3RpbGwgZG9lc24ndCBtZWFuXG4gIC8vIHRoYXQgdGhlIFJlYWRhYmxlIGNsYXNzIHNob3VsZCBiZWhhdmUgaW1wcm9wZXJseSwgYXMgc3RyZWFtcyBhcmVcbiAgLy8gZGVzaWduZWQgdG8gYmUgc3luYy9hc3luYyBhZ25vc3RpYy5cbiAgLy8gVGFrZSBub3RlIGlmIHRoZSBfcmVhZCBjYWxsIGlzIHN5bmMgb3IgYXN5bmMgKGllLCBpZiB0aGUgcmVhZCBjYWxsXG4gIC8vIGhhcyByZXR1cm5lZCB5ZXQpLCBzbyB0aGF0IHdlIGtub3cgd2hldGhlciBvciBub3QgaXQncyBzYWZlIHRvIGVtaXRcbiAgLy8gJ3JlYWRhYmxlJyBldGMuXG4gIC8vXG4gIC8vIDMuIEFjdHVhbGx5IHB1bGwgdGhlIHJlcXVlc3RlZCBjaHVua3Mgb3V0IG9mIHRoZSBidWZmZXIgYW5kIHJldHVybi5cblxuICAvLyBpZiB3ZSBuZWVkIGEgcmVhZGFibGUgZXZlbnQsIHRoZW4gd2UgbmVlZCB0byBkbyBzb21lIHJlYWRpbmcuXG4gIHZhciBkb1JlYWQgPSBzdGF0ZS5uZWVkUmVhZGFibGU7XG4gIGRlYnVnKCduZWVkIHJlYWRhYmxlJywgZG9SZWFkKTtcblxuICAvLyBpZiB3ZSBjdXJyZW50bHkgaGF2ZSBsZXNzIHRoYW4gdGhlIGhpZ2hXYXRlck1hcmssIHRoZW4gYWxzbyByZWFkIHNvbWVcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCB8fCBzdGF0ZS5sZW5ndGggLSBuIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykge1xuICAgIGRvUmVhZCA9IHRydWU7XG4gICAgZGVidWcoJ2xlbmd0aCBsZXNzIHRoYW4gd2F0ZXJtYXJrJywgZG9SZWFkKTtcbiAgfVxuXG4gIC8vIGhvd2V2ZXIsIGlmIHdlJ3ZlIGVuZGVkLCB0aGVuIHRoZXJlJ3Mgbm8gcG9pbnQsIGFuZCBpZiB3ZSdyZSBhbHJlYWR5XG4gIC8vIHJlYWRpbmcsIHRoZW4gaXQncyB1bm5lY2Vzc2FyeS5cbiAgaWYgKHN0YXRlLmVuZGVkIHx8IHN0YXRlLnJlYWRpbmcpIHtcbiAgICBkb1JlYWQgPSBmYWxzZTtcbiAgICBkZWJ1ZygncmVhZGluZyBvciBlbmRlZCcsIGRvUmVhZCk7XG4gIH1cblxuICBpZiAoZG9SZWFkKSB7XG4gICAgZGVidWcoJ2RvIHJlYWQnKTtcbiAgICBzdGF0ZS5yZWFkaW5nID0gdHJ1ZTtcbiAgICBzdGF0ZS5zeW5jID0gdHJ1ZTtcbiAgICAvLyBpZiB0aGUgbGVuZ3RoIGlzIGN1cnJlbnRseSB6ZXJvLCB0aGVuIHdlICpuZWVkKiBhIHJlYWRhYmxlIGV2ZW50LlxuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApXG4gICAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIC8vIGNhbGwgaW50ZXJuYWwgcmVhZCBtZXRob2RcbiAgICB0aGlzLl9yZWFkKHN0YXRlLmhpZ2hXYXRlck1hcmspO1xuICAgIHN0YXRlLnN5bmMgPSBmYWxzZTtcbiAgfVxuXG4gIC8vIElmIF9yZWFkIHB1c2hlZCBkYXRhIHN5bmNocm9ub3VzbHksIHRoZW4gYHJlYWRpbmdgIHdpbGwgYmUgZmFsc2UsXG4gIC8vIGFuZCB3ZSBuZWVkIHRvIHJlLWV2YWx1YXRlIGhvdyBtdWNoIGRhdGEgd2UgY2FuIHJldHVybiB0byB0aGUgdXNlci5cbiAgaWYgKGRvUmVhZCAmJiAhc3RhdGUucmVhZGluZylcbiAgICBuID0gaG93TXVjaFRvUmVhZChuT3JpZywgc3RhdGUpO1xuXG4gIHZhciByZXQ7XG4gIGlmIChuID4gMClcbiAgICByZXQgPSBmcm9tTGlzdChuLCBzdGF0ZSk7XG4gIGVsc2VcbiAgICByZXQgPSBudWxsO1xuXG4gIGlmICh1dGlsLmlzTnVsbChyZXQpKSB7XG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICBuID0gMDtcbiAgfVxuXG4gIHN0YXRlLmxlbmd0aCAtPSBuO1xuXG4gIC8vIElmIHdlIGhhdmUgbm90aGluZyBpbiB0aGUgYnVmZmVyLCB0aGVuIHdlIHdhbnQgdG8ga25vd1xuICAvLyBhcyBzb29uIGFzIHdlICpkbyogZ2V0IHNvbWV0aGluZyBpbnRvIHRoZSBidWZmZXIuXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgIXN0YXRlLmVuZGVkKVxuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG5cbiAgLy8gSWYgd2UgdHJpZWQgdG8gcmVhZCgpIHBhc3QgdGhlIEVPRiwgdGhlbiBlbWl0IGVuZCBvbiB0aGUgbmV4dCB0aWNrLlxuICBpZiAobk9yaWcgIT09IG4gJiYgc3RhdGUuZW5kZWQgJiYgc3RhdGUubGVuZ3RoID09PSAwKVxuICAgIGVuZFJlYWRhYmxlKHRoaXMpO1xuXG4gIGlmICghdXRpbC5pc051bGwocmV0KSlcbiAgICB0aGlzLmVtaXQoJ2RhdGEnLCByZXQpO1xuXG4gIHJldHVybiByZXQ7XG59O1xuXG5mdW5jdGlvbiBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKSB7XG4gIHZhciBlciA9IG51bGw7XG4gIGlmICghdXRpbC5pc0J1ZmZlcihjaHVuaykgJiZcbiAgICAgICF1dGlsLmlzU3RyaW5nKGNodW5rKSAmJlxuICAgICAgIXV0aWwuaXNOdWxsT3JVbmRlZmluZWQoY2h1bmspICYmXG4gICAgICAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGVyID0gbmV3IFR5cGVFcnJvcignSW52YWxpZCBub24tc3RyaW5nL2J1ZmZlciBjaHVuaycpO1xuICB9XG4gIHJldHVybiBlcjtcbn1cblxuXG5mdW5jdGlvbiBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIXN0YXRlLmVuZGVkKSB7XG4gICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcbiAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSB7XG4gICAgICBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG4gICAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgfVxuICB9XG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcblxuICAvLyBlbWl0ICdyZWFkYWJsZScgbm93IHRvIG1ha2Ugc3VyZSBpdCBnZXRzIHBpY2tlZCB1cC5cbiAgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG59XG5cbi8vIERvbid0IGVtaXQgcmVhZGFibGUgcmlnaHQgYXdheSBpbiBzeW5jIG1vZGUsIGJlY2F1c2UgdGhpcyBjYW4gdHJpZ2dlclxuLy8gYW5vdGhlciByZWFkKCkgY2FsbCA9PiBzdGFjayBvdmVyZmxvdy4gIFRoaXMgd2F5LCBpdCBtaWdodCB0cmlnZ2VyXG4vLyBhIG5leHRUaWNrIHJlY3Vyc2lvbiB3YXJuaW5nLCBidXQgdGhhdCdzIG5vdCBzbyBiYWQuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgc3RhdGUubmVlZFJlYWRhYmxlID0gZmFsc2U7XG4gIGlmICghc3RhdGUuZW1pdHRlZFJlYWRhYmxlKSB7XG4gICAgZGVidWcoJ2VtaXRSZWFkYWJsZScsIHN0YXRlLmZsb3dpbmcpO1xuICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgaWYgKHN0YXRlLnN5bmMpXG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgICBlbWl0UmVhZGFibGVfKHN0cmVhbSk7XG4gICAgICB9KTtcbiAgICBlbHNlXG4gICAgICBlbWl0UmVhZGFibGVfKHN0cmVhbSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlXyhzdHJlYW0pIHtcbiAgZGVidWcoJ2VtaXQgcmVhZGFibGUnKTtcbiAgc3RyZWFtLmVtaXQoJ3JlYWRhYmxlJyk7XG4gIGZsb3coc3RyZWFtKTtcbn1cblxuXG4vLyBhdCB0aGlzIHBvaW50LCB0aGUgdXNlciBoYXMgcHJlc3VtYWJseSBzZWVuIHRoZSAncmVhZGFibGUnIGV2ZW50LFxuLy8gYW5kIGNhbGxlZCByZWFkKCkgdG8gY29uc3VtZSBzb21lIGRhdGEuICB0aGF0IG1heSBoYXZlIHRyaWdnZXJlZFxuLy8gaW4gdHVybiBhbm90aGVyIF9yZWFkKG4pIGNhbGwsIGluIHdoaWNoIGNhc2UgcmVhZGluZyA9IHRydWUgaWZcbi8vIGl0J3MgaW4gcHJvZ3Jlc3MuXG4vLyBIb3dldmVyLCBpZiB3ZSdyZSBub3QgZW5kZWQsIG9yIHJlYWRpbmcsIGFuZCB0aGUgbGVuZ3RoIDwgaHdtLFxuLy8gdGhlbiBnbyBhaGVhZCBhbmQgdHJ5IHRvIHJlYWQgc29tZSBtb3JlIHByZWVtcHRpdmVseS5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlYWRpbmdNb3JlKSB7XG4gICAgc3RhdGUucmVhZGluZ01vcmUgPSB0cnVlO1xuICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICBtYXliZVJlYWRNb3JlXyhzdHJlYW0sIHN0YXRlKTtcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlXyhzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBsZW4gPSBzdGF0ZS5sZW5ndGg7XG4gIHdoaWxlICghc3RhdGUucmVhZGluZyAmJiAhc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUuZW5kZWQgJiZcbiAgICAgICAgIHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmspIHtcbiAgICBkZWJ1ZygnbWF5YmVSZWFkTW9yZSByZWFkIDAnKTtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgICBpZiAobGVuID09PSBzdGF0ZS5sZW5ndGgpXG4gICAgICAvLyBkaWRuJ3QgZ2V0IGFueSBkYXRhLCBzdG9wIHNwaW5uaW5nLlxuICAgICAgYnJlYWs7XG4gICAgZWxzZVxuICAgICAgbGVuID0gc3RhdGUubGVuZ3RoO1xuICB9XG4gIHN0YXRlLnJlYWRpbmdNb3JlID0gZmFsc2U7XG59XG5cbi8vIGFic3RyYWN0IG1ldGhvZC4gIHRvIGJlIG92ZXJyaWRkZW4gaW4gc3BlY2lmaWMgaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vIGNhbGwgY2IoZXIsIGRhdGEpIHdoZXJlIGRhdGEgaXMgPD0gbiBpbiBsZW5ndGguXG4vLyBmb3IgdmlydHVhbCAobm9uLXN0cmluZywgbm9uLWJ1ZmZlcikgc3RyZWFtcywgXCJsZW5ndGhcIiBpcyBzb21ld2hhdFxuLy8gYXJiaXRyYXJ5LCBhbmQgcGVyaGFwcyBub3QgdmVyeSBtZWFuaW5nZnVsLlxuUmVhZGFibGUucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24obikge1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKSk7XG59O1xuXG5SZWFkYWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uKGRlc3QsIHBpcGVPcHRzKSB7XG4gIHZhciBzcmMgPSB0aGlzO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIHN3aXRjaCAoc3RhdGUucGlwZXNDb3VudCkge1xuICAgIGNhc2UgMDpcbiAgICAgIHN0YXRlLnBpcGVzID0gZGVzdDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTpcbiAgICAgIHN0YXRlLnBpcGVzID0gW3N0YXRlLnBpcGVzLCBkZXN0XTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBzdGF0ZS5waXBlcy5wdXNoKGRlc3QpO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgc3RhdGUucGlwZXNDb3VudCArPSAxO1xuICBkZWJ1ZygncGlwZSBjb3VudD0lZCBvcHRzPSVqJywgc3RhdGUucGlwZXNDb3VudCwgcGlwZU9wdHMpO1xuXG4gIHZhciBkb0VuZCA9ICghcGlwZU9wdHMgfHwgcGlwZU9wdHMuZW5kICE9PSBmYWxzZSkgJiZcbiAgICAgICAgICAgICAgZGVzdCAhPT0gcHJvY2Vzcy5zdGRvdXQgJiZcbiAgICAgICAgICAgICAgZGVzdCAhPT0gcHJvY2Vzcy5zdGRlcnI7XG5cbiAgdmFyIGVuZEZuID0gZG9FbmQgPyBvbmVuZCA6IGNsZWFudXA7XG4gIGlmIChzdGF0ZS5lbmRFbWl0dGVkKVxuICAgIHByb2Nlc3MubmV4dFRpY2soZW5kRm4pO1xuICBlbHNlXG4gICAgc3JjLm9uY2UoJ2VuZCcsIGVuZEZuKTtcblxuICBkZXN0Lm9uKCd1bnBpcGUnLCBvbnVucGlwZSk7XG4gIGZ1bmN0aW9uIG9udW5waXBlKHJlYWRhYmxlKSB7XG4gICAgZGVidWcoJ29udW5waXBlJyk7XG4gICAgaWYgKHJlYWRhYmxlID09PSBzcmMpIHtcbiAgICAgIGNsZWFudXAoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbmVuZCgpIHtcbiAgICBkZWJ1Zygnb25lbmQnKTtcbiAgICBkZXN0LmVuZCgpO1xuICB9XG5cbiAgLy8gd2hlbiB0aGUgZGVzdCBkcmFpbnMsIGl0IHJlZHVjZXMgdGhlIGF3YWl0RHJhaW4gY291bnRlclxuICAvLyBvbiB0aGUgc291cmNlLiAgVGhpcyB3b3VsZCBiZSBtb3JlIGVsZWdhbnQgd2l0aCBhIC5vbmNlKClcbiAgLy8gaGFuZGxlciBpbiBmbG93KCksIGJ1dCBhZGRpbmcgYW5kIHJlbW92aW5nIHJlcGVhdGVkbHkgaXNcbiAgLy8gdG9vIHNsb3cuXG4gIHZhciBvbmRyYWluID0gcGlwZU9uRHJhaW4oc3JjKTtcbiAgZGVzdC5vbignZHJhaW4nLCBvbmRyYWluKTtcblxuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIGRlYnVnKCdjbGVhbnVwJyk7XG4gICAgLy8gY2xlYW51cCBldmVudCBoYW5kbGVycyBvbmNlIHRoZSBwaXBlIGlzIGJyb2tlblxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgb25kcmFpbik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCd1bnBpcGUnLCBvbnVucGlwZSk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBjbGVhbnVwKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpO1xuXG4gICAgLy8gaWYgdGhlIHJlYWRlciBpcyB3YWl0aW5nIGZvciBhIGRyYWluIGV2ZW50IGZyb20gdGhpc1xuICAgIC8vIHNwZWNpZmljIHdyaXRlciwgdGhlbiBpdCB3b3VsZCBjYXVzZSBpdCB0byBuZXZlciBzdGFydFxuICAgIC8vIGZsb3dpbmcgYWdhaW4uXG4gICAgLy8gU28sIGlmIHRoaXMgaXMgYXdhaXRpbmcgYSBkcmFpbiwgdGhlbiB3ZSBqdXN0IGNhbGwgaXQgbm93LlxuICAgIC8vIElmIHdlIGRvbid0IGtub3csIHRoZW4gYXNzdW1lIHRoYXQgd2UgYXJlIHdhaXRpbmcgZm9yIG9uZS5cbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiAmJlxuICAgICAgICAoIWRlc3QuX3dyaXRhYmxlU3RhdGUgfHwgZGVzdC5fd3JpdGFibGVTdGF0ZS5uZWVkRHJhaW4pKVxuICAgICAgb25kcmFpbigpO1xuICB9XG5cbiAgc3JjLm9uKCdkYXRhJywgb25kYXRhKTtcbiAgZnVuY3Rpb24gb25kYXRhKGNodW5rKSB7XG4gICAgZGVidWcoJ29uZGF0YScpO1xuICAgIHZhciByZXQgPSBkZXN0LndyaXRlKGNodW5rKTtcbiAgICBpZiAoZmFsc2UgPT09IHJldCkge1xuICAgICAgZGVidWcoJ2ZhbHNlIHdyaXRlIHJlc3BvbnNlLCBwYXVzZScsXG4gICAgICAgICAgICBzcmMuX3JlYWRhYmxlU3RhdGUuYXdhaXREcmFpbik7XG4gICAgICBzcmMuX3JlYWRhYmxlU3RhdGUuYXdhaXREcmFpbisrO1xuICAgICAgc3JjLnBhdXNlKCk7XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIGRlc3QgaGFzIGFuIGVycm9yLCB0aGVuIHN0b3AgcGlwaW5nIGludG8gaXQuXG4gIC8vIGhvd2V2ZXIsIGRvbid0IHN1cHByZXNzIHRoZSB0aHJvd2luZyBiZWhhdmlvciBmb3IgdGhpcy5cbiAgZnVuY3Rpb24gb25lcnJvcihlcikge1xuICAgIGRlYnVnKCdvbmVycm9yJywgZXIpO1xuICAgIHVucGlwZSgpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgaWYgKEVFLmxpc3RlbmVyQ291bnQoZGVzdCwgJ2Vycm9yJykgPT09IDApXG4gICAgICBkZXN0LmVtaXQoJ2Vycm9yJywgZXIpO1xuICB9XG4gIC8vIFRoaXMgaXMgYSBicnV0YWxseSB1Z2x5IGhhY2sgdG8gbWFrZSBzdXJlIHRoYXQgb3VyIGVycm9yIGhhbmRsZXJcbiAgLy8gaXMgYXR0YWNoZWQgYmVmb3JlIGFueSB1c2VybGFuZCBvbmVzLiAgTkVWRVIgRE8gVEhJUy5cbiAgaWYgKCFkZXN0Ll9ldmVudHMgfHwgIWRlc3QuX2V2ZW50cy5lcnJvcilcbiAgICBkZXN0Lm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuICBlbHNlIGlmIChpc0FycmF5KGRlc3QuX2V2ZW50cy5lcnJvcikpXG4gICAgZGVzdC5fZXZlbnRzLmVycm9yLnVuc2hpZnQob25lcnJvcik7XG4gIGVsc2VcbiAgICBkZXN0Ll9ldmVudHMuZXJyb3IgPSBbb25lcnJvciwgZGVzdC5fZXZlbnRzLmVycm9yXTtcblxuXG5cbiAgLy8gQm90aCBjbG9zZSBhbmQgZmluaXNoIHNob3VsZCB0cmlnZ2VyIHVucGlwZSwgYnV0IG9ubHkgb25jZS5cbiAgZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgdW5waXBlKCk7XG4gIH1cbiAgZGVzdC5vbmNlKCdjbG9zZScsIG9uY2xvc2UpO1xuICBmdW5jdGlvbiBvbmZpbmlzaCgpIHtcbiAgICBkZWJ1Zygnb25maW5pc2gnKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIHVucGlwZSgpO1xuICB9XG4gIGRlc3Qub25jZSgnZmluaXNoJywgb25maW5pc2gpO1xuXG4gIGZ1bmN0aW9uIHVucGlwZSgpIHtcbiAgICBkZWJ1ZygndW5waXBlJyk7XG4gICAgc3JjLnVucGlwZShkZXN0KTtcbiAgfVxuXG4gIC8vIHRlbGwgdGhlIGRlc3QgdGhhdCBpdCdzIGJlaW5nIHBpcGVkIHRvXG4gIGRlc3QuZW1pdCgncGlwZScsIHNyYyk7XG5cbiAgLy8gc3RhcnQgdGhlIGZsb3cgaWYgaXQgaGFzbid0IGJlZW4gc3RhcnRlZCBhbHJlYWR5LlxuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncGlwZSByZXN1bWUnKTtcbiAgICBzcmMucmVzdW1lKCk7XG4gIH1cblxuICByZXR1cm4gZGVzdDtcbn07XG5cbmZ1bmN0aW9uIHBpcGVPbkRyYWluKHNyYykge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0YXRlID0gc3JjLl9yZWFkYWJsZVN0YXRlO1xuICAgIGRlYnVnKCdwaXBlT25EcmFpbicsIHN0YXRlLmF3YWl0RHJhaW4pO1xuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluKVxuICAgICAgc3RhdGUuYXdhaXREcmFpbi0tO1xuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluID09PSAwICYmIEVFLmxpc3RlbmVyQ291bnQoc3JjLCAnZGF0YScpKSB7XG4gICAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTtcbiAgICAgIGZsb3coc3JjKTtcbiAgICB9XG4gIH07XG59XG5cblxuUmVhZGFibGUucHJvdG90eXBlLnVucGlwZSA9IGZ1bmN0aW9uKGRlc3QpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICAvLyBpZiB3ZSdyZSBub3QgcGlwaW5nIGFueXdoZXJlLCB0aGVuIGRvIG5vdGhpbmcuXG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAwKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIC8vIGp1c3Qgb25lIGRlc3RpbmF0aW9uLiAgbW9zdCBjb21tb24gY2FzZS5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHtcbiAgICAvLyBwYXNzZWQgaW4gb25lLCBidXQgaXQncyBub3QgdGhlIHJpZ2h0IG9uZS5cbiAgICBpZiAoZGVzdCAmJiBkZXN0ICE9PSBzdGF0ZS5waXBlcylcbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgaWYgKCFkZXN0KVxuICAgICAgZGVzdCA9IHN0YXRlLnBpcGVzO1xuXG4gICAgLy8gZ290IGEgbWF0Y2guXG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICBpZiAoZGVzdClcbiAgICAgIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBzbG93IGNhc2UuIG11bHRpcGxlIHBpcGUgZGVzdGluYXRpb25zLlxuXG4gIGlmICghZGVzdCkge1xuICAgIC8vIHJlbW92ZSBhbGwuXG4gICAgdmFyIGRlc3RzID0gc3RhdGUucGlwZXM7XG4gICAgdmFyIGxlbiA9IHN0YXRlLnBpcGVzQ291bnQ7XG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICBkZXN0c1tpXS5lbWl0KCd1bnBpcGUnLCB0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHRyeSB0byBmaW5kIHRoZSByaWdodCBvbmUuXG4gIHZhciBpID0gaW5kZXhPZihzdGF0ZS5waXBlcywgZGVzdCk7XG4gIGlmIChpID09PSAtMSlcbiAgICByZXR1cm4gdGhpcztcblxuICBzdGF0ZS5waXBlcy5zcGxpY2UoaSwgMSk7XG4gIHN0YXRlLnBpcGVzQ291bnQgLT0gMTtcbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpXG4gICAgc3RhdGUucGlwZXMgPSBzdGF0ZS5waXBlc1swXTtcblxuICBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gc2V0IHVwIGRhdGEgZXZlbnRzIGlmIHRoZXkgYXJlIGFza2VkIGZvclxuLy8gRW5zdXJlIHJlYWRhYmxlIGxpc3RlbmVycyBldmVudHVhbGx5IGdldCBzb21ldGhpbmdcblJlYWRhYmxlLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uKGV2LCBmbikge1xuICB2YXIgcmVzID0gU3RyZWFtLnByb3RvdHlwZS5vbi5jYWxsKHRoaXMsIGV2LCBmbik7XG5cbiAgLy8gSWYgbGlzdGVuaW5nIHRvIGRhdGEsIGFuZCBpdCBoYXMgbm90IGV4cGxpY2l0bHkgYmVlbiBwYXVzZWQsXG4gIC8vIHRoZW4gY2FsbCByZXN1bWUgdG8gc3RhcnQgdGhlIGZsb3cgb2YgZGF0YSBvbiB0aGUgbmV4dCB0aWNrLlxuICBpZiAoZXYgPT09ICdkYXRhJyAmJiBmYWxzZSAhPT0gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKSB7XG4gICAgdGhpcy5yZXN1bWUoKTtcbiAgfVxuXG4gIGlmIChldiA9PT0gJ3JlYWRhYmxlJyAmJiB0aGlzLnJlYWRhYmxlKSB7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAoIXN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nKSB7XG4gICAgICBzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZyA9IHRydWU7XG4gICAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGRlYnVnKCdyZWFkYWJsZSBuZXh0dGljayByZWFkIDAnKTtcbiAgICAgICAgICBzZWxmLnJlYWQoMCk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5sZW5ndGgpIHtcbiAgICAgICAgZW1pdFJlYWRhYmxlKHRoaXMsIHN0YXRlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblJlYWRhYmxlLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IFJlYWRhYmxlLnByb3RvdHlwZS5vbjtcblxuLy8gcGF1c2UoKSBhbmQgcmVzdW1lKCkgYXJlIHJlbW5hbnRzIG9mIHRoZSBsZWdhY3kgcmVhZGFibGUgc3RyZWFtIEFQSVxuLy8gSWYgdGhlIHVzZXIgdXNlcyB0aGVtLCB0aGVuIHN3aXRjaCBpbnRvIG9sZCBtb2RlLlxuUmVhZGFibGUucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncmVzdW1lJyk7XG4gICAgc3RhdGUuZmxvd2luZyA9IHRydWU7XG4gICAgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7XG4gICAgICBkZWJ1ZygncmVzdW1lIHJlYWQgMCcpO1xuICAgICAgdGhpcy5yZWFkKDApO1xuICAgIH1cbiAgICByZXN1bWUodGhpcywgc3RhdGUpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gcmVzdW1lKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZXN1bWVTY2hlZHVsZWQpIHtcbiAgICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSB0cnVlO1xuICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICByZXN1bWVfKHN0cmVhbSwgc3RhdGUpO1xuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3VtZV8oc3RyZWFtLCBzdGF0ZSkge1xuICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgc3RyZWFtLmVtaXQoJ3Jlc3VtZScpO1xuICBmbG93KHN0cmVhbSk7XG4gIGlmIChzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5yZWFkaW5nKVxuICAgIHN0cmVhbS5yZWFkKDApO1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ2NhbGwgcGF1c2UgZmxvd2luZz0laicsIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyk7XG4gIGlmIChmYWxzZSAhPT0gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3BhdXNlJyk7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgdGhpcy5lbWl0KCdwYXVzZScpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gZmxvdyhzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBkZWJ1ZygnZmxvdycsIHN0YXRlLmZsb3dpbmcpO1xuICBpZiAoc3RhdGUuZmxvd2luZykge1xuICAgIGRvIHtcbiAgICAgIHZhciBjaHVuayA9IHN0cmVhbS5yZWFkKCk7XG4gICAgfSB3aGlsZSAobnVsbCAhPT0gY2h1bmsgJiYgc3RhdGUuZmxvd2luZyk7XG4gIH1cbn1cblxuLy8gd3JhcCBhbiBvbGQtc3R5bGUgc3RyZWFtIGFzIHRoZSBhc3luYyBkYXRhIHNvdXJjZS5cbi8vIFRoaXMgaXMgKm5vdCogcGFydCBvZiB0aGUgcmVhZGFibGUgc3RyZWFtIGludGVyZmFjZS5cbi8vIEl0IGlzIGFuIHVnbHkgdW5mb3J0dW5hdGUgbWVzcyBvZiBoaXN0b3J5LlxuUmVhZGFibGUucHJvdG90eXBlLndyYXAgPSBmdW5jdGlvbihzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHBhdXNlZCA9IGZhbHNlO1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgc3RyZWFtLm9uKCdlbmQnLCBmdW5jdGlvbigpIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBlbmQnKTtcbiAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhc3RhdGUuZW5kZWQpIHtcbiAgICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG4gICAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKVxuICAgICAgICBzZWxmLnB1c2goY2h1bmspO1xuICAgIH1cblxuICAgIHNlbGYucHVzaChudWxsKTtcbiAgfSk7XG5cbiAgc3RyZWFtLm9uKCdkYXRhJywgZnVuY3Rpb24oY2h1bmspIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBkYXRhJyk7XG4gICAgaWYgKHN0YXRlLmRlY29kZXIpXG4gICAgICBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspO1xuICAgIGlmICghY2h1bmsgfHwgIXN0YXRlLm9iamVjdE1vZGUgJiYgIWNodW5rLmxlbmd0aClcbiAgICAgIHJldHVybjtcblxuICAgIHZhciByZXQgPSBzZWxmLnB1c2goY2h1bmspO1xuICAgIGlmICghcmV0KSB7XG4gICAgICBwYXVzZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLnBhdXNlKCk7XG4gICAgfVxuICB9KTtcblxuICAvLyBwcm94eSBhbGwgdGhlIG90aGVyIG1ldGhvZHMuXG4gIC8vIGltcG9ydGFudCB3aGVuIHdyYXBwaW5nIGZpbHRlcnMgYW5kIGR1cGxleGVzLlxuICBmb3IgKHZhciBpIGluIHN0cmVhbSkge1xuICAgIGlmICh1dGlsLmlzRnVuY3Rpb24oc3RyZWFtW2ldKSAmJiB1dGlsLmlzVW5kZWZpbmVkKHRoaXNbaV0pKSB7XG4gICAgICB0aGlzW2ldID0gZnVuY3Rpb24obWV0aG9kKSB7IHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHN0cmVhbVttZXRob2RdLmFwcGx5KHN0cmVhbSwgYXJndW1lbnRzKTtcbiAgICAgIH19KGkpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHByb3h5IGNlcnRhaW4gaW1wb3J0YW50IGV2ZW50cy5cbiAgdmFyIGV2ZW50cyA9IFsnZXJyb3InLCAnY2xvc2UnLCAnZGVzdHJveScsICdwYXVzZScsICdyZXN1bWUnXTtcbiAgZm9yRWFjaChldmVudHMsIGZ1bmN0aW9uKGV2KSB7XG4gICAgc3RyZWFtLm9uKGV2LCBzZWxmLmVtaXQuYmluZChzZWxmLCBldikpO1xuICB9KTtcblxuICAvLyB3aGVuIHdlIHRyeSB0byBjb25zdW1lIHNvbWUgbW9yZSBieXRlcywgc2ltcGx5IHVucGF1c2UgdGhlXG4gIC8vIHVuZGVybHlpbmcgc3RyZWFtLlxuICBzZWxmLl9yZWFkID0gZnVuY3Rpb24obikge1xuICAgIGRlYnVnKCd3cmFwcGVkIF9yZWFkJywgbik7XG4gICAgaWYgKHBhdXNlZCkge1xuICAgICAgcGF1c2VkID0gZmFsc2U7XG4gICAgICBzdHJlYW0ucmVzdW1lKCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBzZWxmO1xufTtcblxuXG5cbi8vIGV4cG9zZWQgZm9yIHRlc3RpbmcgcHVycG9zZXMgb25seS5cblJlYWRhYmxlLl9mcm9tTGlzdCA9IGZyb21MaXN0O1xuXG4vLyBQbHVjayBvZmYgbiBieXRlcyBmcm9tIGFuIGFycmF5IG9mIGJ1ZmZlcnMuXG4vLyBMZW5ndGggaXMgdGhlIGNvbWJpbmVkIGxlbmd0aHMgb2YgYWxsIHRoZSBidWZmZXJzIGluIHRoZSBsaXN0LlxuZnVuY3Rpb24gZnJvbUxpc3Qobiwgc3RhdGUpIHtcbiAgdmFyIGxpc3QgPSBzdGF0ZS5idWZmZXI7XG4gIHZhciBsZW5ndGggPSBzdGF0ZS5sZW5ndGg7XG4gIHZhciBzdHJpbmdNb2RlID0gISFzdGF0ZS5kZWNvZGVyO1xuICB2YXIgb2JqZWN0TW9kZSA9ICEhc3RhdGUub2JqZWN0TW9kZTtcbiAgdmFyIHJldDtcblxuICAvLyBub3RoaW5nIGluIHRoZSBsaXN0LCBkZWZpbml0ZWx5IGVtcHR5LlxuICBpZiAobGlzdC5sZW5ndGggPT09IDApXG4gICAgcmV0dXJuIG51bGw7XG5cbiAgaWYgKGxlbmd0aCA9PT0gMClcbiAgICByZXQgPSBudWxsO1xuICBlbHNlIGlmIChvYmplY3RNb2RlKVxuICAgIHJldCA9IGxpc3Quc2hpZnQoKTtcbiAgZWxzZSBpZiAoIW4gfHwgbiA+PSBsZW5ndGgpIHtcbiAgICAvLyByZWFkIGl0IGFsbCwgdHJ1bmNhdGUgdGhlIGFycmF5LlxuICAgIGlmIChzdHJpbmdNb2RlKVxuICAgICAgcmV0ID0gbGlzdC5qb2luKCcnKTtcbiAgICBlbHNlXG4gICAgICByZXQgPSBCdWZmZXIuY29uY2F0KGxpc3QsIGxlbmd0aCk7XG4gICAgbGlzdC5sZW5ndGggPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlYWQganVzdCBzb21lIG9mIGl0LlxuICAgIGlmIChuIDwgbGlzdFswXS5sZW5ndGgpIHtcbiAgICAgIC8vIGp1c3QgdGFrZSBhIHBhcnQgb2YgdGhlIGZpcnN0IGxpc3QgaXRlbS5cbiAgICAgIC8vIHNsaWNlIGlzIHRoZSBzYW1lIGZvciBidWZmZXJzIGFuZCBzdHJpbmdzLlxuICAgICAgdmFyIGJ1ZiA9IGxpc3RbMF07XG4gICAgICByZXQgPSBidWYuc2xpY2UoMCwgbik7XG4gICAgICBsaXN0WzBdID0gYnVmLnNsaWNlKG4pO1xuICAgIH0gZWxzZSBpZiAobiA9PT0gbGlzdFswXS5sZW5ndGgpIHtcbiAgICAgIC8vIGZpcnN0IGxpc3QgaXMgYSBwZXJmZWN0IG1hdGNoXG4gICAgICByZXQgPSBsaXN0LnNoaWZ0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGNvbXBsZXggY2FzZS5cbiAgICAgIC8vIHdlIGhhdmUgZW5vdWdoIHRvIGNvdmVyIGl0LCBidXQgaXQgc3BhbnMgcGFzdCB0aGUgZmlyc3QgYnVmZmVyLlxuICAgICAgaWYgKHN0cmluZ01vZGUpXG4gICAgICAgIHJldCA9ICcnO1xuICAgICAgZWxzZVxuICAgICAgICByZXQgPSBuZXcgQnVmZmVyKG4pO1xuXG4gICAgICB2YXIgYyA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbCAmJiBjIDwgbjsgaSsrKSB7XG4gICAgICAgIHZhciBidWYgPSBsaXN0WzBdO1xuICAgICAgICB2YXIgY3B5ID0gTWF0aC5taW4obiAtIGMsIGJ1Zi5sZW5ndGgpO1xuXG4gICAgICAgIGlmIChzdHJpbmdNb2RlKVxuICAgICAgICAgIHJldCArPSBidWYuc2xpY2UoMCwgY3B5KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGJ1Zi5jb3B5KHJldCwgYywgMCwgY3B5KTtcblxuICAgICAgICBpZiAoY3B5IDwgYnVmLmxlbmd0aClcbiAgICAgICAgICBsaXN0WzBdID0gYnVmLnNsaWNlKGNweSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBsaXN0LnNoaWZ0KCk7XG5cbiAgICAgICAgYyArPSBjcHk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZW5kUmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcblxuICAvLyBJZiB3ZSBnZXQgaGVyZSBiZWZvcmUgY29uc3VtaW5nIGFsbCB0aGUgYnl0ZXMsIHRoZW4gdGhhdCBpcyBhXG4gIC8vIGJ1ZyBpbiBub2RlLiAgU2hvdWxkIG5ldmVyIGhhcHBlbi5cbiAgaWYgKHN0YXRlLmxlbmd0aCA+IDApXG4gICAgdGhyb3cgbmV3IEVycm9yKCdlbmRSZWFkYWJsZSBjYWxsZWQgb24gbm9uLWVtcHR5IHN0cmVhbScpO1xuXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCkge1xuICAgIHN0YXRlLmVuZGVkID0gdHJ1ZTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgLy8gQ2hlY2sgdGhhdCB3ZSBkaWRuJ3QgZ2V0IG9uZSBsYXN0IHVuc2hpZnQuXG4gICAgICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgc3RhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHN0YXRlLmVuZEVtaXR0ZWQgPSB0cnVlO1xuICAgICAgICBzdHJlYW0ucmVhZGFibGUgPSBmYWxzZTtcbiAgICAgICAgc3RyZWFtLmVtaXQoJ2VuZCcpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZvckVhY2ggKHhzLCBmKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZih4c1tpXSwgaSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5kZXhPZiAoeHMsIHgpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoeHNbaV0gPT09IHgpIHJldHVybiBpO1xuICB9XG4gIHJldHVybiAtMTtcbn1cbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5cbi8vIGEgdHJhbnNmb3JtIHN0cmVhbSBpcyBhIHJlYWRhYmxlL3dyaXRhYmxlIHN0cmVhbSB3aGVyZSB5b3UgZG9cbi8vIHNvbWV0aGluZyB3aXRoIHRoZSBkYXRhLiAgU29tZXRpbWVzIGl0J3MgY2FsbGVkIGEgXCJmaWx0ZXJcIixcbi8vIGJ1dCB0aGF0J3Mgbm90IGEgZ3JlYXQgbmFtZSBmb3IgaXQsIHNpbmNlIHRoYXQgaW1wbGllcyBhIHRoaW5nIHdoZXJlXG4vLyBzb21lIGJpdHMgcGFzcyB0aHJvdWdoLCBhbmQgb3RoZXJzIGFyZSBzaW1wbHkgaWdub3JlZC4gIChUaGF0IHdvdWxkXG4vLyBiZSBhIHZhbGlkIGV4YW1wbGUgb2YgYSB0cmFuc2Zvcm0sIG9mIGNvdXJzZS4pXG4vL1xuLy8gV2hpbGUgdGhlIG91dHB1dCBpcyBjYXVzYWxseSByZWxhdGVkIHRvIHRoZSBpbnB1dCwgaXQncyBub3QgYVxuLy8gbmVjZXNzYXJpbHkgc3ltbWV0cmljIG9yIHN5bmNocm9ub3VzIHRyYW5zZm9ybWF0aW9uLiAgRm9yIGV4YW1wbGUsXG4vLyBhIHpsaWIgc3RyZWFtIG1pZ2h0IHRha2UgbXVsdGlwbGUgcGxhaW4tdGV4dCB3cml0ZXMoKSwgYW5kIHRoZW5cbi8vIGVtaXQgYSBzaW5nbGUgY29tcHJlc3NlZCBjaHVuayBzb21lIHRpbWUgaW4gdGhlIGZ1dHVyZS5cbi8vXG4vLyBIZXJlJ3MgaG93IHRoaXMgd29ya3M6XG4vL1xuLy8gVGhlIFRyYW5zZm9ybSBzdHJlYW0gaGFzIGFsbCB0aGUgYXNwZWN0cyBvZiB0aGUgcmVhZGFibGUgYW5kIHdyaXRhYmxlXG4vLyBzdHJlYW0gY2xhc3Nlcy4gIFdoZW4geW91IHdyaXRlKGNodW5rKSwgdGhhdCBjYWxscyBfd3JpdGUoY2h1bmssY2IpXG4vLyBpbnRlcm5hbGx5LCBhbmQgcmV0dXJucyBmYWxzZSBpZiB0aGVyZSdzIGEgbG90IG9mIHBlbmRpbmcgd3JpdGVzXG4vLyBidWZmZXJlZCB1cC4gIFdoZW4geW91IGNhbGwgcmVhZCgpLCB0aGF0IGNhbGxzIF9yZWFkKG4pIHVudGlsXG4vLyB0aGVyZSdzIGVub3VnaCBwZW5kaW5nIHJlYWRhYmxlIGRhdGEgYnVmZmVyZWQgdXAuXG4vL1xuLy8gSW4gYSB0cmFuc2Zvcm0gc3RyZWFtLCB0aGUgd3JpdHRlbiBkYXRhIGlzIHBsYWNlZCBpbiBhIGJ1ZmZlci4gIFdoZW5cbi8vIF9yZWFkKG4pIGlzIGNhbGxlZCwgaXQgdHJhbnNmb3JtcyB0aGUgcXVldWVkIHVwIGRhdGEsIGNhbGxpbmcgdGhlXG4vLyBidWZmZXJlZCBfd3JpdGUgY2IncyBhcyBpdCBjb25zdW1lcyBjaHVua3MuICBJZiBjb25zdW1pbmcgYSBzaW5nbGVcbi8vIHdyaXR0ZW4gY2h1bmsgd291bGQgcmVzdWx0IGluIG11bHRpcGxlIG91dHB1dCBjaHVua3MsIHRoZW4gdGhlIGZpcnN0XG4vLyBvdXRwdXR0ZWQgYml0IGNhbGxzIHRoZSByZWFkY2IsIGFuZCBzdWJzZXF1ZW50IGNodW5rcyBqdXN0IGdvIGludG9cbi8vIHRoZSByZWFkIGJ1ZmZlciwgYW5kIHdpbGwgY2F1c2UgaXQgdG8gZW1pdCAncmVhZGFibGUnIGlmIG5lY2Vzc2FyeS5cbi8vXG4vLyBUaGlzIHdheSwgYmFjay1wcmVzc3VyZSBpcyBhY3R1YWxseSBkZXRlcm1pbmVkIGJ5IHRoZSByZWFkaW5nIHNpZGUsXG4vLyBzaW5jZSBfcmVhZCBoYXMgdG8gYmUgY2FsbGVkIHRvIHN0YXJ0IHByb2Nlc3NpbmcgYSBuZXcgY2h1bmsuICBIb3dldmVyLFxuLy8gYSBwYXRob2xvZ2ljYWwgaW5mbGF0ZSB0eXBlIG9mIHRyYW5zZm9ybSBjYW4gY2F1c2UgZXhjZXNzaXZlIGJ1ZmZlcmluZ1xuLy8gaGVyZS4gIEZvciBleGFtcGxlLCBpbWFnaW5lIGEgc3RyZWFtIHdoZXJlIGV2ZXJ5IGJ5dGUgb2YgaW5wdXQgaXNcbi8vIGludGVycHJldGVkIGFzIGFuIGludGVnZXIgZnJvbSAwLTI1NSwgYW5kIHRoZW4gcmVzdWx0cyBpbiB0aGF0IG1hbnlcbi8vIGJ5dGVzIG9mIG91dHB1dC4gIFdyaXRpbmcgdGhlIDQgYnl0ZXMge2ZmLGZmLGZmLGZmfSB3b3VsZCByZXN1bHQgaW5cbi8vIDFrYiBvZiBkYXRhIGJlaW5nIG91dHB1dC4gIEluIHRoaXMgY2FzZSwgeW91IGNvdWxkIHdyaXRlIGEgdmVyeSBzbWFsbFxuLy8gYW1vdW50IG9mIGlucHV0LCBhbmQgZW5kIHVwIHdpdGggYSB2ZXJ5IGxhcmdlIGFtb3VudCBvZiBvdXRwdXQuICBJblxuLy8gc3VjaCBhIHBhdGhvbG9naWNhbCBpbmZsYXRpbmcgbWVjaGFuaXNtLCB0aGVyZSdkIGJlIG5vIHdheSB0byB0ZWxsXG4vLyB0aGUgc3lzdGVtIHRvIHN0b3AgZG9pbmcgdGhlIHRyYW5zZm9ybS4gIEEgc2luZ2xlIDRNQiB3cml0ZSBjb3VsZFxuLy8gY2F1c2UgdGhlIHN5c3RlbSB0byBydW4gb3V0IG9mIG1lbW9yeS5cbi8vXG4vLyBIb3dldmVyLCBldmVuIGluIHN1Y2ggYSBwYXRob2xvZ2ljYWwgY2FzZSwgb25seSBhIHNpbmdsZSB3cml0dGVuIGNodW5rXG4vLyB3b3VsZCBiZSBjb25zdW1lZCwgYW5kIHRoZW4gdGhlIHJlc3Qgd291bGQgd2FpdCAodW4tdHJhbnNmb3JtZWQpIHVudGlsXG4vLyB0aGUgcmVzdWx0cyBvZiB0aGUgcHJldmlvdXMgdHJhbnNmb3JtZWQgY2h1bmsgd2VyZSBjb25zdW1lZC5cblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2Zvcm07XG5cbnZhciBEdXBsZXggPSByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudXRpbC5pbmhlcml0cyhUcmFuc2Zvcm0sIER1cGxleCk7XG5cblxuZnVuY3Rpb24gVHJhbnNmb3JtU3RhdGUob3B0aW9ucywgc3RyZWFtKSB7XG4gIHRoaXMuYWZ0ZXJUcmFuc2Zvcm0gPSBmdW5jdGlvbihlciwgZGF0YSkge1xuICAgIHJldHVybiBhZnRlclRyYW5zZm9ybShzdHJlYW0sIGVyLCBkYXRhKTtcbiAgfTtcblxuICB0aGlzLm5lZWRUcmFuc2Zvcm0gPSBmYWxzZTtcbiAgdGhpcy50cmFuc2Zvcm1pbmcgPSBmYWxzZTtcbiAgdGhpcy53cml0ZWNiID0gbnVsbDtcbiAgdGhpcy53cml0ZWNodW5rID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gYWZ0ZXJUcmFuc2Zvcm0oc3RyZWFtLCBlciwgZGF0YSkge1xuICB2YXIgdHMgPSBzdHJlYW0uX3RyYW5zZm9ybVN0YXRlO1xuICB0cy50cmFuc2Zvcm1pbmcgPSBmYWxzZTtcblxuICB2YXIgY2IgPSB0cy53cml0ZWNiO1xuXG4gIGlmICghY2IpXG4gICAgcmV0dXJuIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignbm8gd3JpdGVjYiBpbiBUcmFuc2Zvcm0gY2xhc3MnKSk7XG5cbiAgdHMud3JpdGVjaHVuayA9IG51bGw7XG4gIHRzLndyaXRlY2IgPSBudWxsO1xuXG4gIGlmICghdXRpbC5pc051bGxPclVuZGVmaW5lZChkYXRhKSlcbiAgICBzdHJlYW0ucHVzaChkYXRhKTtcblxuICBpZiAoY2IpXG4gICAgY2IoZXIpO1xuXG4gIHZhciBycyA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgcnMucmVhZGluZyA9IGZhbHNlO1xuICBpZiAocnMubmVlZFJlYWRhYmxlIHx8IHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspIHtcbiAgICBzdHJlYW0uX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBUcmFuc2Zvcm0ob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVHJhbnNmb3JtKSlcbiAgICByZXR1cm4gbmV3IFRyYW5zZm9ybShvcHRpb25zKTtcblxuICBEdXBsZXguY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICB0aGlzLl90cmFuc2Zvcm1TdGF0ZSA9IG5ldyBUcmFuc2Zvcm1TdGF0ZShvcHRpb25zLCB0aGlzKTtcblxuICAvLyB3aGVuIHRoZSB3cml0YWJsZSBzaWRlIGZpbmlzaGVzLCB0aGVuIGZsdXNoIG91dCBhbnl0aGluZyByZW1haW5pbmcuXG4gIHZhciBzdHJlYW0gPSB0aGlzO1xuXG4gIC8vIHN0YXJ0IG91dCBhc2tpbmcgZm9yIGEgcmVhZGFibGUgZXZlbnQgb25jZSBkYXRhIGlzIHRyYW5zZm9ybWVkLlxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG5cbiAgLy8gd2UgaGF2ZSBpbXBsZW1lbnRlZCB0aGUgX3JlYWQgbWV0aG9kLCBhbmQgZG9uZSB0aGUgb3RoZXIgdGhpbmdzXG4gIC8vIHRoYXQgUmVhZGFibGUgd2FudHMgYmVmb3JlIHRoZSBmaXJzdCBfcmVhZCBjYWxsLCBzbyB1bnNldCB0aGVcbiAgLy8gc3luYyBndWFyZCBmbGFnLlxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLnN5bmMgPSBmYWxzZTtcblxuICB0aGlzLm9uY2UoJ3ByZWZpbmlzaCcsIGZ1bmN0aW9uKCkge1xuICAgIGlmICh1dGlsLmlzRnVuY3Rpb24odGhpcy5fZmx1c2gpKVxuICAgICAgdGhpcy5fZmx1c2goZnVuY3Rpb24oZXIpIHtcbiAgICAgICAgZG9uZShzdHJlYW0sIGVyKTtcbiAgICAgIH0pO1xuICAgIGVsc2VcbiAgICAgIGRvbmUoc3RyZWFtKTtcbiAgfSk7XG59XG5cblRyYW5zZm9ybS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZykge1xuICB0aGlzLl90cmFuc2Zvcm1TdGF0ZS5uZWVkVHJhbnNmb3JtID0gZmFsc2U7XG4gIHJldHVybiBEdXBsZXgucHJvdG90eXBlLnB1c2guY2FsbCh0aGlzLCBjaHVuaywgZW5jb2RpbmcpO1xufTtcblxuLy8gVGhpcyBpcyB0aGUgcGFydCB3aGVyZSB5b3UgZG8gc3R1ZmYhXG4vLyBvdmVycmlkZSB0aGlzIGZ1bmN0aW9uIGluIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXG4vLyAnY2h1bmsnIGlzIGFuIGlucHV0IGNodW5rLlxuLy9cbi8vIENhbGwgYHB1c2gobmV3Q2h1bmspYCB0byBwYXNzIGFsb25nIHRyYW5zZm9ybWVkIG91dHB1dFxuLy8gdG8gdGhlIHJlYWRhYmxlIHNpZGUuICBZb3UgbWF5IGNhbGwgJ3B1c2gnIHplcm8gb3IgbW9yZSB0aW1lcy5cbi8vXG4vLyBDYWxsIGBjYihlcnIpYCB3aGVuIHlvdSBhcmUgZG9uZSB3aXRoIHRoaXMgY2h1bmsuICBJZiB5b3UgcGFzc1xuLy8gYW4gZXJyb3IsIHRoZW4gdGhhdCdsbCBwdXQgdGhlIGh1cnQgb24gdGhlIHdob2xlIG9wZXJhdGlvbi4gIElmIHlvdVxuLy8gbmV2ZXIgY2FsbCBjYigpLCB0aGVuIHlvdSdsbCBuZXZlciBnZXQgYW5vdGhlciBjaHVuay5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKTtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcbiAgdHMud3JpdGVjYiA9IGNiO1xuICB0cy53cml0ZWNodW5rID0gY2h1bms7XG4gIHRzLndyaXRlZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgaWYgKCF0cy50cmFuc2Zvcm1pbmcpIHtcbiAgICB2YXIgcnMgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICAgIGlmICh0cy5uZWVkVHJhbnNmb3JtIHx8XG4gICAgICAgIHJzLm5lZWRSZWFkYWJsZSB8fFxuICAgICAgICBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKVxuICAgICAgdGhpcy5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgfVxufTtcblxuLy8gRG9lc24ndCBtYXR0ZXIgd2hhdCB0aGUgYXJncyBhcmUgaGVyZS5cbi8vIF90cmFuc2Zvcm0gZG9lcyBhbGwgdGhlIHdvcmsuXG4vLyBUaGF0IHdlIGdvdCBoZXJlIG1lYW5zIHRoYXQgdGhlIHJlYWRhYmxlIHNpZGUgd2FudHMgbW9yZSBkYXRhLlxuVHJhbnNmb3JtLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uKG4pIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG5cbiAgaWYgKCF1dGlsLmlzTnVsbCh0cy53cml0ZWNodW5rKSAmJiB0cy53cml0ZWNiICYmICF0cy50cmFuc2Zvcm1pbmcpIHtcbiAgICB0cy50cmFuc2Zvcm1pbmcgPSB0cnVlO1xuICAgIHRoaXMuX3RyYW5zZm9ybSh0cy53cml0ZWNodW5rLCB0cy53cml0ZWVuY29kaW5nLCB0cy5hZnRlclRyYW5zZm9ybSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gbWFyayB0aGF0IHdlIG5lZWQgYSB0cmFuc2Zvcm0sIHNvIHRoYXQgYW55IGRhdGEgdGhhdCBjb21lcyBpblxuICAgIC8vIHdpbGwgZ2V0IHByb2Nlc3NlZCwgbm93IHRoYXQgd2UndmUgYXNrZWQgZm9yIGl0LlxuICAgIHRzLm5lZWRUcmFuc2Zvcm0gPSB0cnVlO1xuICB9XG59O1xuXG5cbmZ1bmN0aW9uIGRvbmUoc3RyZWFtLCBlcikge1xuICBpZiAoZXIpXG4gICAgcmV0dXJuIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcblxuICAvLyBpZiB0aGVyZSdzIG5vdGhpbmcgaW4gdGhlIHdyaXRlIGJ1ZmZlciwgdGhlbiB0aGF0IG1lYW5zXG4gIC8vIHRoYXQgbm90aGluZyBtb3JlIHdpbGwgZXZlciBiZSBwcm92aWRlZFxuICB2YXIgd3MgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XG4gIHZhciB0cyA9IHN0cmVhbS5fdHJhbnNmb3JtU3RhdGU7XG5cbiAgaWYgKHdzLmxlbmd0aClcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NhbGxpbmcgdHJhbnNmb3JtIGRvbmUgd2hlbiB3cy5sZW5ndGggIT0gMCcpO1xuXG4gIGlmICh0cy50cmFuc2Zvcm1pbmcpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdjYWxsaW5nIHRyYW5zZm9ybSBkb25lIHdoZW4gc3RpbGwgdHJhbnNmb3JtaW5nJyk7XG5cbiAgcmV0dXJuIHN0cmVhbS5wdXNoKG51bGwpO1xufVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIEEgYml0IHNpbXBsZXIgdGhhbiByZWFkYWJsZSBzdHJlYW1zLlxuLy8gSW1wbGVtZW50IGFuIGFzeW5jIC5fd3JpdGUoY2h1bmssIGNiKSwgYW5kIGl0J2xsIGhhbmRsZSBhbGxcbi8vIHRoZSBkcmFpbiBldmVudCBlbWlzc2lvbiBhbmQgYnVmZmVyaW5nLlxuXG5tb2R1bGUuZXhwb3J0cyA9IFdyaXRhYmxlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5Xcml0YWJsZS5Xcml0YWJsZVN0YXRlID0gV3JpdGFibGVTdGF0ZTtcblxuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKTtcblxudXRpbC5pbmhlcml0cyhXcml0YWJsZSwgU3RyZWFtKTtcblxuZnVuY3Rpb24gV3JpdGVSZXEoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB0aGlzLmNodW5rID0gY2h1bms7XG4gIHRoaXMuZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgdGhpcy5jYWxsYmFjayA9IGNiO1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkge1xuICB2YXIgRHVwbGV4ID0gcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIC8vIHRoZSBwb2ludCBhdCB3aGljaCB3cml0ZSgpIHN0YXJ0cyByZXR1cm5pbmcgZmFsc2VcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyB0aGF0IHdlIGFsd2F5cyByZXR1cm4gZmFsc2UgaWZcbiAgLy8gdGhlIGVudGlyZSBidWZmZXIgaXMgbm90IGZsdXNoZWQgaW1tZWRpYXRlbHkgb24gd3JpdGUoKVxuICB2YXIgaHdtID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrO1xuICB2YXIgZGVmYXVsdEh3bSA9IG9wdGlvbnMub2JqZWN0TW9kZSA/IDE2IDogMTYgKiAxMDI0O1xuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSAoaHdtIHx8IGh3bSA9PT0gMCkgPyBod20gOiBkZWZhdWx0SHdtO1xuXG4gIC8vIG9iamVjdCBzdHJlYW0gZmxhZyB0byBpbmRpY2F0ZSB3aGV0aGVyIG9yIG5vdCB0aGlzIHN0cmVhbVxuICAvLyBjb250YWlucyBidWZmZXJzIG9yIG9iamVjdHMuXG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuXG4gIGlmIChzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXgpXG4gICAgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy53cml0YWJsZU9iamVjdE1vZGU7XG5cbiAgLy8gY2FzdCB0byBpbnRzLlxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSB+fnRoaXMuaGlnaFdhdGVyTWFyaztcblxuICB0aGlzLm5lZWREcmFpbiA9IGZhbHNlO1xuICAvLyBhdCB0aGUgc3RhcnQgb2YgY2FsbGluZyBlbmQoKVxuICB0aGlzLmVuZGluZyA9IGZhbHNlO1xuICAvLyB3aGVuIGVuZCgpIGhhcyBiZWVuIGNhbGxlZCwgYW5kIHJldHVybmVkXG4gIHRoaXMuZW5kZWQgPSBmYWxzZTtcbiAgLy8gd2hlbiAnZmluaXNoJyBpcyBlbWl0dGVkXG4gIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcblxuICAvLyBzaG91bGQgd2UgZGVjb2RlIHN0cmluZ3MgaW50byBidWZmZXJzIGJlZm9yZSBwYXNzaW5nIHRvIF93cml0ZT9cbiAgLy8gdGhpcyBpcyBoZXJlIHNvIHRoYXQgc29tZSBub2RlLWNvcmUgc3RyZWFtcyBjYW4gb3B0aW1pemUgc3RyaW5nXG4gIC8vIGhhbmRsaW5nIGF0IGEgbG93ZXIgbGV2ZWwuXG4gIHZhciBub0RlY29kZSA9IG9wdGlvbnMuZGVjb2RlU3RyaW5ncyA9PT0gZmFsc2U7XG4gIHRoaXMuZGVjb2RlU3RyaW5ncyA9ICFub0RlY29kZTtcblxuICAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JztcblxuICAvLyBub3QgYW4gYWN0dWFsIGJ1ZmZlciB3ZSBrZWVwIHRyYWNrIG9mLCBidXQgYSBtZWFzdXJlbWVudFxuICAvLyBvZiBob3cgbXVjaCB3ZSdyZSB3YWl0aW5nIHRvIGdldCBwdXNoZWQgdG8gc29tZSB1bmRlcmx5aW5nXG4gIC8vIHNvY2tldCBvciBmaWxlLlxuICB0aGlzLmxlbmd0aCA9IDA7XG5cbiAgLy8gYSBmbGFnIHRvIHNlZSB3aGVuIHdlJ3JlIGluIHRoZSBtaWRkbGUgb2YgYSB3cml0ZS5cbiAgdGhpcy53cml0aW5nID0gZmFsc2U7XG5cbiAgLy8gd2hlbiB0cnVlIGFsbCB3cml0ZXMgd2lsbCBiZSBidWZmZXJlZCB1bnRpbCAudW5jb3JrKCkgY2FsbFxuICB0aGlzLmNvcmtlZCA9IDA7XG5cbiAgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgb253cml0ZSBjYiBpcyBjYWxsZWQgaW1tZWRpYXRlbHksXG4gIC8vIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2UgYW55XG4gIC8vIGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHdyaXRlIGNhbGwuXG4gIHRoaXMuc3luYyA9IHRydWU7XG5cbiAgLy8gYSBmbGFnIHRvIGtub3cgaWYgd2UncmUgcHJvY2Vzc2luZyBwcmV2aW91c2x5IGJ1ZmZlcmVkIGl0ZW1zLCB3aGljaFxuICAvLyBtYXkgY2FsbCB0aGUgX3dyaXRlKCkgY2FsbGJhY2sgaW4gdGhlIHNhbWUgdGljaywgc28gdGhhdCB3ZSBkb24ndFxuICAvLyBlbmQgdXAgaW4gYW4gb3ZlcmxhcHBlZCBvbndyaXRlIHNpdHVhdGlvbi5cbiAgdGhpcy5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7XG5cbiAgLy8gdGhlIGNhbGxiYWNrIHRoYXQncyBwYXNzZWQgdG8gX3dyaXRlKGNodW5rLGNiKVxuICB0aGlzLm9ud3JpdGUgPSBmdW5jdGlvbihlcikge1xuICAgIG9ud3JpdGUoc3RyZWFtLCBlcik7XG4gIH07XG5cbiAgLy8gdGhlIGNhbGxiYWNrIHRoYXQgdGhlIHVzZXIgc3VwcGxpZXMgdG8gd3JpdGUoY2h1bmssZW5jb2RpbmcsY2IpXG4gIHRoaXMud3JpdGVjYiA9IG51bGw7XG5cbiAgLy8gdGhlIGFtb3VudCB0aGF0IGlzIGJlaW5nIHdyaXR0ZW4gd2hlbiBfd3JpdGUgaXMgY2FsbGVkLlxuICB0aGlzLndyaXRlbGVuID0gMDtcblxuICB0aGlzLmJ1ZmZlciA9IFtdO1xuXG4gIC8vIG51bWJlciBvZiBwZW5kaW5nIHVzZXItc3VwcGxpZWQgd3JpdGUgY2FsbGJhY2tzXG4gIC8vIHRoaXMgbXVzdCBiZSAwIGJlZm9yZSAnZmluaXNoJyBjYW4gYmUgZW1pdHRlZFxuICB0aGlzLnBlbmRpbmdjYiA9IDA7XG5cbiAgLy8gZW1pdCBwcmVmaW5pc2ggaWYgdGhlIG9ubHkgdGhpbmcgd2UncmUgd2FpdGluZyBmb3IgaXMgX3dyaXRlIGNic1xuICAvLyBUaGlzIGlzIHJlbGV2YW50IGZvciBzeW5jaHJvbm91cyBUcmFuc2Zvcm0gc3RyZWFtc1xuICB0aGlzLnByZWZpbmlzaGVkID0gZmFsc2U7XG5cbiAgLy8gVHJ1ZSBpZiB0aGUgZXJyb3Igd2FzIGFscmVhZHkgZW1pdHRlZCBhbmQgc2hvdWxkIG5vdCBiZSB0aHJvd24gYWdhaW5cbiAgdGhpcy5lcnJvckVtaXR0ZWQgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gV3JpdGFibGUob3B0aW9ucykge1xuICB2YXIgRHVwbGV4ID0gcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIC8vIFdyaXRhYmxlIGN0b3IgaXMgYXBwbGllZCB0byBEdXBsZXhlcywgdGhvdWdoIHRoZXkncmUgbm90XG4gIC8vIGluc3RhbmNlb2YgV3JpdGFibGUsIHRoZXkncmUgaW5zdGFuY2VvZiBSZWFkYWJsZS5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFdyaXRhYmxlKSAmJiAhKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKVxuICAgIHJldHVybiBuZXcgV3JpdGFibGUob3B0aW9ucyk7XG5cbiAgdGhpcy5fd3JpdGFibGVTdGF0ZSA9IG5ldyBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMpO1xuXG4gIC8vIGxlZ2FjeS5cbiAgdGhpcy53cml0YWJsZSA9IHRydWU7XG5cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59XG5cbi8vIE90aGVyd2lzZSBwZW9wbGUgY2FuIHBpcGUgV3JpdGFibGUgc3RyZWFtcywgd2hpY2ggaXMganVzdCB3cm9uZy5cbldyaXRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0Nhbm5vdCBwaXBlLiBOb3QgcmVhZGFibGUuJykpO1xufTtcblxuXG5mdW5jdGlvbiB3cml0ZUFmdGVyRW5kKHN0cmVhbSwgc3RhdGUsIGNiKSB7XG4gIHZhciBlciA9IG5ldyBFcnJvcignd3JpdGUgYWZ0ZXIgZW5kJyk7XG4gIC8vIFRPRE86IGRlZmVyIGVycm9yIGV2ZW50cyBjb25zaXN0ZW50bHkgZXZlcnl3aGVyZSwgbm90IGp1c3QgdGhlIGNiXG4gIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICBjYihlcik7XG4gIH0pO1xufVxuXG4vLyBJZiB3ZSBnZXQgc29tZXRoaW5nIHRoYXQgaXMgbm90IGEgYnVmZmVyLCBzdHJpbmcsIG51bGwsIG9yIHVuZGVmaW5lZCxcbi8vIGFuZCB3ZSdyZSBub3QgaW4gb2JqZWN0TW9kZSwgdGhlbiB0aGF0J3MgYW4gZXJyb3IuXG4vLyBPdGhlcndpc2Ugc3RyZWFtIGNodW5rcyBhcmUgYWxsIGNvbnNpZGVyZWQgdG8gYmUgb2YgbGVuZ3RoPTEsIGFuZCB0aGVcbi8vIHdhdGVybWFya3MgZGV0ZXJtaW5lIGhvdyBtYW55IG9iamVjdHMgdG8ga2VlcCBpbiB0aGUgYnVmZmVyLCByYXRoZXIgdGhhblxuLy8gaG93IG1hbnkgYnl0ZXMgb3IgY2hhcmFjdGVycy5cbmZ1bmN0aW9uIHZhbGlkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGNiKSB7XG4gIHZhciB2YWxpZCA9IHRydWU7XG4gIGlmICghdXRpbC5pc0J1ZmZlcihjaHVuaykgJiZcbiAgICAgICF1dGlsLmlzU3RyaW5nKGNodW5rKSAmJlxuICAgICAgIXV0aWwuaXNOdWxsT3JVbmRlZmluZWQoY2h1bmspICYmXG4gICAgICAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIHZhciBlciA9IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbm9uLXN0cmluZy9idWZmZXIgY2h1bmsnKTtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgIGNiKGVyKTtcbiAgICB9KTtcbiAgICB2YWxpZCA9IGZhbHNlO1xuICB9XG4gIHJldHVybiB2YWxpZDtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuICB2YXIgcmV0ID0gZmFsc2U7XG5cbiAgaWYgKHV0aWwuaXNGdW5jdGlvbihlbmNvZGluZykpIHtcbiAgICBjYiA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGlmICh1dGlsLmlzQnVmZmVyKGNodW5rKSlcbiAgICBlbmNvZGluZyA9ICdidWZmZXInO1xuICBlbHNlIGlmICghZW5jb2RpbmcpXG4gICAgZW5jb2RpbmcgPSBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG5cbiAgaWYgKCF1dGlsLmlzRnVuY3Rpb24oY2IpKVxuICAgIGNiID0gZnVuY3Rpb24oKSB7fTtcblxuICBpZiAoc3RhdGUuZW5kZWQpXG4gICAgd3JpdGVBZnRlckVuZCh0aGlzLCBzdGF0ZSwgY2IpO1xuICBlbHNlIGlmICh2YWxpZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgY2IpKSB7XG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgcmV0ID0gd3JpdGVPckJ1ZmZlcih0aGlzLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLmNvcmsgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBzdGF0ZS5jb3JrZWQrKztcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS51bmNvcmsgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkLS07XG5cbiAgICBpZiAoIXN0YXRlLndyaXRpbmcgJiZcbiAgICAgICAgIXN0YXRlLmNvcmtlZCAmJlxuICAgICAgICAhc3RhdGUuZmluaXNoZWQgJiZcbiAgICAgICAgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiZcbiAgICAgICAgc3RhdGUuYnVmZmVyLmxlbmd0aClcbiAgICAgIGNsZWFyQnVmZmVyKHRoaXMsIHN0YXRlKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZykge1xuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiZcbiAgICAgIHN0YXRlLmRlY29kZVN0cmluZ3MgIT09IGZhbHNlICYmXG4gICAgICB1dGlsLmlzU3RyaW5nKGNodW5rKSkge1xuICAgIGNodW5rID0gbmV3IEJ1ZmZlcihjaHVuaywgZW5jb2RpbmcpO1xuICB9XG4gIHJldHVybiBjaHVuaztcbn1cblxuLy8gaWYgd2UncmUgYWxyZWFkeSB3cml0aW5nIHNvbWV0aGluZywgdGhlbiBqdXN0IHB1dCB0aGlzXG4vLyBpbiB0aGUgcXVldWUsIGFuZCB3YWl0IG91ciB0dXJuLiAgT3RoZXJ3aXNlLCBjYWxsIF93cml0ZVxuLy8gSWYgd2UgcmV0dXJuIGZhbHNlLCB0aGVuIHdlIG5lZWQgYSBkcmFpbiBldmVudCwgc28gc2V0IHRoYXQgZmxhZy5cbmZ1bmN0aW9uIHdyaXRlT3JCdWZmZXIoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjaHVuayA9IGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpO1xuICBpZiAodXRpbC5pc0J1ZmZlcihjaHVuaykpXG4gICAgZW5jb2RpbmcgPSAnYnVmZmVyJztcbiAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuXG4gIHN0YXRlLmxlbmd0aCArPSBsZW47XG5cbiAgdmFyIHJldCA9IHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIC8vIHdlIG11c3QgZW5zdXJlIHRoYXQgcHJldmlvdXMgbmVlZERyYWluIHdpbGwgbm90IGJlIHJlc2V0IHRvIGZhbHNlLlxuICBpZiAoIXJldClcbiAgICBzdGF0ZS5uZWVkRHJhaW4gPSB0cnVlO1xuXG4gIGlmIChzdGF0ZS53cml0aW5nIHx8IHN0YXRlLmNvcmtlZClcbiAgICBzdGF0ZS5idWZmZXIucHVzaChuZXcgV3JpdGVSZXEoY2h1bmssIGVuY29kaW5nLCBjYikpO1xuICBlbHNlXG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBmYWxzZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcblxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHdyaXRldiwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHN0YXRlLndyaXRlbGVuID0gbGVuO1xuICBzdGF0ZS53cml0ZWNiID0gY2I7XG4gIHN0YXRlLndyaXRpbmcgPSB0cnVlO1xuICBzdGF0ZS5zeW5jID0gdHJ1ZTtcbiAgaWYgKHdyaXRldilcbiAgICBzdHJlYW0uX3dyaXRldihjaHVuaywgc3RhdGUub253cml0ZSk7XG4gIGVsc2VcbiAgICBzdHJlYW0uX3dyaXRlKGNodW5rLCBlbmNvZGluZywgc3RhdGUub253cml0ZSk7XG4gIHN0YXRlLnN5bmMgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYikge1xuICBpZiAoc3luYylcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgc3RhdGUucGVuZGluZ2NiLS07XG4gICAgICBjYihlcik7XG4gICAgfSk7XG4gIGVsc2Uge1xuICAgIHN0YXRlLnBlbmRpbmdjYi0tO1xuICAgIGNiKGVyKTtcbiAgfVxuXG4gIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSkge1xuICBzdGF0ZS53cml0aW5nID0gZmFsc2U7XG4gIHN0YXRlLndyaXRlY2IgPSBudWxsO1xuICBzdGF0ZS5sZW5ndGggLT0gc3RhdGUud3JpdGVsZW47XG4gIHN0YXRlLndyaXRlbGVuID0gMDtcbn1cblxuZnVuY3Rpb24gb253cml0ZShzdHJlYW0sIGVyKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHN5bmMgPSBzdGF0ZS5zeW5jO1xuICB2YXIgY2IgPSBzdGF0ZS53cml0ZWNiO1xuXG4gIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSk7XG5cbiAgaWYgKGVyKVxuICAgIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpO1xuICBlbHNlIHtcbiAgICAvLyBDaGVjayBpZiB3ZSdyZSBhY3R1YWxseSByZWFkeSB0byBmaW5pc2gsIGJ1dCBkb24ndCBlbWl0IHlldFxuICAgIHZhciBmaW5pc2hlZCA9IG5lZWRGaW5pc2goc3RyZWFtLCBzdGF0ZSk7XG5cbiAgICBpZiAoIWZpbmlzaGVkICYmXG4gICAgICAgICFzdGF0ZS5jb3JrZWQgJiZcbiAgICAgICAgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiZcbiAgICAgICAgc3RhdGUuYnVmZmVyLmxlbmd0aCkge1xuICAgICAgY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuXG4gICAgaWYgKHN5bmMpIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICAgIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKSB7XG4gIGlmICghZmluaXNoZWQpXG4gICAgb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpO1xuICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgY2IoKTtcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG59XG5cbi8vIE11c3QgZm9yY2UgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIG9uIG5leHRUaWNrLCBzbyB0aGF0IHdlIGRvbid0XG4vLyBlbWl0ICdkcmFpbicgYmVmb3JlIHRoZSB3cml0ZSgpIGNvbnN1bWVyIGdldHMgdGhlICdmYWxzZScgcmV0dXJuXG4vLyB2YWx1ZSwgYW5kIGhhcyBhIGNoYW5jZSB0byBhdHRhY2ggYSAnZHJhaW4nIGxpc3RlbmVyLlxuZnVuY3Rpb24gb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5uZWVkRHJhaW4pIHtcbiAgICBzdGF0ZS5uZWVkRHJhaW4gPSBmYWxzZTtcbiAgICBzdHJlYW0uZW1pdCgnZHJhaW4nKTtcbiAgfVxufVxuXG5cbi8vIGlmIHRoZXJlJ3Mgc29tZXRoaW5nIGluIHRoZSBidWZmZXIgd2FpdGluZywgdGhlbiBwcm9jZXNzIGl0XG5mdW5jdGlvbiBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKSB7XG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSB0cnVlO1xuXG4gIGlmIChzdHJlYW0uX3dyaXRldiAmJiBzdGF0ZS5idWZmZXIubGVuZ3RoID4gMSkge1xuICAgIC8vIEZhc3QgY2FzZSwgd3JpdGUgZXZlcnl0aGluZyB1c2luZyBfd3JpdGV2KClcbiAgICB2YXIgY2JzID0gW107XG4gICAgZm9yICh2YXIgYyA9IDA7IGMgPCBzdGF0ZS5idWZmZXIubGVuZ3RoOyBjKyspXG4gICAgICBjYnMucHVzaChzdGF0ZS5idWZmZXJbY10uY2FsbGJhY2spO1xuXG4gICAgLy8gY291bnQgdGhlIG9uZSB3ZSBhcmUgYWRkaW5nLCBhcyB3ZWxsLlxuICAgIC8vIFRPRE8oaXNhYWNzKSBjbGVhbiB0aGlzIHVwXG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB0cnVlLCBzdGF0ZS5sZW5ndGgsIHN0YXRlLmJ1ZmZlciwgJycsIGZ1bmN0aW9uKGVycikge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc3RhdGUucGVuZGluZ2NiLS07XG4gICAgICAgIGNic1tpXShlcnIpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gQ2xlYXIgYnVmZmVyXG4gICAgc3RhdGUuYnVmZmVyID0gW107XG4gIH0gZWxzZSB7XG4gICAgLy8gU2xvdyBjYXNlLCB3cml0ZSBjaHVua3Mgb25lLWJ5LW9uZVxuICAgIGZvciAodmFyIGMgPSAwOyBjIDwgc3RhdGUuYnVmZmVyLmxlbmd0aDsgYysrKSB7XG4gICAgICB2YXIgZW50cnkgPSBzdGF0ZS5idWZmZXJbY107XG4gICAgICB2YXIgY2h1bmsgPSBlbnRyeS5jaHVuaztcbiAgICAgIHZhciBlbmNvZGluZyA9IGVudHJ5LmVuY29kaW5nO1xuICAgICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG5cbiAgICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG5cbiAgICAgIC8vIGlmIHdlIGRpZG4ndCBjYWxsIHRoZSBvbndyaXRlIGltbWVkaWF0ZWx5LCB0aGVuXG4gICAgICAvLyBpdCBtZWFucyB0aGF0IHdlIG5lZWQgdG8gd2FpdCB1bnRpbCBpdCBkb2VzLlxuICAgICAgLy8gYWxzbywgdGhhdCBtZWFucyB0aGF0IHRoZSBjaHVuayBhbmQgY2IgYXJlIGN1cnJlbnRseVxuICAgICAgLy8gYmVpbmcgcHJvY2Vzc2VkLCBzbyBtb3ZlIHRoZSBidWZmZXIgY291bnRlciBwYXN0IHRoZW0uXG4gICAgICBpZiAoc3RhdGUud3JpdGluZykge1xuICAgICAgICBjKys7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjIDwgc3RhdGUuYnVmZmVyLmxlbmd0aClcbiAgICAgIHN0YXRlLmJ1ZmZlciA9IHN0YXRlLmJ1ZmZlci5zbGljZShjKTtcbiAgICBlbHNlXG4gICAgICBzdGF0ZS5idWZmZXIubGVuZ3RoID0gMDtcbiAgfVxuXG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKSk7XG5cbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGV2ID0gbnVsbDtcblxuV3JpdGFibGUucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAodXRpbC5pc0Z1bmN0aW9uKGNodW5rKSkge1xuICAgIGNiID0gY2h1bms7XG4gICAgY2h1bmsgPSBudWxsO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfSBlbHNlIGlmICh1dGlsLmlzRnVuY3Rpb24oZW5jb2RpbmcpKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAoIXV0aWwuaXNOdWxsT3JVbmRlZmluZWQoY2h1bmspKVxuICAgIHRoaXMud3JpdGUoY2h1bmssIGVuY29kaW5nKTtcblxuICAvLyAuZW5kKCkgZnVsbHkgdW5jb3Jrc1xuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkID0gMTtcbiAgICB0aGlzLnVuY29yaygpO1xuICB9XG5cbiAgLy8gaWdub3JlIHVubmVjZXNzYXJ5IGVuZCgpIGNhbGxzLlxuICBpZiAoIXN0YXRlLmVuZGluZyAmJiAhc3RhdGUuZmluaXNoZWQpXG4gICAgZW5kV3JpdGFibGUodGhpcywgc3RhdGUsIGNiKTtcbn07XG5cblxuZnVuY3Rpb24gbmVlZEZpbmlzaChzdHJlYW0sIHN0YXRlKSB7XG4gIHJldHVybiAoc3RhdGUuZW5kaW5nICYmXG4gICAgICAgICAgc3RhdGUubGVuZ3RoID09PSAwICYmXG4gICAgICAgICAgIXN0YXRlLmZpbmlzaGVkICYmXG4gICAgICAgICAgIXN0YXRlLndyaXRpbmcpO1xufVxuXG5mdW5jdGlvbiBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnByZWZpbmlzaGVkKSB7XG4gICAgc3RhdGUucHJlZmluaXNoZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5lbWl0KCdwcmVmaW5pc2gnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBuZWVkID0gbmVlZEZpbmlzaChzdHJlYW0sIHN0YXRlKTtcbiAgaWYgKG5lZWQpIHtcbiAgICBpZiAoc3RhdGUucGVuZGluZ2NiID09PSAwKSB7XG4gICAgICBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSk7XG4gICAgICBzdGF0ZS5maW5pc2hlZCA9IHRydWU7XG4gICAgICBzdHJlYW0uZW1pdCgnZmluaXNoJyk7XG4gICAgfSBlbHNlXG4gICAgICBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbiAgcmV0dXJuIG5lZWQ7XG59XG5cbmZ1bmN0aW9uIGVuZFdyaXRhYmxlKHN0cmVhbSwgc3RhdGUsIGNiKSB7XG4gIHN0YXRlLmVuZGluZyA9IHRydWU7XG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICBpZiAoY2IpIHtcbiAgICBpZiAoc3RhdGUuZmluaXNoZWQpXG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGNiKTtcbiAgICBlbHNlXG4gICAgICBzdHJlYW0ub25jZSgnZmluaXNoJywgY2IpO1xuICB9XG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcbn1cbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBOT1RFOiBUaGVzZSB0eXBlIGNoZWNraW5nIGZ1bmN0aW9ucyBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBgaW5zdGFuY2VvZmBcbi8vIGJlY2F1c2UgaXQgaXMgZnJhZ2lsZSBhbmQgY2FuIGJlIGVhc2lseSBmYWtlZCB3aXRoIGBPYmplY3QuY3JlYXRlKClgLlxuZnVuY3Rpb24gaXNBcnJheShhcikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShhcik7XG59XG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuXG5mdW5jdGlvbiBpc0Jvb2xlYW4oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnYm9vbGVhbic7XG59XG5leHBvcnRzLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcblxuZnVuY3Rpb24gaXNOdWxsKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGwgPSBpc051bGw7XG5cbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gaXNOdWxsT3JVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5leHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZyc7XG59XG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XG5cbmZ1bmN0aW9uIGlzU3ltYm9sKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCc7XG59XG5leHBvcnRzLmlzU3ltYm9sID0gaXNTeW1ib2w7XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG5leHBvcnRzLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzUmVnRXhwKHJlKSB7XG4gIHJldHVybiBpc09iamVjdChyZSkgJiYgb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbmV4cG9ydHMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIHJldHVybiBpc09iamVjdChkKSAmJiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XG5cbmZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuICByZXR1cm4gaXNPYmplY3QoZSkgJiZcbiAgICAgIChvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB8fCBlIGluc3RhbmNlb2YgRXJyb3IpO1xufVxuZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnIHx8ICAvLyBFUzYgc3ltYm9sXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJztcbn1cbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcblxuZnVuY3Rpb24gaXNCdWZmZXIoYXJnKSB7XG4gIHJldHVybiBCdWZmZXIuaXNCdWZmZXIoYXJnKTtcbn1cbmV4cG9ydHMuaXNCdWZmZXIgPSBpc0J1ZmZlcjtcblxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufSIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanNcIilcbiIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fcmVhZGFibGUuanMnKTtcbmV4cG9ydHMuU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJyk7XG5leHBvcnRzLlJlYWRhYmxlID0gZXhwb3J0cztcbmV4cG9ydHMuV3JpdGFibGUgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzJyk7XG5leHBvcnRzLkR1cGxleCA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fZHVwbGV4LmpzJyk7XG5leHBvcnRzLlRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzJyk7XG5leHBvcnRzLlBhc3NUaHJvdWdoID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qcycpO1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanNcIilcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vbGliL19zdHJlYW1fd3JpdGFibGUuanNcIilcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5tb2R1bGUuZXhwb3J0cyA9IFN0cmVhbTtcblxudmFyIEVFID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxuaW5oZXJpdHMoU3RyZWFtLCBFRSk7XG5TdHJlYW0uUmVhZGFibGUgPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vcmVhZGFibGUuanMnKTtcblN0cmVhbS5Xcml0YWJsZSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS93cml0YWJsZS5qcycpO1xuU3RyZWFtLkR1cGxleCA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS9kdXBsZXguanMnKTtcblN0cmVhbS5UcmFuc2Zvcm0gPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vdHJhbnNmb3JtLmpzJyk7XG5TdHJlYW0uUGFzc1Rocm91Z2ggPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vcGFzc3Rocm91Z2guanMnKTtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC40LnhcblN0cmVhbS5TdHJlYW0gPSBTdHJlYW07XG5cblxuXG4vLyBvbGQtc3R5bGUgc3RyZWFtcy4gIE5vdGUgdGhhdCB0aGUgcGlwZSBtZXRob2QgKHRoZSBvbmx5IHJlbGV2YW50XG4vLyBwYXJ0IG9mIHRoaXMgY2xhc3MpIGlzIG92ZXJyaWRkZW4gaW4gdGhlIFJlYWRhYmxlIGNsYXNzLlxuXG5mdW5jdGlvbiBTdHJlYW0oKSB7XG4gIEVFLmNhbGwodGhpcyk7XG59XG5cblN0cmVhbS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uKGRlc3QsIG9wdGlvbnMpIHtcbiAgdmFyIHNvdXJjZSA9IHRoaXM7XG5cbiAgZnVuY3Rpb24gb25kYXRhKGNodW5rKSB7XG4gICAgaWYgKGRlc3Qud3JpdGFibGUpIHtcbiAgICAgIGlmIChmYWxzZSA9PT0gZGVzdC53cml0ZShjaHVuaykgJiYgc291cmNlLnBhdXNlKSB7XG4gICAgICAgIHNvdXJjZS5wYXVzZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHNvdXJjZS5vbignZGF0YScsIG9uZGF0YSk7XG5cbiAgZnVuY3Rpb24gb25kcmFpbigpIHtcbiAgICBpZiAoc291cmNlLnJlYWRhYmxlICYmIHNvdXJjZS5yZXN1bWUpIHtcbiAgICAgIHNvdXJjZS5yZXN1bWUoKTtcbiAgICB9XG4gIH1cblxuICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gIC8vIElmIHRoZSAnZW5kJyBvcHRpb24gaXMgbm90IHN1cHBsaWVkLCBkZXN0LmVuZCgpIHdpbGwgYmUgY2FsbGVkIHdoZW5cbiAgLy8gc291cmNlIGdldHMgdGhlICdlbmQnIG9yICdjbG9zZScgZXZlbnRzLiAgT25seSBkZXN0LmVuZCgpIG9uY2UuXG4gIGlmICghZGVzdC5faXNTdGRpbyAmJiAoIW9wdGlvbnMgfHwgb3B0aW9ucy5lbmQgIT09IGZhbHNlKSkge1xuICAgIHNvdXJjZS5vbignZW5kJywgb25lbmQpO1xuICAgIHNvdXJjZS5vbignY2xvc2UnLCBvbmNsb3NlKTtcbiAgfVxuXG4gIHZhciBkaWRPbkVuZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBvbmVuZCgpIHtcbiAgICBpZiAoZGlkT25FbmQpIHJldHVybjtcbiAgICBkaWRPbkVuZCA9IHRydWU7XG5cbiAgICBkZXN0LmVuZCgpO1xuICB9XG5cblxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIGlmIChkaWRPbkVuZCkgcmV0dXJuO1xuICAgIGRpZE9uRW5kID0gdHJ1ZTtcblxuICAgIGlmICh0eXBlb2YgZGVzdC5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSBkZXN0LmRlc3Ryb3koKTtcbiAgfVxuXG4gIC8vIGRvbid0IGxlYXZlIGRhbmdsaW5nIHBpcGVzIHdoZW4gdGhlcmUgYXJlIGVycm9ycy5cbiAgZnVuY3Rpb24gb25lcnJvcihlcikge1xuICAgIGNsZWFudXAoKTtcbiAgICBpZiAoRUUubGlzdGVuZXJDb3VudCh0aGlzLCAnZXJyb3InKSA9PT0gMCkge1xuICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCBzdHJlYW0gZXJyb3IgaW4gcGlwZS5cbiAgICB9XG4gIH1cblxuICBzb3VyY2Uub24oJ2Vycm9yJywgb25lcnJvcik7XG4gIGRlc3Qub24oJ2Vycm9yJywgb25lcnJvcik7XG5cbiAgLy8gcmVtb3ZlIGFsbCB0aGUgZXZlbnQgbGlzdGVuZXJzIHRoYXQgd2VyZSBhZGRlZC5cbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgb25kcmFpbik7XG5cbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTtcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG5cbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcblxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZW5kJywgY2xlYW51cCk7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIGNsZWFudXApO1xuXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBjbGVhbnVwKTtcbiAgfVxuXG4gIHNvdXJjZS5vbignZW5kJywgY2xlYW51cCk7XG4gIHNvdXJjZS5vbignY2xvc2UnLCBjbGVhbnVwKTtcblxuICBkZXN0Lm9uKCdjbG9zZScsIGNsZWFudXApO1xuXG4gIGRlc3QuZW1pdCgncGlwZScsIHNvdXJjZSk7XG5cbiAgLy8gQWxsb3cgZm9yIHVuaXgtbGlrZSB1c2FnZTogQS5waXBlKEIpLnBpcGUoQylcbiAgcmV0dXJuIGRlc3Q7XG59O1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG5cbnZhciBpc0J1ZmZlckVuY29kaW5nID0gQnVmZmVyLmlzRW5jb2RpbmdcbiAgfHwgZnVuY3Rpb24oZW5jb2RpbmcpIHtcbiAgICAgICBzd2l0Y2ggKGVuY29kaW5nICYmIGVuY29kaW5nLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgIGNhc2UgJ2hleCc6IGNhc2UgJ3V0ZjgnOiBjYXNlICd1dGYtOCc6IGNhc2UgJ2FzY2lpJzogY2FzZSAnYmluYXJ5JzogY2FzZSAnYmFzZTY0JzogY2FzZSAndWNzMic6IGNhc2UgJ3Vjcy0yJzogY2FzZSAndXRmMTZsZSc6IGNhc2UgJ3V0Zi0xNmxlJzogY2FzZSAncmF3JzogcmV0dXJuIHRydWU7XG4gICAgICAgICBkZWZhdWx0OiByZXR1cm4gZmFsc2U7XG4gICAgICAgfVxuICAgICB9XG5cblxuZnVuY3Rpb24gYXNzZXJ0RW5jb2RpbmcoZW5jb2RpbmcpIHtcbiAgaWYgKGVuY29kaW5nICYmICFpc0J1ZmZlckVuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKTtcbiAgfVxufVxuXG4vLyBTdHJpbmdEZWNvZGVyIHByb3ZpZGVzIGFuIGludGVyZmFjZSBmb3IgZWZmaWNpZW50bHkgc3BsaXR0aW5nIGEgc2VyaWVzIG9mXG4vLyBidWZmZXJzIGludG8gYSBzZXJpZXMgb2YgSlMgc3RyaW5ncyB3aXRob3V0IGJyZWFraW5nIGFwYXJ0IG11bHRpLWJ5dGVcbi8vIGNoYXJhY3RlcnMuIENFU1UtOCBpcyBoYW5kbGVkIGFzIHBhcnQgb2YgdGhlIFVURi04IGVuY29kaW5nLlxuLy9cbi8vIEBUT0RPIEhhbmRsaW5nIGFsbCBlbmNvZGluZ3MgaW5zaWRlIGEgc2luZ2xlIG9iamVjdCBtYWtlcyBpdCB2ZXJ5IGRpZmZpY3VsdFxuLy8gdG8gcmVhc29uIGFib3V0IHRoaXMgY29kZSwgc28gaXQgc2hvdWxkIGJlIHNwbGl0IHVwIGluIHRoZSBmdXR1cmUuXG4vLyBAVE9ETyBUaGVyZSBzaG91bGQgYmUgYSB1dGY4LXN0cmljdCBlbmNvZGluZyB0aGF0IHJlamVjdHMgaW52YWxpZCBVVEYtOCBjb2RlXG4vLyBwb2ludHMgYXMgdXNlZCBieSBDRVNVLTguXG52YXIgU3RyaW5nRGVjb2RlciA9IGV4cG9ydHMuU3RyaW5nRGVjb2RlciA9IGZ1bmN0aW9uKGVuY29kaW5nKSB7XG4gIHRoaXMuZW5jb2RpbmcgPSAoZW5jb2RpbmcgfHwgJ3V0ZjgnKS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1stX10vLCAnJyk7XG4gIGFzc2VydEVuY29kaW5nKGVuY29kaW5nKTtcbiAgc3dpdGNoICh0aGlzLmVuY29kaW5nKSB7XG4gICAgY2FzZSAndXRmOCc6XG4gICAgICAvLyBDRVNVLTggcmVwcmVzZW50cyBlYWNoIG9mIFN1cnJvZ2F0ZSBQYWlyIGJ5IDMtYnl0ZXNcbiAgICAgIHRoaXMuc3Vycm9nYXRlU2l6ZSA9IDM7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIC8vIFVURi0xNiByZXByZXNlbnRzIGVhY2ggb2YgU3Vycm9nYXRlIFBhaXIgYnkgMi1ieXRlc1xuICAgICAgdGhpcy5zdXJyb2dhdGVTaXplID0gMjtcbiAgICAgIHRoaXMuZGV0ZWN0SW5jb21wbGV0ZUNoYXIgPSB1dGYxNkRldGVjdEluY29tcGxldGVDaGFyO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIC8vIEJhc2UtNjQgc3RvcmVzIDMgYnl0ZXMgaW4gNCBjaGFycywgYW5kIHBhZHMgdGhlIHJlbWFpbmRlci5cbiAgICAgIHRoaXMuc3Vycm9nYXRlU2l6ZSA9IDM7XG4gICAgICB0aGlzLmRldGVjdEluY29tcGxldGVDaGFyID0gYmFzZTY0RGV0ZWN0SW5jb21wbGV0ZUNoYXI7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhpcy53cml0ZSA9IHBhc3NUaHJvdWdoV3JpdGU7XG4gICAgICByZXR1cm47XG4gIH1cblxuICAvLyBFbm91Z2ggc3BhY2UgdG8gc3RvcmUgYWxsIGJ5dGVzIG9mIGEgc2luZ2xlIGNoYXJhY3Rlci4gVVRGLTggbmVlZHMgNFxuICAvLyBieXRlcywgYnV0IENFU1UtOCBtYXkgcmVxdWlyZSB1cCB0byA2ICgzIGJ5dGVzIHBlciBzdXJyb2dhdGUpLlxuICB0aGlzLmNoYXJCdWZmZXIgPSBuZXcgQnVmZmVyKDYpO1xuICAvLyBOdW1iZXIgb2YgYnl0ZXMgcmVjZWl2ZWQgZm9yIHRoZSBjdXJyZW50IGluY29tcGxldGUgbXVsdGktYnl0ZSBjaGFyYWN0ZXIuXG4gIHRoaXMuY2hhclJlY2VpdmVkID0gMDtcbiAgLy8gTnVtYmVyIG9mIGJ5dGVzIGV4cGVjdGVkIGZvciB0aGUgY3VycmVudCBpbmNvbXBsZXRlIG11bHRpLWJ5dGUgY2hhcmFjdGVyLlxuICB0aGlzLmNoYXJMZW5ndGggPSAwO1xufTtcblxuXG4vLyB3cml0ZSBkZWNvZGVzIHRoZSBnaXZlbiBidWZmZXIgYW5kIHJldHVybnMgaXQgYXMgSlMgc3RyaW5nIHRoYXQgaXNcbi8vIGd1YXJhbnRlZWQgdG8gbm90IGNvbnRhaW4gYW55IHBhcnRpYWwgbXVsdGktYnl0ZSBjaGFyYWN0ZXJzLiBBbnkgcGFydGlhbFxuLy8gY2hhcmFjdGVyIGZvdW5kIGF0IHRoZSBlbmQgb2YgdGhlIGJ1ZmZlciBpcyBidWZmZXJlZCB1cCwgYW5kIHdpbGwgYmVcbi8vIHJldHVybmVkIHdoZW4gY2FsbGluZyB3cml0ZSBhZ2FpbiB3aXRoIHRoZSByZW1haW5pbmcgYnl0ZXMuXG4vL1xuLy8gTm90ZTogQ29udmVydGluZyBhIEJ1ZmZlciBjb250YWluaW5nIGFuIG9ycGhhbiBzdXJyb2dhdGUgdG8gYSBTdHJpbmdcbi8vIGN1cnJlbnRseSB3b3JrcywgYnV0IGNvbnZlcnRpbmcgYSBTdHJpbmcgdG8gYSBCdWZmZXIgKHZpYSBgbmV3IEJ1ZmZlcmAsIG9yXG4vLyBCdWZmZXIjd3JpdGUpIHdpbGwgcmVwbGFjZSBpbmNvbXBsZXRlIHN1cnJvZ2F0ZXMgd2l0aCB0aGUgdW5pY29kZVxuLy8gcmVwbGFjZW1lbnQgY2hhcmFjdGVyLiBTZWUgaHR0cHM6Ly9jb2RlcmV2aWV3LmNocm9taXVtLm9yZy8xMjExNzMwMDkvIC5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gIHZhciBjaGFyU3RyID0gJyc7XG4gIC8vIGlmIG91ciBsYXN0IHdyaXRlIGVuZGVkIHdpdGggYW4gaW5jb21wbGV0ZSBtdWx0aWJ5dGUgY2hhcmFjdGVyXG4gIHdoaWxlICh0aGlzLmNoYXJMZW5ndGgpIHtcbiAgICAvLyBkZXRlcm1pbmUgaG93IG1hbnkgcmVtYWluaW5nIGJ5dGVzIHRoaXMgYnVmZmVyIGhhcyB0byBvZmZlciBmb3IgdGhpcyBjaGFyXG4gICAgdmFyIGF2YWlsYWJsZSA9IChidWZmZXIubGVuZ3RoID49IHRoaXMuY2hhckxlbmd0aCAtIHRoaXMuY2hhclJlY2VpdmVkKSA/XG4gICAgICAgIHRoaXMuY2hhckxlbmd0aCAtIHRoaXMuY2hhclJlY2VpdmVkIDpcbiAgICAgICAgYnVmZmVyLmxlbmd0aDtcblxuICAgIC8vIGFkZCB0aGUgbmV3IGJ5dGVzIHRvIHRoZSBjaGFyIGJ1ZmZlclxuICAgIGJ1ZmZlci5jb3B5KHRoaXMuY2hhckJ1ZmZlciwgdGhpcy5jaGFyUmVjZWl2ZWQsIDAsIGF2YWlsYWJsZSk7XG4gICAgdGhpcy5jaGFyUmVjZWl2ZWQgKz0gYXZhaWxhYmxlO1xuXG4gICAgaWYgKHRoaXMuY2hhclJlY2VpdmVkIDwgdGhpcy5jaGFyTGVuZ3RoKSB7XG4gICAgICAvLyBzdGlsbCBub3QgZW5vdWdoIGNoYXJzIGluIHRoaXMgYnVmZmVyPyB3YWl0IGZvciBtb3JlIC4uLlxuICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIC8vIHJlbW92ZSBieXRlcyBiZWxvbmdpbmcgdG8gdGhlIGN1cnJlbnQgY2hhcmFjdGVyIGZyb20gdGhlIGJ1ZmZlclxuICAgIGJ1ZmZlciA9IGJ1ZmZlci5zbGljZShhdmFpbGFibGUsIGJ1ZmZlci5sZW5ndGgpO1xuXG4gICAgLy8gZ2V0IHRoZSBjaGFyYWN0ZXIgdGhhdCB3YXMgc3BsaXRcbiAgICBjaGFyU3RyID0gdGhpcy5jaGFyQnVmZmVyLnNsaWNlKDAsIHRoaXMuY2hhckxlbmd0aCkudG9TdHJpbmcodGhpcy5lbmNvZGluZyk7XG5cbiAgICAvLyBDRVNVLTg6IGxlYWQgc3Vycm9nYXRlIChEODAwLURCRkYpIGlzIGFsc28gdGhlIGluY29tcGxldGUgY2hhcmFjdGVyXG4gICAgdmFyIGNoYXJDb2RlID0gY2hhclN0ci5jaGFyQ29kZUF0KGNoYXJTdHIubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGNoYXJDb2RlID49IDB4RDgwMCAmJiBjaGFyQ29kZSA8PSAweERCRkYpIHtcbiAgICAgIHRoaXMuY2hhckxlbmd0aCArPSB0aGlzLnN1cnJvZ2F0ZVNpemU7XG4gICAgICBjaGFyU3RyID0gJyc7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdGhpcy5jaGFyUmVjZWl2ZWQgPSB0aGlzLmNoYXJMZW5ndGggPSAwO1xuXG4gICAgLy8gaWYgdGhlcmUgYXJlIG5vIG1vcmUgYnl0ZXMgaW4gdGhpcyBidWZmZXIsIGp1c3QgZW1pdCBvdXIgY2hhclxuICAgIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gY2hhclN0cjtcbiAgICB9XG4gICAgYnJlYWs7XG4gIH1cblxuICAvLyBkZXRlcm1pbmUgYW5kIHNldCBjaGFyTGVuZ3RoIC8gY2hhclJlY2VpdmVkXG4gIHRoaXMuZGV0ZWN0SW5jb21wbGV0ZUNoYXIoYnVmZmVyKTtcblxuICB2YXIgZW5kID0gYnVmZmVyLmxlbmd0aDtcbiAgaWYgKHRoaXMuY2hhckxlbmd0aCkge1xuICAgIC8vIGJ1ZmZlciB0aGUgaW5jb21wbGV0ZSBjaGFyYWN0ZXIgYnl0ZXMgd2UgZ290XG4gICAgYnVmZmVyLmNvcHkodGhpcy5jaGFyQnVmZmVyLCAwLCBidWZmZXIubGVuZ3RoIC0gdGhpcy5jaGFyUmVjZWl2ZWQsIGVuZCk7XG4gICAgZW5kIC09IHRoaXMuY2hhclJlY2VpdmVkO1xuICB9XG5cbiAgY2hhclN0ciArPSBidWZmZXIudG9TdHJpbmcodGhpcy5lbmNvZGluZywgMCwgZW5kKTtcblxuICB2YXIgZW5kID0gY2hhclN0ci5sZW5ndGggLSAxO1xuICB2YXIgY2hhckNvZGUgPSBjaGFyU3RyLmNoYXJDb2RlQXQoZW5kKTtcbiAgLy8gQ0VTVS04OiBsZWFkIHN1cnJvZ2F0ZSAoRDgwMC1EQkZGKSBpcyBhbHNvIHRoZSBpbmNvbXBsZXRlIGNoYXJhY3RlclxuICBpZiAoY2hhckNvZGUgPj0gMHhEODAwICYmIGNoYXJDb2RlIDw9IDB4REJGRikge1xuICAgIHZhciBzaXplID0gdGhpcy5zdXJyb2dhdGVTaXplO1xuICAgIHRoaXMuY2hhckxlbmd0aCArPSBzaXplO1xuICAgIHRoaXMuY2hhclJlY2VpdmVkICs9IHNpemU7XG4gICAgdGhpcy5jaGFyQnVmZmVyLmNvcHkodGhpcy5jaGFyQnVmZmVyLCBzaXplLCAwLCBzaXplKTtcbiAgICBidWZmZXIuY29weSh0aGlzLmNoYXJCdWZmZXIsIDAsIDAsIHNpemUpO1xuICAgIHJldHVybiBjaGFyU3RyLnN1YnN0cmluZygwLCBlbmQpO1xuICB9XG5cbiAgLy8gb3IganVzdCBlbWl0IHRoZSBjaGFyU3RyXG4gIHJldHVybiBjaGFyU3RyO1xufTtcblxuLy8gZGV0ZWN0SW5jb21wbGV0ZUNoYXIgZGV0ZXJtaW5lcyBpZiB0aGVyZSBpcyBhbiBpbmNvbXBsZXRlIFVURi04IGNoYXJhY3RlciBhdFxuLy8gdGhlIGVuZCBvZiB0aGUgZ2l2ZW4gYnVmZmVyLiBJZiBzbywgaXQgc2V0cyB0aGlzLmNoYXJMZW5ndGggdG8gdGhlIGJ5dGVcbi8vIGxlbmd0aCB0aGF0IGNoYXJhY3RlciwgYW5kIHNldHMgdGhpcy5jaGFyUmVjZWl2ZWQgdG8gdGhlIG51bWJlciBvZiBieXRlc1xuLy8gdGhhdCBhcmUgYXZhaWxhYmxlIGZvciB0aGlzIGNoYXJhY3Rlci5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLmRldGVjdEluY29tcGxldGVDaGFyID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gIC8vIGRldGVybWluZSBob3cgbWFueSBieXRlcyB3ZSBoYXZlIHRvIGNoZWNrIGF0IHRoZSBlbmQgb2YgdGhpcyBidWZmZXJcbiAgdmFyIGkgPSAoYnVmZmVyLmxlbmd0aCA+PSAzKSA/IDMgOiBidWZmZXIubGVuZ3RoO1xuXG4gIC8vIEZpZ3VyZSBvdXQgaWYgb25lIG9mIHRoZSBsYXN0IGkgYnl0ZXMgb2Ygb3VyIGJ1ZmZlciBhbm5vdW5jZXMgYW5cbiAgLy8gaW5jb21wbGV0ZSBjaGFyLlxuICBmb3IgKDsgaSA+IDA7IGktLSkge1xuICAgIHZhciBjID0gYnVmZmVyW2J1ZmZlci5sZW5ndGggLSBpXTtcblxuICAgIC8vIFNlZSBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1VURi04I0Rlc2NyaXB0aW9uXG5cbiAgICAvLyAxMTBYWFhYWFxuICAgIGlmIChpID09IDEgJiYgYyA+PiA1ID09IDB4MDYpIHtcbiAgICAgIHRoaXMuY2hhckxlbmd0aCA9IDI7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyAxMTEwWFhYWFxuICAgIGlmIChpIDw9IDIgJiYgYyA+PiA0ID09IDB4MEUpIHtcbiAgICAgIHRoaXMuY2hhckxlbmd0aCA9IDM7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyAxMTExMFhYWFxuICAgIGlmIChpIDw9IDMgJiYgYyA+PiAzID09IDB4MUUpIHtcbiAgICAgIHRoaXMuY2hhckxlbmd0aCA9IDQ7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgdGhpcy5jaGFyUmVjZWl2ZWQgPSBpO1xufTtcblxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gIHZhciByZXMgPSAnJztcbiAgaWYgKGJ1ZmZlciAmJiBidWZmZXIubGVuZ3RoKVxuICAgIHJlcyA9IHRoaXMud3JpdGUoYnVmZmVyKTtcblxuICBpZiAodGhpcy5jaGFyUmVjZWl2ZWQpIHtcbiAgICB2YXIgY3IgPSB0aGlzLmNoYXJSZWNlaXZlZDtcbiAgICB2YXIgYnVmID0gdGhpcy5jaGFyQnVmZmVyO1xuICAgIHZhciBlbmMgPSB0aGlzLmVuY29kaW5nO1xuICAgIHJlcyArPSBidWYuc2xpY2UoMCwgY3IpLnRvU3RyaW5nKGVuYyk7XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblxuZnVuY3Rpb24gcGFzc1Rocm91Z2hXcml0ZShidWZmZXIpIHtcbiAgcmV0dXJuIGJ1ZmZlci50b1N0cmluZyh0aGlzLmVuY29kaW5nKTtcbn1cblxuZnVuY3Rpb24gdXRmMTZEZXRlY3RJbmNvbXBsZXRlQ2hhcihidWZmZXIpIHtcbiAgdGhpcy5jaGFyUmVjZWl2ZWQgPSBidWZmZXIubGVuZ3RoICUgMjtcbiAgdGhpcy5jaGFyTGVuZ3RoID0gdGhpcy5jaGFyUmVjZWl2ZWQgPyAyIDogMDtcbn1cblxuZnVuY3Rpb24gYmFzZTY0RGV0ZWN0SW5jb21wbGV0ZUNoYXIoYnVmZmVyKSB7XG4gIHRoaXMuY2hhclJlY2VpdmVkID0gYnVmZmVyLmxlbmd0aCAlIDM7XG4gIHRoaXMuY2hhckxlbmd0aCA9IHRoaXMuY2hhclJlY2VpdmVkID8gMyA6IDA7XG59XG4iLCJcclxudmFyIGpzZ3VpID0gcmVxdWlyZSgnLi4vLi4vLi4vLi4vLi4vanMvd2ViL2pzZ3VpLWh0bWwtY2xpZW50Jyk7XHJcbnZhciBDbGllbnRfUGFnZV9Db250ZXh0ID0gcmVxdWlyZSgnLi4vLi4vLi4vLi4vLi4vanMvd2ViL2NsaWVudC1wYWdlLWNvbnRleHQnKTtcclxuLy92YXIgVG9nZ2xlX0J1dHRvbiA9IHJlcXVpcmUoJy4uLy4uLy4uLy4uLy4uL2pzL3dlYi9jb250cm9scy9hZHZhbmNlZC90b2dnbGUtYnV0dG9uJyk7XHJcbi8vdmFyIFN0YXJ0X1N0b3BfVG9nZ2xlX0J1dHRvbiA9IHJlcXVpcmUoJy4uLy4uLy4uLy4uLy4uL2pzL3dlYi9jb250cm9scy9hZHZhbmNlZC9zdGFydC1zdG9wLXRvZ2dsZS1idXR0b24nKTtcclxuXHJcbnZhciBlYWNoID0ganNndWkuZWFjaCwgc3RyaW5naWZ5ID0ganNndWkuc3RyaW5naWZ5O1xyXG5cclxudmFyIHBjID0gbmV3IENsaWVudF9QYWdlX0NvbnRleHQoe1xyXG4gICAgJ2RvY3VtZW50JzogZG9jdW1lbnRcclxufSk7XHJcblxyXG4vL3BjLnVwZGF0ZV9Db250cm9scygndG9nZ2xlX2J1dHRvbicsIFRvZ2dsZV9CdXR0b24pO1xyXG4vL3BjLnVwZGF0ZV9Db250cm9scygnc3RhcnRfc3RvcF90b2dnbGVfYnV0dG9uJywgU3RhcnRfU3RvcF9Ub2dnbGVfQnV0dG9uKTtcclxuXHJcblxyXG53aW5kb3cub25sb2FkID0gZnVuY3Rpb24oKSB7XHJcbiAgICBjb25zb2xlLmxvZygncHJlIGFjdGl2YXRlJyk7XHJcblxyXG4gICAganNndWkuYWN0aXZhdGUocGMpO1xyXG5cclxuXHJcbn1cclxuIiwiLypcblxuaWYgKHR5cGVvZiBkZWZpbmUgIT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgZGVmaW5lID0gcmVxdWlyZSgnYW1kZWZpbmUnKShtb2R1bGUpO1xufVxuXG5cbmRlZmluZShbXCIuL2pzZ3VpLWxhbmctZXNzZW50aWFsc1wiLCBcIi4vanNndWktZGF0YS1zdHJ1Y3R1cmVzXCIsIFwiLi9kYXRhLW9iamVjdFwiLCBcIi4vY29uc3RyYWludFwiXSwgZnVuY3Rpb24oanNndWksIERhdGFfU3RydWN0dXJlcywgRGF0YV9PYmplY3QsIENvbnN0cmFpbnQpIHtcblxuKi9cblxudmFyIGpzZ3VpID0gcmVxdWlyZSgnLi9qc2d1aS1sYW5nLWVzc2VudGlhbHMnKTtcbnZhciBEYXRhX1N0cnVjdHVyZXMgPSByZXF1aXJlKCcuL2pzZ3VpLWRhdGEtc3RydWN0dXJlcycpO1xudmFyIERhdGFfT2JqZWN0ID0gcmVxdWlyZSgnLi9kYXRhLW9iamVjdCcpO1xudmFyIENvbnN0cmFpbnQgPSByZXF1aXJlKCcuL2NvbnN0cmFpbnQnKTtcblxuXHQvLyBDb2xsZWN0aW9uLi4uIHVzZSBzbGlnbnRseSBtb3JlIHRoYW4gZXNzZW50aWFscz9cblx0Ly8gTGlrZWx5IHRvIHVzZSB0aGUgRGF0YV9PYmplY3QgY2xhc3MgaGVyZS5cblx0XG5cdC8vIERvbid0IHdhbnQgdGhpcyBzdHVmZiBncm93aW5nIG11Y2ggbW9yZSBpbiBzaXplXG5cdC8vICBUaGVyZSB3aWxsIGJlIG1vcmUgZmVhdHVyZXMsIHNob3VsZCBhZGQgdGhlbSBzcGFyaW5nbHlcblx0Ly8gICBNYXliZSBhIG1vcmUgYWR2YW5jZWQgbGF5ZXIuLi4gcmVhbGx5IGZvciB0aGUgc2VydmVyIHNpZGUgb3IgdGhlIG1vc3QgaW4tZGVwdGggYXBwbGljYXRpb25zLlxuXHQvLyAgIFdpbGwgd2FudCBzb21lIGtpbmQgb2YgbGF0ZXIgbG9hZGluZywgdGhlIGxhdGVyIGxvYWRpbmcgc3lzdGVtIGluIHRoZSBjb3JlIGxheWVyLlxuXHRcblx0Ly8gRG9uJ3QgdGhpbmsgdGhpcyBuZWVkcyBtdWNoIG1vcmUgY29kZSBhdCB0aGUgbW9tZW50LlxuXHQvLyAgSXQncyBnb3QgZmFpcmx5IGxhcmdlLlxuXHQvLyAgSXQgc2hvdWxkIGJlIGEgdmVyeSB1c2VmdWwgcGFydCBvZiB0aGUgc3lzdGVtLlxuXHRcblx0Ly8gR2xvYmFsIGNvbGxlY3Rpb24gcmVmZXJlbmNlLi4uXG5cdC8vICB3YW50IGl0IHNvIHRoYXQgYSBjb2xsZWN0aW9uIGNhbiByZWZlcmVuY2UgYW5vdGhlciBjb2xsZWN0aW9uLCBzbyB0aGF0IGV2ZXJ5IGl0ZW0gZ2V0cyBwdXQgaW50byB0aGlzIGNvbGxlY3Rpb25cblx0Ly8gICBhbHNvIGdldHMgcHV0IGludG8gdGhlIGdsb2JhbCBjb2xsZWN0aW9uLiBXaWxsIGNoZWNrIHVuaXF1ZSBjb25mbGljdHMgYXMgd2VsbC4uLiBidXQgdGhlIGdsb2JhbCBjb2xsZWN0aW9uIGNvdWxkIGhhdmUgZGlmZmVyZW50IHRoaW5ncyB0byBpbmRleCBvblxuXHRcblx0Ly8gUmVzdHJpY3Rpbmcgb2JqZWN0cyBpbiBjb2xsZWN0aW9uIGJ5IGRhdGEgdHlwZS5cblx0XG5cdC8vIENvbGxlY3Rpb24gY2FuIG9wZXJhdGUgYSBsb3QgbGlrZSBhIG5vcm1hbCBvYmplY3QgYW55d2F5IG5vdy4gSXQgY2FuIGhvbGQgb2JqZWN0cyBpbmRleGVkIGJ5IG5hbWUsIGp1c3QgbGlrZSBhIG5vcm1hbCBtYXAuXG5cdC8vICBIb3dldmVyLCB0aGUgbmFtZSBwcm9wZXJ0eSBpcyBub3cgaW50cmluc2ljIHRvIHRoYXQgb2JqZWN0IGFzIHdlbGwgYXMgc29tZXRoaW5nIHRoYXQgZ2V0cyBpbmRleGVkLlxuXHRcblx0Ly8gTmVlZCB0byBkZWFsIHdpdGggYXR0YWNoZWQgZmllbGRzLCBsaWtlIHRoaXM6XG5cdC8vIHsnYXR0YWNoZWQnOiB7J21ldGEnOiAnbmFtZSd9fVxuXG5cdHZhciBqID0ganNndWk7XG5cdHZhciBDbGFzcyA9IGouQ2xhc3M7XG5cdHZhciBlYWNoID0gai5lYWNoO1xuXHR2YXIgaXNfYXJyYXkgPSBqLmlzX2FycmF5O1xuXHR2YXIgaXNfZG9tX25vZGUgPSBqLmlzX2RvbV9ub2RlO1xuXHR2YXIgaXNfY3RybCA9IGouaXNfY3RybDtcblx0dmFyIGV4dGVuZCA9IGouZXh0ZW5kO1xuXHR2YXIgY2xvbmUgPSBqLmNsb25lO1xuXHR2YXIgeF9jbG9uZXMgPSBqLnhfY2xvbmVzO1xuXHR2YXIgZ2V0X3RydXRoX21hcF9mcm9tX2FyciA9IGouZ2V0X3RydXRoX21hcF9mcm9tX2Fycjtcblx0dmFyIGdldF9tYXBfZnJvbV9hcnIgPSBqLmdldF9tYXBfZnJvbV9hcnI7XG5cdHZhciBhcnJfbGlrZV90b19hcnIgPSBqLmFycl9saWtlX3RvX2Fycjtcblx0dmFyIHRvZiA9IGoudG9mO1xuXHR2YXIgaXNfZGVmaW5lZCA9IGouaXNfZGVmaW5lZDtcblx0dmFyIHN0cmluZ2lmeSA9IGouc3RyaW5naWZ5O1xuXHR2YXIgZnVuY3Rpb25hbF9wb2x5bW9ycGhpc20gPSBqLmZ1bmN0aW9uYWxfcG9seW1vcnBoaXNtO1xuXHR2YXIgZnAgPSBqLmZwO1xuXHR2YXIgYXJyYXlpZnkgPSBqLmFycmF5aWZ5O1xuXHR2YXIgbWFwaWZ5ID0gai5tYXBpZnk7XG5cdHZhciBhcmVfZXF1YWwgPSBqLmFyZV9lcXVhbDtcblx0dmFyIGdldF9pdGVtX3NpZyA9IGouZ2V0X2l0ZW1fc2lnO1xuXHR2YXIgc2V0X3ZhbHMgPSBqLnNldF92YWxzO1xuXHR2YXIgdHJ1dGggPSBqLnRydXRoO1xuXHR2YXIgdHJpbV9zaWdfYnJhY2tldHMgPSBqLnRyaW1fc2lnX2JyYWNrZXRzO1xuXHR2YXIgaXRlcmF0ZV9hbmNlc3Rvcl9jbGFzc2VzID0gai5pdGVyYXRlX2FuY2VzdG9yX2NsYXNzZXM7XG5cdHZhciBpc19jb25zdHJ1Y3Rvcl9mbiA9IGouaXNfY29uc3RydWN0b3JfZm47XG5cdFxuXHR2YXIgaXNfYXJyX29mX3N0cnMgPSBqLmlzX2Fycl9vZl9zdHJzO1xuXHR2YXIgaXNfYXJyX29mX2FycnMgPSBqLmlzX2Fycl9vZl9hcnJzO1xuXHQgXG5cdHZhciBTb3J0ZWRfS1ZTID0gRGF0YV9TdHJ1Y3R1cmVzLlNvcnRlZF9LVlM7XG5cdHZhciBkb2JqID0gRGF0YV9PYmplY3QuZG9iajtcblx0XG5cdHZhciBpbnB1dF9wcm9jZXNzb3JzID0gai5pbnB1dF9wcm9jZXNzb3JzO1xuXHR2YXIgRGF0YV9WYWx1ZSA9IERhdGFfT2JqZWN0LkRhdGFfVmFsdWU7XG5cdFxuXHRcblx0dmFyIGNvbnN0cmFpbnRfZnJvbV9vYmogPSBDb25zdHJhaW50LmZyb21fb2JqO1xuXHR2YXIgbmF0aXZlX2NvbnN0cnVjdG9yX3RvZiA9IGpzZ3VpLm5hdGl2ZV9jb25zdHJ1Y3Rvcl90b2Y7XG5cdC8vIERlZmluaXRpZWx5IHdpbGwgaGVscCB0aGUgd2Vic2l0ZSB0byBwb3dlciBxdWl0ZSBhIGZldyB0aGluZ3MuXG5cdC8vICBIYXZpbmcgYSByZWFsbHkgbmljZSB3ZWJzaXRlIG9mIG15IG93biB3aWxsIGRlZmluaXRlbHkgaGVscC5cblx0XG5cdC8vIFdpbGwgaGF2ZSBleGFtcGxlcyBpbiBkaWZmZXJlbnQgY2F0ZWdvcmllcywgc3VjaCBhcyBkYXRhIHRvb2xzXG5cdC8vICBNYXkgbWFrZSBzb21lIGtpbmQgb2YgZGF0YWJhc2UgYXZhaWxhYmxlIGFuZCB2aWV3YWJsZSBpbiBhIHJlYWQtb25seSBmb3JtLCB0aGVuIHRoaXMgd291bGQgYmUgdXNhYmxlIGZvciBxdWVyaWVzIHRoYXQgYXJlIGRvbmUgYnkgdGhlIHVzZXJzIG9mIG15IHN5c3RlbS5cblx0Ly8gIFRoaXMgd291bGQgYmUgZ29vZCBmb3IgZGVtb25zdHJhdGluZyBzb21lIGZyb250LWVuZCB2aXN1YWxpemF0aW9uIGNvZGUuXG5cdFxuXHQvLyBXaWxsIGJlIG5pY2UgdG8gYWxsb3cgdXNlcnMgLyBzdWJzY3JpYmVycyB0byBtYW5hZ2Ugc29tZSBvZiB0aGVpciBvd24gZGF0YS5cblx0XG5cdFxuXHQvLyBVcGdyYWRlIHRvIHRoZSBEYXRhX09iamVjdCBzZXRfZmllbGQuLi5cblx0Ly8gIFdpbGwgYmUgYWJsZSB0byBwcm9jZXNzIGFycmF5IG9mIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLCBtZWFuaW5nIGEgY29sbGVjdGlvbiBvZiB0aGF0IHR5cGUuXG5cdFxuXHR2YXIgQ29sbGVjdGlvbl9JbmRleCA9IENsYXNzLmV4dGVuZCh7XG5cdFx0J2luaXQnIDogZnVuY3Rpb24oc3BlYykge1xuXHRcdFx0Ly8gQ291bGQgZG8gc29tZSBpbml0aWFsaXphdGlvbiBoZXJlP1xuXHRcdFx0Ly9jb25zb2xlLmxvZygnaW5pdCBDb2xsZWN0aW9uX0luZGV4Jyk7XG5cdFx0XHQvL2NvbnNvbGUubG9nKCdzcGVjLmZpZWxkcyAnICsgc3RyaW5naWZ5KHNwZWMuZmllbGRzKSk7XG5cdFx0XHRpZiAoaXNfZGVmaW5lZChzcGVjLmZpZWxkcykpIHtcblx0XHRcdFx0dGhpcy5maWVsZHMgPSBzcGVjLmZpZWxkcztcblx0XHRcdFx0XG5cdFx0XHRcdC8vIGFuZCBpZiBpdCBpcyBhbiBhcnJheSwgc2F2ZSBhbiBhbHBoYWJldGljYWxseSBvcmRlcmVkIGNvcHkuXG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAodG9mKHNwZWMuZmllbGRzKSA9PSAnYXJyYXknKSB7XG5cdFx0XHRcdFx0Ly8gTm90IHN1cmUgd2UgY2FuIHNvcnQgb2JqZWN0IGZpZWxkcyBieSBuYW1lIGxpa2UgdGhpcz9cblx0XHRcdFx0XHQvLyAgSXQgc2VlbXMgdG8gd29yaz9cblxuICAgICAgICAgICAgICAgICAgICAvLyBGaWVsZHMgaW4gYWxwaGFiZXRpYyBvcmRlci4uLlxuICAgICAgICAgICAgICAgICAgICAvLyAgSG93ZXZlciwgdGhlcmUgd2lsbCBiZSB0aGUgY2FwYWJpbGl0eSBmb3IgbmVzdGVkIGZpZWxkcywgYW5kIGludHJpbnNpYyBwcm9wZXJ0eSByZWZlcmVuY2VzLlxuXG5cblxuXHRcdFx0XHRcdHRoaXMuYWxwaGFiZXRpY19maWVsZHMgPSBjbG9uZShzcGVjLmZpZWxkcykuc29ydCgpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gdGhlIGZpZWxkcyBoZWxkIGJ5IHRoZSBDb2xsZWN0aW9uX0luZGV4LlxuXHRcdFx0XHQvLyAgc29tZSBmaWVsZHMgbWF5IHJlcHJlc2VudCBmaWVsZHMgb24gYXR0YWNoZWQgaXRlbXMuXG5cdFx0XHRcdC8vICAgbG9va3MgbGlrZSB0aGVyZSB3b24ndCBiZSBhbnl0aGluZyB0byBkbyBvbiB0aGlzIHNpbXBsZSBmaWVsZCBhc3NpZ25tZW50P1xuXG5cblxuXHRcdFx0XHQvLyB0aGlzIGluZGV4IHdpbGwgYmUgcXVpY2tlciBmb3IgbWF0Y2hpbmcuXG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHRoaXMuX190eXBlID0gJ2NvbGxlY3Rpb25faW5kZXgnO1xuXHRcdFx0XG5cdFx0fSxcblx0XHQnYWRkX29iamVjdCcgOiBmdW5jdGlvbihvYmopIHtcblx0XHRcdHZhciB0b2JqID0gdG9mKG9iaik7XG5cblx0XHRcdC8vY29uc29sZS5sb2coJ2FkZF9vYmplY3QgQ29sbGVjdGlvbl9JbmRleCcpO1xuXHRcdFx0Ly9jb25zb2xlLmxvZygnKioqKiogdG9iaiAnICsgdG9iaik7XG5cblx0XHRcdGlmICh0b2JqID09ICdhcnJheScpIHtcblxuXHRcdFx0XHQvLyBjaGVjayB0aGF0IGFsbCBvZiB0aGUgaXRlbXMgY2FuIGJlIGFkZGVkIGJlZm9yZSBhZGRpbmcgYW55IG9mXG5cdFx0XHRcdC8vIHRoZW0/Pz9cblx0XHRcdFx0Ly8gb3IgYmV0dGVyIHRvIGFkZCB0aGVtIHNlcXVlbnRpYWxseSwgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZVxuXHRcdFx0XHQvLyBjb25mbGljdHMgd2l0aGluIHRoZSBpdGVtcyB0aGVtc2VsdmVzLlxuXHRcdFx0XHQvLyB0aG91Z2gsIGNvdWxkIGNoZWNrIHRoYXQgZmlyc3QsIGJ1dCBtYWtlcyB0aGUgY29kZSBtb3JlXG5cdFx0XHRcdC8vIGNvbXBsZXguXG5cdFx0XHRcdC8vIGNvdWxkIGRvIHRoaXMgYnkgY3JlYXRpbmcgYSBwYXJhbGxlbCBpbmRleCB3aXRoIHRoZSBzYW1lXG5cdFx0XHRcdC8vIHByb3BlcnRpZXMsIGFuZCBoYXZlIHRoYXQgbG9hZCB0aGUgZGF0YSBmaXJzdC5cblx0XHRcdFx0dmFyIHRoYXQgPSB0aGlzO1xuXHRcdFx0XHRlYWNoKG9iaiwgZnVuY3Rpb24oaSwgdikge1xuXHRcdFx0XHRcdHRoYXQuYWRkX29iamVjdCh2KTtcblx0XHRcdFx0fSk7XG5cblx0XHRcdH0gZWxzZSBpZiAodG9iaiA9PSAnZGF0YV9vYmplY3QnKSB7XG5cdFx0XHRcdC8vY29uc29sZS5sb2coJ2FkZGluZyBkYXRhX29iamVjdCcpO1xuXG5cdFx0XHRcdC8vIGNoYWNrIGlmIHdlIGNhbiBhZGQgaXQuXG5cblx0XHRcdFx0Ly9pZiAodGhpcy5jYW5fYWRkX29iamVjdChvYmopKSB7XG5cdFx0XHRcdC8vIG5vdCBkb2luZyB1bmlxdWVuZXNzIGNoZWNraW5nIGhlcmUuXG5cdFx0XHRcdFxuXHRcdFx0XHRcdHRoaXMudW5zYWZlX2FkZF9vYmplY3Qob2JqKTtcblx0XHRcdFx0Ly99XG5cblx0XHRcdFx0Ly8gdGhlbiBuZWVkIHRvIGFkZCB0aGUgdGhpbmchXG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHQvLyBhZGRfb2JqZWN0XG5cdC8vIHJlbW92ZV9vYmplY3Rcblx0Ly8gaXRlcmF0ZSB0aHJvdWdoIG9iamVjdHMuLi5cblx0Ly8gZGVmYXVsdCBjb3VsZCBiZSBhbiBhcnJheT9cblx0Ly8gPz8gZ2V0X29iamVjdChrZXkpXG5cblx0Ly8gSW5kZXggdGhlIHdob2xlIGNvbGxlY3Rpb24uLi4gdXNlZCB3aGVuIHRoZSBpbmRleCBpcyBjcmVhdGVkLlxuXG5cdC8vIGdldF9vYmplY3Qoa2V5LCBrZXkpXG5cdC8vIGdldF9vYmplY3QoW2tleXNdKVxuXG5cdH0pO1xuXG5cdC8vIE9yZGVyZWRfRGljdD9cblxuXHR2YXIgQlBEX0NvbGxlY3Rpb25fSW5kZXggPSBDb2xsZWN0aW9uX0luZGV4LmV4dGVuZCh7XG5cdFx0J2luaXQnIDogZnVuY3Rpb24oc3BlYykge1xuXHRcdFx0Ly8gaW5kZXhlZCB3aXRoIGJvdGggdGhlIGIrIHRyZWUgYW5kIHRoZSBkaWN0LlxuXG5cdFx0fVxuXHR9KVxuXG5cdC8vIE9yZGVyZWQgY29sbGVjdGlvbiBpbmRleFxuXG5cdC8vIERpY3QgY29sbGVjdGlvbiBpbmRleFxuXG5cdC8vIE9yZGVyZWRfRGljdCBjb2xsZWN0aW9uIGluZGV4IC0gaGFzIGJvdGggb3JkZXJlZCBhbmQgZGljdCBjYXBhYmlsaXRpZXMuXG5cdC8vIE1vcmUgc3BhY2UgcmVxdWlyZWQsIGZhc3RlciBnZXQgb3BlcmF0aW9ucyB0aHJvdWdoIHRoZSBkaWN0LlxuXG5cdC8vIEZ1bGxfVGV4dCBjb2xsZWN0aW9uIGluZGV4P1xuXHQvLyBUaGlzIHdpbGwgYmUgdGhlIG1vc3QgY29tcGxpY2F0ZWQgdG8gZG8uIFdvdWxkIG1ha2UgZGF0YSBzdHJ1Y3R1cmVzIGxpa2Vcblx0Ly8gdGhlIFRyaWUuXG5cdC8vIENvdWxkIGhhdmUgdGhhdCBwbHVnZ2FibGUgZm9yIG1vcmUgYWR2YW5jZWQgZGF0YSBzdHJ1Y3R1cmVzLlxuXG5cdC8vIERpY3QsIE9yZGVyZWQsIGFuZCBGdWxsX1RleHQgc2VlbSBsaWtlIGdvb2QgaW5kZXggdHlwZXMuXG5cdC8vIE5vdCBzYXlpbmcgaG93IE9yZGVyZWQgYW5kIEZ1bGxfVGV4dCB3aWxsIGJlIGltcGxlbWVudGVkLlxuXHQvLyBJcyBpdCBwb3NzaWJsZSAvIGVhc3kgZm9yIGFuIGluZGV4IHRvIGJlIGJvdGggZnVsbC10ZXh0IGFuZCBvcmRlcmVkP1xuXG5cdC8vIENvdWxkIHBvc3NpYmx5IGV2ZW4gcmF0ZSB0aW1lIGNvbXBsZXhpdHkgZm9yIGVhY2ggb3BlcmF0aW9uLlxuXHQvLyBTbyBwcm9ncmFtIGNvdWxkIGV2ZW4gZGV0ZXJtaW5lIC0gd2UgaGF2ZSAzMCwwMDAgcmVjb3JkcywgYmV0dGVyIGRvd25sb2FkXG5cdC8vIGEgbW9yZSBlZmZpY2llbnQgaW5kZXguXG5cblx0Ly8gRGljdCBhcyB0aGUgZGVmYXVsdCBpbmRleD9cblxuXHQvLyBoYXZlIGRpY3RfaW5kZXgocHJvcGVydHlfbmFtZSkgZnVuY3Rpb24/XG5cdC8vIHNldHMgdXAgdGhlIGluZGV4LiBkaShwbiwgZmFsc2UpIGNvdWxkIHJlbW92ZSBpdC5cblxuXHQvLyBTZWVtcyBnb29kIHRvIHNlcGFyYXRlIHRoZXNlIHRoaW5ncyBvdXQgYSBsb3QuXG5cdC8vIEhhdmluZyBpdCBzbyB0aGF0IHRoZSBpbmRleCBlbmdpbmVzIGNvdWxkIGdldCB1cGdyYWRlZC5cblxuXHQvLyBXb3VsZCBiZSB3b3J0aCBhcHByb2FjaGluZyB0aGlzIGluIGEgdmVyeSBtb2R1bGFyIHdheSwgc28gdGhhdCB0aGUgZGF0YVxuXHQvLyBzdHJ1Y3R1cmVzIGNvdWxkIGFsbCBiZSB0ZXN0ZWQgYW5kIG9wdGltaXplZCBzZXBhcmF0ZWx5LlxuXHQvLyBTd2FwcGVkIGFzIHdlbGwsIGFzIG1vcmUgYWR2YW5jZWQgb25lcyBnZXQgd3JpdHRlbi5cblxuXHQvL3ZhciBpbmRleF9rZXlfc2VwYXJhdG9yID0gJyoub09vLionO1xuXHRcblx0dmFyIGluZGV4X2tleV9zZXBhcmF0b3IgPSAnLCc7XG5cdC8vICBjb21tYSBzaG91bGQgd29yayBPSz8gTWF5YmUgbm90IHdoZW4gcmVhZGluZyBvdXQgdGhlIHZhbHVlcyBhbmQga25vd2luZyB3aGF0IHRoZXkgYXJlIGZyb20gdGhlIGtleSxcblx0Ly8gIGJ1dCBzaG91bGQgYmUgZmluZSBmb3IgY29tcGFyaXNvbnMgYW5kIG9yZGVyaW5nXG5cdFxuXHQvLyBUaGUgdHJvdWJsZSBpcywgdGhpcyBjb3VsZCBnZXQgd3JpdHRlbiBhYm91dCFcblx0Ly8gSXMgdGhlcmUgYSB3YXkgYXJvdW5kIHVzaW5nIHN1Y2ggYSBzZXBhcmF0b3I/XG5cdC8vIE5vdCBzdXJlIGFib3V0IG1vcmUgZGljdCBpbmRleGVzIGF0IGVhY2ggbGV2ZWwuXG5cdC8vIE1heSBub3QgYmUgYSBwcm9ibGVtIGJlY2F1c2Ugd2Ugd2lsbCBiZSBzZWFyY2hpbmcgaW4gdGhlIHJpZ2h0IGluZGV4ZXNcblx0Ly8gYW55d2F5LlxuXG5cdC8vIEF0dGFjaGVkIGZpZWxkcy4uLiB0aGVzZSB3aWxsIGdldCBpbmRleGVkIHRvby5cblx0Ly8gIEhvd2V2ZXIsIHdlIHdvbid0IGhhdmUgdGhhdCBtdWNoIG9mIGFuIGludGVyZmFjZSBvciBhYnN0cmFjdGlvbiBmb3IgZGVhbGluZyB3aXRoIGF0dGFjaGVkIG9iamVjdHMuXG5cdC8vICBUaGV5IGFyZSBzaW1wbGUgb2JqZWN0W2F0dGFjaG1lbnROYW1lXS5cblxuXHQvLyBTbyBpbiBhIGNvbGxlY3Rpb24sIHdlIHdhbnQgdG8gYmUgYWJsZSB0byBpbmRleCBhdHRhY2hlZCBmaWVsZHMuXG5cdC8vICBXaGVuIHF1ZXJ5aW5nIHRoZW0sIHdlIG5lZWQgdG8gdXNlIGEgbm90YXRpb24gdGhhdCBpbmRpY2F0ZWQgd2UgYXJlIHF1ZXJ5aW5nIGF0dGFjaGVkIGZpZWxkcy5cblx0Ly8gICBJdCBzZWVtcyBsaWtlIHRoZXkgc2hvdWxkIGJlIGluIHRoZSBzYW1lIGluZGV4IHN0cnVjdHVyZSB0aG91Z2guXG5cblx0Ly8gUGVyaGFwcyBuZWVkIHRvIGV4dGVuZCB0aGUgaW5kZXhlcyBhIGJpdCB0byBjb3ZlciBhdHRhY2hlZCBmaWVsZHMgc3BlY2lmaWNhbGx5IGluIHNvbWUgcGxhY2VzLlxuXG5cdC8vIE1vcmUgdGhvdWdodCBhYm91dCBhdHRhY2hlZCBmaWVsZHMgc2VlbXMgaW1wb3J0YW50LlxuXG5cblxuXG5cblxuXHR2YXIgT3JkZXJlZF9Db2xsZWN0aW9uX0luZGV4ID0gQ29sbGVjdGlvbl9JbmRleC5leHRlbmQoe1xuXHRcdCdpbml0JzogZnVuY3Rpb24oc3BlYykge1xuXHRcdFx0dGhpcy5fc3VwZXIoc3BlYyk7XG5cdFx0XHQvLyB3aGljaCBmaWVsZChzKSBnZXQgaW5kZXhlZD9cblx0XHRcdC8vdGhpcy5maWVsZHMgPSBzcGVjLmZpZWxkcztcblx0XHRcdHRoaXMuaW5kZXhfdHlwZSA9ICdvcmRlcmVkJztcblxuXHRcdH1cblxuXHQvLyB0aGlzIHdpbGwgcHJvYmFibHkgcmVmZXIgdG8gdGhlIEIrIGltcGxlbWVudGF0aW9uLiBuZWVkIHRvIHdyYXAgaXRcblx0Ly8gY29uY2lzZWx5LlxuXG5cdH0pXG5cblx0Ly8gbm90IHNvIHN1cmUgYWJvdXQgdGhpcyBmbi5cblx0dmFyIGdldF9maWVsZHNfa2V5ID0gZnVuY3Rpb24oZmllbGRzKSB7XG5cdFx0dmFyIHRmID0gdG9mKGZpZWxkcyk7XG5cdFx0aWYgKHRmID09ICdhcnJheScpIHtcblx0XHRcdHJldHVybiBmaWVsZHMuam9pbihpbmRleF9rZXlfc2VwYXJhdG9yKTtcblx0XHR9IGVsc2UgaWYgKHRmID09ICdzdHJpbmcnKSB7XG5cdFx0XHRyZXR1cm4gZmllbGRzO1xuXHRcdH1cblx0fVxuXG4gICAgLy8gV2UgbWF5YmUgbmVlZCB0ZXN0cyB0byBkbyB3aXRoIGFkZGluZyBEYXRhX09iamVjdHMgdG8gQ29sbGVjdGlvbnMsIGFuZCBzZWVpbmcgdGhhdCB0aGV5IGFyZSBhdXRvbWF0aWNhbGx5IGluZGV4ZWQuXG4gICAgLy8gIEN1cnJlbnRseSBoYXZpbmcgYSBwcm9ibGVtIGFjY2Vzc2luZyBhbiBBYnN0cmFjdCBQb3N0Z3JlcyBUYWJsZSB0aHJvdWdoIHRoZSBDb2xsZWN0aW9uIG9mIHRhYmxlcy5cblxuICAgIC8vIFNvbWUgdW5pdCB0ZXN0cyB0byBjb3ZlciBzaW1pbGFyIGNhc2VzIHdvdWxkIGhlbHAuXG5cblx0dmFyIGdldF9vYmpfZmllbGRzX2tleSA9IGZ1bmN0aW9uKG9iaiwgZmllbGRzKSB7XG4gICAgICAgIC8vY29uc29sZS5sb2coJycpO1xuXHRcdC8vY29uc29sZS5sb2coJ2dldF9vYmpfZmllbGRzX2tleScpO1xuXG5cdFx0Ly92YXIgc3RhY2sgPSBuZXcgRXJyb3IoKS5zdGFja1xuXHRcdC8vY29uc29sZS5sb2coIHN0YWNrIClcblxuICAgICAgICAvL2NvbnNvbGUubG9nKCdnZXRfb2JqX2ZpZWxkc19rZXkgb2JqJywgb2JqKTtcbiAgICAgICAgLy9jb25zb2xlLmxvZygnZ2V0X29ial9maWVsZHNfa2V5IHN0cmluZ2lmeSBvYmonLCBzdHJpbmdpZnkob2JqKSk7XG4gICAgICAgIC8vY29uc29sZS5sb2coJ3RvZiBvYmonLCB0b2Yob2JqKSk7XG5cblx0XHR2YXIgdEZpZWxkcyA9IHRvZihmaWVsZHMpO1xuXG4gICAgICAgIC8vY29uc29sZS5sb2coJ2ZpZWxkcyAnICsgc3RyaW5naWZ5KGZpZWxkcykpO1xuXHRcdC8vY29uc29sZS5sb2coJ3RGaWVsZHMgJyArIHRGaWVsZHMpO1xuXG4gICAgICAgIC8vIEFuIGF0dGFjaGVkIGZpZWxkP1xuICAgICAgICAvLyAgU28gaXQncyBvbmUgb2JqZWN0IGF0dGFjaGVkIHRvIGFub3RoZXIuXG5cbiAgICAgICAgLy90aHJvdyAnc3RvcCc7XG5cdFx0aWYgKHRGaWVsZHMgPT0gJ3N0cmluZycpIHtcblx0XHRcdGZpZWxkcyA9IFtmaWVsZHNdO1xuXHRcdH1cblx0XHRcblx0XHQvLyB2YXIgZmlyc3QgPSB0cnVlO1xuXHRcdHZhciBhcnJfcmVzID0gW107XG5cdFx0ZWFjaChmaWVsZHMsIGZ1bmN0aW9uKGksIGZpZWxkX2RlZmluaXRpb24pIHtcblxuXHRcdFx0Ly8gbWF5IGNoZWNrIGlmIGl0IGlzIGEgc3RyaW5nIG9yIGNhbiBiZSBzdHJpbmdpZmllZC5cblx0XHRcdC8vIG1heWJlIHNob3VsZCBjYWxsIGZ1bmN0aW9ucyB0byBnZXQgYSBzdHJpbmcgcmVzdWx0IHRvby5cblxuXHRcdFx0Ly8gbWF5YmUgd2lsbCBsb29rIGF0IG9iai5fIGZvciB0aGUgZmllbGQgdmFsdWUuXG5cdFx0XHQvLyBvciB1c2UgdGhlIGdldCBmdW5jdGlvbi5cblx0XHRcdFxuXHRcdFx0Ly9jb25zb2xlLmxvZygnZmllbGRfbmFtZSAnICsgc3RyaW5naWZ5KGZpZWxkX25hbWUpKTtcblxuXG5cdFx0XHR2YXIgdEZpZWxkRGVmID0gdG9mKGZpZWxkX2RlZmluaXRpb24pO1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygndEZpZWxkRGVmJywgdEZpZWxkRGVmKTtcblx0XHRcdFxuXHRcdFx0aWYgKHRGaWVsZERlZiA9PSAnYXJyYXknKSB7XG5cdFx0XHRcdFxuXG5cdFx0XHRcdC8vIGdldHMgbW9yZSBjb21wbGljYXRlZCB3aXRoIHRoZSBhcnJheS5cblx0XHRcdFx0Ly8gIGNvbW1hcyB3aWxsIGRvIGZpbmUgZm9yIG5vdy5cblx0XHRcdFx0XG5cdFx0XHRcdC8vdmFyIHJlcyA9IGZpZWxkX25hbWUuam9pbignLCcpO1xuXHRcdFx0XHQvL2NvbnNvbGUubG9nKCdyZXMgJyArIHJlcyk7XG5cdFx0XHRcdC8vYXJyX3Jlcy5wdXNoKCdbJyArIGZpZWxkX25hbWUuam9pbignLCAnKSArICddJyk7XG5cdFx0XHRcdC8vcmV0dXJuIHJlcztcblx0XHRcdFx0YXJyX3Jlcy5wdXNoKHN0cmluZ2lmeShmaWVsZF9kZWZpbml0aW9uKSk7XG5cdFx0XHRcdFxuXHRcdFx0fSBlbHNlIGlmICh0RmllbGREZWYgPT0gJ3N0cmluZycpIHtcblxuXHRcdFx0XHQvLyBCdXQgZm9yIG9iamVjdHMsIHdlIGFyZSBnZXR0aW5nIHBvdGVudGlhbGx5IGF0dGFjaGVkIGZpZWxkIHZhbHVlcy5cblxuXG5cblxuXHRcdFx0XHQvL2NvbnNvbGUubG9nKCdmaWVsZF9uYW1lICcgKyBmaWVsZF9uYW1lKTtcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdmaWVsZF9kZWZpbml0aW9uJywgZmllbGRfZGVmaW5pdGlvbik7XG5cdFx0XHRcdHZhciBmaWVsZF92YWwgPSBvYmouZ2V0KGZpZWxkX2RlZmluaXRpb24pO1xuXG4gICAgICAgICAgICAgICAgLy8gTmVlZCB0byB1cGdyYWRlIHRoZSBvYmplY3Qgc28gaXQgbG9va3MgYXQgaW50cmluc2ljIG5lc3RlZCBwcm9wZXJ0aWVzLlxuXG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygndG9mIG9iaicsIHRvZihvYmopKTtcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdvYmonLCBzdHJpbmdpZnkob2JqKSk7XG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnb2JqJywgb2JqKTtcblxuXHRcdFx0XHQvL2NvbnNvbGUubG9nKCdmaWVsZF92YWwgJyArIGZpZWxkX3ZhbCk7XG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygndG9mIGZpZWxkX3ZhbCAnICsgdG9mKGZpZWxkX3ZhbCkpO1xuXG4gICAgICAgICAgICAgICAvLyB0aHJvdyAnc3RvcCc7XG5cbiAgICAgICAgICAgICAgICBpZiAoZmllbGRfdmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaWVsZF92YWwudmFsdWUpIGZpZWxkX3ZhbCA9IGZpZWxkX3ZhbC52YWx1ZSgpO1xuICAgICAgICAgICAgICAgICAgICBhcnJfcmVzLnB1c2goZmllbGRfdmFsKTtcbiAgICAgICAgICAgICAgICB9XG5cblxuXG5cbiAgICAgICAgICAgICAgICAvL3Rocm93ICdzdG9wJztcblxuXHRcdFx0fSBlbHNlIGlmICh0RmllbGREZWYgPT0gJ29iamVjdCcpIHtcblx0XHRcdFx0Ly9jb25zb2xlLmxvZygnaGF2ZSBhbiBvYmplY3QgZmllbGROYW1lLCB3ZWxsIGl0cyBub3QgcmVhbGx5IGEgc2ltcGxlIGZpZWxkIG5hbWUgaXQgc2VlbXMsIGNvdWxkIGJlIGFuIGF0dGFjaGVkIG9iamVjdFxcJ3MgZmllbGQuJyk7XG5cblx0XHRcdFx0Ly8gdGhlIGtleSBpbiB0aGUgaW5kZXggaXMgdGhlIHZhbHVlP1xuXHRcdFx0XHQvLyAgaXMgdGhhdCB3aGF0IGFuIGluZGV4IGlzIGluIHRlcm1zIG9mIGtleSBhbmQgdmFsdWU/XG5cblx0XHRcdFx0Ly8gbmVlZCBhIHdheSBvZiBpdGVyYXRpbmcgdGhyb3VnaCB0aGUgYXR0YWNoZWQgZmllbGRzP1xuXHRcdFx0XHQvLyAgb3IgZGVhbCB3aXRoIG9uZSBsZXZlbCBvZiBhdHRhY2htZW50IGF0IHRoaXMgdGltZT9cblxuICAgICAgICAgICAgICAgIC8vIDE3LzA2LzIwMTQgLSBJJ20gbmVlZGluZyB0aGlzLCBhbmQgbm90aWNpbmcgdGhhdCBpdCdzIHNvbWV3aGF0IGFscmVhZHkgYmVlbiBkb25lLlxuXG5cblxuXHRcdFx0XHRpZiAoZmllbGRfZGVmaW5pdGlvbi5hdHRhY2hlZCkge1xuXHRcdFx0XHRcdC8vIGl0IHdpbGwgb25seSBiZSBvbmUgYXR0YWNoZWQgaXRlbS5cblx0XHRcdFx0XHR2YXIgYXR0YWNoZWRPYmpOYW1lO1xuXHRcdFx0XHRcdHZhciBhdHRhY2hlZE9iakZpZWxkTmFtZTtcblx0XHRcdFx0XHR2YXIgYyA9IDA7XG5cdFx0XHRcdFx0ZWFjaChmaWVsZF9kZWZpbml0aW9uLmF0dGFjaGVkLCBmdW5jdGlvbihpLCB2KSB7XG5cdFx0XHRcdFx0XHRhdHRhY2hlZE9iak5hbWUgPSBpO1xuXHRcdFx0XHRcdFx0YXR0YWNoZWRPYmpGaWVsZE5hbWUgPSB2O1xuXHRcdFx0XHRcdFx0YysrO1xuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0Ly9jb25zb2xlLmxvZygnYyAnICsgYyk7XG5cdFx0XHRcdFx0aWYgKGMgIT0gMSkge1xuXHRcdFx0XHRcdFx0dGhyb3cgJ3VuZXhwZWN0ZWQgbnVtYmVyIG9mIGl0ZW1zIGluIGF0dGFjaGVkIGRlZmluaXRpb24nO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR2YXIgYXR0YWNoZWRPYmogPSBvYmpbYXR0YWNoZWRPYmpOYW1lXTtcblx0XHRcdFx0XHRcdC8vY29uc29sZS5sb2coJ2F0dGFjaGVkT2JqICcgKyBzdHJpbmdpZnkoYXR0YWNoZWRPYmopKTtcblx0XHRcdFx0XHRcdHZhciByZXMgPSBhdHRhY2hlZE9iai5nZXQoYXR0YWNoZWRPYmpGaWVsZE5hbWUpO1xuXHRcdFx0XHRcdFx0YXJyX3Jlcy5wdXNoKHJlcyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblxuXHRcdFx0XHQvL3Rocm93ICdzdG9wJztcblxuXHRcdFx0fVxuXHRcdFx0Ly8gb2JqZWN0Li4uXG5cblxuXHRcdFx0Ly8gdmFyIGZpZWxkX3ZhbCA9IG9ialtmaWVsZF9uYW1lXTtcblx0XHR9KVxuXG4gICAgICAgIHZhciByZXMgPSBhcnJfcmVzLmpvaW4oaW5kZXhfa2V5X3NlcGFyYXRvcik7XG4gICAgICAgIC8vY29uc29sZS5sb2coJ2dldF9vYmpfZmllbGRzX2tleSByZXMnLCByZXMpO1xuXHRcdHJldHVybiByZXM7XG5cdH1cblxuXHQvLyBGdW5jdGlvbiB0byBnZXQgdGhlIGZpcnN0IG9yIG50aD9cblxuXHRcblx0XG5cdHZhciBTb3J0ZWRfQ29sbGVjdGlvbl9JbmRleCA9IENvbGxlY3Rpb25fSW5kZXguZXh0ZW5kKHtcblx0XHQnaW5pdCc6IGZ1bmN0aW9uKHNwZWMpIHtcblx0XHRcdHRoaXMuX3N1cGVyKHNwZWMpO1xuXHRcdFx0XG5cdFx0XHQvL3RoaXMuZmllbGRzID0gc3BlYy5maWVsZHM7XG5cdFx0XHRcblx0XHRcdC8vIHRoZSBmaWVsZHMsIHNvcnRlZCBieSBuYW1lIGFscGhhYmV0aWNhbGx5XG5cdFx0XHQvLyAgIGNvdWxkIGJlIGRvbmUgYnkgQ29sbGVjdGlvbl9JbmRleFxuXHRcdFx0dGhpcy5pbmRleF90eXBlID0gJ3NvcnRlZCc7XG5cdFx0XHRcblx0XHRcdC8vIGhhdmUgc29tZXRoaW5nIGFib3V0IGl0cyBpbXBsZW1lbnRhdGlvbj9cblx0XHRcdC8vIGNvdWxkIGdldCB0aGF0IGZyb20gdGhlIFNvcnRlZF9LVlMuXG5cdFx0XHQvLyAgTWF5YmUgYXMgYSBmdW5jdGlvbiB0aGF0IGFwcGxpZXMgdG8gdGhlIHR5cGUuLi4gZ2V0dGluZyBtb3JlIGluZm8gYWJvdXQgd2hhdCB1bmRlcmx5aW5nIGRhdGEgc3RydWN0dXJlIGl0IGlzIHVzaW5nIGFuZCB0aGVcblx0XHRcdC8vICAgZWZmaWNpZW5jeSBvZiB2YXJpb3VzIG9wZXJhdGlvbnMgKGhpZ2ggZWZmaWNpZW5jeSBmb3Igc29ydGVkIGluZGV4ZXMpXG5cdFx0XHRcblx0XHRcdC8vdGhpcy51bmlxdWVfbW9kZSA9IHRydWU7XG5cdFx0XHRcblx0XHRcdC8vIENhbiB1c2UgdGhlIFNvcnRlZCBLVlMuIFRoZSBmYWN0IGl0J3MgdXNpbmcgYSB0cmVlIGlzIG5vdCB2ZXJ5IHJlbGV2YW50IGhlcmUuXG5cdFx0XHRcblx0XHRcdHRoaXMuc29ydGVkX2t2cyA9IG5ldyBTb3J0ZWRfS1ZTKDEyKTtcblx0XHRcdFxuXHRcdH0sXG5cdFx0J2VhY2gnOiBmdW5jdGlvbihjYWxsYmFjaykge1xuXHRcdFx0cmV0dXJuIHRoaXMuc29ydGVkX2t2cy5lYWNoKGNhbGxiYWNrKTtcblx0XHR9LFxuXHRcdFxuXHRcdC8vIHRoaXMgaXMgbm90IGEgY29uc3RyYWludC5cblx0XHRcblx0XHQvKlxuXHRcdCdjYW5fYWRkX29iamVjdCc6IGZ1bmN0aW9uKG9iaikge1xuXHRcdFx0dmFyIGZpZWxkc19rZXkgPSBnZXRfb2JqX2ZpZWxkc19rZXkob2JqLCB0aGlzLmZpZWxkcyk7XG5cdFx0XHRcblx0XHRcdHZhciBjb3VudF93aXRoX2ZpZWxkc19rZXkgPSB0aGlzLnNvcnRlZF9rdnMua2V5X2NvdW50KGZpZWxkc19rZXkpO1xuXHRcdFx0XG5cdFx0XHQvLyBUaGUgY29sbGVjdGlvbiBpbmRleCB3b24ndCBiZSBvcGVyYXRpbmcgdW5pcXVlIG1vZGUuXG5cdFx0XHQvLyAgSXQgd2lsbCBiZSBhIGNvbGxlY3Rpb24gY29uc3RyYWludCwgdGhhdCBtYWtlcyByZWZlcmVuY2UgdG8gdGhlIGluZGV4LlxuXHRcdFx0XG5cdFx0XHQvLyBIYXZlIGRvbmUgYSByZWFsbHkgbGFyZ2UgYW1vdW50IG9uIHRoaXMgY29kZWJhc2UuXG5cdFx0XHQvLyAgTmVlZCB0byBkbyBhIGZhaXIgYml0IG1vcmUuLi5cblx0XHRcdC8vICBOZWVkIHRvIGhhdmUgaXQgZnVsbHkgb3BlcmF0aW5nIHdpdGggY29uc3RyYWludHMuXG5cdFx0XHRcblx0XHRcdC8vIFRoZW4gc29tZXRoaW5nIHJlbGF0aXZlbHkgc2ltcGxlLCBzZXQgdXAgd2l0aCBjb25zdHJhaW50cyBhbmQgbWF5YmUgc29tZSBkYXRhLCBjb3VsZCBiZSB1c2VkIHRvIGNyZWF0ZSB0aGUgcG9wdWxhdGVkIGRhdGFiYXNlXG5cdFx0XHRcblx0XHRcdC8vIFF1aXRlIGEgYml0IG1vcmUgdG8gZG8gb24gdGhlIGdlbmVyYWwvYmFjay1lbmQgY29kZS5cblx0XHRcdC8vICBUaGVuIGl0IHdvbid0IGJlIHNvIGhhcmQgdG8gcG9wdWxhdGUgYSBmZXcgbmljZSBjb21wb25lbnRzIHdpdGggc29tZSB0ZXh0ICYgaW1hZ2VzLlxuXHRcdFx0XG5cdFx0XHRcblx0XHRcdFxuXHRcdFx0XG5cdFx0XHRcblx0XHRcdC8vaWYgKGNvdW50X3dpdGhfZmllbGRzX2tleSA+IDApIHtcblx0XHRcdC8vXHRpZiAodGhpcy51bmlxdWVfbW9kZSkgcmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcblx0XHRcdC8vfVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSxcblx0XHQqL1xuXHRcdFxuXHRcdCd1bnNhZmVfYWRkX29iamVjdCc6IGZ1bmN0aW9uKG9iaikge1xuXHRcdFx0XG5cdFx0XHQvLyBpZiB0aGUgb2JqZWN0IGlzIGp1c3QgYSBzdHJpbmc/XG5cdFx0XHQvLyAgb2JqZWN0IG5lZWRzIHRvIGJlIGluIGEgZGF0YV9vYmplY3QgdGhvdWdoLlxuXHRcdFx0Ly8gIHRoYXQgRGF0YV9PYmplY3QgY2FuIGhhdmUgYSBzZXQgdHlwZS5cblx0XHRcdC8vY29uc29sZS5sb2coJ1NvcnRlZF9Db2xsZWN0aW9uX0luZGV4IHVuc2FmZV9hZGRfb2JqZWN0Jyk7XG5cdFx0XHQvL2NvbnNvbGUubG9nKCdTb3J0ZWRfQ29sbGVjdGlvbl9JbmRleCB1YW8gb2JqICcgKyBzdHJpbmdpZnkob2JqKSk7XG5cdFx0XHRcblx0XHRcdC8vIGJ1dCBkbyB3ZSBoYXZlIHRoZSBvYmplY3QncyBwb3NpdGlvbi9udW1lcmljYWwgaW5kZXggd2l0aGluIHRoZSBjb2xsZWN0aW9uP1xuXHRcdFx0XG5cdFx0XHQvLyBUaGUgZmllbGRzIGtleS4uLlxuXHRcdFx0Ly8gIFRoZSBmaWVsZCdzIGtleT9cblxuXHRcdFx0Ly9jb25zb2xlLmxvZygndGhpcy5maWVsZHMgJyArIHN0cmluZ2lmeSh0aGlzLmZpZWxkcykpO1xuXG5cblx0XHRcdC8vIHdoYXQgaXMgdGhpcyBmdW5jdGlvbj9cblx0XHRcdC8vICBnZXRzIGEgc3RyaW5nXG5cdFx0XHQvLyAgZ2V0cyB0aGUga2V5IGZvciB0aGUgb2JqZWN0J3MgdmFsdWVzIHdpdGhpbiB0aGlzIGluZGV4J3MgZmllbGRzP1xuXG5cdFx0XHQvLyBzbyB0aGF0IGZpZWxkcyBrZXkgd291bGQgbmVlZCB0byBwcm9kdWNlIGEgc3RyaW5nIHRoYXQgYWxsb3dzIHRoZSBmaWVsZHMgaW4gdGhlIG9iamVjdFxuXHRcdFx0Ly8gIHRvIGJlIGluZGV4ZWRcblxuXG5cblx0XHRcdHZhciBmaWVsZHNfa2V5ID0gZ2V0X29ial9maWVsZHNfa2V5KG9iaiwgdGhpcy5maWVsZHMpO1xuXG5cblxuXHRcdFx0Ly9jb25zb2xlLmxvZygndGhpcy5maWVsZHMgJyArIHN0cmluZ2lmeSh0aGlzLmZpZWxkcykpO1xuXHRcdFx0Ly9jb25zb2xlLmxvZygnZmllbGRzX2tleSAnICsgc3RyaW5naWZ5KGZpZWxkc19rZXkpKTtcblxuXHRcdFx0Ly8gc28sIHdlIGFkZCBpdCB0byB0aGUgaW5kZXguXG5cblxuXHRcdFx0Ly90aHJvdyAoJzUpIHN0b3AnKTtcblx0XHRcdHRoaXMuc29ydGVkX2t2cy5wdXQoZmllbGRzX2tleSwgb2JqKTtcblx0XHRcdC8vIHNvIGZhciwgc28gZ29vZC5cblxuXHRcdH0sXG5cdFx0XG5cdFx0Ly8gZ2V0IGZvciBvbmUgb2JqZWN0P1xuXHRcdC8vICBvciBmaW5kPyBXYW50IGZsZXhpYmlsaXR5IHdoZXJlIHBvc3NpYmxlLCBzbyBtYXkgcHJvdmlkZSBhcnJheXMuXG5cdFx0XG5cdFx0J2dldCc6IGZwKGZ1bmN0aW9uKGEsIHNpZykge1xuXHRcdFx0Ly9jb25zb2xlLmxvZygnU29ydGVkX0NvbGxlY3Rpb25fSW5kZXggZ2V0Jyk7XG5cdFx0XHQvLyB3aWxsIGJlIHByb3ZpZGluZyBhIGtleSwgb3IgcGFydCBvZiBhIGtleVxuXHRcdFx0Ly8gIHVzZXMgdGhlIHByZWZpeCBzZWFyY2guXG5cdFx0XHQvL2NvbnNvbGUubG9nKCdzaWcgJyArIHNpZyk7XG5cdFx0XHRcblx0XHRcdGlmIChzaWcgPT0gJ1tzXScpIHtcblx0XHRcdFx0dmFyIHNlYXJjaF90ZXJtID0gYVswXTtcblx0XHRcdFx0Ly9jb25zb2xlLmxvZygnc2VhcmNoX3Rlcm0gJyArIHNlYXJjaF90ZXJtKTtcblx0XHRcdFx0dmFyIGt2cHMgPSB0aGlzLnNvcnRlZF9rdnMuZ2V0KHNlYXJjaF90ZXJtKTtcblx0XHRcdFx0Ly9jb25zb2xlLmxvZygna3ZwcyAnICsgc3RyaW5naWZ5KGt2cHMpKTtcblx0XHRcdFx0cmV0dXJuIGt2cHM7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGlmICh0b2YoYVswXSkgPT0gJ2FycmF5Jykge1xuXHRcdFx0XHQvL3Rocm93ICgnc3RvcHBpbmcgZm9yIGFycmF5Jyk7XG5cdFx0XHRcdHZhciBzZWFyY2hfdGVybSA9IGFbMF0uam9pbignLCcpO1xuXHRcdFx0XHQvL2NvbnNvbGUubG9nKCdzZWFyY2hfdGVybSAnICsgc2VhcmNoX3Rlcm0pO1xuXHRcdFx0XHQvL3ZhciBrZXlzID0gdGhpcy5zb3J0ZWRfa3ZzLmtleXMoKTtcblx0XHRcdFx0Ly9jb25zb2xlLmxvZygna2V5cyAnICsgc3RyaW5naWZ5KGtleXMpKTtcblx0XHRcdFx0dmFyIGt2cHMgPSB0aGlzLnNvcnRlZF9rdnMuZ2V0KHNlYXJjaF90ZXJtKTtcblx0XHRcdFx0Ly9jb25zb2xlLmxvZygna3ZwcyAnICsgc3RyaW5naWZ5KGt2cHMpKTtcblx0XHRcdFx0Ly8gc2hvdWxkIHJldHVybiBrZXlzIGFuZCB2YWx1ZXNcblx0XHRcdFx0cmV0dXJuIGt2cHM7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHR9KSxcblx0XHQnaGFzJzogZnAoZnVuY3Rpb24oYSwgc2lnKSB7XG5cdFx0XHRpZiAoc2lnID09ICdbc10nKSB7XG5cdFx0XHRcdHJldHVybiAodGhpcy5zb3J0ZWRfa3ZzLmtleV9jb3VudCgpID4gMCk7XG5cdFx0XHR9XG5cdFx0fSksXG5cdFx0J3JlbW92ZSc6IGZ1bmN0aW9uKG9iaikge1xuXHRcdFx0Ly8gZGVwZW5kcyBvbiB3aGF0IHR5cGUgb2Ygb2JqZWN0IHRoZSBjb2xsZWN0aW9uIGlzIGhvbGRpbmcgdG9vLlxuXHRcdFx0Ly8gIFdoZW4gaW5pdGlhbGl6ZWQgYXMgQ29sbGVjdGlvbihTdHJpbmcpLlxuXHRcdFx0Ly8gICBIYXMgYSBjb2xsZWN0aW9uIGRhdGEgdHlwZSBjb25zdHJhaW50LlxuXHRcdFx0Ly8gICBUaGUgY29sbGVjdGlvbiB3aWxsIHN0aWxsIGhhdmUgaXRlbXMgaW5kZXhlZC5cblx0XHRcdFxuXHRcdFx0Ly8gU28gd2hlbiBhIHN0cmluZyBpdGVtIGlzIGFkZGVkLCBpdCBuZWVkcyB0byBnZXQgaW5kZXhlZC4gSSdsbCB0cmFjZSB0aGF0LlxuXHRcdFx0XG5cdFx0XHR2YXIgZmllbGRzX2tleTtcblx0XHRcdGlmICh0b2Yob2JqKSA9PSAnc3RyaW5nJykge1xuXHRcdFx0XHRmaWVsZHNfa2V5ID0gb2JqO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZmllbGRzX2tleSA9IGdldF9vYmpfZmllbGRzX2tleShvYmosIHRoaXMuZmllbGRzKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuc29ydGVkX2t2cy5vdXQoZmllbGRzX2tleSk7XG5cdFx0fVxuXHRcdFxuXHRcdC8vIHdoZW4gZ2V0dGluZy4uLiBkbyB3ZSBoYXZlIHRoZSBmaWVsZHM/XG5cdH0pO1xuXHRcblx0Ly8gTWFwIHJhdGhlciB0aGFuIGRpY3Q/XG5cdHZhciBEaWN0X0NvbGxlY3Rpb25fSW5kZXggPSBDb2xsZWN0aW9uX0luZGV4LmV4dGVuZCh7XG5cdFx0J2luaXQnOiBmdW5jdGlvbihzcGVjKSB7XG5cdFx0XHR0aGlzLl9zdXBlcihzcGVjKTtcblx0XHRcdC8vIHdoaWNoIGZpZWxkKHMpIGdldCBpbmRleGVkP1xuXHRcdFx0Ly90aGlzLmZpZWxkcyA9IHNwZWMuZmllbGRzO1xuXHRcdFx0dGhpcy5pbmRleF90eXBlID0gJ2RpY3QnO1xuXHRcdFx0Ly8gYWxzbyBjb3VsZCBkbyBtb3JlIHRoYW4gb25lIGZpZWxkIGF0IG9uY2UuXG5cdFx0XHQvLyBob3dldmVyLCB0aGlzIG9uZSBpcyBubyBnb29kIGZvciBkb2luZyBhIHNlYXJjaCB3aGVyZSB0aGUgZmlyc3Rcblx0XHRcdC8vIGZpZWxkIGluIHRoZSBtdWx0aS1maWVsZCBpbmRleCBpcyBzcGVjaWZpZWQgYnV0IG5vIG90aGVyc1xuXHRcdFx0dGhpcy5kaWN0ID0ge307XG5cdFx0XHQvLyB0aGlzIHNob3VsZCBhc3N1bWUgaXRlbXMgYXJlIHVuaXF1ZSBmb3IgdGhlIG1vbWVudC5cblx0XHRcdC8vIHBlcmhhcHMgdGhlIERpY3RfQ29sbGVjdGlvbl9JbmRleCBjb3VsZCBvcGVyYXRlIGluIHVuaXF1ZV9tb2RlID1cblx0XHRcdC8vIGZhbHNlIGFzIHdlbGwuXG5cdFx0XHR0aGlzLnVuaXF1ZV9tb2RlID0gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0J2Nhbl9hZGRfb2JqZWN0JyA6IGZ1bmN0aW9uKG9iaikge1xuXHRcdFx0Ly8gdHJ1ZSAvIGZhbHNlP1xuXHRcdFx0Ly8gd29uJ3QgaGF2ZSB0aGUgZXJyb3IgbWVzc2FnZS5cblx0XHRcdC8vIHBlcmhhcHMgYW5vdGhlciBmdW5jdGlvbiBjb3VsZCByZXZlYWwgdGhlIHByb2JsZW0gaWYgYXNrZWQuXG5cdFx0XHQvLyB0aGlzIHdvdWxkIGJlIHVzZWQgZm9yIGRldGVjdGluZyBpZiBhbiBvYmplY3Qgd2lsbCBiZSBPSyBpbiBhXG5cdFx0XHQvLyBudW1iZXIgb2YgZGlmZmVyZW50IGluZGV4ZXMgYmVmb3JlIGFkZGluZyBpdCB0byB0aGUgY29sbGVjdGlvbi5cblx0XHRcdHZhciBmaWVsZHNfa2V5ID0gZ2V0X29ial9maWVsZHNfa2V5KG9iaiwgdGhpcy5maWVsZHMpO1xuXHRcdFx0Ly8gaXMgdGhlcmUgYWxyZWFkeSBhbiBvYmplY3QgdGhlcmU/IERpZmZlcmVudCBvYmplY3Q/XG5cdFx0XHQvLyBzYW1lIG9iamVjdD9cblxuXHRcdFx0Ly8gV2FudCB0byByYWlzZSB0aGUgcmlnaHQgZXhjZXB0aW9uLlxuXHRcdFx0dmFyIGV4aXN0aW5nX29iaiA9IHRoaXMuZGljdFtmaWVsZHNfa2V5XTtcblx0XHRcdC8vY29uc29sZS5sb2coJ2V4aXN0aW5nX29iaiAnICsgZXhpc3Rpbmdfb2JqKTtcblx0XHRcdGlmIChpc19kZWZpbmVkKGV4aXN0aW5nX29iaikpIHtcblx0XHRcdFx0aWYgKHRoaXMudW5pcXVlX21vZGUgPT09IHRydWUpIHtcblxuXHRcdFx0XHRcdC8vIGlmIChpc19kZWZpbmVkKGV4aXN0aW5nX29iai5fX2lkKSAmJlxuXHRcdFx0XHRcdC8vIGlzX2RlZmluZWQob2JqLl9faWQpKSB7XG5cdFx0XHRcdFx0Ly8gaWYgKGV4aXN0aW5nX29iai5fX2lkID09PSBvYmouX19pZCkge1xuXHRcdFx0XHRcdC8vIHRocm93ICdUaGUgc2FtZSBpdGVtIChpZGVudGlmaWVkIGJ5IElEKSBpcyBhbHJlYWR5IGluIHRoZVxuXHRcdFx0XHRcdC8vIGNvbGxlY3Rpb24sIHVuaXF1ZSBmaWVsZHMgY2xhc2gnO1xuXHRcdFx0XHRcdC8vXHRcdFxuXHRcdFx0XHRcdC8vIH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gdGhyb3cgJ1VuaXF1ZSBmaWVsZHMgY2xhc2gnO1xuXHRcdFx0XHRcdC8vIH1cblx0XHRcdFx0XHQvLyB9XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0J3Vuc2FmZV9hZGRfb2JqZWN0JyA6IChmdW5jdGlvbihvYmopIHtcblxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnRGljdF9Db2xsZWN0aW9uX0luZGV4IHVuc2FmZV9hZGRfb2JqZWN0Jyk7XG5cdFx0XHQvL2NvbnNvbGUubG9nKCdESUNUIHVuc2FmZV9hZGRfb2JqZWN0Jyk7XG5cdFx0XHQvLyBpdCdzIGN1cnJlbnRseSB1bnNhZmUgdG8gc3RyaW5naWZ5IHNvbWUgb2JqZWN0cy5cblx0XHRcdC8vY29uc29sZS5sb2coJ3Vuc2FmZV9hZGRfb2JqZWN0ICcgKyBzdHJpbmdpZnkob2JqKSk7XG5cdFx0XHQvLyBzaG91bGQgaGF2ZSBhIGNhbl9hZGRfb2JqZWN0IGZ1bmN0aW9uIHRvbyxcblx0XHRcdC8vIHBvc3NpYmx5IGFuIHVuc2FmZV9hZGQgZnVuY3Rpb24gdGhhdCBkb2VzIG5vdCBkbyBjaGVja2luZy5cblx0XHRcdC8vIElmIHNvbWV0aGluZyBjYW4ndCBiZSBhZGRlZCB0byBvbmUgaW5kZXgsIHdlIGRvbid0IHdhbnQgaXQgYWRkZWRcblx0XHRcdC8vIHRvIGFueSBvZiB0aGVtLlxuXHRcdFx0dmFyIGZpZWxkc19rZXkgPSBnZXRfb2JqX2ZpZWxkc19rZXkob2JqLCB0aGlzLmZpZWxkcyk7XG5cdFx0XHQvLyB3b24ndCBiZSAoZGlyZWN0bHkpIGFkZGluZyBhcnJheSBvYmplY3RzIHRvIHRoZSBjb2xsZWN0aW9uLlxuXHRcdFx0Ly8gd2lsbCBiZSBhZGRpbmcgY29sbGVjdGlvbnMgdG8gY29sbGVjdGlvbnMgdGhvdWdoLlxuXHRcdFx0Ly8gY29uc29sZS5sb2coJ3RvZihvYmopICcgKyB0b2Yob2JqKSk7XG5cdFx0XHQvLyBjb25zb2xlLmxvZygnRGljdF9Db2xsZWN0aW9uX0luZGV4IGFkZF9vYmplY3QnKTtcblx0XHRcdC8vIGlzIHRoaXMgaW5kZXggZG9pbmcgbXVsdGlwbGUgZmllbGRzP1xuXHRcdFx0Ly8gY29uc29sZS5sb2coJ2ZpZWxkcyAnICsgc3RyaW5naWZ5KHRoaXMuZmllbGRzKSk7XG5cdFx0XHQvLyBmb3Igb25lIGZpZWxkLCBubyBzZXBhcmF0b3IuXG5cdFx0XHR0aGlzLmRpY3RbZmllbGRzX2tleV0gPSBvYmo7XG5cdFx0XHQvLyBnZXQgdGhlIGZpZWxkcyBrZXkgZnJvbSB0aGUgZmllbGQgdmFsdWVzLlxuXHRcdFx0Ly8gdGhpcy5kaWN0W2ZpZWxkc19rZXldXG5cblx0XHR9KSxcblx0XHQnZ2V0JzogZnAoZnVuY3Rpb24oYSwgc2lnKSB7XG5cdFx0XHQvLyBbc11cblx0XHRcdC8vIGp1c3Qgb25lIHZhbHVlLCBzZWFyY2hpbmcgdGhlIGluZGV4IGJhc2VkIG9uIHRoYXQgdmFsdWUuXG5cdFx0XHRcblx0XHRcdC8vIFRoaXMgb25lIHdvbid0IGhhdmUgdGhlIGxheWVyIC8gd3JhcHBlciBmb3IgbXVsdGlwbGUgdmFsdWVzIHN0b3JlZCBhdCBvbmUga2V5ICh5ZXQpLlxuXHRcdFx0XG5cdFx0XHQvLyBUaGF0IHdvdWxkIGJlIGEgZGVjZW50IHdheSBvZiBkb2luZyBhbiBpbmRleC5cblx0XHRcdC8vICBUaGUgQisgdHJlZSB3b3VsZCBpbnNlcnQgdGhlIG11bHRpcGxlIGlkZW50aWNhbCBrZXlzIGFueXdheS5cblx0XHRcdGlmIChhLmwgPT0gMSAmJiB0b2YoYVswXSkgPT0gJ3N0cmluZycpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZGljdFthWzBdXTtcblx0XHRcdH1cblx0XHRcdC8vIGFycmF5IG9mIHZhbHVlcyAtIHdpbGwgbmVlZCB0byBncm91cCB0aGVtIHRvZ2V0aGVyIGFuZCBzZWFyY2ggdGhlXG5cdFx0XHQvLyBpbmRleC5cblx0XHR9KVxuXG5cdC8vIHNvbWUga2luZCBvZiBzZWFyY2ggb3IgcmV0cmlldmFsIGZ1bmN0aW9uLlxuXHQvLyAnZ2V0JyBJIHRoaW5rIGZvciB0aGlzIGluZGV4LlxuXG5cdH0pXG5cblx0Ly8gQSB3aG9sZSBzeXN0ZW0gZm9yIGNvbGxlY3Rpb24gaW5kZXhlcy5cblx0Ly8gTWF5YmUgaXQgc2hvdWxkIGJlIGluIHRoZSBjb2xsZWN0aW9uIGNsYXNzP1xuXHQvLyBCdXQgbWF5YmUgbm90IGlmIGl0IGVuY2Fwc3VsYXRlcyBhIGZhaXIgYml0IG9mIGZ1bmN0aW9uYWxpdHkgYW5kIGhhcyBhXG5cdC8vIHNpbXBsZSBlbm91Z2ggQVBJLlxuXG5cdC8vIE1heSBtYWtlIHNlbnNlIHRvIGtlZXAgdGhlIGluZGV4aW5nIHN5c3RlbSBpbiBvbmUgcGxhY2UuXG5cblx0Ly8gRW5zdXJlIHRoZXJlIGFyZSB2YXJpb3VzIGluZGV4ZXMuLi5cblxuXHQvLyBNYXkgaGF2ZSBib3RoIGIrIGFuZCBkaWN0IGluZGV4IGF0IG9uY2U/XG5cdC8vIENvbWJpbmVkIGluZGV4PyBMaWtlIHRoZSBLU1ZTP1xuXHQvLyBXYW50IHRoZSBpbmRleGVzIHRvIGJlIGZhc3QgYW5kIGVhc3kgdG8gc2V0IHVwIHByaW1hcmlseVxuXHQvLyBNYWtlIGl0IGVhc3kgdG8gdXNlIGEgYisgdHJlZSBhbG9uZ3NpZGUgYSBkaWN0IGluIGluZGV4aW5nLlxuXG5cdC8vIFRoZSB0aGUgc3BlY2lmaWMgaW5kZXhlcy4uLlxuXG5cdC8vIFdpbGwgYWRkIG9iamVjdHMgdG8gdGhlbSwgYW5kIGJlIGFibGUgdG8gZG8gc2VhcmNoZXMgLyBnZXQgYnkga2V5LlxuXG5cdC8vIFdhbnQgYW4gaW5kZXggdGhhdCBpcyBib3RoIGIrIGFuZCBkaWN0LlxuXHQvLyBEaWN0IGlzIHVzZWQgZm9yIHRoZSBvYmplY3QgcmV0cmlldmFsIGZyb20ga2V5XG5cdC8vIFRoZSBiKyB0cmVlIGlzIHVzZWQgdG8gZW5zdXJlIHRoZSBjb3JyZWN0IG9yZGVyLlxuXG5cdC8vIENvbGxlY3Rpb24gYWx3YXlzIGhhcyBpdGVtcyBpbiBhbiBhcnJheS4uLj9cblx0Ly8gVGhhdCBhcnJheSBpbXBsZW1lbnRhdGlvbiBjb3VsZCBwb3NzaWJseSBjaGFuZ2UuXG5cdC8vIEhvd2V2ZXIsIEkgdGhpbmsgaXQgd2lsbCBiZSBPSyBmb3IgdGhlIG1vbWVudC5cblxuXHQvLyBBZGQgYW5kIHJlbW92ZSBkaWZmZXJlbnQgdHlwZXMgb2YgaW5kZXguXG5cdC8vIFBvc3NpYmx5IHNheSB3aGF0IHNvcnQgb2YgaW5kZXggaXMgbmVlZGVkLi4uXG5cdC8vIFRoZW4gdGhlIGluZGV4ZXMgY291bGQgaGF2ZSBkaWZmZXJlbnQgaW50ZXJuYWwgaW1wbGVtZW50YXRpb25zXG5cdC8vICBcblxuXHQvLyBXZSBtYXkgd2FudCB0byBleHBhbmQgdGhpcyBpbiB2YXJpb3VzIHdheXMuXG5cblx0Ly8gSGFzIGEgY29sbGVjdGlvbiBvZiBpbmRleGVzP1xuXHQvLyBXaXRoIHRoZW0gaW5kZXhlZD9cblx0Ly8gSW4gdGhpcyBzaXR1YXRpb24sIEkgdGhpbmsgd2UgbmVlZCB0byBkbyB0aGUgaW5kZXhpbmcgd2l0aGluIHRoZSBpbmRleFxuXHQvLyBzeXN0ZW0gb24gYSBsb3dlciBsZXZlbC4uLiBhIGJpdCBtb3JlIGNvZGUuXG5cdC8vIFRoaXMgaW5kZXhpbmcgc3lzdGVtIHdpbGwgYmUgdXNlZCBpbiBhIGZhaXIgZmV3IHBsYWNlcy5cblx0Ly8gTWF5IHdpc2ggdG8gYnVpbGQgb24gdGhpcyAobWF5YmUgc2VwYXJhdGUgbW9kdWxlKVxuXHQvLyB3aXRoIGEgZGlzY29ubmVjdGVkIC8gYXN5bmMgaW5kZXggc3lzdGVtLlxuXHQvLyBjYW4gbWFrZSB1c2Ugb2YgYXN5bmNyb25vdXMgZGF0YSBzdHJ1Y3R1cmVzLiBUaGVzZSBjb3VsZCBiZSBhY3Jvc3MgYVxuXHQvLyBuZXR3b3JrLlxuXG5cdC8vIENvbGxlY3Rpb25zIHdpbGwgaGF2ZSBkaWZmZXJlbnQga2luZHMgb2YgY29uc3RyYWludHMgdG8gRGF0YV9PYmplY3RzXG5cdC8vICBUaG91Z2ggYSBjb2xsZWN0aW9uIGNvbnN0cmFpbnQgY291bGQgYmUgdGhhdCBmaWVsZCBjb25zdHJhaW50cyBhcmUgcmVxdWlyZWQuXG5cdC8vICBEYXRhIG1vZGVscyBkZWZpbmVkIHVzaW5nIHRoaXMgc3lzdGVtIHdpbGwgdGhlbiBiZSBtb3JlIGVhc2lseSB0cmFuc2xhdGVkIHRvIERCIGFuZCBSRE0gZm9ybWF0cy5cblx0Ly8gICBDb3VsZCB1c2UgdGhlc2UgY29uc3RyYWludHMgaGVyZSBpbiBKYXZhU2NyaXB0IGZvciBjaGVja2luZyBiZWZvcmUgcHV0dGluZyBpbnRvIGFuIG9iamVjdCBkYXRhYmFzZVxuXHQvLyAgIENhbiBhbHNvIHVzZSB0aGVtIGluIGdlbmVyYXRpbmcgdGhlIFNRTCBkYXRhYmFzZSBhbmQgaXRzIENSVUQgZnVuY3Rpb25zLlxuXHQvLyAgICBMaWtlbHkgdG8gd2FudCB0byBjb250aW51ZSB3b3JraW5nIG9uIHRoZSBwYXJzZXIuIEJlaW5nIGFibGUgdG8gcGFyc2UgYSB2YXJpZXR5IG9mIGxhbmd1YWdlcyB3b3VsZCBwcm92ZSB2ZXJ5IHVzZWZ1bC5cblx0Ly8gICAgIEl0IHdvdWxkIGFsc28gaGVscCBmb3IgdGhlbSB0byBiZSBpbnRlZ3JhdGVkIHdpdGggdGhlIGRhdGEgbW9kZWwgYW5kIEphdmFTY3JpcHQgc3lzdGVtIEkgYW0gdXNpbmcgaGVyZS5cblx0Ly8gICAgIEJlaW5nIGFibGUgdG8gZ3JhcGhpY2FsbHkgaWxsdXN0cmF0ZSB3aGF0IGNvdWxkIGdvIGF0IGFueSBwb2ludCBpbiBhIGRvY3VtZW50IHdvdWxkIGJlIHZlcnkgdXNlZnVsLi4uXG5cdC8vICAgICAgaXQgd291bGQga25vdyB3aGF0IHRoZSBvYmplY3RzIGFyZSwgYW5kIGhlbHAgLyBoZWxwZnVsIHdpbmRvd3MgY291bGQgZGlzcGxheSBpbmZvcm1hdGlvbiByZWFkeSB0byBiZSBjbGlja2VkIG9uIG9yIHRhcHBlZCBpbiBvcmRlclxuXHQvLyAgICAgIHRvIGFkZCB0aGF0IHRleHQgb2YgZnVuY3Rpb24gY2FsbC4gV291bGQgYmUgbmljZSB0byBoYXZlIGFuIGlQYWQgbmV4dCB0byB0aGUga2V5Ym9hcmQgdG8gdGFwIHRoaW5ncyBhbmQgdmlldyBpbmZvIGludGVyYWN0aXZlbHkuXG5cdC8vICAgICAgQ291bGQgZWFzaWx5IGJlIGNvbm5lY3RlZCB0byBhbiBhZGRyZXNzIG92ZXIgdGhlIExBTiwgSSBkbyB0aGluayBhIExvY2FsX01CX05vZGUgc3lzdGVtIHJ1bm5pbmcgaW4gbm9kZS5qcyBjb3VsZCBlbmhhbmNlIHBlb3BsZSdzXG5cdC8vICAgICAgIGV4cGVyaWVuY2UgYXMgdGhleSB1c2UgdGhlIHdlYnNpdGUuIFxuXHRcblx0Ly8gRm9yIHRoZSBtb21lbnQsIHRoZSBzaW5nbGUgY2xpZW50IGlzIHdoYXQgbWF0dGVycy5cblx0XG5cdC8vIEFzIHdlbGwgYXMgdGhlIGluZGV4IHN5c3RlbSwgYXJlIHRoZSBjb2xsZWN0aW9uX2NvbnN0cmFpbnRzXG5cdC8vIFRoZXNlIGFyZSBkaWZmZXJlbnQgdG8gZmllbGRfY29uc3RyYWludHMuXG5cdC8vIE9uZSBjb2xsZWN0aW9uX2NvbnN0cmludCB3aWxsIGJlIGFwcGx5aW5nIGZpZWxkX2NvbnN0cmFpbnRzXG5cdFxuXHRcblx0Ly8gV2hlbiBhIGNvbGxlY3Rpb24gaXMgZ2l2ZW4gYSBmaWVsZCBjb25zdHJhaW50LCBpdCdzIGEgY29uc3RyYWludCB0aGF0IGFwcGxpZXMgdG8gdGhlIGZpZWxkcyBvZiBhbGwgb2JqZWN0cyBpbiB0aGUgY29sbGVjdGlvbi5cblx0XG5cdC8vIE5vdCBhIERhdGFfT2JqZWN0P1xuXHQvLyAgSXQgd291bGQgcHJvYmFibHkgYmUgc2FmZSB0byBtYWtlIHRoaXMgYSBEYXRhX09iamVjdC5cblx0Ly8gIE1ha2luZyB0aGlzIEluZGV4X1N5c3RlbSB1c2Ugc29tZSBsb3dlciBsZXZlbCBtZWNoYW5pc21zIGZvciBpbmRleGluZy4gVGhlIGluZGV4IGlzIG5vdCBhdmFpbGFibGUgaGVyZSwgdGhpcyBpcyB1c2VkIHRvIGltcGxlbWVudCBpbmRleGluZy5cblx0XG5cdC8vIFRoaXMga2luZCBvZiBpcyB0aGUgaW5kZXggaW5kZXguIE5vdCBzbyBzdXJlIGFib3V0IGEgbW9yZSBjb21wbGV4IGluZGV4IGluZGV4IGluc2lkZSB0aGlzLlxuXHQvLyAgQ2FuIHB1dCBhIGZldyBvZiB0aGUgb3BlcmF0aW9ucyBpbiBmdW5jdGlvbnMgdG8gZW5jYXBzdWxhdGUgaW5kZXggc2VhcmNoLlxuXHRcblx0Ly8gTWF5YmUgZG9uJ3QgY3JlYXRlIHRoZSBpbmRleCBzeXN0ZW0gaWYgdGhlcmUgaXMgbm90aGluZyB0byBkby5cblxuXHR2YXIgQ29sbGVjdGlvbl9JbmRleF9TeXN0ZW0gPSBDbGFzcy5leHRlbmQoe1xuXHRcdFxuXHRcdC8vIEkgYW0gbm93IGdvaW5nIHRvIGV4dGVuZCB0aGlzIHNvIHRoYXQgaXQgYWxzbyBjYW4gdXNlIEIrIHRyZWVzLlxuXHRcdC8vICBCKyB0cmVlcyBtYXkgYmUgYWR2YW50YWdlb3VzIHRvIHVzZSBpbiBtYW55IGNhc2VzIG92ZXIgZGljdHMsIGJ1dCB3aWxsIGxpa2VseSBiZSBzbG93ZXIgYW5kIHVzZSBtb3JlIG1lbW9yeSwgdGhvdWdoIHdpbGxcblx0XHQvLyAgYWxzbyBwcm92aWRlIHByZWZpeCBzZWFyY2ggYW5kIG9yZGVyaW5nIGZ1bmN0aW9uYWxpdHkgaW4gYWRkaXRpb24gdG8gdGhlIGRpY3QgaW5kZXguXG5cdFx0XG5cdFx0XG5cdFx0J2luaXQnIDogZnVuY3Rpb24oc3BlYykge1xuXG5cdFx0XHQvLyBUaGlzIGNvdWxkIGtlZXAgdHJhY2sgb2YgdGhlIHByaW1hcnlfdW5pcXVlX2luZGV4IGZvciBnZXRcblx0XHRcdC8vIG9wZXJhdGlvbnMuXG5cblx0XHRcdHRoaXMuY29sbGVjdGlvbiA9IHNwZWMuY29sbGVjdGlvbjtcblxuXHRcdFx0Ly8gVGhpcyBzaG91bGQgZG8gYSBmYWlyIGZldyB0aGluZ3MuLi5cblx0XHRcdC8vIEEgbmV3IGluZGV4IGNhbiBiZSBhZGRlZFxuXG5cdFx0XHQvLyBOZXcgaW5kZXggY3JlYXRlZD8gTWFrZXMgdGhlIGluZGV4IGdvIGFuZCBjb2xsZWN0IHRoZVxuXHRcdFx0Ly8gZGF0YSBieSBpdGVyYXRpbmcgdGhyb3VnaCB0aGUgYXJyYXkuXG5cblx0XHRcdC8vIFdpbGwgdGhpcyBTeXN0ZW0gY2xhc3MgbWFrZSB0aGUgQ29sbGVjdGlvbkluZGV4ZXMgYWxsXG5cdFx0XHQvLyB3b3JrIHRvZ2V0aGVyIHNtb290aGx5IGluIHRoZSBDb2xsZWN0aW9uIGNvZGU/XG5cblx0XHRcdC8vIFRoZSBzeXN0ZW0gd2lsbCBuZWVkIHRvIGtlZXAgdHJhY2sgb2YgdGhlIGluZGV4ZXMsIGtpbmRcblx0XHRcdC8vIG9mIHByb3ZpZGUgYW4gaW5kZXggdG8gdGhlbS5cblxuXHRcdFx0Ly8gV2lsbCB0aGlzIGJlIHRhc2tlZCB3aXRoIGNhcnJ5aW5nIG91dCB0aGUgcXVlcmllcz9cblx0XHRcdC8vIFdlIGhhdmUgdGhlIGluZGV4ZXMsIHdlIHNvIHdlIGhhdmUgYWNjZXNzIHRvIHRoZSByZXN1bHRzLlxuXG5cdFx0XHQvLyBUaGUgcXVlcnkgcGxhbm5lciBvciBleGVjdXRlciBjb3VsZCBnbyBpbiB0aGlzIHBhcnQuXG5cdFx0XHQvLyBKdXN0IG5lZWQgdG8gbWFrZSBpdCBzbyB0aGF0IGNvbGxlY3Rpb25zIGRvIGdldCBpbmRleGVkXG5cdFx0XHQvLyBPSywgc29tZSBzZXBhcmF0aW9uIG9mIGNvbmNlcm5zIG1heSBoZWxwLlxuXG5cdFx0XHQvLyBUaGlzIGNvdWxkIHJlYWxseSBiZSBpbiB0aGUgQ29sbGVjdGlvbi5cblxuXHRcdFx0Ly8gQ291bGQgaG9vayB0aGlzIHVwIHRvIGxpc3RlbiBmb3IgYW55IGl0ZW0gYmVpbmcgYWRkZWQgKG9yXG5cdFx0XHQvLyByZW1vdmVkKSBmcm9tIHRoZSBjb2xsZWN0aW9uP1xuXHRcdFx0Ly8gT3IganVzdCBoYXZlIHRoZSBjb2xsZWN0aW9uIG5vdGlmeSBpdCAtIG5vdCBzdXJlIHJpZ2h0XG5cdFx0XHQvLyBub3cuXG5cblx0XHRcdC8vIFRoaXMgY291bGQgZXhwb3NlIGFuIGVhc2llciBBUEkuXG5cdFx0XHQvLyBDb3VsZCBhbHNvIGhhdmUgYSBmdW5jdGlvbiB0aGF0IGdldHMgdGhlIGluZGV4IGJhc2VkIG9uXG5cdFx0XHQvLyB3aGljaCBmaWVsZHMsIGFuZCB3aGljaCBpbmRleCB0eXBlLlxuXG5cdFx0XHQvLyBUaGVuIHdpdGggZXZlcnl0aGluZyBpbmRleGVkIHdpdGhpbiB0aGlzIHN5c3RlbSwgaXQgbWF5XG5cdFx0XHQvLyBub3QgYmUgdG9vIGhhcmQgdG8gaGF2ZSB0aGlzIHN5c3RlbSBjYXJyeSBvdXQgdGhlXG5cdFx0XHQvLyBzZWFyY2hlcy5cblxuXHRcdFx0Ly8gSG93ZXZlciwgdGhlIHNlYXJjaGVzIGNvdWxkIGdldCBhIGJpdCBtb3JlIGNvbXBsZXguLi5cblx0XHRcdC8vIHNlYXJjaGluZyBub24taW5kZXhlZCBkYXRhLlxuXHRcdFx0Ly8gT3Igc29ydCwgdmFyaW91cyBmdW5jdGlvbnMuXG5cblx0XHRcdC8vIFBlcmhhcHMgaXQgd2lsbCBqdXN0IGJlIGluIHRoZSBjb2xsZWN0aW9uLi4uXG5cdFx0XHQvLyBPciB0aGVyZSBjb3VsZCBiZSBhbiBJbmRleF9TeXN0ZW1fU2VhcmNoZXIgb2JqZWN0LlxuXHRcdFx0Ly8gVGhhdCB3b3VsZCBoZWxwIGVuY2Fwc3VsYXRlIHRoZSBmdW5jdGlvbmFsaXR5LCBoYXZlIHRoZVxuXHRcdFx0Ly8gY29kZSBleHByZXNzIHdoYXQgaXQgaXMgZG9pbmcgYXQgdGhlIHNhbWUgdGltZS5cblx0XHRcdC8vIFNvIHdoZW4gYSBzZWFyY2ggcXVlcnkgaXMgZ2l2ZW4sIGl0IGlzIHRoZSBzZWFyY2hlciB0aGF0XG5cdFx0XHQvLyBxdWVyaWVzIHRoZSBpbmRleCBzeXN0ZW0sIGZpbmRzIG91dCB3aGF0IGluZGV4ZXMgdG8gdXNlLFxuXHRcdFx0Ly8gZ2V0cyB0aG9zZSBpbmRleGVzLCB0aGVuIHByZXBhcmVzIHRoZSByZXN1bHQuXG5cdFx0XHQvLyBJdCB3aWxsIGtub3cgd2hhdCBmaW5hbCBzdGFnZXMgbWF5IGJlIG5lY2Vzc2FyeSB0byBjYXJyeVxuXHRcdFx0Ly8gb3V0IHRoZSBxdWVyeSBzcGVjaWZpZWQuXG5cblx0XHRcdC8vIHRoaXMuaW5kZXhlcyA9IFtdO1xuXHRcdFx0Ly8ganVzdCBzdG9yZWQgaW4gYW4gYXJyYXk/XG5cblx0XHRcdC8vIG9yIGhhdmUgdGhlbSBpbiBzb21lIGtpbmQgb2Ygb2JqZWN0IG1hdHJpeD9cblxuXHRcdFx0Ly8gYSBjb2xsZWN0aW9uIG9mIGluZGV4ZXMgYW5kIHRoZW4gYW4gaW5kZXggb2YgdGhlbT9cblxuXHRcdFx0Ly8gYSByZWZlcmVuY2UgdG8gdGhlIHByaW1hcnkgaW5kZXggLSB0aGUgb25lIHRoYXQgaXMgdXNlZFxuXHRcdFx0Ly8gd2hlbiBwcm9jZXNzaW5nICdnZXQnIHJlcXVlc3RzLlxuXG5cdFx0XHQvLyBpbmRleCB0eXBlcz8gZGljdCwgb3JkZXJlZF9zdHJpbmcsIGZ1bGxfdGV4dD9cblx0XHRcdC8vIDMgaW5kZXggdHlwZXMgd2l0aCBkZWZpbmVkIGNhcGFiaWxpdGllcy4uLlxuXHRcdFx0Ly8gY291bGQgcHV0IGluIGEgZnVsbCB0ZXh0IGluZGV4LCB3aXRoIHRoZSBmdWxsIHRleHQgaW5kZXhcblx0XHRcdC8vIEFQSSBjbGVhcmx5IGRlZmluZWQuXG5cdFx0XHQvLyB0aGVuIGl0IHdvdWxkIGJlIGEgam9iIHRvIHdyaXRlIHNvbWUgY29tcHJlc3NlZCBkeW5hbWljXG5cdFx0XHQvLyBzdWZmaXggdHJlZSBKYXZhU2NyaXB0IGNvZGUuXG5cdFx0XHQvLyB0aGF0IGRhdGEgc3RydWN0dXJlIHdvdWxkIGJlIGludGVyZXN0aW5nIHdoZW4gcnVuIGluIGFcblx0XHRcdC8vIGRpc3RyaWJ1dGVkIGZhc2hpb24sIGNvdWxkIGhhdmUgaXQgYXMgdGhvdWdoIHZlcnkgbGFyZ2Vcblx0XHRcdC8vIGJsb2NrcyBvZiBtZW1vcnkgYXJlIGF2YWlsYWJsZS5cblxuXHRcdFx0Ly8gaW5kZXhlcyBieSBmaWVsZC4uLlxuXHRcdFx0Ly8gaW5kZXhlcyB3aXRoIG11bHRpcGxlIGZpZWxkcy5cblxuXHRcdFx0Ly8gZmllbGQgb2JqZWN0XG5cdFx0XHQvLyBzaW5nbGUgaW5kZXhcblx0XHRcdC8vIG9iamVjdCBjb250YWluaW5nIGluZGV4ZXMgd2l0aCBuZXN0ZWQgaW5kZXhlc1xuXG5cdFx0XHQvLyBpbmRleF9tYXBbJ2xhc3RfbmFtZSddLmluZGV4X21hcFsnZmlyc3RfbmFtZSddLmluZGV4ZXNfYnlfdHlwZVsnZGljdCddXG5cdFx0XHQvLyBvbmUgd2F5IG9mIGJlaW5nIGFibGUgdG8gZ2V0IHRoZSBpbmRleGVzIGZvciBhIHBhcnRpY3VsYXJcblx0XHRcdC8vIGZpZWxkLCBvZiBhIHBhcnRpY3VsYXIgdHlwZS5cblx0XHRcdC8vIFRoaW5rIHRoaXMgaXMgYW4gT0sgd2F5IHRvIHN0b3JlIGEgbWFwIG9mIHRoZSB2YXJpb3VzXG5cdFx0XHQvLyBpbmRleGVzIHRoYXQgYXJlIHVzZWQuXG5cdFx0XHQvLyBXaGF0IGFib3V0IGdldHRpbmcgYWxsIGluZGV4ZXM/IFNob3VsZCB3ZSBzdG9yZSB0aGVtIGluXG5cdFx0XHQvLyBhbiBhcnJheT9cblx0XHRcdC8vIE5vdCBzbyBzdXJlIGZvciB0aGUgbW9tZW50LCBjb3VsZCBpdGVyYXRlIG92ZXIgdGhlc2Vcblx0XHRcdC8vIGluZGV4ZXMsIGFuZCBhZGQgYW5kIHJlbW92ZSB0aGVtIHdpdGhvdXQgdG9vIG11Y2ggdHJvdWJsZVxuXHRcdFx0Ly8gaW4gdGhpcyBmb3JtYXQuXG5cblx0XHRcdC8vIGdldF9pbmRleGVzX2J5X3R5cGVfYnlfZmllbGRzKGFycl9maWVsZF9uYW1lcylcblx0XHRcdC8vIHRoZW4gdGhvc2UgaW5kZXhlcyBhcmUgcmVmZXJyZWQgdG8gYnkgdGhlIHR5cGUgb2YgaW5kZXhcblx0XHRcdC8vIChub3QgdGhlIGRhdGEgc3RydWN0dXJlIHVzZWQpLlxuXHRcdFx0Ly8gVGhvdWdoICdkaWN0JyB3b3JrcyBhcyBhIGhhc2ggdW5kZXIgdGhlIEpTIGRpY3QuXG5cblx0XHRcdC8vIG1heSBiZSBhIGxpdHRsZSB2ZXJib3NlIHNwZWNpZnlpbmcgc29tZSBpbmRleGVzLlxuXHRcdFx0Ly8gaG93ZXZlciwgd2FudCBhIHZlcnkgZnVuY3Rpb25hbCBpbmRleCBvZiBpbmRleGVzLlxuXHRcdFx0Ly8gd2l0aCB0aGUgcG9zc2liaWxpdHkgb2YgZGlmZmVyZW50IHR5cGVzIG9mIGluZGV4ZXMgYmVpbmdcblx0XHRcdC8vIHVzZWQuXG5cdFx0XHQvLyBiZWluZyBhYmxlIHRvIHJ1biByZWxhdGl2ZWx5IHNpbXBsZSBkaWN0IGluZGV4ZXMgb25cblx0XHRcdC8vIGNvbGxlY3Rpb25zIGZvciAnZ2V0JyBvcGVyYXRpb25zIHNlZW1zIGxpa2UgYSBnb29kIHBsYW4uXG5cdFx0XHQvLyBoYXZlIHRoYXQgd2l0aGluIGEgZmxleGlibGUgc3lzdGVtIHRoYXQgYWxsb3dzIGRpZmZlcmVudFxuXHRcdFx0Ly8gaW5kZXggdHlwZXMuXG5cblx0XHRcdC8vIGhhcyBhIGRpY3QgaW5kZXggKGxvb2t1cCAvIHVuaXF1ZSBrZXkpIChjb3VsZCBiZSBzZXQgdG9cblx0XHRcdC8vIGFsbG93IG11bHRpcGxlIGl0ZW1zLCBzbyB0aGF0IGFsbCBpdGVtcyBhdCBrZXkgZ2V0XG5cdFx0XHQvLyByZXR1cm5lZClcblx0XHRcdC8vIG9yIG9yZGVyZWRfc3RyaW5nPyAoYWxsb3dzIG11bHRpcGxlIGl0ZW1zIG1vcmUgZWFzaWx5KVxuXHRcdFx0Ly8gb3IgZnVsbF90ZXh0P1xuXG5cdFx0XHQvLyBjb3VsZCBnZXQgZGlmZmVyZW50IGltcGxlbWVudGF0aW9ucyBvZiB0aGVzZSB2YXJpb3VzXG5cdFx0XHQvLyBpbmRleGVzLlxuXHRcdFx0Ly8gZm9yIGZ1bGwgdGV4dCwgY291bGQgbWFrZSBhIHJlbGF0aXZlbHkgc2ltcGxlIHRyZWUgaW5kZXguXG5cdFx0XHQvLyBhbmQgY291bGQgYWxzbyBleHBlcmltZW50IHdpdGggc29tZSBvcHRpbWl6ZWQgZnVsbCB0ZXh0XG5cdFx0XHQvLyBpbmRleGVzLiBUaGUgdW5pdCB0ZXN0aW5nIHdvdWxkIGJlIHVzZWZ1bCBmb3IgbWFraW5nXG5cdFx0XHQvLyB0aGVzZSBpbmRleGVzLCBhbmQgaGF2aW5nIGEgc2ltcGxlIG9uZSBjb3VsZCB3b3JrXG5cdFx0XHQvLyB2ZXJ5IHdlbGwgZm9yIHRlc3RpbmcgYW5kIGNvbXBhcmlzb24uXG5cblx0XHRcdC8vIENvdWxkIGhhdmUgYSBkYXRhIHN0cnVjdHVyZXMgcHJvamVjdCB3aGVyZSBkaWZmZXJlbnQgb25lc1xuXHRcdFx0Ly8gY291bGQgYmUgbWFkZS5cblx0XHRcdC8vIE5vdCBzbyBzdXJlIHRoYXQgdGhlIGNsaWVudCBpbiBhIHdlYiBhcHAgd291bGQgbmVlZCB0aGlzP1xuXHRcdFx0Ly8gU2VhcmNoaW5nIHdvdWxkIHByb2JhYmx5IGJlIGRvbmUgb24gdGhlIHNlcnZlci5cblx0XHRcdC8vIEhvd2V2ZXIsIHRoZXNlIGRhdGEgc3RydWN0dXJlcyBjb3VsZCBsZWFkIHRvIHNlcnZlclxuXHRcdFx0Ly8gaW1wbGVtZW50YXRpb25zLlxuXG5cdFx0XHQvLyBpbmRleF9tYXBbJ2xhc3RfbmFtZSddLmluZGV4ZXNbJ2RpY3QnXVxuXHRcdFx0Ly8gYW5kIGtlZXBpbmcgdHJhY2sgb2YgdGhlIHByaW1hcnkgdW5pcXVlIGluZGV4LlxuXHRcdFx0XG5cdFx0XHQvLyBUaGVyZSBjb3VsZCBiZSBvbmUgaW5kZXggdGhhdCBpcyBjb25zaWRlcmVkIHRoZSBwcmltYXJ5X3VuaXF1ZV9pbmRleC5cblx0XHRcdC8vICBNYXliZSBkZXRlcm1pbmUgdGhlIHByaW1hcnkgdW5pcXVlIGZpZWxkP1xuXHRcdFx0XG5cdFx0XHRcblx0XHRcdFxuXHRcdFx0dGhpcy5pbmRleF9tYXAgPSB7fTtcblx0XHRcdC8vICB0aGUgaW5kZXhlcyBzdG9yZWQgaW4gdGhlIGluZGV4IG1hcC5cblx0XHRcdC8vICBtYXkgcmVxdWlyZSBzZWFyY2hpbmcgYXQgdGltZXMuXG5cdFx0XHRcblx0XHRcdFxuXHRcdH0sXG5cblx0XHQvLyByZXNwb25kIHRvIGV2ZW50cyBpbiB0aGUgRGF0YU9iamVjdHMgLyB2YWx1ZXMgc3RvcmVkIHdpdGhpbiB0aGUgY29sbGVjdGlvbi5cblx0XHQvLyAgdGhlIG5vcm1hbCBzeXN0ZW0gb2YgcHJvcGFnYXRpbmcgZXZlbnRzIHVwIHRvIHRoZSBwYXJlbnRzIC8gYW5jZXN0b3JzP1xuXHRcdC8vICBcblxuXHRcdCdub3RpZnlfaW5zZXJ0aW9uJzogZnVuY3Rpb24ocG9zKSB7XG5cdFx0XHQvLyBuZWVkIHRvIGNvZGUgdGhpcy5cblx0XHRcdC8vICBkb24ndCB0aGluayBpdHMgcmVsZXZhbnQgZm9yIGNvbnRyb2xzLCB3aGljaCBpcyB3aGF0IEknbSB3b3JraW5nIG9uIHJpZ2h0IG5vdy5cblxuXHRcdFx0Ly9jb25zb2xlLmxvZygnVE9ETyBjb2xsZWN0aW9uLWluZGV4IG5vdGlmeV9pbnNlcnRpb24nKTtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9LFxuXHRcdFxuXHRcdFxuXHRcdCdjbGVhcicgOiBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMuaW5kZXhfbWFwID0ge307XG5cdFx0fSxcblxuXHRcdC8vIHJlLWluZGV4IGEgd2hvbGUgY29sbGVjdGlvbiAvIGFycmF5Li4uXG5cblx0XHQvLyBhZGQgaW5kZXggYnkgdHlwZSBieSBmaWVsZHMuXG5cblx0XHQvLyBhbmQgc2V0IGl0IGFzIHRoZSBwcmltYXJ5IGluZGV4P1xuXHRcdC8vIHdhbnQgdG8gZG8gdGhhdCBmb3IgcXVpY2sgcmV0cmlldmFsIHdpdGggZ2V0IG9wZXJhdGlvbnMuXG5cblx0XHQvLyBPciBzZXQgdGhpbmdzIGFzIGJlaW5nIGEgcHJpbWFyeSAvIHVuaXF1ZSBmaWVsZCB0aGF0IHdpbGxcblx0XHQvLyB3b3JrIHdpdGggZ2V0IG9wZXJhdGlvbnMuXG5cdFx0Ly8gVGhlIGluZGV4aW5nIHN5c3RlbSBpcyBhIGxpdHRsZSBjb21wbGV4LCBidXQgaXQgd29uJ3QgdGFrZSB1cFxuXHRcdC8vIHRvbyBtdWNoIGNvZGUgd2hlbiBpdCdzIGluIHBsYWNlIGluIHRoZSBidWlsZC5cblx0XHQvLyBKdXN0IGEgZmV3IGh1bmRyZWQgYnl0ZXMgSSB0aGluay5cblxuXHRcdC8vIFN1cHBvcnRpbmcgZ2V0IG9wZXJhdGlvbnMgd2lsbCBtYWtlIHRoZSBDb2xsZWN0aW9uIHF1aXRlXG5cdFx0Ly8gdXNlZnVsLlxuXHRcdC8vIFdhbnQgaXQgc28gdGhhdCBjb2xsZWN0aW9ucyBlYXNpbHkgZml0IGludG8gcGxhY2UgaW4gY29kZSBpblxuXHRcdC8vIHZhcmlvdXMgc2l0dWF0aW9ucy5cblx0XHQvLyBXaWxsIG9mdGVuIGJlIGRlZmluaW5nIHdoaWNoIGZpZWxkcyBpbiBhbiBvYmplY3QgYXJlIHVuaXF1ZVxuXHRcdC8vIENvcnJlc3BvbmRpbmcgdG8gdW5pcXVlIGNvbHVtbnMgLyBjb2x1bW4gY29uc3RyYWludHMgaW4gYVxuXHRcdC8vIGRhdGFiYXNlLlxuXG5cdFx0Ly8gV2FudCB0byBtYWtlIGEgbmljZSBJREUgd2Vic2l0ZSwgYW5kIHVzZSB0aGF0IHRvIGRldmVsb3Bcblx0XHQvLyB2ZXJzaW9uIDIuXG5cdFx0Ly8gU2F2aW5nIGRhdGFiYXNlIHJlc291cmNlcy4uLlxuXHRcdC8vIExpa2VseSB0byBiZSBzdG9yaW5nIGNsYXNzZXMgYW5kIGZ1bmN0aW9ucyB3aXRoaW4gdGhlXG5cdFx0Ly8gZGF0YWJhc2UuIFdpbGwgYmUgYWJsZSB0byBidWlsZCB0aGVtIGludG8gbW9kdWxlcy5cblxuXHRcdC8vIElzIGEgY29tcGxpY2F0ZWQgd2F5IG9mIGdvaW5nIGFib3V0IHRoaW5ncyB0byBoYXZlIHNvbWV0aGluZ1xuXHRcdC8vIGluZGV4ZWQgd2l0aCBhIGRpY3QuLi5cblx0XHQvLyBCdXQgd2lsbCBzYXZlIG9uIGNvZGUgdXNlZCBpbiB2YXJpb3VzIG9iamVjdHMuIFNvbWVcblx0XHQvLyBjb21wbGV4aXR5IHRvIGJlIGhhbmRsZWQgYnkgdGhlIGNvbGxlY3Rpb24uXG5cdFx0Ly8gV2lsbCByZW1vdmUgY2x1dHRlciBmcm9tIGNvZGUgdGhhdCBzaG91bGQgYmUgZG9pbmcgc29tZXRoaW5nXG5cdFx0Ly8gZWxzZSBhcGFydCBmcm9tIGluZGV4aW5nIGEgZmllbGQuXG5cblx0XHQvLyBXaWxsIGdldCBzb21lIGV4YW1wbGVzIHdpdGggZGF0YSB3b3JraW5nLCB0aGVuIHdpbGwgZ2V0IHNvbWVcblx0XHQvLyBhYnN0cmFjdCBwb3N0Z3JlcyBvYmplY3RzIGhvbGRpbmcgdGhlaXIgb2JqZWN0cyB1c2luZ1xuXHRcdC8vIENvbGxlY3Rpb24uXG5cdFx0Ly8gVGhlIEFic3RyYWN0IFBvc3RncmVzIGNvZGUgd2lsbCBiZSB2ZXJ5IGNsZWFyLCBhbmQgZWFzeVxuXHRcdC8vIGFjY2VzcyB0byB0aGUgb2JqZWN0cyB3aWxsIGJlIHByb3ZpZGVkLlxuXG5cdFx0Ly8gUG9zc2libHkgd2lsbCBpbmRleCBhIGZ1bmN0aW9uIG1hdHJpeCB1c2luZyBtdWx0aXBsZSBmaWVsZHNcblx0XHQvLyBpbiBhbiBpbmRleD9cblx0XHQvLyBXaWxsIHRha2UgdGltZSBhbmQgZWZmb3J0IHRvIGltcHJvdmUgdGhlIGNvbGxlY3Rpb24sIGJ1dCB0aGVuXG5cdFx0Ly8gaXQgd2lsbCBiZSB1c2FibGUgdG8gc3RvcmUgbW9yZSB0aGluZ3MuXG5cdFx0Ly8gT3JkZXJpbmcgd2lsbCBub3QgbWF0dGVyIGluIG1hbnkgc2l0dWF0aW9ucy5cblx0XHQvLyBXaWxsIGJlIGFibGUgdG8gc29ydCBhIGNvbGxlY3Rpb24gdG9vLCBwcm9iYWJseSB0byBrZWVwIGl0XG5cdFx0Ly8gc29ydGVkIHRvby5cblxuXHRcdC8vIERpZmZlcmVudCBpbXBsZW1lbnRhdGlvbiBmb3IgZ2V0X2J5X3Bvc2l0aW9uIHBvc3NpYmxlIHJhdGhlclxuXHRcdC8vIHRoYW4gdXNpbmcgYXJyYXk/XG5cdFx0Ly8gUGVyaGFwcyB0aGVzZSBub3JtYWwgY29sbGVjdGlvbnMgd29uJ3QgYmUgc28gZ29vZCBmb3IgZGVhbGluZ1xuXHRcdC8vIHdpdGggbGFyZ2UgYW1vdW50cyBvZiBkYXRhLCB3aXRoIHRoZSBhcnJheSBvcGVyYXRpb25zLlxuXHRcdC8vIENvdWxkIG1heWJlIG1ha2UgYSBjb2xsZWN0aW9uIHRoYXQgZG9lcyBub3QgdXNlIGFuIGFycmF5IGZvclxuXHRcdC8vIGludGVybmFsIHN0b3JhZ2UuXG5cdFx0Ly8gUmlnaHQgbm93LCBrZWVwaW5nIHRyYWNrIG9mIHRoZSBwb3NpdGlvbiBpbiB0aGUgYXJyYXkgaXNcblx0XHQvLyBpbXBvcnRhbnQuXG5cdFx0Ly8gQ291bGQgcGVyaGFwcyBtYWtlIGEgQisgdHJlZSB3aGVyZSBpdGVtcyBrbm93IHRoZWlyIHBvc2l0aW9uLlxuXG5cdFx0Ly8gc2VhcmNoIGltcGxpZXMgcG9zc2libHkgcmV0dXJuaW5nIG11bHRpcGxlIHJlY29yZHMuXG5cdFx0Ly8gd2Ugc2hvdWxkIGtub3cgdGhlcmUgd29uJ3QgYmUgbXVsdGlwbGUgcmVjb3JkcyB3aGVuIHNlYXJjaGluZ1xuXHRcdC8vIHVzaW5nIGEgdW5pcXVlIGZpZWxkIC8gdW5pcXVlIGZpZWxkIGNvbWJpbmF0aW9uLlxuXG5cdFx0Ly8gY291bGQgaGF2ZSAnZ2V0Jz9cblx0XHQvLyBhIHdheSBvZiB0ZXN0aW5nIGlmIHRoaW5ncyBhcmUgc3RvcmVkIGluIGEgdW5pcXVlIGluZGV4XG5cdFx0Ly8gc3lzdGVtP1xuXG5cdFx0Ly8gYSBub24tdW5pcXVlIGRpY3Qgc3lzdGVtIHdoZXJlIG5ldyBkaWN0cyBnZXQgY3JlYXRlZCBhdCBlYWNoXG5cdFx0Ly8gbGV2ZWw/XG5cblx0XHQvLyBnZXRfYnkuXG5cdFx0Ly8gIHdpbGwgZ2V0IGJ5IGFuIGluZGV4ZWQgcHJvcGVydHkuXG5cdFx0XG5cdFx0Ly8gZ2V0IGlzIGZhaXJseSBzaW1wbGUuLi4gbmVlZCB0byBoYXZlIHRoZSBpbmRleCBkb2luZyBzZWFyY2hlcyB0b28uXG5cdFx0XG5cdFx0Ly8gYWxzbyB3YW50IHRvIHNlYXJjaCB0aGUgaW5kZXggc3lzdGVtIGZvciBpbmRleGVzIHRoYXQgYXJlIGZvciB2YXJpb3VzIGZpZWxkcywgYnV0IGluIGFueSBvcmRlci5cblx0XHQvLyAgVGhlc2UgaW5kZXhlcyBjYW4gYmUgdXNlZCB0byBpbXBsZW1lbnQgdW5pcXVlbmVzcyBjb25zdHJhaW50cyBldmVuIGlmIHRoZSBvcmRlciBvZiBrZXlzIGRvZXMgbm90IG1hdGNoLlxuXHRcdC8vICBIYXZpbmcgdGhpcyBkZWFsIHdpdGggc29tZSBtb3JlIGNvbXBsaWNhdGVkIGluZGV4aW5nIHBhdHRlcm5zIHNob3VsZCBtYWtlIGZvciBhIHZlcnkgcG93ZXJmdWwgY29sbGVjdGlvbiBjb21wb25lbnQuXG5cdFx0XG5cdFx0XG5cdFx0XG5cdFx0J3NlYXJjaF9mb3JfaW5kZXhfd2l0aF9maWVsZHMnOiBmcChmdW5jdGlvbihhLCBzaWcpIHtcblx0XHRcdC8vIHdpbGwgYmUgY29uc3VsdGluZyB0aGUgYWxwaGFiZXRpY2FsIGxpc3Qgb2YgZmllbGRzLlxuXHRcdFx0Ly8gIGFsc28sIGluZGV4IGNvdWxkIGJlIGluZGV4ZWQgd2l0aCBpdHMgYWxwaGFiZXRpY2FsIGxpc3Qgb2YgZmllbGRzLlxuXHRcdFx0XG5cdFx0XHQvLyBzY29wZSBmb3Igb3B0aW1pemF0aW9uIHRocm91Z2ggaW1wcm92ZWQgaW5kZXggaW5kZXhcblx0XHRcdC8vICBhbHBoYWJldGljYWxseSBzb3J0ZWQgS1ZTIG9mIGFscGhhYmV0aWNhbGx5IHNvcnRlZCBpbmRleCBmaWVsZHMuXG5cdFx0XHQvLyAgVGhpcyBpcyB0aGUga2luZCBvZiB0aGluZyB0aGF0IHdpbGwgbWFrZSB0aGlzIGEgZ29vZCBzeXN0ZW0hXG5cblx0XHRcdC8vIFBlcmhhcHMgbmVlZCBkaWZmZXJlbnQgbmFtaW5nIGZvciBhdHRhY2hlZCBmaWVsZHM/XG5cdFx0XHQvLyAgTmVlZCB0byBiZSBhYmxlIHRvIHRlbGwgdGhlbSBhcGFydCBmcm9tIGEgbGlzdCBvZiBmaWVsZHMuXG5cblx0XHRcdC8vIGFuIGF0dGFjaGVkIGZpZWxkOlxuXHRcdFx0Ly8gWydhdHRhY2hlZCcsICdtZXRhJywgJ25hbWUnXVxuXHRcdFx0Ly8gIGNvdWxkIGdldCBjb25mdXNlZCB3aXRoIGFuIGFycmF5IG9mIHRocmVlIHN0cmluZyBmaWVsZCBuYW1lcy5cblxuXHRcdFx0Ly8gJy8ubWV0YS5uYW1lJ1xuXHRcdFx0Ly8gIC8uIGNvdWxkIGJlIGNvbnZlbmllbnQgc3ludGF4IGZvciB0aGlzLCBzbyB3ZSBpbmRpY2F0ZSB0aGF0IGEgZmllbGQgaGFzIGJlZW4gYWRkZWQgdGhhdCBpc1xuXHRcdFx0Ly8gICBhbiBhdHRhY2hlZCBmaWVsZC5cblxuXHRcdFx0XG5cdFx0XHQvL2NvbnNvbGUubG9nKCdzZWFyY2hfZm9yX2luZGV4X3dpdGhfZmllbGRzICcgKyBzaWcpO1xuXHRcdFx0Ly9jb25zb2xlLmxvZygnYSAnICsgc3RyaW5naWZ5KGEpKTtcblx0XHRcdFxuXHRcdFx0aWYgKHNpZyA9PSAnW3NdJykge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5zZWFyY2hfZm9yX2luZGV4X3dpdGhfZmllbGRzKFthWzBdXSk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoc2lnID09ICdbYV0nKSB7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBjaGVjayB0aGUgaW5kZXggaW4gYWxwaGFiZXRpY2FsIG9yZGVyIC0gYW55IGluZGV4IHdpdGggdGhlIHJpZ2h0IGZpZWxkcyB3aWxsIGRvLlxuXHRcdFx0XHRcblx0XHRcdFx0Ly8gIG1heSBoYXZlIG9wdGlvbiB0byBjb250aW51ZSBzZWFyY2ggZm9yIHRoZSBpbmRleCB3aXRoIHRoZW0gbWF0Y2hpbmcgaW4gdGhlIHJpZ2h0IG9yZGVyLlxuXHRcdFx0XHRcblx0XHRcdFx0Ly8gY291bGQgY2hlY2sgZm9yIHRoYXQgb25lIGZpcnN0LlxuXG5cdFx0XHRcdC8vIE9LLCBidXQgdG8gaWRlbnRpZnkgdGhpcyBpcyBvbmUgZmllbGQ/XG5cdFx0XHRcdC8vICBQZXJoYXBzIHRoZSB3aG9sZSBmaWVsZCBuYW1lIGFzIGEgc3RyaW5nIGlzIGJldHRlcj9cblxuXHRcdFx0XHRcblx0XHRcdFx0Ly9jb25zb2xlLmxvZygnYVswXSAnICsgc3RyaW5naWZ5KGFbMF0pKTtcblx0XHRcdFx0XG5cdFx0XHRcdC8vdmFyIHNvcnRlZF9cblx0XHRcdFx0dmFyIGlkeCA9IHRoaXMuZ2V0X2luZGV4X3N0YXJ0aW5nKGFbMF0pO1xuXHRcdFx0XHQvL2NvbnNvbGUubG9nKCdpZHgnLCBpZHgpO1xuXHRcdFx0XHRyZXR1cm4gaWR4O1xuXHRcdFx0XHRcblx0XHRcdH1cblx0XHRcdC8vIGhvdyBhYm91dCBsb29raW5nIHRocm91Z2ggdGhlIGluZGV4ZXMgaW4gdGhpcyBmdW5jdGlvbj9cblxuXHRcdFx0aWYgKHNpZyA9PSAnW29dJykge1xuXHRcdFx0XHR2YXIgcmVzO1xuXHRcdFx0XHR2YXIgbWF0Y2hpbmdfY291bnQgPSAwO1xuXG5cdFx0XHRcdHRoaXMuaXRlcmF0ZV9pbmRleGVzKGZ1bmN0aW9uKGluZGV4LCBzdG9wKSB7XG5cdFx0XHRcdFxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdC8vY29uc29sZS5sb2coJ2l0ZXJhdGVfaW5kZXhlcyBpbmRleCAnICsgaW5kZXgpO1xuXHRcdFx0XHRcdC8vY29uc29sZS5sb2coJ2l0ZXJhdGVfaW5kZXhlcyBpbmRleC5maWVsZHMgJyArIHN0cmluZ2lmeShpbmRleC5maWVsZHMpKTtcblx0XHRcdFx0XHQvL2NvbnNvbGUubG9nKCdpdGVyYXRlX2luZGV4ZXMgaW5kZXguZmllbGRzICcgKyBzdHJpbmdpZnkoaW5kZXguZmllbGRzKSk7XG5cdFx0XHRcdFx0Ly9jb25zb2xlLmxvZygnZmllbGRzICcgKyBzdHJpbmdpZnkoZmllbGRzKSk7XG5cdFx0XHRcdFx0Ly8gY29tcGFyZSB0aGUgdHdvIGFycmF5c1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdHZhciBpX2ZpZWxkcyA9IGluZGV4LmZpZWxkcztcblx0XHRcdFx0XHRpZiAodG9mKGlfZmllbGRzKSA9PSAnc3RyaW5nJykgaV9maWVsZHMgPSBbaV9maWVsZHNdO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdC8vY29uc29sZS5sb2coJ2FbMF0gJyArIHN0cmluZ2lmeShhWzBdKSk7XG5cdFx0XHRcdFx0Ly9jb25zb2xlLmxvZygnaV9maWVsZHMgJyArIHN0cmluZ2lmeShpX2ZpZWxkcykpO1xuXG5cdFx0XHRcdFx0dmFyIGFlID0gYXJlX2VxdWFsKFthWzBdXSwgaV9maWVsZHMpO1xuXHRcdFx0XHRcdFxuXG5cdFx0XHRcdFx0aWYgKGFlKSB7XG5cdFx0XHRcdFx0XHQvL21hdGNoaW5nX2luZGV4ZXMucHVzaChpbmRleCk7XG5cdFx0XHRcdFx0XHRyZXMgPSBpbmRleDtcblx0XHRcdFx0XHRcdG1hdGNoaW5nX2NvdW50ICsrO1xuXHRcdFx0XHRcdFx0Ly9jb25zb2xlLmxvZygncmVzICcgKyByZXMpO1xuXHRcdFx0XHRcdFx0Ly9yZXR1cm4gcmVzO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcblx0XHRcdFx0XHQvL2NvbnNvbGUubG9nKCdhZSAnICsgYWUpO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdC8vdGhyb3cgKCdpdGVyYXRlX2luZGV4ZXMgc3RvcCcpO1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0aWYgKG1hdGNoaW5nX2NvdW50ID4gMSkge1xuXHRcdFx0XHRcdHRocm93ICd1bmV4cGVjdGVkIG1hdGNoaW5nX2NvdW50ID4gMSc7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aWYgKG1hdGNoaW5nX2NvdW50ID09IDEpIHtcblx0XHRcdFx0XHRcdHJldHVybiByZXM7XG5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRcblx0XHRcdFxuXHRcdFx0XG5cdFx0fSksXG5cdFx0XG5cdFx0XG5cdFx0Ly8gY2FsbGluZyB0aGlzIGZpbmQgbm93LlxuXHRcdC8vICBzaG9ydGVyLCBtb3JlIHBvc2l0aXZlIHNvdW5kaW5nLlxuXHRcdCdmaW5kJzogZnAoZnVuY3Rpb24oYSwgc2lnKSB7XG5cdFx0XHRcblx0XHRcdC8vIHdlIGNhbid0IHJlYWxseSBkbyBzZWFyY2ggYXQgdGhlIG1vbWVudC5cblx0XHRcdC8vICAyMS8wNi8yMDEyLCBub3cgd2UgY2FuLiBHb29kIEIrIGltcGxlbWVudGF0aW9uIG5vdyBpbiB0aGVyZS5cblx0XHRcdC8vICBpdCBsb29rcyBsaWtlIHdlIGNhbiBub3cuLi4gYnV0IG1heWJlIGl0J3MgdXNpbmcgJ2dldCcuXG5cdFx0XHRcblx0XHRcdC8vIGhvd2V2ZXIsIGRvIHdhbnQgZnVsbC10ZXh0IHNlYXJjaC5cblx0XHRcdFxuXHRcdFx0Ly8gd2lsbCBiZSBkb2luZyBzZWFyY2hlcyB3aXRoID0gb3IgcHJlZml4ZXMgb2suXG5cdFx0XHRcblx0XHRcdC8vICAobm90IGFsbCB0aGF0IHdlbGwpXG5cdFx0XHQvLyBhdCBhIGxhdGVyIHN0YWdlIHdlIHdpbGwgaGF2ZSBmdWxsLXRleHQgc2VhcmNoIG9uIGluZGV4ZXNcblx0XHRcdC8vICB3aWxsIHNlYXJjaCBhIGxvd2VyIGNhc2UgdmVyc2lvbiBvZiB0aGUgdGV4dC5cblx0XHRcdFxuXHRcdFx0Ly8gSSB0aGluayBhIHRyaWUgd2lsbCBzdWZmaWNlIGZvciB0aGlzIGZ1bmN0aW9uYWxpdHkuXG5cdFx0XHQvLyAgV2lsbCBkbyBtb3JlIGV4cGVyaW1lbnRzIG9uIHRoaXMuXG5cdFx0XHQvLyAgTWF5IGhhdmUgYW4gaW5kZXggb2Ygd29yZHMgYW5kIHdvcmQgb2NjdXJyYW5jZXMgd2l0aGluIGEgY29sbGVjdGlvbi5cblx0XHRcdC8vICAgVGhhdCB3b3VsZCBiZSBhIGRlY2VudCBpbmRleGluZyBzeXN0ZW0uXG5cdFx0XHQvLyAgIENvdWxkIGFsc28gZ28gZm9yIHRoZSBmdWxsIHRleHQgaW5kZXggdGhhdCBjb3VsZCBiZSBtb3JlIHBvd2VyZnVsIGFuZCBmbGV4aWJsZS5cblx0XHRcdC8vICAgTWF5IHdhbnQgdG8gYmUgY2FyZWZ1bCBhYm91dCBzZXR0aW5nIHdvcmQgYm91bmRhcnkgc2VhcmNoIHJ1bGVzLlxuXHRcdFx0XG5cdFx0XHQvLyB0aGF0IGNvdWxkIGJlIGRvbmUgdXNpbmcgYSB0cmllLCBwcmV4aXggdHJlZSwgc3VmZml4IHRyZWUsIHN1ZmZpeCBhcnJheSwgY29tcHJlc3NlZCBkeW5hbWljIHN1ZmZpeCBhcnJheSwgb3Igb3RoZXIgZGF0YSBzdHJ1Y3R1cmUuXG5cdFx0XHRcblx0XHRcdFxuXHRcdFx0Ly8gY2FuIHNlYXJjaCBvbmUgZmllbGQgZm9yIGEgbmFtZSAvIHZhbHVlIHBhaXIuXG5cdFx0XHQvL2NvbnNvbGUubG9nKCdDb2xsZWN0aW9uX0luZGV4X1N5c3RlbSBzZWFyY2ggc2lnOiAnICsgc2lnKTtcblx0XHRcdC8vIHNlYXJjaGluZyBtdWx0aXBsZSBmaWVsZHMgLSBtdWx0aXBsZSBuYW1lIHZhbHVlIHBhaXJzLlxuXG5cdFx0XHQvLyBudnA6IFtzLD9dXG5cblx0XHRcdC8vIGRvIHdlIGhhdmUgYW55IGluZGV4ZXMgdGhhdCBjb3ZlciBhbGwgZmllbGRzP1xuXHRcdFx0Ly8gY291bGQgZG8gbWVyZ2luZyBiYXNlZCBvbiB0aGUgcmVzdWx0cyBvZiBtb3JlIHRoYW4gb25lXG5cdFx0XHQvLyBpbmRleC5cblxuXHRcdFx0Ly8gZGV2aXNpbmcgdGhlIHNlYXJjaCBzdHJhdGVneSBiZWNvbWVzIGEgYml0IG1vcmUgY29tcGxleFxuXHRcdFx0Ly8gd2hlbiBkZWFsaW5nIHdpdGggbW9yZSB0aGFuIG9uZSBpbmRleCwgYmVpbmcgYXNrZWQgdG9cblx0XHRcdC8vIHNlYXJjaCBieSBtb3JlIHRoYW4gb25lIGZpZWxkLlxuXG5cdFx0XHQvLyB0aGUgaW5kZXhpbmcgc3lzdGVtIGRvZXMgbm90IGhvbGQgYWxsIGRhdGEgYW55d2F5LlxuXHRcdFx0Ly8gaXQgd29uJ3QgYmUgYWJsZSB0byBkbyBhbGwgc2VhcmNoZXMuXG5cblx0XHRcdC8vIHBlcmhhcHMgaXQgc2hvdWxkIGJlIHF1ZXJpZWQgdG8gc2VlIHdoYXQgZmllbGRzIGl0IGRvZXNcblx0XHRcdC8vIGluZGV4IGJ5IGJlZm9yZSBkb2luZyBhIHNlYXJjaC5cblx0XHRcdC8vIGFmdGVyIGRvaW5nIGEgc2VhcmNoIHdpdGggYW4gaW5kZXgsIG1heSBuZWVkIHRvIHRoZW5cblx0XHRcdC8vIHNlYXJjaCB0aHJvdWdoIG90aGVyIGZpZWxkcyB3aXRob3V0IHVzaW5nIHRoZSBpbmRleC5cblxuXHRcdFx0Ly8gc2VhcmNoaW5nIGJ5IHRoaW5ncyBpbiB0aGUgb3JkZXIgb2YgdGhlIGluZGV4ZXNcblx0XHRcdC8vIHNlYXJjaGluZyBpbiBvdGhlciBvcmRlciwgd291bGQgYmUgbmljZSBpZiBpdCBjYW4gY29uc3VsdFxuXHRcdFx0Ly8gdGhlIHJpZ2h0IGluZGV4LlxuXHRcdFx0XG5cdFx0XHQvLyB2YXIgZm91bmQgPSBjb2xsX3ByZXNpZGVudHMuZmluZChbWyduYW1lJywgJ0ZyYW5rbGluIFBpZXJjZSddLCBbJ3BhcnR5JywgJ1JlcHVibGljYW4nXV0pO1xuXHRcdFx0XG5cdFx0XHQvL2NvbnNvbGUubG9nKCdDb2xsZWN0aW9uX0luZGV4X1N5c3RlbSBmaW5kIHNpZyAnICsgc2lnKTtcblx0XHRcdC8vY29uc29sZS5sb2coJ2EubCAnICsgYS5sKTtcblxuXHRcdFx0aWYgKHNpZyA9PSAnW29dJykge1xuXHRcdFx0XHR2YXIgb2JqUXVlcnkgPSBhWzBdO1xuXHRcdFx0XHQvL2NvbnNvbGUubG9nKCdvYmpRdWVyeSAnICsgc3RyaW5naWZ5KG9ialF1ZXJ5KSk7XG5cblx0XHRcdFx0Ly9jb25zb2xlLmxvZygndGhpcy5pbmRleF9tYXAgJyArIHN0cmluZ2lmeSh0aGlzLmluZGV4X21hcCkpO1xuXHRcdFx0XHQvLyBzbyBtYXliZSBpZiB0aGVyZSBpcyBubyBpbmRleCBtYXAgd2UgcmV0dXJuIGZhbHNlLlxuXHRcdFx0XHQvLyAgbm90IHN1cmUgYWJvdXQgaW5kZXhlZCBzdWItaXRlbXMuXG5cblx0XHRcdFx0Ly8gIG1heSBsZWF2ZSB0aGF0IGZvciB0aGUgbW9tZW50LlxuXHRcdFx0XHQvLyAgIEknbSBzdXJlIGl0IHdpbGwgYmUgdXNlZnVsIHRob3VnaC5cblx0XHRcdFx0Ly8gICAgUGVyaGFwcyB0aGV5IGNvdWxkIGJlIGZvdW5kIHRocm91Z2ggaW5kZXhlcyBpbiB0aGVpciBvd24gY29sbGVjdGlvbnMsIHNvIGl0J3Mgbm90IGRvd25cblx0XHRcdFx0Ly8gICAgIHRvIHRoZSBpbmRleGluZyBzeXN0ZW0gdG8gZmluZCB0aGVtIGFwYXJ0IGZyb20gcG9pbnQgdGhlbSB0byB0aGUgcmlnaHQgaXRlbSB3aGVyZSBpdCBjYW4uXG5cblx0XHRcdFx0Ly8gT2JqZWN0IHF1ZXJ5XG5cdFx0XHRcdC8vIC0tLS0tLS0tLS0tLVxuXG5cdFx0XHRcdC8vIEFyZSB3ZSBsb29raW5nIGZvciBhIGZpZWxkIHRoYXQgaXMgaW5kZXhlZD9cblx0XHRcdFx0Ly8gIEFyZSB3ZSBzcGVjaWZ5aW5nIG11bHRpcGxlIGZpZWxkcz9cblxuXHRcdFx0XHQvLyBEZWFsaW5nIHdpdGggc2VhcmNoaW5nIGZvciBhIHNpbmdsZSBpdGVtIHdpdGggYSBxdWVyeSBzZWVtcyBsaWtlIGEgZ29vZCBjYXNlIHRvIGhhbmRsZS5cblx0XHRcdFx0Ly8gIE90aGVyIGxvZ2ljIGNhbiBkZWFsIHdpdGggb3RoZXIgY2FzZXMuXG5cblx0XHRcdFx0Ly8gaW5kZXhlc1xuXG5cdFx0XHRcdHZhciBpbmRleGVzID0gdGhpcy5pbmRleGVzKCk7XG5cblx0XHRcdFx0Ly8gY2FuJ3Qgc3RyaW5naWZ5IHRoZSBpbmRleGVzLlxuXG5cblxuXHRcdFx0XHQvL2NvbnNvbGUubG9nKCd0IGluZGV4ZXMgJyArIHRvZihpbmRleGVzKSk7XG5cdFx0XHRcdC8vY29uc29sZS5sb2coJ2luZGV4ZXMubGVuZ3RoICcgKyBpbmRleGVzLmxlbmd0aCk7XG5cblx0XHRcdFx0Ly8gdGhlbiBmb3IgZWFjaCBpbmRleCwgd2Ugc2VlIHdoaWNoIGZpZWxkcyBpdCBpcy4uLlxuXHRcdFx0XHR2YXIgbWFwX3NpbmdsZV9maWVsZF9pbmRleGVzX2J5X2ZpZWxkID0ge307XG5cdFx0XHRcdGVhY2goaW5kZXhlcywgZnVuY3Rpb24oaSwgdikge1xuXHRcdFx0XHRcdGlmICh2LmZpZWxkcy5sZW5ndGggPT0gMSkge1xuXHRcdFx0XHRcdFx0Ly9jb25zb2xlLmxvZygndG9mIHYuZmllbGRzWzBdICcgKyB0b2Yodi5maWVsZHNbMF0pKTtcblxuXHRcdFx0XHRcdFx0dmFyIGZpZWxkID0gdi5maWVsZHNbMF07XG5cdFx0XHRcdFx0XHR2YXIgdEZpZWxkID0gdG9mKGZpZWxkKTtcblxuXHRcdFx0XHRcdFx0aWYgKHRGaWVsZCA9PSAnc3RyaW5nJykge1xuXHRcdFx0XHRcdFx0XHRtYXBfc2luZ2xlX2ZpZWxkX2luZGV4ZXNfYnlfZmllbGRbZmllbGRdID0gdjtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vY29uc29sZS5sb2coJ3YuZmllbGRzICcgKyBzdHJpbmdpZnkodi5maWVsZHMpKTtcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0Ly8gT0ssIHNvIHdlIHNlZSB3aGF0IGl0J3MgaW5kZXhlZCBieS5cblx0XHRcdFx0Ly8gIFdlIGFsc28gbmVlZCB0byB1c2UgdGhlIGluZGV4IHRvIGZpbmQgdGhlIGl0ZW1zIGJ5IHRoZSBvYmplY3Qga2V5LlxuXG5cdFx0XHRcdC8vIHtrZXk6IHZhbHVlfVxuXG5cdFx0XHRcdC8vIFdpbGwgbmVlZCB0byBsb29rIHRocm91Z2ggdGhlIHByb3BlcnRpZXMgb2YgdGhlIG9iamVjdCBnaXZlbiB0byB0aGlzLlxuXHRcdFx0XHR2YXIgYyA9IDA7XG5cdFx0XHRcdHZhciBrZXlzID0gW107XG5cblx0XHRcdFx0ZWFjaChvYmpRdWVyeSwgZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuXHRcdFx0XHRcdC8vY29uc29sZS5sb2coJ2tleSAnICsga2V5KTtcblx0XHRcdFx0XHQvL2NvbnNvbGUubG9nKCd2YWx1ZSAnICsgdmFsdWUpO1xuXHRcdFx0XHRcdGMrKztcblx0XHRcdFx0XHRrZXlzLnB1c2goa2V5KTtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdC8vY29uc29sZS5sb2coJ2MgJyArIGMpO1xuXG5cdFx0XHRcdGlmIChrZXlzLmxlbmd0aCA9PSAxKSB7XG5cdFx0XHRcdFx0dmFyIGluZGV4ID0gbWFwX3NpbmdsZV9maWVsZF9pbmRleGVzX2J5X2ZpZWxkW2tleXNbMF1dO1xuXG5cdFx0XHRcdFx0aWYgKGluZGV4KSB7XG5cdFx0XHRcdFx0XHR2YXIgcmVzID0gaW5kZXguZ2V0KG9ialF1ZXJ5W2tleXNbMF1dKTtcblx0XHRcdFx0XHRcdC8vY29uc29sZS5sb2coJ3JlcyAnICsgc3RyaW5naWZ5KHJlcykpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHJlcztcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Ly90aHJvdyAnbm8gaW5kZXggZm91bmQnO1xuXG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gd2Ugc2VlIHdoaWNoIFxuXG5cblx0XHRcdFx0Ly8gV2FudCB0byBzZWFyY2ggYW55IGluZGV4ZXMgdGhhdCBtYXRjaC4gTWF5IG5lZWQgdG8gbG9vayB0aHJvdWdoIGRpZmZlcmVudCBzZXRzIGlmIHdlIGFyZSBzZWFyY2hpbmdcblx0XHRcdFx0Ly8gIGZvciBtb3JlIHRoYW4gb25lIHRoaW5nP1xuXG5cblxuXG5cdFx0XHRcdHRocm93ICdzdG9wJztcblxuXG5cdFx0XHRcdC8vY29uc29sZS5sb2coJ0NvbGxlY3Rpb25fSW5kZXhfU3lzdGVtIHNlYXJjaCBkb2VzIG5vdCBoYW5kbGUgb2JqZWN0IHF1ZXJ5LicpO1xuXHRcdFx0XHQvLyAgbm90IHlldD8gdGhhdCB3aWxsIGJlIGEgZmllbGQgbmFtZSB0eXBlIHRoaW5nLCBjYW4gbG9vayBmb3IgZmllbGRzIG9uIGFuIGF0dGFjaGVkXG5cdFx0XHRcdC8vICAgb2JqZWN0LlxuXHRcdFx0XHQvL3Rocm93ICdzdG9wJztcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXG5cblxuXHRcdFx0aWYgKHNpZyA9PSAnW2FdJykge1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gLmZpbmQoJ0RvbmFsZCBUc2FuZyA8IG5hbWUgPCBKYW1pZSBPbGl2ZXInKVxuXHRcdFx0XHQvLyAuZmluZCgnSmFtaWUgT2xpdmVyID4gbmFtZSA+IERvbmFsZCBUc2FuZycpIC8vIGluIHJldmVyc2Ugb3JkZXIgLSBpdCBjb3VsZCBub3RpY2UgdGhhdCBhID4gYiBhbmQgZG8gdGhlIERFU0MgcXVlcnkuXG5cdFx0XHRcdFxuXHRcdFx0XHQvLy5maW5kKClcblx0XHRcdFx0XG5cdFx0XHRcdC8vIFdlIGNvdWxkIGRvIGEgYml0IG9mIGludGVycHJldGF0aW9uIG9uIHdoYXQgaXMgYmVpbmcgbG9va2VkIGZvci5cblx0XHRcdFx0Ly8gIFRoZXJlIGNvdWxkIGJlIGEgc2VhcmNoIGV4cHJlc3Npb24gaGVyZS5cblx0XHRcdFx0Ly8gIEF0IHRoZSBtb21lbnQgdGhlIHNlYXJjaCBleHByZXNzaW9uIGlzIGp1c3QgdGhlIGZpZWxkIHZhbHVlLCB3aXRob3V0IHRoZSBmaWVsZCBuYW1lXG5cdFx0XHRcdFxuXHRcdFx0XHQvLyAnW2luZGV4ZWRfZmllbGRfdmFsdWVdID0gSmFtaWUgT2xpdmVyJ1xuXHRcdFx0XHQvLyAnPSBKYW1pZSBPbGl2ZXInXG5cdFx0XHRcdC8vICdKYW1pZSBPbGl2ZXInXG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBJbmRleCBwYXJzaW5nIGZvciB0aGUgcXVlcmllcyBzaG91bGQgYmUgdXNlZnVsLlxuXHRcdFx0XHQvLyAgQWxzbyB3YW50IHRoaW5ncyBhYmxlIHRvIGJlIGRvbmUgbm90IGluIHN0cmluZ3MuLi5cblx0XHRcdFx0Ly8gICBEb24ndCB3YW50IHRvIGZhbGwgaW50byB0aGUgJ1NRTCBUcmFwJyBvZiBjcmVhdGluZyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBkeW5hbWljYWxseSBvbmx5IHRvIGhhdmUgdG8gcGFyc2UgaXQgYWdhaW4uXG5cdFx0XHRcdFxuXHRcdFx0XHQvLyAuZmluZChbJ0RvbmFsZCBUc2FuZycsICc8JywgJ25hbWUnLCAnPCcsICdKYW1pZSBPbGl2ZXInXSlcblx0XHRcdFx0XG5cdFx0XHRcdC8vIHRoZSBkZWZhdWx0IHdpbGwgYmUgPD1cblx0XHRcdFx0Ly8gLmZpbmQoWydEb25hbGQgVHNhbmcnLCAnPD0nLCAnbmFtZScsICc8PScsICdKYW1pZSBPbGl2ZXInXSlcblx0XHRcdFx0Ly8gICAgICAgICAgICAgICAgICAgICAgICAgICA9PVxuXHRcdFx0XHQvLyAuZmluZChbJ0RvbmFsZCBUc2FuZycsICduYW1lJywgJ0phbWllIE9saXZlciddKVxuXHRcdFx0XHRcblx0XHRcdFx0Ly8gLmZpbmQoe1xuXHRcdFx0XHQvLyAgICAnbmFtZSc6IFsnRG9uYWxkIFRzYW5nJywgJ0phbWllIE9saXZlciddIC8vIG5vdCBzYXlpbmcgaW5jbHVzaXZlIG9yIGV4Y2x1c2l2ZSwgY291bGQgYmUgaW5jbHVzaXZlIGJ5IGRlZmF1bHRcblx0XHRcdFx0Ly8gICAgJ25hbWUnOiBbWydEb25hbGQgVHNhbmcnLCBmYWxzZV0sIFsnSmFtaWUgT2xpdmVyJywgZmFsc2VdXSAvLyBleGNsdXNpdmVcblx0XHRcdFx0Ly8gICAgIGV4Y2x1c2l2ZShzdHIpIC0+IFtzdHIsIGZhbHNlXVxuXHRcdFx0XHQvLyAgV2lsbCBuZWVkIHRvIGRvIG1vcmUgc3BlY2lmeWluZyBhbmQgdGVzdGluZyBmb3Igbm9uLXN0cmluZyB2YWx1ZXMgaW4gaW5kZXhlcy5cblx0XHRcdFx0Ly8gICBHZXR0aW5nIG51bWVyaWNhbCBpbmRleGVzIHJpZ2h0IHdpdGggdGhlIGNvbXBhcmlzb24gZnVuY3Rpb24gd291bGQgYmUgbmljZS5cblx0XHRcdFx0Ly8gICAgc3RvcmVzIHRoZSBudW1iZXIgYXMgYSBzdHJpbmcuLi4gYnV0IHN0b3JlcyBpdCBpbiBudW1lcmljYWwgb3JkZXIuXG5cdFx0XHRcdC8vICAgICBXb3VsZCBwcm9iYWJseSBiZSBiZXN0IHRvIHBhcnNlIGl0IHRvIGEgbnVtYmVyIGZvciB0aGUgY29tcGFyaXNvbi5cblx0XHRcdFx0Ly8gICAgICBDb3VsZCB0cnkgd2l0aCBudW1lcmljIGtleXMgZGlyZWN0bHkgLSB0aGV5IGNvdWxkIHdvcmsgd2l0aCBjb21wYXJpc29ucy5cblx0XHRcdFx0Ly8gfSlcblx0XHRcdFx0XG5cdFx0XHRcdC8vICBzbGlnaHRseSBvZGQgc3ludGF4LCBidXQgaXQgbWFrZXMgc2Vuc2UuXG5cdFx0XHRcdC8vICAgaGF2aW5nIHRoZSAnbmFtZScgZmllbGQgaW4gdGhlIG1pZGRsZS4uLiBkb2VzIG1ha2Ugc2Vuc2UuXG5cdFx0XHRcdC8vICBleHByZXNzZXMgdGhlIG9wZXJhbmRzIC0gYXMgaWYgaXQgaGFzIGJlZW4gcGFyc2VkLCB0aGUgbmV4dCBzdGFnZS5cblx0XHRcdFx0Ly8gc2VhcmNoaW5nIGZvciB0aGlzIG9uZSB2YWx1ZS5cblx0XHRcdFx0Ly8gbm90IGFsbCBpbmRleGVzLi4uIG5lZWQgdG8gaGF2ZSBhIGRlZmF1bHQgaW5kZXguXG5cdFx0XHRcdC8vIHByaW1hcnkgaW5kZXg/XG5cdFx0XHRcdC8vICBtYXkgYmUgc3BhY2lmeWluZyB0aGUgbmFtZSBvZiB0aGUgZmllbGQgaW4gbWFueSBjYXNlcy5cblx0XHRcdFx0Ly8gIHRoaXMgd2lsbCBiZSBtb3N0IHVzZWZ1bCB3aGVuIG9ubHkgb25lIGluZGV4IGlzIHNldCB1cC5cblx0XHRcdFx0Ly9jb25zb2xlLmxvZygnSW5kZXggU3lzdGVtIGZpbmQgYVswXSAnICsgc3RyaW5naWZ5KGFbMF0pKTtcblx0XHRcdFx0Ly8gcHJpbWFyeSBpbmRleD9cblx0XHRcdFx0Ly8gIG1heSBiZSB0aGUgY2FzZSB3aGVuIHRoZXJlIGlzIG9ubHkgb25lIGluZGV4LlxuXHRcdFx0XHQvLyAgbWF5IHNwZWNpZnkgcHJpbWFyeSBpbmRleGVzIGF0IG90aGVyIHRpbWVzLlxuXHRcdFx0XHRcblx0XHRcdFx0dmFyIGluZGV4ZXMgPSBbXTtcblx0XHRcdFx0XG5cdFx0XHRcdHRoaXMuaXRlcmF0ZV9pbmRleGVzKGZ1bmN0aW9uKGZpbmRpbmdfaW5kZXgpIHtcblx0XHRcdFx0XHQvL2NvbnNvbGUubG9nKCdmaW5kaW5nX2luZGV4ICcgKyBmaW5kaW5nX2luZGV4KTtcblx0XHRcdFx0XHRpbmRleGVzLnB1c2goZmluZGluZ19pbmRleCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHQvL3Rocm93KCdzdG9wJyk7XG5cdFx0XHRcdC8vY29uc29sZS5sb2coJ2luZGV4ZXMubGVuZ3RoICcgKyBpbmRleGVzLmxlbmd0aCk7XG5cdFx0XHRcdC8vY29uc29sZS5sb2coJ3RoaXMuaW5kZXhfbWFwICcgKyBzdHJpbmdpZnkodGhpcy5pbmRleF9tYXApKTtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIFNvLCBhc2tpbmcgZWFjaCBpbmRleCBmb3IgdGhlIGFuc3dlcj9cblx0XHRcdFx0XG5cdFx0XHRcdC8vY29uc29sZS5sb2coJ2luZGV4ZXMubGVuZ3RoICcgKyBpbmRleGVzLmxlbmd0aCk7XG5cdFx0XHRcdC8vY29uc29sZS5sb2coJ2FbMF0gJyArIHN0cmluZ2lmeShhWzBdKSk7XG5cdFx0XHRcdFxuXHRcdFx0XHR2YXIgc2VhcmNoX2ZpZWxkcyA9IFtdO1xuXHRcdFx0XHR2YXIgc2VhcmNoX3ZhbHVlcyA9IFtdO1xuXHRcdFx0XHRcblx0XHRcdFx0XG5cdFx0XHRcdFxuXHRcdFx0XHRlYWNoKGFbMF0sIGZ1bmN0aW9uKGksIHYpIHtcblx0XHRcdFx0XHQvL2NvbnNvbGUubG9nKCd2ICcgKyBzdHJpbmdpZnkodikpO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcblx0XHRcdFx0XHRzZWFyY2hfZmllbGRzLnB1c2godlswXSk7XG5cdFx0XHRcdFx0c2VhcmNoX3ZhbHVlcy5wdXNoKHZbMV0pO1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0XG5cdFx0XHRcdC8vY29uc29sZS5sb2coJ3NlYXJjaF9maWVsZHMgJyArIHN0cmluZ2lmeShzZWFyY2hfZmllbGRzKSk7XG5cdFx0XHRcdFxuXHRcdFx0XHQvKlxuXHRcdFx0XHRcblx0XHRcdFx0aWYgKGluZGV4ZXMubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdC8vIHNlYXJjaCBmb3IgdGhlIHJpZ2h0IGluZGV4LlxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdC8vIGNvbnN1bHQgdGhlIGZpcnN0IGluZGV4LlxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdHZhciByZXMgPSBpbmRleGVzWzBdLmdldChhWzBdKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHQvL2lmIChyZXMubGVuZ3RoID09IDEpIHtcblx0XHRcdFx0XHQvL1x0cmV0dXJuIHJlcztcblx0XHRcdFx0XHQvL31cblx0XHRcdFx0XHQvL2NvbnNvbGUubG9nKCdpdGVtICcgKyBzdHJpbmdpZnkoaXRlbSkpO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdHJldHVybiByZXM7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdH1cblx0XHRcdFx0Ki9cblx0XHRcdFx0dmFyIGVxdWFsX2luZGljZXMgPSBbXTtcblx0XHRcdFx0Ly9jb25zb2xlLmxvZygnaW5kZXhlcyAnICsgc3RyaW5naWZ5KGluZGV4ZXMpKTtcblx0XHRcdFx0XG5cdFx0XHRcdGVhY2goaW5kZXhlcywgZnVuY3Rpb24oaSwgaWR4KSB7XG5cdFx0XHRcdFx0dmFyIGlkeF9maWVsZHMgPSBpZHguZmllbGRzO1xuXHRcdFx0XHRcdC8vY29uc29sZS5sb2coJ2lkeF9maWVsZHMgJyArIHN0cmluZ2lmeShpZHhfZmllbGRzKSk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKGlkeF9maWVsZHMubGVuZ3RoID49IHNlYXJjaF9maWVsZHMubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHQvLyBnZXQgdGhlIGZpcnN0IHBhcnQgb2YgdGhlIGlkeF9maWVsZHNcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0Ly8gaWYgaXQgaXMgYW4gYXJyYXkuLi5cblx0XHRcdFx0XHRcdHZhciBpZHhfZmllbGRzX3RvX2NoZWNrO1xuXHRcdFx0XHRcdFx0aWYgKHRvZihpZHhfZmllbGRzKSA9PSAnYXJyYXknKSB7XG5cdFx0XHRcdFx0XHRcdGlkeF9maWVsZHNfdG9fY2hlY2sgPSBpZHhfZmllbGRzLnNsaWNlKDAsIHNlYXJjaF9maWVsZHMubGVuZ3RoKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGlkeF9maWVsZHNfdG9fY2hlY2sgPSBbaWR4X2ZpZWxkc107XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdC8vY29uc29sZS5sb2coJ2lkeF9maWVsZHNfdG9fY2hlY2sgJyArIHN0cmluZ2lmeShpZHhfZmllbGRzX3RvX2NoZWNrKSk7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdGlmIChhcmVfZXF1YWwoaWR4X2ZpZWxkc190b19jaGVjaywgc2VhcmNoX2ZpZWxkcykpIHtcblx0XHRcdFx0XHRcdFx0Ly9jb25zb2xlLmxvZygndGhleSBhcmUgZXF1YWwnKTtcblx0XHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRcdGVxdWFsX2luZGljZXMucHVzaChpZHgpO1xuXHRcdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcblx0XHRcdFx0XHQvL2lmIChpc19lcXVhbChpZHhfZmllbGRzLCBzZWFyY2hfZmllbGRzKSlcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRcblx0XHRcdFx0fSk7XG5cdFx0XHRcdFxuXHRcdFx0XHQvL2NvbnNvbGUubG9nKCdlcXVhbF9pbmRpY2VzLmxlbmd0aCAnICsgZXF1YWxfaW5kaWNlcy5sZW5ndGgpO1xuXHRcdFx0XHQvL3JldHVybiBlcXVhbF9pbmRpY2VzWzBdO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKGVxdWFsX2luZGljZXMubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRcdC8vIHVzZSB0aGF0IGluZGV4XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Ly8gd2lsbCBnaXZlIHRoYXQgaW5kZXggdHdvIHZhbHVlcyB0byBsb29rIGZvciwgaW4gYW4gYXJyYXlcblx0XHRcdFx0XHRcblx0XHRcdFx0XHQvLyB3aWxsIGFsc28gZG8gc29tZSB0ZXN0aW5nIHdpdGggbm9uLXN0cmluZyB2YWx1ZXMsIGFuZCBpbmRleGluZyB0aGVtIGF0IHNvbWUgcG9pbnQuXG5cdFx0XHRcdFx0Ly8gIG1heSBkbyBzb21lIGxvd2VyIGxldmVsIHdvcmsgaW4gdGhlIEIrIHRyZWUgdG8gZ2V0IHRoaXMgcmlnaHQuXG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0dmFyIGlkeCA9IGVxdWFsX2luZGljZXNbMF07XG5cdFx0XHRcdFx0Ly9jb25zb2xlLmxvZygnaWR4ICcgKyBzdHJpbmdpZnkoaWR4KSk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0dmFyIHJlc19pbmRpY2VzX2dldCA9IGVxdWFsX2luZGljZXNbMF0uZ2V0KHNlYXJjaF92YWx1ZXMpO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdC8vY29uc29sZS5sb2coJ3Jlc19pbmRpY2VzX2dldCAnICsgc3RyaW5naWZ5KHJlc19pbmRpY2VzX2dldCkpO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdHJldHVybiByZXNfaW5kaWNlc19nZXQ7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdFxuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvKlxuXHRcdFx0aWYgKHNpZyA9PSAnW3NdJykge1xuXHRcdFx0XHQvLyBpdCdzIHNlYXJjaGluZyBmb3IgYW4gaW5kZXggd2l0aCBhIHNpbmdsZSBmaWVsZC4gRWFzeSBpZiB0aGVyZSBpcyBqdXN0IG9uZSBvZiB0aGVtIGZvdW5kLlxuXHRcdFx0XHRcblx0XHRcdFx0Ly8gdGhlbiBzcGxpdCB0aGF0IHN0cmluZywgaXQgY291bGQgYmUgc2VwYXJhdGVkIGJ5IGNvbW1hcy5cblx0XHRcdFx0Ly8gIHdoYXQgYWJvdXQgc3BsaXQgd2l0aCAnLCAnP1xuXHRcdFx0XHQvLyAgY291bGQgaGF2ZSBhIG5ldyBzcGxpdCBmdW5jdGlvbiB0aGF0IG1heWJlIHVzZXMgcmVnZXhlcyB0byBzcGxpdCBsaWtlIHRoYXQ/XG5cdFx0XHRcdC8vICBzcGxpdCwgcmVtb3Zpbmcgd2hpdGVzcGFjZSBhZnRlciBjb21tYXMuXG5cdFx0XHRcdC8vICB3b3VsZCBnbyBpbiB1dGlsIC8gZXNzZW50aWFscy5cblx0XHRcdFx0XG5cdFx0XHRcdHZhciBmaWVsZF9zdHIgPSBhWzBdO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKGZpZWxkX3N0ci5pbmRleE9mKCcsJykgPiAtMSkge1xuXHRcdFx0XHRcdHRocm93ICgnTXVsdGlwbGUgZmllbGRzIHNlYXJjaCB0aHJvdWdoIGEgc3RyaW5nIG5vdCB5ZXQgaW1wbGVtZW50ZWQuJyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dmFyIHJlcyA9IFtdO1xuXHRcdFx0XHRcblx0XHRcdFx0dGhpcy5pdGVyYXRlX2luZGV4ZXMoZnVuY3Rpb24oaW5kZXgpIHtcblx0XHRcdFx0XHRpZiAoaW5kZXguZmllbGRzLmxlbmd0aCA9PSAxKSB7XG5cdFx0XHRcdFx0XHQvL3Jlcy5wdXNoKClcblx0XHRcdFx0XHRcdGlmIChpbmRleC5maWVsZHNbMF0gPT0gZmllbGRfc3RyKSB7XG5cdFx0XHRcdFx0XHRcdHJlcy5wdXNoKGluZGV4KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pXG5cdFx0XHRcdGlmIChyZXMubGVuZ3RoIDw9IDEpIHJldHVybiByZXNbMF07XG5cdFx0XHRcdHJldHVybiByZXM7XG5cdFx0XHR9XG5cdFx0XHQqL1xuXHRcdFx0aWYgKHNpZyA9PSAnW28sc10nKSB7XG5cdFx0XHRcdC8vIGFuIG9iamVjdCB3aGljaCByZXByZXNlbnRzIHRoZSBmaWVsZC5cblx0XHRcdFx0Ly8gIE1heSBuZWVkIHRvIHJlYWQgLyB1bmRlcnN0YW5kIHRoYXQgb2JqZWN0LlxuXHRcdFx0XHQvLyAgIGhvd2V2ZXIsIGl0IGNvdWxkIGhhdmUgYmVlbiBwdXQgaW50byB0aGUgaW5kZXggYXMgYSBKU09OIGZpZWxkLlxuXHRcdFx0XHQvLyAgICBzbyBpdCB3aWxsIGdldCByZWNvcmRlZCBpbiB0aGUgaW5kZXggdW5kZXIgdGhhdCBzdHJpbmcgbmFtZS5cblx0XHRcdFx0dmFyIGZpZWxkRGVmID0gYVswXTtcblx0XHRcdFx0Ly92YXIgc3RyRmllbGQgPSBzdHJpbmdpZnkoZmllbGREZWYpO1xuXHRcdFx0XHQvL2NvbnNvbGUubG9nKCdzdHJGaWVsZCAnICsgc3RyRmllbGQpO1xuXG5cdFx0XHRcdC8vIHdpbGwgc2VhcmNoIHRocm91Z2ggYW5kIHJldHJpZXZlIGZyb20gdGhlIGluZGV4IChzeXN0ZW0pXG5cblx0XHRcdFx0Ly8gY2FuIHB1dCBpbiB0aGUgb2JqZWN0IHRvIHRoZSBzZWFyY2guXG5cdFx0XHRcdC8vICB3aWxsIGl0IGdldCBzdHJpbmdpZmllZCBsYXRlcj9cblx0XHRcdFx0Ly8gICB0aGlzIG5lZWRzIHRvIGJlIHVzZWQgYXMgYSBrZXkgZm9yIGEgc3RyaW5nIGZpZWxkIHRob3VnaC5cblx0XHRcdFx0dmFyIGluZGV4ID0gdGhpcy5zZWFyY2hfZm9yX2luZGV4X3dpdGhfZmllbGRzKGZpZWxkRGVmKTtcblx0XHRcdFx0Ly92YXIgaW5kZXggPSB0aGlzLnNlYXJjaF9mb3JfaW5kZXhfd2l0aF9maWVsZHMoc3RyRmllbGQpO1xuXHRcdFx0XHQvLyAgbWF5IGNvbnN1bHQgZGlmZmVyZW50IGluZGV4ZXMgLyBsb29rIGZvciB0aGVtIGluIGEgc3BlY2lmaWMgb3JkZXIgd2hlbiBkb2luZyBhIGxvb2t1cCBvcGVyYXRpb24uXG5cdFx0XHRcdC8vY29uc29sZS5sb2coJ2luZGV4ICcgKyBzdHJpbmdpZnkoaW5kZXgpKTtcblx0XHRcdFx0aWYgKGluZGV4KSB7XG5cdFx0XHRcdFx0Ly9jb25zb2xlLmxvZygnYVsxXSAnICsgc3RyaW5naWZ5KGFbMV0pKTtcblx0XHRcdFx0XHR2YXIgcmVzID0gaW5kZXguZ2V0KGFbMV0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vY29uc29sZS5sb2coJ3JlcyAnICsgc3RyaW5naWZ5KHJlcykpO1xuXHRcdFx0XHRyZXR1cm4gcmVzO1xuXHRcdFx0XHQvL3Rocm93ICdzdG9wJztcblxuXG5cdFx0XHR9XG5cblxuXHRcdFx0Ly8gVGhhdCBsb29rcyBsaWtlIG11bHRpcGxlIGZpZWxkcyBzcGVjaWZpZWQuXG5cdFx0XHRpZiAoYS5sID09IDIgJiYgdG9mKGFbMF0pID09ICdhcnJheScpIHtcblx0XHRcdFx0Ly9jb25zb2xlLmxvZygnc2lnICcgKyBzaWcpO1xuXHRcdFx0XHQvL2NvbnNvbGUubG9nKCc0KSBhICcgKyBzdHJpbmdpZnkoYSkpO1xuXHRcdFx0XHQvL3ZhciBpbmRleCA9IHRoaXMuc2VhcmNoX2Zvcl9pbmRleF93aXRoX2ZpZWxkcyhzdHJpbmdpZnkoYVswXSkpO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHQvLyBwdXQgdGhlbSBpbiBhbiBhcnJheSB0byBpbmRpY2F0ZSB0aGV5IGFyZSBvbmUgZmllbGQ/XG5cblx0XHRcdFx0dmFyIGluZGV4ID0gdGhpcy5zZWFyY2hfZm9yX2luZGV4X3dpdGhfZmllbGRzKFthWzBdXSk7XG5cblx0XHRcdFx0Ly8gIG1heSBjb25zdWx0IGRpZmZlcmVudCBpbmRleGVzIC8gbG9vayBmb3IgdGhlbSBpbiBhIHNwZWNpZmljIG9yZGVyIHdoZW4gZG9pbmcgYSBsb29rdXAgb3BlcmF0aW9uLlxuXHRcdFx0XHQvL2NvbnNvbGUubG9nKCdpbmRleCAnICsgc3RyaW5naWZ5KGluZGV4KSk7XG5cdFx0XHRcdGlmIChpbmRleCkge1xuXHRcdFx0XHRcdC8vY29uc29sZS5sb2coJ2FbMV0gJyArIHN0cmluZ2lmeShhWzFdKSk7XG5cdFx0XHRcdFx0dmFyIHJlcyA9IGluZGV4LmdldChhWzFdKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvL2NvbnNvbGUubG9nKCdyZXMgJyArIHN0cmluZ2lmeShyZXMpKTtcblx0XHRcdFx0cmV0dXJuIHJlcztcblx0XHRcdH1cblxuXHRcdFx0aWYgKGEubCA9PSAyICYmIHRvZihhWzBdKSA9PSAnc3RyaW5nJykge1xuXHRcdFx0XHQvLyBpdCdzIGEgc2luZ2xlIG5hbWUtdmFsdWUgcGFpci5cblx0XHRcdFx0Ly8gaXMgaXQ/XG5cdFx0XHRcdFxuXHRcdFx0XHQvL2NvbnNvbGUubG9nKCdzaWcgJyArIHNpZyk7XG5cdFx0XHRcdC8vY29uc29sZS5sb2coJ2EgJyArIHN0cmluZ2lmeShhKSk7XG5cdFx0XHRcdFxuXHRcdFx0XHRcblx0XHRcdFx0Ly8gc2VhcmNoIGZvciB0aGUgc2luZ2xlIGluZGV4LlxuXHRcdFx0XHQvLyBqdXN0IHVzZSBhIGRpY3QgaW5kZXggZm9yIHRoZSBtb21lbnQuXG5cdFx0XHRcdC8vIHNlYXJjaGluZyBhIGRpY3QgaXMgYSAnZ2V0JyBvcGVyYXRpb24uXG5cdFx0XHRcdC8vIG1heWJlIHdlIG5lZWQgdG8gc2VhcmNoIGEgZnVsbCB0ZXh0IGluZGV4IG9ubHk/XG5cdFx0XHRcdC8vIHRoZSBiKyBpbmRleCBjYW4gZG8gdGhlIHByZWZpeCBzZWFyY2gsIHdoaWNoIGlzIGFcblx0XHRcdFx0Ly8gc3RhcnQuXG5cdFx0XHRcdC8vIG1vcmUgZ2VuZXJhbCBzZWFyY2hlcywgc3VjaCBhcyB3aXRoIGEgcmVnZXg/IGJlY29tZXNcblx0XHRcdFx0Ly8gbW9yZSBjb21wbGV4LlxuXG5cdFx0XHRcdFxuXHRcdFx0XHQvL2NvbnNvbGUubG9nKCd0aGlzLmluZGV4X21hcCAnICsgc3RyaW5naWZ5KHRoaXMuaW5kZXhfbWFwKSk7XG5cdFx0XHRcdFxuXHRcdFx0XHQvL3ZhciBpbmRleCA9IHRoaXMuaW5kZXhfbWFwW2FbMF1dWydpbmRleGVzX2J5X3R5cGUnXVsnZGljdCddO1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gdXNlIGEgZ2V0X2luZGV4IGZ1bmN0aW9uIGZvciB0aGlzLlxuXHRcdFx0XHR2YXIgaW5kZXggPSB0aGlzLnNlYXJjaF9mb3JfaW5kZXhfd2l0aF9maWVsZHMoYVswXSk7XG5cdFx0XHRcdFxuXHRcdFx0XHRcblx0XHRcdFx0Ly8gIG1heSBjb25zdWx0IGRpZmZlcmVudCBpbmRleGVzIC8gbG9vayBmb3IgdGhlbSBpbiBhIHNwZWNpZmljIG9yZGVyIHdoZW4gZG9pbmcgYSBsb29rdXAgb3BlcmF0aW9uLlxuXHRcdFx0XHQvL2NvbnNvbGUubG9nKCdpbmRleCAnICsgaW5kZXgpO1xuXHRcdFx0XHQvL2NvbnNvbGUubG9nKCdpbmRleCAnICsgc3RyaW5naWZ5KGluZGV4KSk7XG5cblx0XHRcdFx0Ly8gdGhlbiB3ZSBzZWFyY2ggdGhlIGluZGV4P1xuXHRcdFx0XHQvLyB3aGF0IEFQSSB0byBsb29rdXAgdGhlIHZhbHVlIHdpdGggdGhlIGtleT9cblxuXHRcdFx0XHQvLyByZXR1cm4gYSBzZWFyY2ggb2YgdGhlIGluZGV4LlxuXHRcdFx0XHQvLyBhIGRpY3QgaW5kZXguLi4gc2hvdWxkIG1heWJlIGhhdmUgJ2dldCcgcmF0aGVyIHRoYW5cblx0XHRcdFx0Ly8gc2VhcmNoLlxuXHRcdFx0XHQvL2NvbnNvbGUubG9nKCdhWzFdICcgKyBhWzFdKTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChpbmRleCkge1xuXHRcdFx0XHRcdHZhciByZXMgPSBpbmRleC5nZXQoYVsxXSk7XG5cdFx0XHRcdFx0Ly9jb25zb2xlLmxvZygncmVzICcgKyBzdHJpbmdpZnkocmVzKSk7XG5cdFx0XHRcdFx0Ly9jb25zb2xlLmxvZygnYVsxXSAnICsgYVsxXSk7XG5cdFx0XHRcdFx0Ly9jb25zb2xlLmxvZygnc2lnICcgKyBzaWcpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHQvL2NvbnNvbGUubG9nKCdyZXMgJyArIHN0cmluZ2lmeShyZXMpKTtcblx0XHRcdFx0cmV0dXJuIHJlcztcblx0XHRcdH1cblx0XHR9KSxcblxuXHRcdC8vIFRoaXMgaXMgZ29pbmcgdG8gYmUgcmVwbGFjZWQgd2l0aCB0aGUgc3lzdGVtIG9mIGNvbnN0cmFpbnRzLlxuXHRcdC8vICBUaGVyZSBpcyB0aGUgaW5kZXhcblx0XHQvLyAgVGhlbiB0aGVyZSBpcyB0aGUgdW5pcXVlIGNvbnN0cmFpbnRcblx0XHQvLyAgVGhlbiBpdCBpcyB0aGUgcHJpbWFyeSBrZXksIG9yIHNpbWlsYXIgdG8gaXQsIHdpbGwgYmUgYSBmaWVsZC9jb2x1bW4gb3IgYSBjb21iaW5hdGlvbiBvZiB0aGVtIHRoYXQgZ2V0cyB1c2VkIGV4dGVuc2l2ZWx5IGluIHRoZVxuXHRcdC8vICAgZGF0YWJhc2UuXG5cdFx0XG5cdFx0Ly8gVGhpcyB3aWxsIG5lZWQgdG8gYmUgdGVzdGVkIGZhaXJseSB0aG9yb3VnaGx5LCB0aGVuIGl0IHdpbGwgYmUgZG9jdW1lbnRlZCBvbiB0aGUgd2Vic2l0ZS5cblx0XHQvLyAgSSB0aGluayB0aGUgd2Vic2l0ZSB3aWxsIGhhdmUgcXVpdGUgYSBsb3Qgb2YgZG9jdW1lbnRhdGlvbiwgYW5kIEknbGwgYmUgYWJsZSB0byBtb2RpZnkgaXQgdXNpbmcgYSBDTVMuXG5cdFx0XG5cdFx0Ly8gU29tZSBkb2N1bWVudGF0aW9uIHdpbGwgYmUgZ2VuZXJhdGVkIGZyb20gdGhlIGNvZGUuXG5cdFx0Ly8gIFdpbGwgYmUgYWJsZSB0byBlZGl0IEFQSSByZWZlcmVuY2UgZG9jdW1lbnRzLCB0aGV5J2xsIGJlIHZpZXdhYmxlIHVzaW5nIGEgbmljZSBpbnRlcmZhY2UuXG5cdFx0Ly8gSSB0aGluayB0aGF0IGNvdWxkIGhlbHAgdGFrZS11cCBvZiB0aGlzIGxpYnJhcnkgcXVpdGUgY29uc2lkZXJhYmx5LlxuXHRcdC8vICBUaGF0IHdpbGwgYmUgcXVpdGUgYSBiaWcgcHJvamVjdC5cblx0XHQvLyAgSSB0aGluayBxdWl0ZSBhIGxvdCBvZiBtYXRlcmlhbCBhYm91dCB0aGlzLCBhbmQgSmF2YVNjcmlwdCBwcm9ncmFtbWluZyB3aWxsIGdvIG9uIG15IHNpdGUuXG5cdFx0Ly8gIEl0IHdvdWxkIGJlIGdvb2QgdG8gaGF2ZSBhbiBhY3RpdmUgZGlzY3Vzc2lvbiBmb3J1bSBhcyB3ZWxsLlxuXHRcdC8vIFRoZSBkZW1vcyBhcmVhLCBjb25zdWx0YW5jeSBhcmVhLCBXZWIgZGV2ZWxvcG1lbnQgd29yayAtIGdldHRpbmcgYmFjayB0byBwZW9wbGUgd2l0aCBhIHF1b3RlLlxuXHRcdC8vICBJdCBtYXkgYmUgcG9zc2libGUgdG8gcHV0IHRvZ2V0aGVyIGdvb2Qgc2l0ZXMsIHF1aWNrbHksIGZvciBub3QgYWxsIHRoYXQgbXVjaC5cblx0XHQvLyBDb3VsZCBiZSByZWNydWl0aW5nIGNvbnRyYWN0b3JzIG9uIHRoYXQgc2l0ZS4gV291bGQgYmUgYSBnb29kIGludGVyZmFjZSB3aXRoIHRoZSBwcm9ncmFtbWluZyBjb21tdW5pdHkuXG5cdFx0Ly8gIENvdWxkIHBvc3NpYmx5IGhhdmUgYSBjaGF0IHNlcnZpY2UsIGJ1dCBhbnN3ZXJpbmcgcGVvcGxlJ3MgcXVlc3Rpb25zIHF1aWNrbHksIG9yIGRpcmVjdGluZyB0aGVtIHRvIHRoZSBmb3J1bSwgbWF5IGJlIGEgdXNlZnVsIHRoaW5nIHRvIGRvLlxuXHRcdFxuXHRcdC8vIEkgdGhpbmsgdGhpcyBzeXN0ZW0gd291bGQgYmUgYSB2ZXJ5IHNvbGlkIHRlY2hub2xvZ2ljYWwgYmFzaXMgZm9yIHRoZSBzaXRlLlxuXHRcdC8vICBXb3VsZCBiZSBwYXRpY3VsYXJseSBnb29kIGZvciBoYXZpbmcgb3RoZXIgcHJvY2Vzc2VzIHJ1bm5pbmcgdGhhdCBrZWVwIHVwLXRvLWRhdGUgYmFja3Vwcy5cblx0XHQvLyAgQWxzbyBpbnRlcmVzdGVkIGluIGNvbm5lY3RpbmcgdGhlIHdlYiBzZXJ2ZXIgd2l0aCBvdGhlciBNZXRhQmVuY2ggbm9kZXMgdGhhdCBoYXBwZW4gdG8gYmUgb24gYW5kIHJ1bm5pbmcuXG5cdFx0XG5cdFx0XG5cdFx0Ly8gVGhlcmUgaXMgbm8gc3VjaCB0aGluZyBhcyB0aGUgcHJpbWFyeSB1bmlxdWUgaW5kZXguXG5cdFx0Ly8gIFRoZXJlIGlzIHRoZSAnY29uc3RyYWludHMnIHN5c3RlbS5cblx0XHRcblx0XHQvKlxuXHRcdFxuXHRcdCdwcmltYXJ5X3VuaXF1ZV9pbmRleCc6IGZwKGZ1bmN0aW9uKGEsIHNpZykge1xuXHRcdFx0Ly8ganVzdCBhIHN0cmluZyAtIHRoZSBmaWVsZCBuYW1lXG5cdFx0XHQvLyBkaWN0cyBzZXJ2ZSB1bmlxdWVuZXNzIGNoZWNraW5nIHdlbGwsIHRob3VnaCBvdGhlciBkYXRhIHN0cnVjdHVyZXMgY2FuIGRvIHRoYXQgdG9vLlxuXHRcdFx0XG5cdFx0XHQvL2NvbnNvbGUubG9nKCdwcmltYXJ5X3VuaXF1ZV9pbmRleCBzaWcgJyArIHNpZyk7XG5cdFx0XHRcblx0XHRcdGlmIChzaWcgPT0gJ1tzXScpIHtcblx0XHRcdFx0Ly8gZW5zdXJpbmcgdGhlcmUgaXMgdGhhdCB1bmlxdWUgaW5kZXgsIHdpdGggdGhhdCBmaWVsZFxuXHRcdFx0XHQvLyBhcyB0aGUga2V5LlxuXHRcdFx0XHR2YXIgZmllbGRfbmFtZSA9IGFbMF07XG5cdFx0XHRcdC8vIGdldCB0aGUgaW5kZXggZm9yIHRoYXQgZmllbGQuXG5cdFx0XHRcdC8vIG5vdCBzdXJlIGl0IHdpbGwgYWxyZWFkeSBleGlzdC5cblxuXHRcdFx0XHQvLyBob3dldmVyLCBtYXkgd2FudCB0byBmaXJzdCBsb29rIHRvIHNlZSBpZiB0aGVyZSBhcmVcblx0XHRcdFx0Ly8gYW55IGluZGV4ZXMgZm9yIHRoYXQgZmllbGQuXG5cdFx0XHRcdC8vIGVuc3VyaW5nIHRoZSBkaWN0IGluZGV4IGlzIHRoZSByaWdodCB3YXkgb2YgZG9pbmdcblx0XHRcdFx0Ly8gdGhpbmdzIGZvciB0aGUgbW9tZW50LlxuXHRcdFx0XHQvLyB3aWxsIGxhdGVyIGRvIG1vcmUgZGV2ZWxvcG1lbnQgb2YgdGhlIGluZGV4aW5nIHN5c3RlbVxuXHRcdFx0XHQvLyBzbyB0aGF0IG90aGVyIHR5cGVzIG9mIGluZGV4IGNhbiBiZSB1c2VkIGFzIGEgdW5pcXVlXG5cdFx0XHRcdC8vIGluZGV4LlxuXHRcdFx0XHQvLyBhbmQgc28gdGhhdCB0aGUgZGljdCBpbmRleCBjYW4gYmUgdXNlZCBhcyBhXG5cdFx0XHRcdC8vIG5vbi11bmlxdWUgaW5kZXguXG5cdFx0XHRcdC8vdGhpcy5fcHJpbWFyeV91bmlxdWVfaW5kZXggPSBcblx0XHRcdFx0dGhpcy5lbnN1cmVfaW5kZXgoZmllbGRfbmFtZSwgJ2RpY3QnKTtcblx0XHRcdH1cblx0XHRcdGlmIChzaWcgPSAnW10nKSB7XG5cdFx0XHRcdC8vY29uc29sZS5sb2coJ3RoaXMuX3ByaW1hcnlfdW5pcXVlX2luZGV4ICcgKyB0aGlzLl9wcmltYXJ5X3VuaXF1ZV9pbmRleCk7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9wcmltYXJ5X3VuaXF1ZV9pbmRleDtcblx0XHRcdH1cblxuXHRcdH0pLFxuXHRcdCovXG5cdFx0XG5cdFx0XG5cdFx0J2dldF9pbmRleF9zdGFydGluZyc6IGZ1bmN0aW9uKGZpZWxkcykge1xuXHRcdFx0Ly8gd2lsbCBiZSBzdGFydGluZyB3aXRoIGp1c3Qgb25lIGZpZWxkPy4uLlxuXHRcdFx0Ly8gIGdldCBpbmRleGVzIHN0YXJ0aW5nLi4uXG5cdFx0XHRcblx0XHRcdC8vY29uc29sZS5sb2coJ2dldF9pbmRleF9zdGFydGluZyAnICsgc3RyaW5naWZ5KGZpZWxkcykpO1xuXHRcdFx0XG5cdFx0XHRpZiAodG9mKGZpZWxkcykgPT0gJ3N0cmluZycpIHtcblx0XHRcdFx0ZmllbGRzID0gW2ZpZWxkc107XG5cdFx0XHR9XG5cdFx0XHQvL2NvbnNvbGUubG9nKCdnZXRfaW5kZXhfc3RhcnRpbmcgZmllbGRzICcgKyBzdHJpbmdpZnkoZmllbGRzKSk7XG5cdFx0XHQvLyBnbyB0aHJvdWdoIGFsbCBpbmRleGVzLCBsb29raW5nIGZvciB0aGUgaW5kZXggd2hpY2ggaGFzIGdvdCB0aGUgcmlnaHQgbWF0Y2guXG5cdFx0XHQvLyAgd2hhdCBhYm91dCBjb25zdWx0aW5nIGFuIGluZGV4IG9mIGluZGV4ZXM/XG5cdFx0XHQvLyAgdGhpcyBjb3VsZCBiZSBkb25lIGxhdGVyLCByZWFsbHkgd29uJ3QgYmUgbWFueSBpbmRleGVzIHRvIHNlYXJjaCB0aHJvdWdoLlxuXHRcdFx0XG5cdFx0XHQvLyBsb29rIGF0IHRoZSBpbmRleCBtYXAuLi4gZ2V0IHRoZSBmaWVsZHMgYXMgYSBzdHJpbmcgd2hpY2ggd2lsbCBnZXQgdXNlZCBpbiB0aGUgaW5kZXggbG9va3VwP1xuXHRcdFx0Ly8gIHdhbnQgdG8gYmUgbG9va2luZyBhdCBhbGwgaW5kZXhlcyBhdCB0aGUgbW9tZW50LlxuXHRcdFx0XG5cdFx0XHRcblx0XHRcdC8vIHdhbnQgdGhlIHN0b3AgZnVuY3Rpb24gaW4gaXRlcmF0ZV9pbmRleGVzXG5cdFx0XHRcblx0XHRcdHZhciBtYXRjaGluZ19pbmRleGVzID0gW107XG5cdFx0XHRcblx0XHRcdHRoaXMuaXRlcmF0ZV9pbmRleGVzKGZ1bmN0aW9uKGluZGV4LCBzdG9wKSB7XG5cdFx0XHRcdFxuXHRcdFx0XHRcblx0XHRcdFx0XG5cdFx0XHRcdC8vY29uc29sZS5sb2coJ2l0ZXJhdGVfaW5kZXhlcyBpbmRleCAnICsgaW5kZXgpO1xuXHRcdFx0XHQvL2NvbnNvbGUubG9nKCdpdGVyYXRlX2luZGV4ZXMgaW5kZXguZmllbGRzICcgKyBzdHJpbmdpZnkoaW5kZXguZmllbGRzKSk7XG5cdFx0XHRcdC8vY29uc29sZS5sb2coJ2ZpZWxkcyAnICsgc3RyaW5naWZ5KGZpZWxkcykpO1xuXHRcdFx0XHQvLyBjb21wYXJlIHRoZSB0d28gYXJyYXlzXG5cdFx0XHRcdFxuXHRcdFx0XHR2YXIgaV9maWVsZHMgPSBpbmRleC5maWVsZHM7XG5cdFx0XHRcdGlmICh0b2YoaV9maWVsZHMpID09ICdzdHJpbmcnKSBpX2ZpZWxkcyA9IFtpX2ZpZWxkc107XG5cdFx0XHRcdFxuXHRcdFx0XHR2YXIgYWUgPSBhcmVfZXF1YWwoZmllbGRzLCBpX2ZpZWxkcyk7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoYWUpIHtcblx0XHRcdFx0XHRtYXRjaGluZ19pbmRleGVzLnB1c2goaW5kZXgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHQvL2NvbnNvbGUubG9nKCdhZSAnICsgYWUpO1xuXHRcdFx0XHRcblx0XHRcdFx0XG5cdFx0XHRcdFxuXHRcdFx0XHQvL3Rocm93ICgnaXRlcmF0ZV9pbmRleGVzIHN0b3AnKTtcblx0XHRcdH0pO1xuXHRcdFx0XG5cdFx0XHQvL2NvbnNvbGUubG9nKCdtYXRjaGluZ19pbmRleGVzLmxlbmd0aCAnICsgbWF0Y2hpbmdfaW5kZXhlcy5sZW5ndGgpO1xuXHRcdFx0XG5cdFx0XHRpZiAobWF0Y2hpbmdfaW5kZXhlcy5sZW5ndGggPiAxKSB7XG5cdFx0XHRcdHRocm93ICdnZXRfaW5kZXhfc3RhcnRpbmcsIG1vcmUgdGhhbiAxIG1hdGNoaW5nIGluZGV4IGZvdW5kLiBOZWVkcyBpbXBsZW1lbnRhdGlvbic7XG5cdFx0XHRcdC8vIE1heSByZXR1cm4gdGhlIGJlc3QgbWF0Y2hcblx0XHRcdFx0Ly8gIFRoZSBiZXN0IG1hdGNoIGNvdWxkIGJlIGZvdW5kIHRocm91Z2ggYW4gaW5kZXguXG5cdFx0XHRcdFxuXHRcdFx0XHRcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiBtYXRjaGluZ19pbmRleGVzWzBdO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRcblx0XHR9LFxuXHRcdFxuXHRcdFxuXHRcdCdlbnN1cmVfaW5kZXgnOiBmcChmdW5jdGlvbihhLCBzaWcpIHtcblx0XHRcdC8vIGluZGV4IG1heSBiZSBnaXZlbiBhcyB0aGUgZmllbGQocylcblx0XHRcdC8vIHNpbmdsZSBzdHJpbmcgZmllbGQsIG9yIGFuIGFycmF5IG9mIGZpZWxkcy5cblxuXHRcdFx0Ly8gaW5kZXggdHlwZSBhcyB3ZWxsLi4uXG5cdFx0XHQvLyB3ZSBjb3VsZCBoYXZlIGEgZGVmYXVsdCBpbmRleCB0eXBlLlxuXG5cdFx0XHQvLyBjb3VsZCB0cnkgc29tZSBiZW5jaG1hcmtzIGxhdGVyIG9uLCBqdWRnZSBkaWZmZXJlbmNlXG5cdFx0XHQvLyBiZXR3ZWVuIGIrIGluZGV4IGFuZCB0aGUgZGljdCBpbmRleCBmb3IgcmV0cml2ZWluZ1xuXHRcdFx0Ly8gdmFsdWVzLlxuXHRcdFx0Ly8gZGljdCB3aWxsIHByb2JhYmx5IGJlIG11Y2ggZmFzdGVyIGluIEpTIGJlY2F1c2UgaXQgdXNlc1xuXHRcdFx0Ly8gbmF0aXZlIGNvZGUgYmVoaW5kIGl0LCBwcm9iYWJseSB3aXRoIGEgZ29vZCBzdHJpbmdcblx0XHRcdC8vIGhhc2hpbmcgYWxnb3JpdGhtLlxuXG5cdFx0XHQvLyBmaWVsZHMsIGluZGV4X3R5cGVcblx0XHRcdC8vIGZpZWxkLCBpbmRleF90eXBlXG5cblx0XHRcdC8vIGFuZCBlbnN1cmluZyBhIHVuaXF1ZSBpbmRleCB0b28/XG5cdFx0XHQvLyBwZXJoYXBzIHRoZSAnZGljdCcgaW5kZXggaXMgdW5pcXVlLlxuXHRcdFx0Ly8gY291bGQgY2hvb3NlIHRvIG9wZXJhdGUgdGhlIGluZGV4ZXMgb24gJ3VuaXF1ZSBtb2RlJyBvclxuXHRcdFx0Ly8gbm90LlxuXG5cdFx0XHQvLyBXYW50IGl0IGVhc2llciB0byBjcmVhdGUgYSBuZXcgaW5kZXggd2l0aCB0aGUgY29kZS5cblx0XHRcdC8vICBNYXkgaGF2ZSB1bnNhZmVfYWRkX2luZGV4LCBvciBqdXN0IGJlIGNsZWFyZXIgYWJvdXQgd2hhdCBjb2RlIGlzIHVzZWQuXG5cdFx0XHRcblx0XHRcdC8vIG1heSBlbnN1cmUgYSBzaW5nbGUgaW5kZXguXG5cdFx0XHRcblx0XHRcdC8vIG1heSBiZSBnaXZlbiBhbiBhcnJheSBvZiBzdHJpbmdzLlxuXHRcdFx0Ly8gICBpZiBzbywgaXQgaXMgYSBzaW5nbGUgaW5kZXguXG5cdFx0XHRcblx0XHRcdFxuXHRcdFx0Ly9jb25zb2xlLmxvZygnZW5zdXJlX2luZGV4IHNpZyAnICsgc2lnKTtcblx0XHRcdFxuXHRcdFx0aWYgKGEubCA9PSAxICYmIGlzX2Fycl9vZl9zdHJzKGFbMF0pKSB7XG5cdFx0XHRcdC8vIG5vdCBzcGVjaWZ5aW5nIHRoZSB0eXBlIG9mIGluZGV4IGhlcmUuXG5cdFx0XHRcdC8vICBpdCBpcyBhc3N1bWVkIHRvIGJlIHRoZSBzb3J0ZWQgKEIrKSBpbmRleC5cblx0XHRcdFx0XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyB3YW50IHRvIHNlZSBpZiB0aGVyZSBpcyBhbiBleGlzdGluZyBpbmRleC5cblx0XHRcdFx0XG5cdFx0XHRcdC8vLyBobW1tbSBub3Qgc3VyZS4uLiBcblx0XHRcdFx0XG5cdFx0XHRcdHZhciBuZXdfaW5kZXhfc3BlYyA9IGFbMF07XG5cdFx0XHRcdC8vY29uc29sZS5sb2coJ25ld19pbmRleF9zcGVjICcgKyBzdHJpbmdpZnkobmV3X2luZGV4X3NwZWMpKTtcblx0XHRcdFx0XG5cdFx0XHRcdC8vdGhyb3coJ3N0b3AnKTtcblx0XHRcdFx0Ly8gdGhlbiBjcmVhdGUgdGhlIGFjdHVhbCAoc29ydGVkKSBpbmRleC5cblx0XHRcdFx0XG5cdFx0XHRcdC8vIHdpbGwgbWFudWFsbHkgcHV0IHRoaXMgaW50byB0aGUgaW5kZXggbWFwLlxuXHRcdFx0XHQvLyAgbWF5IGtlZXAgdGhlIGluZGV4IG1hcCwgaXQncyBkZXRhaWxlZCwgYnV0IGFsc28gaGF2ZSBhIGZpZWxkX2luZGV4X2luZGV4IHdoZXJlIGl0IHBvaW50cyB0byB0aGUgcmVsZXZhbnQgaW5kZXguXG5cdFx0XHRcdC8vICBtYXkgbWFrZSBvdGhlciBtb3JlIGRpcmVjdCBvYmplY3RzIGluIHRoZSBpbmRleF9zeXN0ZW0gdG8gcmVmZXIgdG8gaW5kZXhlcy5cblx0XHRcdFx0XG5cdFx0XHRcdHZhciBzY2kgPSBuZXcgU29ydGVkX0NvbGxlY3Rpb25fSW5kZXgoe1xuXHRcdFx0XHRcdCdmaWVsZHMnOiBuZXdfaW5kZXhfc3BlY1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0Ly8gdGhlbiBwb3B1bGF0ZSB0aGUgaW5kZXguXG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBjYW4gYWRkX29iamVjdCB3aXRoIGFuIGFycmF5IHRvIHRoZSBpbmRleC5cblx0XHRcdFx0c2NpLmFkZF9vYmplY3QodGhpcy5jb2xsZWN0aW9uLl9hcnIpO1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gdGhlbiBhZGQgdGhlIGluZGV4IGludG8gdGhlIGluZGV4X3N5c3RlbS5cblx0XHRcdFx0XG5cdFx0XHRcdC8vIHBlcmhhcHMgdGhlIG1hcCBjb3VsZCBiZSBkb25lIGluIGEgaGVpcmFjaHkgbGlrZSBpbiBuZXN0ZWQ/XG5cdFx0XHRcdC8vICB3aWxsIGhhdmUgc29tZSBjb2RlIHRoYXQgaXMgYSBiaXQgY29tcGxleCBhbmQgc2luZ2xlLXB1cnBvc2UgaGVyZS5cblx0XHRcdFx0Ly8gICBpdCB3aWxsIGJlIHN1cHBvcnRpbmcgdGhlIGNvbGxlY3Rpb24gYW5kIGluZGV4IHN5c3RlbS5cblx0XHRcdFx0XG5cdFx0XHRcdC8vIE1heSBjcmVhdGUgbGlnaHQgY29sbGVjdGlvbiBhbmQgZGF0YV9vYmplY3QgY29tcG9uZW50cy4gTWF5IGhhdmUgYmVlbiBiZXR0ZXIgZWFybGllciwgYnV0IHRoZW4gd291bGQgaGF2ZSBtYWRlIHRoaW5ncyBtb3JlIGNvbXBsZXggdG9vLCB0aGlzIGhhcyBiZWVuXG5cdFx0XHRcdC8vICBPSyBmb3IgZGV2ZWxvcGluZy5cblx0XHRcdFx0XG5cdFx0XHRcdFxuXHRcdFx0XHRcblx0XHRcdFx0Ly8gbm90IHNvIHN1cmUgYWJvdXQgaGF2aW5nIHRoZSBzaW5nbGUgZmllbGQgbmFtZT9cblx0XHRcdFx0Ly8gIGJ1dCB0aGV5IGNvdWxkIGJlIGluZGV4ZWQgaGVyZSBieSB0aGVpciBzdHJpbmcgZmllbGRzIGtleVxuXHRcdFx0XHRcblx0XHRcdFx0Ly8gdGhpcy5pbmRleF9tYXBbZmllbGRfbmFtZV1bJ2luZGV4ZXNfYnlfdHlwZSddW2luZGV4X3R5cGVdID0gaWR4O1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gIGNvdWxkIGhhdmUgdGhlIGZpZWxkIG5hbWVzIGluIHNlcXVlbmNlIGluIHRoZSBpbmRleCAtIGEgbGl0dGxlIGxpa2UgdGhlIG5lc3RlZCBzeXN0ZW0uXG5cdFx0XHRcdC8vICB0aGF0IHdvdWxkIGFsbG93IHNlYXJjaGluZyB0aGUgaW5kZXggd2hlbiBsb29raW5nIHNlcXVlbnRpYWxseSBmb3IgYW4gaW5kZXggZm9yIGZpZWxkcy5cblx0XHRcdFx0XG5cdFx0XHRcdC8vIHRob3VnaCB0aGUgc29ydGVkIEtWUyB3aXRoIHByZWZpeCBzZWFyY2ggY291bGQgYWN0dWFsbHkgaGVscCByZXRyaWV2ZSB0aGUgaW5kZXggaGVyZS5cblx0XHRcdFx0Ly8gIFRoYXQgd291bGQgcG9zc2libHkgYmUgYSB1c2VmdWwgZGF0YSBzdHJ1Y3R1cmVcblx0XHRcdFx0XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBUaGUgaW5kZXggbWFwIGlzIGFscmVhZHkgcHJldHR5IHVud2llbGR5LCBwZXJoYXBzIGl0IGNhbiBiZSBpbXBydmVkLlxuXHRcdFx0XHQvLyAgSSB0aGluayBhIHNwZWNpYWxpemVkIGluZGV4IGluZGV4IHdpbGwgYmUgd2hhdCBpcyBuZWVkZWQgaW4gYSBiaXQuIEF0IGxlYXN0IHRoZXJlIHdvbid0IG5lZWQgdG8gYmUgc28gbXVjaCBzcGVjaWFsaXplZCBpbmRleGluZyBjb2RlLlxuXHRcdFx0XHQvLyAgU29tZSBraW5kIG9mIHNwZWNpYWxpc2VkIGNvZGUgdG8gcG93ZXIgdGhlIGluZGV4aW5nIGVuZ2luZSBtYWtlcyBhIGxvdCBvZiBzZW5zZS5cblx0XHRcdFx0XG5cdFx0XHRcdC8vIFdpbGwgdXNlIHRoZSBtYXAgYW5kIHRoZSBmaWVsZHNfa2V5IGZvciB0aGUgbW9tZW50LlxuXHRcdFx0XHRcblx0XHRcdFx0dmFyIGZpZWxkc19rZXkgPSBnZXRfZmllbGRzX2tleShuZXdfaW5kZXhfc3BlYyk7XG5cdFx0XHRcdC8vY29uc29sZS5sb2coJzIpIGZpZWxkc19rZXkgJyArIGZpZWxkc19rZXkpO1xuXHRcdFx0XHRcblx0XHRcdFx0dGhpcy5pbmRleF9tYXBbZmllbGRzX2tleV0gPSB0aGlzLmluZGV4X21hcFtmaWVsZHNfa2V5XSB8fCB7fTtcblx0XHRcdFx0dGhpcy5pbmRleF9tYXBbZmllbGRzX2tleV1bJ2luZGV4ZXNfYnlfdHlwZSddID0gdGhpcy5pbmRleF9tYXBbZmllbGRzX2tleV1bJ2luZGV4ZXNfYnlfdHlwZSddIHx8IHt9O1xuXHRcdFx0XHR0aGlzLmluZGV4X21hcFtmaWVsZHNfa2V5XVsnaW5kZXhlc19ieV90eXBlJ11bJ3NvcnRlZCddID0gc2NpO1xuXHRcdFx0XHRcblx0XHRcdFx0cmV0dXJuIHNjaTtcblx0XHRcdFx0XG5cdFx0XHRcdC8vdGhyb3coJzQpIHN0b3AnKTtcblx0XHRcdFx0XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8vIG1heWJlIGNoYW5nZSB0aGlzIGludGVyZmFjZS5cblx0XHRcdGlmIChhLmwgPT0gMikge1xuXHRcdFx0XHRpZiAodG9mKGFbMV0pID09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdFx0dmFyIGluZGV4X3R5cGUgPSBhWzFdO1xuXHRcdFx0XHRcdGlmICh0b2YoYVswXSkgPT0gJ2FycmF5Jykge1xuXHRcdFx0XHRcdFx0dmFyIGZpZWxkcyA9IGFbMF07XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdHJldHVybiB0aGlzLmVuc3VyZV9pbmRleFthWzBdXTtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcblx0XHRcdFx0XHQvLyB3aGF0IGFib3V0IHdoZW4gdGhlcmUgYXJlIG11bHRpcGxlIGZpZWxkcyB0byBpbmRleC5cblx0XHRcdFx0XHQvLyAgY291bGQgdHJ5IGluZGV4aW5nIHByZXNpZGVudCdzIHBhcnR5IGFmZmlsaWF0aW9ucyB0b28uXG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKHRvZihhWzBdKSA9PSAnc3RyaW5nJykge1xuXHRcdFx0XHRcdFx0dmFyIGZpZWxkX25hbWUgPSBhWzBdO1xuXG5cdFx0XHRcdFx0XHQvLyBlbnN1cmUgYSBkaWN0IGluZGV4Li4uXG5cdFx0XHRcdFx0XHQvLyB0aGluayB3ZSB3aWxsIGhhdmUgdG8gcnVuIHRocm91Z2ggdGhlIHR5cGVzXG5cdFx0XHRcdFx0XHQvLyBzZXF1ZW50aWFsbHkgaGVyZS5cblxuXHRcdFx0XHRcdFx0Ly8gaWYgKGluZGV4X3R5cGUgPT0gJ2RpY3QnKSB7XG5cdFx0XHRcdFx0XHQvLyBzZWUgaWYgdGhlcmUgaXMgYSBkaWN0IGluZGV4IGFscmVhZHkgZm9yIHRoYXRcblx0XHRcdFx0XHRcdC8vIGZpZWxkLlxuXG5cdFx0XHRcdFx0XHQvLyB9XG5cblx0XHRcdFx0XHRcdC8vIHNlZSBpZiB0aGVyZSBpcyBhbiBleGlzdGluZyBpbmRleCBmb3IgdGhhdFxuXHRcdFx0XHRcdFx0Ly8gZmllbGQuXG5cblx0XHRcdFx0XHRcdHZhciBlX2lkeCA9IHRoaXMuZ2V0X2luZGV4X2J5X3R5cGVfYnlfZmllbGRzKFsgZmllbGRfbmFtZSBdLCBpbmRleF90eXBlKTtcblx0XHRcdFx0XHRcdGlmICghaXNfZGVmaW5lZChlX2lkeCkpIHtcblx0XHRcdFx0XHRcdFx0Ly8gbmVlZCB0byBjcmVhdGUgdGhlIGluZGV4LlxuXG5cdFx0XHRcdFx0XHRcdC8vIHNob3VsZCBwcm9iYWJseSBzdGFydCBpdCB1cCB3aXRoIHRoZVxuXHRcdFx0XHRcdFx0XHQvLyBleGlzdGluZyBkYXRhc2V0LlxuXG5cdFx0XHRcdFx0XHRcdHZhciBpZHggPSBuZXcgRGljdF9Db2xsZWN0aW9uX0luZGV4KHtcblx0XHRcdFx0XHRcdFx0XHQnZmllbGRzJyA6IFsgZmllbGRfbmFtZSBdXG5cdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHQvLyB0aGVuIHdhbnQgdG8gbG9hZCBhbGwgdGhlIGRhdGEgaW4gdGhlXG5cdFx0XHRcdFx0XHRcdC8vIGNvbGxlY3Rpb24gaW50byB0aGUgaW5kZXguXG5cblx0XHRcdFx0XHRcdFx0Ly8gTmVlZCB0byBwdXQgdGhlIGluZGV4IGluIHRoZSBpbmRleCBtYXAuXG5cdFx0XHRcdFx0XHRcdC8vIFdpbGwgZG8gc29tZSBsbF9zZXQgb3IgbGxfZW5zdXJlIGNvZGUgdG9cblx0XHRcdFx0XHRcdFx0Ly8gbWFrZSB0aGlzIHNob3J0ZXIuXG5cdFx0XHRcdFx0XHRcdHRoaXMuaW5kZXhfbWFwW2ZpZWxkX25hbWVdID0gdGhpcy5pbmRleF9tYXBbZmllbGRfbmFtZV0gfHwge307XG5cdFx0XHRcdFx0XHRcdHRoaXMuaW5kZXhfbWFwW2ZpZWxkX25hbWVdWydpbmRleGVzX2J5X3R5cGUnXSA9IHRoaXMuaW5kZXhfbWFwW2ZpZWxkX25hbWVdWydpbmRleGVzX2J5X3R5cGUnXSB8fCB7fTtcblx0XHRcdFx0XHRcdFx0dGhpcy5pbmRleF9tYXBbZmllbGRfbmFtZV1bJ2luZGV4ZXNfYnlfdHlwZSddW2luZGV4X3R5cGVdID0gaWR4O1xuXHRcdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdFx0Ly8gYSBkaWN0IG9mIGluZGV4ZXMsIG9yZGVyZWQgYnkgdGhlIGZpZWxkIG5hbWVzIG9mIHRoZSBpbmRleCAoY29tbWEgc2VwYXJhdGVkKSwgd2l0aCBhbiBhcnJheSBvZiBpbmRleGVzIHRoYXRcblx0XHRcdFx0XHRcdFx0Ly8gIHNhdGlzZnkgdGhhdCBjb21iaW5hdGlvbiBvZiBmaWVsZHMuXG5cdFx0XHRcdFx0XHRcdC8vIHdvdWxkIGJlIGZhc3QgdG8gc2VhcmNoIHRoYXQgYXJyYXkgZm9yIHBhcnRpY3VsYXIgZmllbGRzIC0gc2VhcmNoIGFsbCB3aXRoIHRoYXQgY29tYmluYXRpb24sXG5cdFx0XHRcdFx0XHRcdC8vICB0aGVuIHNlYXJjaCBmb3IgdGhlIGZpZWxkcyBpbiB0aGUgcGFydGljdWxhciBvcmRlci5cblx0XHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRcdC8vIFNvcnRlZF9LVlNcblx0XHRcdFx0XHRcdFx0Ly8gLmluZGV4ZXNfYnlfYWxwaGFiZXRpY19maWVsZHNcblx0XHRcdFx0XHRcdFx0Ly8gIGEgcHJlZml4IHNlYXJjaCBvbiB0aGlzIGNvdWxkIHF1aWNrbHkgZ2V0IHRoZSByZXF1aXJlZCBpbmRleFxuXHRcdFx0XHRcdFx0XHQvLyBJdCB3b3VsZCBpbmRlZWQgYmUgYSBmYXN0IHdheSB0byBnZXQgdGhlIGluZGV4LlxuXHRcdFx0XHRcdFx0XHQvLyAgQ29sbGVjdGlvbiBpcyBnZXR0aW5nIHF1aXRlIGJpZy4uLiBpdCB3aWxsIGJlIG5pY2UgdG8gZ2V0IGl0IGJhY2sgZG93biB0byBvbmx5IGEgZmV3IEtCLlxuXHRcdFx0XHRcdFx0XHQvLyAgSSB3b25kZXIgaWYgdGhlIGZyYW1ld29yayB3aWxsIHdpbmQgdXAgYmVpbmcgcXVpdGUgaGVmdHk/XG5cdFx0XHRcdFx0XHRcdC8vICAgU2VlbXMgbGlrZSBhIExPVCBvZiBjb21tZW50cyBoZXJlLiBJIHRoaW5rIHRoZSBjb2xsZWN0aW9uIGl0c2VsZiwgd2l0aCB0aGUgaW5kZXggc3lzdGVtIGFuZCBkYXRhIHR5cGVzIGV0YywgY291bGQgYmVcblx0XHRcdFx0XHRcdFx0Ly8gICBmYWlybHkgc21hbGwsIGEgZmV3IEsgd2hlbiB3cmFwcGVkIHVwIHdpdGggb3RoZXIgdGhpbmdzLlxuXHRcdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdFx0Ly8gSSBkbyB3YW50IHRvIHByb3ZpZGUgYW4gaW1wcmVzc2l2ZWx5IHNtYWxsIGxpYnJhcnksIHBlcmhhcHMgaXQgd2lsbCBiZSBhcm91bmQgMzAtNDBLP1xuXHRcdFx0XHRcdFx0XHQvLyAgT25jZSBJIGhhdmUgZ290IGEgZGVjZW50IHN5c3RlbSwgSSBjYW4gZG8gcmVmYWN0b3JpbmcgYW5kIGJ1aWxkaW5nLlxuXHRcdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdFx0Ly8gSSB0aGluayBhbiBhdXRvbWF0ZWQgY29tcGlsYXRpb24gLyBidWlsZCBwcm9jZXNzIHdpbGwgYmUgdmVyeSB1c2VmdWwuXG5cdFx0XHRcdFx0XHRcdC8vICBUaGlzIG9uZSB3aWxsIHB1dCBtb3JlIHRoaW5ncyBhcyBsb2NhbCB2YXJpYWJsZXMuXG5cdFx0XHRcdFx0XHRcdC8vICBTb21lIG9iamVjdC1vcmllbnRlZCBmdW5jdGlvbnMgbWF5IGJlIHJlLXdyaXR0ZW4gYXMgbm9uLW9vIHNvIHRoYXQgdGhleSB3b3JrIGluIHRoZSBsb2NhbCBzY29wZSwgZ2V0dGluZyBjYWxsZWQgZnJvbSB0aGUgbG9jYWwgc2NvcGUuXG5cdFx0XHRcdFx0XHRcdC8vICBXaWxsIGFsc28gYnVpbGQgdXAgc3RyaW5nIG5hbWVzIGZvciBzdHJpbmdzIHRoYXQgZ2V0IHVzZWQgLSBjYW4gY29tcHJlc3MgdGhpbmdzIGEgZmFpciBiaXQgdGhhdCB3YXkuXG5cdFx0XHRcdFx0XHRcdC8vICAgV2l0aCB2YXJpb3VzIGNvbXByZXNzaW9uIG1lYW5zLCBpdCBzaG91bGQgYmUgcG9zc2libGUgdG8gZ2V0IHRoaXMgZG93biB0byBhIHZlcnkgc21hbGwgc2l6ZS5cblx0XHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRcdC8vIFRoZSBhdXRvbWF0aWMgbGlua2luZyAodmFyIHJlbW92YWwpIHdpbGwgcHJvdmUgdXNlZnVsIHdoZW4gYnVpbGRpbmcgdGhpcy5cblx0XHRcdFx0XHRcdFx0Ly8gIEhhdmluZyB0aGlzIG9uIHRoZSBzZXJ2ZXIsIHdpdGggYW4gaW50ZXJmYWNlIGZvciBwcm9kdWNpbmcgYnVpbGRzIHdpbGwgYmUgdXNlZnVsLlxuXHRcdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRcdC8vIGEgc29ydGVkIEtWUyBmb3Igc3RvcmluZyB0aGUgaW5kZXhlcyBieSBhbHBoYWJldGljYWwgZmllbGRzLi4uXG5cdFx0XHRcdFx0XHRcdC8vICB0aGF0IHdvdWxkIGJlIG5pY2UgZm9yIHJldHJpZXZpbmcgYWxsIG9mIHRoZSBpbmRleGVzIHdpdGggYSBnaXZlbiBhbHBoYWJldGljYWwgZmllbGRzIGtleS5cblx0XHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRcdC8vIFdpbGwgdGFrZSBzb21lIG1vcmUgdGVzdGluZyBhbmQgY2hlY2tpbmcgdG8gZ2V0IHRoZSB2YXJpb3VzIHRoaW5ncyB0aGF0IGFyZSBuZWVkZWQgd29ya2luZy5cblx0XHRcdFx0XHRcdFx0Ly8gIEFtIGxvb2tpbmcgZm9yd2FyZCB0byBjcmVhdGluZyB0aGUgYWJzdHJhY3QgcmRiIG1vZGVsLCB0aGVuIHRyYW5zbGF0aW5nIHRoYXQgdG8gYW4gYWJzdHJhY3QgUG9zdGdyZXMgbW9kZWwsXG5cdFx0XHRcdFx0XHRcdC8vICAgdGhlbiBwZXJzaXN0aW5nIHRoYXQgYWJzdHJhY3QgUG9zdGdyZXMgbW9kZWwgdG8gYSBQb3N0Z3JlcyBkYXRhYmFzZS5cblx0XHRcdFx0XHRcdFx0Ly8gQWxsIHRoaXMgbWlkZGxld2FyZSB3aWxsIG1ha2UgZm9yIHNvbWUgdmVyeSBjb252ZW5pZW50IGludGVyZmFjZXMgZXZlbnR1YWxseS5cblx0XHRcdFx0XHRcdFx0Ly8gIEhhdmluZyB0aGUgZGF0YSBzdHJ1Y3R1cmUgaW5mcmFzdHJ1Y3R1cmUgdG8gc3VwcG9ydCB0aGVtIHdpbGwgaGVscCBhIGxvdC5cblx0XHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRcdC8vIGFzIHdlbGwgYXMgbWFwcGluZyBpdCBieSB0eXBlLCBhbmQganVzdCBvbmUgZmllbGQgbmFtZS4uLlxuXHRcdFx0XHRcdFx0XHQvLyAgbmVlZCB0byBoYXZlIGl0IGluZGV4aW5nIGJ5IHRoZSBhbHBoYWJldGljYWxseSBzb3J0ZWQgbGlzdCBvZiBmaWVsZHMuXG5cdFx0XHRcdFx0XHRcdC8vIEkgdGhpbmsgdGhlc2UgdGhpbmdzIHdpbGwgdGFrZSBzb21lIG1vcmUgZXhhbXBsZXMgYW5kIHRlc3RpbmcsIHdpbGwgdGVzdCB0aGluZ3Mgd2l0aCBtdWx0aXBsZSBpbmRpY2VzIGFzIHdlbGwuXG5cdFx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0XHQvLyBPcmRlcmVkIGluZGV4ZXNcblx0XHRcdFx0XHRcdFx0Ly8gIE1heSBiZSBhYmxlIHRvIGdldCB0aGVtIG9yZGVyZWQgYnkgb25lIG9mIHRoZSBzb3J0ZWQgaW5kZXhlcy5cblx0XHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRcdC8vIEl0ZXJhdGUgdGhyb3VnaCBpdCwgb3IgZ2V0IHJlY29yZHMsIG9yIGdldCBrZXlzXG5cdFx0XHRcdFx0XHRcdC8vICBXaWxsIHdhbnQgdG8gaW5kZXggdGhlIGluZGV4ZXMgd2l0aCB0aGVpciBmaWVsZHMgc3RvcmVkIGFscGhhYmV0aWNhbGx5LlxuXHRcdFx0XHRcdFx0XHQvLyAgdGhpcyB3aWxsIG1hdHRlciB3aGVuIHRoZXJlIGFyZSBtdWx0aXBsZSBmaWVsZHMgaW4gdGhlIGluZGV4ZXMuXG5cdFx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0XHRcblxuXHRcdFx0XHRcdFx0XHQvLyBoYXZlIG1hZGUgYWRkX29iamVjdCBpbnRvXG5cdFx0XHRcdFx0XHRcdC8vIHVuc2FmZV9hZGRfb2JqZWN0IHRoYXQgZG9lcyBub3QgZG9cblx0XHRcdFx0XHRcdFx0Ly8gY2hlY2tpbmcuXG5cdFx0XHRcdFx0XHRcdC8vIHBlcmhhcHMgdGhhdCB1bnNhZmUgbWV0aG9kIGNvdWxkIGJlIGFcblx0XHRcdFx0XHRcdFx0Ly8gcHJpdmF0ZSBmdW5jdGlvbj8/P1xuXG5cdFx0XHRcdFx0XHRcdC8vIGNvbnNvbGUubG9nKCd0aGlzLmNvbGxlY3Rpb24uX2FyciAnIClcblxuXHRcdFx0XHRcdFx0XHRpZHguYWRkX29iamVjdCh0aGlzLmNvbGxlY3Rpb24uX2Fycik7XG5cblx0XHRcdFx0XHRcdFx0Ly8gbmVlZCB0byBhY2Nlc3MgdGhlIGNvbGxlY3Rpb24ncyBhcnJheS5cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KSxcblxuXG5cblx0XHQvLyBzZWVtcyBsaWtlIHRoZSBiZXN0IHdheSB0byBpbmRleCB0aGUgaW5kZXhlcy5cblx0XHQvLyBieSBmaWVsZCwgdGhlbiBieSBpbmRleCB0eXBlLlxuXHRcdC8vICBXb3VsZCBiZSBnb29kIHRvIGhhdmUgYSBjbGVhcmVyIG5hbWUgLyBkZXNjcmlwdGlvbiBvZiB0aGlzIGZ1bmN0aW9uLlxuXG5cdFx0J3NldF9pbmRleF9ieV90eXBlX2J5X2ZpZWxkcyc6IGZ1bmN0aW9uKGluZGV4LCBhcnJfZmllbGRzLCBpbmRleF90eXBlKSB7XG5cdFx0XHQvLyBJbiB0aGUgQ29sbGVjdGlvbl9JbmRleF9TeXN0ZW1cblxuXHRcdFx0Ly9jb25zb2xlLmxvZygnc2V0X2luZGV4X2J5X3R5cGVfYnlfZmllbGRzJyk7XG5cdFx0XHQvLyB0aGUgZmllbGRzIGZvciB0aGUgaW5kZXguLi4gcG9zc2libHkgcmVzdHJpY3RlZCB0byBuYW1lZCBmaWVsZHMsIGFuZCBkbyB0aGF0IGNoZWNrLlxuXHRcdFx0Ly8gIG1ha2UgZGlzYWJsaW5nIHNvbWUgY2hlY2tzIG9wdGlvbmFsLiBDb3VsZCBhbHNvIHJlbW92ZSB0aGVtIGF0IHRoZSBidWlsZCBzdGFnZS5cblx0XHRcdFxuXHRcdFx0Ly8gbmVlZHMgdG8gZ28gdGhyb3VnaCB0aGUgaW5kZXhlZCBmaWVsZHNcblx0XHRcdC8vIHdpbGwgY3JlYXRlIHRoZSBkaWN0IG1hcHMgc2F5aW5nIHdoaWNoIGZpZWxkcyBhcmUgZ2V0dGluZ1xuXHRcdFx0Ly8gaW5kZXhlZC5cblxuXHRcdFx0Ly8gQXV0b21hdGljYWxseSBpbmRleGluZyBieSBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlZCBJRHM/XG5cdFx0XHQvLyBUaGF0IHNlZW1zIHVuY2VydGFpbi5cblxuXHRcdFx0Ly8gYXJyX2ZpZWxkcyBbXCJhdHRhY2hlZFwiLCBcIm1ldGFcIiwgXCJuYW1lXCJdIC0gdGhhdCBsb29rcyBsaWtlIG9uZSBmaWVsZC5cblx0XHRcdC8vICB3YW50IGEgd2F5IG9mIHNwZWNpZnlpbmcgYSBmaWVsZCBpcyBhdHRhY2hlZCBpbiBzb21lIHdheS5cblx0XHRcdC8vICBcblxuXHRcdFx0Ly9jb25zb2xlLmxvZygnaW5kZXggJyArIHN0cmluZ2lmeShpbmRleCkpO1xuXHRcdFx0Ly9jb25zb2xlLmxvZygnYXJyX2ZpZWxkcyAnICsgc3RyaW5naWZ5KGFycl9maWVsZHMpKTtcblx0XHRcdC8vY29uc29sZS5sb2coJ2luZGV4X3R5cGUgJyArIHN0cmluZ2lmeShpbmRleF90eXBlKSk7XG5cblx0XHRcdFxuXHRcdFx0Ly8gaG1tbSBpbmRleGluZyBieSBtdWx0aXBsZSBmaWVsZHMuXG5cdFx0XHQvLyAgbWFraW5nIGEgbXVsdGktbGV2ZWwgaW5kZXggbWFwIG9iamVjdC5cblxuXHRcdFx0dmFyIGMgPSAwLCBsID0gYXJyX2ZpZWxkcy5sZW5ndGg7XG5cdFx0XHR2YXIgaSA9IHRoaXM7XG5cdFx0XHQvL2NvbnNvbGUubG9nKCdsICcgKyBsKTtcblx0XHRcdFxuXHRcdFx0d2hpbGUgKGMgPCBsKSB7XG5cdFx0XHRcdHZhciBmaWVsZCA9IGFycl9maWVsZHNbY107XG5cblx0XHRcdFx0dmFyIHRGaWVsZCA9IHRvZihmaWVsZCk7XG5cdFx0XHRcdC8vY29uc29sZS5sb2coJ3RGaWVsZCAnICsgdEZpZWxkKTtcblx0XHRcdFx0Ly90aHJvdyAnc3RvcCc7XG5cdFx0XHRcdGlmICh0RmllbGQgPT0gJ3N0cmluZycpIHtcblx0XHRcdFx0XHRpZiAoIWkuaW5kZXhfbWFwW2ZpZWxkXSkge1xuXHRcdFx0XHRcdFx0aS5pbmRleF9tYXBbZmllbGRdID0ge307XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRpID0gaS5pbmRleF9tYXBbZmllbGRdO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vY29uc29sZS5sb2coJ3RGaWVsZCAnICsgdEZpZWxkKTtcblx0XHRcdFx0XHQvLyBUaGUgZmllbGQgY291bGQgYmUgZ2l2ZW4gYXMgYW4gYXJyYXkuXG5cblx0XHRcdFx0XHQvLyBpZiBpdCdzIGFuIGF0dGFjaGVkIGZpZWxkLi4uXG5cdFx0XHRcdFx0Ly8gIHByb2JhYmx5IGJlc3QgdG8gaW5kZXggaXQgYXMgYW4gYXR0YWNoZWQgZmllbGQuXG5cblx0XHRcdFx0XHQvLyBvYmplY3QgZmllbGRzLi4uXG5cdFx0XHRcdFx0Ly8gIG5lZWQgdG8gYmUgY2FyZWZ1bCBhYm91dCBhZGRpbmcgdGhlc2UgaW5kZXhlcyBmb3IgYXR0YWNoZWQgb2JqZWN0cycgZmllbGRzLlxuXHRcdFx0XHRcdC8vICBpdCBuZWVkcyB0byByZWdpc3RlciBzbyB0aGF0IHdoZW4gb2JqZWN0cyBhcmUgYWRkZWQsIHRoZSByZWxldmFudCBpbmRleGVzIGFyZVxuXHRcdFx0XHRcdC8vICBub3RpZmllZCwgYW5kIGtub3cgdG8gY2hlY2sgdGhlIGF0dGFjaGVkIG9iamVjdCBmaWVsZC5cblxuXHRcdFx0XHRcdGlmICh0RmllbGQgPT0gJ29iamVjdCcpIHtcblx0XHRcdFx0XHRcdC8vY29uc29sZS5sb2coJ2lzIG9iamVjdCcpO1xuXHRcdFx0XHRcdFx0Ly9jb25zb2xlLmxvZygnZmllbGQgJyArIHN0cmluZ2lmeShmaWVsZCkpO1xuXG5cdFx0XHRcdFx0XHQvLyBwcm9jZXNzaW5nIGF0dGFjaGVkIGZpZWxkcyBoZXJlP1xuXG5cdFx0XHRcdFx0XHR2YXIgZmllbGRTdHIgPSBzdHJpbmdpZnkoZmllbGQpO1xuXHRcdFx0XHRcdFx0aWYgKCFpLmluZGV4X21hcFtmaWVsZFN0cl0pIHtcblx0XHRcdFx0XHRcdFx0aS5pbmRleF9tYXBbZmllbGRTdHJdID0ge307XG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0aSA9IGkuaW5kZXhfbWFwW2ZpZWxkU3RyXTtcblxuXG5cdFx0XHRcdFx0XHQvLyBUaGVuIHdvdWxkIG5lZWQgc29tZXRoaW5nIGZvciB3aGVuIHRoZSBvYmplY3QgaXMgYWRkZWQuXG5cblx0XHRcdFx0XHRcdC8vdGhyb3cgJ3N0b3AnO1xuXG5cdFx0XHRcdFx0fVxuXG5cblxuXHRcdFx0XHRcdGlmICh0RmllbGQgPT0gJ2FycmF5Jykge1xuXHRcdFx0XHRcdFx0Ly8gcmVjb3JkIGl0IGluIHRoZSBpbmRleCBhcyBhIHN0cmluZ2lmaWVkIGFycmF5LlxuXHRcdFx0XHRcdFx0Ly8gIHRoYXQgd291bGQgYmUgYW4gYXR0YWNoZWQgZmllbGQuXG5cdFx0XHRcdFx0XHQvLyAgIGF0dGFjaGVkKGZpZWxkTmFtZSkgd291bGQgbG9vayBuZWF0ZXIsIGJ1dCBub3QgYmUgSlNPTi5cblxuXHRcdFx0XHRcdFx0dmFyIGZpZWxkU3RyID0gc3RyaW5naWZ5KGZpZWxkKTtcblx0XHRcdFx0XHRcdGlmICghaS5pbmRleF9tYXBbZmllbGRTdHJdKSB7XG5cdFx0XHRcdFx0XHRcdGkuaW5kZXhfbWFwW2ZpZWxkU3RyXSA9IHt9O1xuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdGkgPSBpLmluZGV4X21hcFtmaWVsZFN0cl07XG5cblxuXG5cblx0XHRcdFx0XHR9XG5cblxuXHRcdFx0XHRcdC8vIENvdWxkIHNldCBpdCBieSB0aGUgbmFtZSBvZiB0aGUgZmllbGQgZXZlbiBpZiBpdCdzIGF0dGFjaGVkP1xuXHRcdFx0XHRcdC8vICBPciB0aGUgYXR0YWNobWVudCBiZWNvbWVzIHBhcnQgb2YgdGhlIG5hbWU/XG5cdFx0XHRcdFx0Ly8gIEkgdGhpbmsgZmllbGRzIHJlZmVycmluZyB0byBhdHRhY2htZW50cyBjb3VsZCBtYWtlIHNlbnNlLlxuXHRcdFx0XHRcdC8vICAgTmVlZCB0byBrZWVwIHRoaXMgY29uc2lzdGFudCBob3dldmVyLlxuXHRcdFx0XHRcdC8vY29uc29sZS5sb2coJ2ZpZWxkICcgKyBzdHJpbmdpZnkoZmllbGQpKTtcblxuXHRcdFx0XHRcdC8vIGlmIHRoZSBmaWVsZCBpcyBhbiBhcnJheSwgc3VjaCBhcyBbJ2F0dGFjaGVkJywgYXR0YWNoZWRPYmpOYW1lLCBhdHRhY2hlZE9iakZpZWxkXVxuXHRcdFx0XHRcdC8vIGFuIGF0dGFjaGVkIGZpZWxkLlxuXG5cblxuXG5cblxuXG5cdFx0XHRcdFx0Ly90aHJvdyAnMykgc3RvcCc7XG5cdFx0XHRcdH1cblxuXG5cdFx0XHRcdFxuXHRcdFx0XHRjKys7XG5cdFx0XHR9XG5cdFx0XHRpWydpbmRleGVzX2J5X3R5cGUnXSA9IGlbJ2luZGV4ZXNfYnlfdHlwZSddIHx8IHt9O1xuXHRcdFx0aVsnaW5kZXhlc19ieV90eXBlJ11baW5kZXhfdHlwZV0gPSBpbmRleDtcblx0XHR9LFxuXHRcdFxuXHRcdC8vIG1heSBqdXN0IGJlIGNhbGxlZCBpbmRleCgpIGluIHRoZSBjb2xsZWN0aW9uLCBidXQgbW9yZSBpbi1kZXB0aCBuYW1lIGhlcmUuXG5cdFx0J3NldF9pbmRleCcgOiBmdW5jdGlvbihpbmRleCkge1xuXHRcdFx0dGhpcy5zZXRfaW5kZXhfYnlfdHlwZV9ieV9maWVsZHMoaW5kZXgsIGluZGV4LmZpZWxkcywgaW5kZXguaW5kZXhfdHlwZSk7XG5cdFx0fSxcblxuXHRcdCdnZXRfaW5kZXhfYnlfdHlwZV9ieV9maWVsZHMnOiBmdW5jdGlvbihhcnJfZmllbGRzLCBpbmRleF90eXBlKSB7XG5cdFx0XHQvLyBuZWVkcyB0byBnbyB0aHJvdWdoIHRoZSBmaWVsZHMsIG1vdmluZyB0aHJvdWdoIHRoZVxuXHRcdFx0Ly8gaW5kZXhlcy5cblx0XHRcdHZhciBjID0gMCwgbCA9IGFycl9maWVsZHMubGVuZ3RoO1xuXHRcdFx0dmFyIGkgPSB0aGlzO1xuXHRcdFx0d2hpbGUgKGMgPCBsKSB7XG5cdFx0XHRcdGkgPSBpLmluZGV4X21hcFthcnJfZmllbGRzW2NdXTtcblxuXHRcdFx0XHRjKys7XG5cdFx0XHR9XG5cdFx0XHQvLyBwZXJoYXBzIHRoZSBpbmRleCBoYXMgbm90IGJlZW4gZGVmaW5lZC5cblx0XHRcdGlmIChpKSB7XG5cdFx0XHRcdHZhciBpbmRleCA9IGlbJ2luZGV4ZXNfYnlfdHlwZSddW2luZGV4X3R5cGVdO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBjb3VsZCB0aGVyZSBiZSBtdWx0aXBsZSBpbmRleGVzIG9mIHRoZSBzYW1lIGluZGV4IHR5cGU/XG5cdFx0XHQvLyBwb3NzaWJseSBjb3VsZCBtYWtlIGl0IGhvbGQgaW5kZXhlcyB3aXRoIGRpZmZlcmVudFxuXHRcdFx0Ly8gZW5naW5lcyAvIGRhdGEgc3RydWN0dXJlcy4uLiBidXQgSSBkb24ndCB0aGluayB0aGF0J3Ncblx0XHRcdC8vIG5lY2Vzc2FyeS5cblx0XHRcdC8vIGJ1dCBub3Qgc3VyZSB0aGUgaW5kZXggZXhpc3RzLi4uXG5cblx0XHRcdHJldHVybiBpbmRleDtcblxuXHRcdH0sXG5cdFx0XG5cdFx0J2luZGV4ZXMnOiBmcChmdW5jdGlvbihhLCBzaWcpIHtcblx0XHRcdGlmIChhLmwgPT0gMCkge1xuXHRcdFx0XHR2YXIgcmVzID0gW107XG5cdFx0XHRcdHRoaXMuaXRlcmF0ZV9pbmRleGVzKGZ1bmN0aW9uKGluZGV4KSB7XG5cdFx0XHRcdFx0cmVzLnB1c2goaW5kZXgpO1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0cmV0dXJuIHJlcztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRocm93ICdTZXR0aW5nIGluZGV4ZXMgbm90IHN1cHBvcnRlZCBoZXJlICh5ZXQpJztcblx0XHRcdH1cblx0XHR9KSxcblxuXHRcdC8vIHdpdGggJ3N0b3AnIGZ1bmN0aW9uIGluIGNhbGxiYWNrXG5cdFx0J2l0ZXJhdGVfaW5kZXhlcyc6IGZ1bmN0aW9uKGluZGV4X2NhbGxiYWNrKSB7XG5cblx0XHRcdC8vY29uc29sZS5sb2coJ2lpJyk7XG5cdFx0XHRcblx0XHRcdC8vIHJlY3Vyc2l2ZSBmdW5jdGlvbiBpbnNpZGUgdG8gZG8gdGhlIGl0ZXJhdGlvbi5cblx0XHRcdC8vY29uc29sZS5sb2coJ2JlZ2lubmluZyBpbmRleCBpdGVyYXRpb24uIHRoaXMuaW5kZXhfbWFwOiAnICsgc3RyaW5naWZ5KHRoaXMuaW5kZXhfbWFwKSk7XG5cdFx0XHQvLyB0aGUgaW5kZXggbWFwIG5lZWRzIHRvIGJlIHVwZGF0ZWQgd2hlbiBpbmRleGVzIGFyZSBhZGRlZC5cblxuXHRcdFx0Ly8gd2lsbCBiZSB1c2VkIHdoZW4gYWRkaW5nIGFuIG9iamVjdCB0byB0aGUgaW5kZXhlcy5cblx0XHRcdC8vIGFsc28gd2hlbiByZW1vdmluZyBvYmplY3QgZnJvbSBpbmRleGVzLlxuXG5cdFx0XHQvLyBzdG9wIGluIHRoaXMgY29kZS4uLiBhIGJpdCBtb3JlIGNvbXBsZXguXG5cdFx0XHRcblx0XHRcdHZhciBpdGVyYXRlX2xldmVsID0gZnVuY3Rpb24obGV2ZWwpIHtcblx0XHRcdFx0ZWFjaChsZXZlbCwgZnVuY3Rpb24oaSwgdiwgc3RvcDEpIHtcblx0XHRcdFx0XHQvL2NvbnNvbGUubG9nKCdpICcgKyBpKTtcblx0XHRcdFx0XHQvL2NvbnNvbGUubG9nKCd2ICcgKyBzdHJpbmdpZnkodikpO1xuXG5cdFx0XHRcdFx0Ly8gaSBpcyB0aGUgZmllbGQgbmFtZS5cblxuXHRcdFx0XHRcdHZhciBpYnQgPSB2WydpbmRleGVzX2J5X3R5cGUnXTtcblx0XHRcdFx0XHRpZiAoaWJ0KSB7XG5cdFx0XHRcdFx0XHRlYWNoKGlidCwgZnVuY3Rpb24oaTIsIHYyLCBzdG9wMikge1xuXHRcdFx0XHRcdFx0XHQvLyBpcyBhbiBpbmRleCwgSSB0aGluay5cblx0XHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRcdHZhciBmdWxsX3N0b3AgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHRzdG9wMigpO1xuXHRcdFx0XHRcdFx0XHRcdHN0b3AxKCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0aW5kZXhfY2FsbGJhY2sodjIsIGZ1bGxfc3RvcCk7XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSlcblxuXHRcdFx0XHQvLyBlYWNoKGxldmVsWydpbmRleGVzX2J5X3R5cGUnXSwgZnVuY3Rpb24oaSwgdikge1xuXHRcdFx0XHQvLyBjb25zb2xlLmxvZygndiAnICsgc3RyaW5naWZ5KHYpKTtcblx0XHRcdFx0Ly8gZWFjaCh2LCBmdW5jdGlvbihpbmRleF90eXBlLCBpbmRleCkge1xuXHRcdFx0XHQvLyBpbmRleF9jYWxsYmFjayhpbmRleCk7XG5cdFx0XHRcdC8vIH0pXG5cblx0XHRcdFx0Ly8gfSk7XG5cblx0XHRcdH1cblx0XHRcdC8vY29uc29sZS5sb2coJ3RoaXMuaW5kZXhfbWFwICcgKyBzdHJpbmdpZnkodGhpcy5pbmRleF9tYXApKTtcblx0XHRcdGl0ZXJhdGVfbGV2ZWwodGhpcy5pbmRleF9tYXApO1xuXG5cdFx0fSxcblxuXHRcdC8vIHRoaXMgd2lsbCBiZSBjaGVja2luZyBpdCBhZ2FpbnN0IGNvbnN0cmFpbnRzIGluc3RlYWQuXG5cdFx0Ly8vIGRlcHJpY2F0ZWQuLi4gd2lsbCBiZSByZW1vdmVkLlxuXHRcdCdfX19fX2Nhbl9hZGRfb2JqZWN0JzogZnVuY3Rpb24ob2JqKSB7XG5cdFx0XHQvLyB0aGluayB3ZSBqdXN0IGNoZWNrIGZvciBzaW5nbGUgb2JqZWN0cyByaWdodCBub3dcblxuXHRcdFx0dmFyIHRvYmogPSB0b2Yob2JqKTtcblx0XHRcdC8vY29uc29sZS5sb2coJ2Nhbl9hZGRfb2JqZWN0IHRvYmogJyArIHRvYmopO1xuXG5cdFx0XHRpZiAodG9iaiA9PSAnZGF0YV9vYmplY3QnKSB7XG5cdFx0XHRcdC8vIGdvIHRocm91Z2ggdGhlIGluZGV4ZXMgdG8gc2VlIGlmIGFsbCB0aGUgaW5kZXhlcyBjYW5cblx0XHRcdFx0Ly8gYWRkIGl0LlxuXHRcdFx0XHRcblx0XHRcdFx0Ly8gZG9lcyBpdCBtYXRjaCB0aGUgYWNjZXB0YW5jZSBjcml0ZXJpYT9cblx0XHRcdFx0Lypcblx0XHRcdFx0aWYgKHRoaXMuX2FjY2VwdHMpIHtcblx0XHRcdFx0XHQvLyBjaGVjayB3aGV0aGVyIHRoZSBvYmogbWF0Y2hlcyB0aGlzLl9hY2NlcHRzXG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Ly8gLl9hY2NlcHRzIGFzIGNvbnN0cmFpbnRzIC8gYSBEYXRhX09iamVjdCBhcyBjb25zdHJhaW50cz9cblx0XHRcdFx0XHQvLyAgYSBEYXRhX09iamVjdCB3aXRoIGl0cyBmaWVsZHMgc2V0IGFzIGNvbnN0cmFpbnRzP1xuXHRcdFx0XHRcdC8vICBvciB3b3VsZCB0aGUgZmllbGRzIGJlIGZpbmUgYnkgdGhlbXNlbHZlcz9cblx0XHRcdFx0XHRcblx0XHRcdFx0XHQvLyB3YW50IGEgZnVuY3Rpb24gdG8gdGVzdCBhIERhdGFfT2JqZWN0IGFnYWluc3QgZmllbGRzXG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Ly8gdGhlIGluZGV4aW5nIHN5c3RlbSBkb2VzIG5vdCBkbyB0aGUgYWNjZXB0YW5jZSB0ZXN0IGZvciBkYXRhIHZhbGlkYXRpb24sIG9ubHkgY2hlY2tpbmcgaXQncyBub3QgY29uZmxpY3RpbmcuXG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Y29uc29sZS5sb2coJ3RoaXMuX2FjY2VwdHMgJyArIHRoaXMuX2FjY2VwdHMpO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdFxuXHRcdFx0XHR9XG5cdFx0XHRcdCovXG5cdFx0XHRcdFxuXHRcdFx0XHR2YXIgY2FuX2FkZCA9IHRydWU7XG5cblx0XHRcdFx0dGhpcy5pdGVyYXRlX2luZGV4ZXMoZnVuY3Rpb24oaW5kZXgpIHtcblx0XHRcdFx0XHQvLyBhIHByb2JsZW0gaXRlcmF0aW5nIHRoZSBpbmRleGVzLlxuXG5cdFx0XHRcdFx0Ly9jb25zb2xlLmxvZygnKmlpIGluZGV4ICcgKyBzdHJpbmdpZnkoaW5kZXgpKTtcblxuXHRcdFx0XHRcdC8vIHdoZW4gYWRkaW5nIGFuIG9iamVjdCB0byBhbiBpbmRleCwgaXQgY291bGQgcmFpc2Vcblx0XHRcdFx0XHQvLyBhbiBlcnJvci5cblx0XHRcdFx0XHQvLyBtYXkgYmUgYmVzdCB0byBjaGVjayBhbGwgaW5kZXhlcyBmaXJzdCB0byBzZWUgaWZcblx0XHRcdFx0XHQvLyB0aGUgb2JqZWN0IHdpbGwgYmUgYWRkYWJsZS5cblxuXHRcdFx0XHRcdC8vIGluZGV4LmFkZF9vYmplY3Qob2JqKTtcblxuXHRcdFx0XHRcdHZhciBpbmRleF9jYW5fYWRkID0gaW5kZXguY2FuX2FkZF9vYmplY3Qob2JqKTtcblxuXHRcdFx0XHRcdC8vY29uc29sZS5sb2coJ2luZGV4X2Nhbl9hZGQgJyArIGluZGV4X2Nhbl9hZGQpO1xuXG5cdFx0XHRcdFx0aWYgKCFpbmRleF9jYW5fYWRkKSB7XG5cdFx0XHRcdFx0XHRjYW5fYWRkID0gZmFsc2U7XG5cdFx0XHRcdFx0XHQvLyBicmVhayBmcm9tIGl0ZXJhdGlvbiwgbGlrZSBpcyBwb3NzaWJsZSBpblxuXHRcdFx0XHRcdFx0Ly8galF1ZXJ5P1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRyZXR1cm4gY2FuX2FkZDtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcblx0XHRcdH1cblxuXHRcdH0sXG5cblx0XHQnYWRkX29iamVjdCc6IGZ1bmN0aW9uKG9iaikge1xuXHRcdFx0Ly9jb25zb2xlLmxvZygnSW5kZXggU3lzdGVtIGFkZF9vYmplY3QgJyArIHN0cmluZ2lmeShvYmopKTtcblx0XHRcdHJldHVybiB0aGlzLnVuc2FmZV9hZGRfb2JqZWN0KG9iaik7XG5cdFx0XHQvKlxuXHRcdFx0XG5cdFx0XHRpZiAodGhpcy5jYW5fYWRkX29iamVjdChvYmopKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLnVuc2FmZV9hZGRfb2JqZWN0KG9iaik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aHJvdyAnQ2FuXFwndCBhZGQgb2JqZWN0LiBDaGVjayB1bmlxdWUga2V5IGNvbGxpc2lvbnMuJztcblx0XHRcdH1cblx0XHRcdCovXG5cdFx0fSxcblxuXHRcdFxuXHRcdC8vIFRoZSBpbmRleCBubyBsb25nZXIgd2lsbCBoYXZlIGEgcHJvYmxlbSB3aXRoIG11bHRpcGxlIGl0ZW1zIHdpdGggdGhlIHNhbWUga2V5IGJlaW5nIGFkZGVkLlxuXHRcdC8vICBJdCdzIHRoZSB1bmlxdWVuZXNzIGNvbnN0cmFpbnRzIHdoaWNoIG1heSBoYXZlIHNvbWV0aGluZyB0byBzYXkgYWJvdXQgaXQuIFRoZXkgd291bGQgY29uc3VsdCB0aGUgaW5kZXhlcy5cblx0XHRcblx0XHQndW5zYWZlX2FkZF9vYmplY3QnOiBmdW5jdGlvbihvYmopIHtcblxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnQ29sbGVjdGlvbl9JbmRleF9TeXN0ZW0gdW5zYWZlX2FkZF9vYmplY3QnKTtcblx0XHRcdC8vIE5PVCBhZGRzIGFuIGluZGV4LlxuXHRcdFx0Ly8gc2hvdWxkIGFkZCBhbiBvYmplY3QgdG8gYWxsIGluZGV4ZXMuXG5cdFx0XHQvLyBhIHdheSB0byBpdGVyYXRlIHRocm91Z2ggYWxsIGluZGV4ZXM/XG5cdFx0XHQvLyBtYXliZSB0aGV5IHdvbid0IGJlIHN0b3JlZCBpbiBhIG5vcm1hbCBhcnJheS5cblx0XHRcdC8vY29uc29sZS5sb2coJ0NvbGxlY3Rpb25fSW5kZXhfU3lzdGVtIHVuc2FmZV9hZGRfb2JqZWN0ICcgKyBzdHJpbmdpZnkob2JqKSk7XG5cdFx0XHQvL2NvbnNvbGUubG9nKCdvYmoubWV0YSAnICsganNndWkuc3RyaW5naWZ5KG9iai5tZXRhKSk7XG5cblx0XHRcdC8vIFRoZSBvYmplY3QgbWF5IGhhdmUgYXR0YWNoZWQgb2JqZWN0cy5cblx0XHRcdC8vICBUaGVyZSBjb3VsZCBiZSBhdHRhY2hlZCBtZXRhZGF0YSwgYnV0IHdlIHdhbnQgYSBnZW5lcmFsIHdheSBmb3IgaW5kZXhpbmcgKGZpZWxkcyBvbilcblx0XHRcdC8vICAgYXR0YWNoZWQgZGF0YS5cblxuXHRcdFx0Ly8gSXQgd2lsbCBzdGlsbCBnZXQgcHV0IGludG8gdGhlIG9iamVjdCBpbmRleCwgYnV0IHRoZSBpbmRleCB3aWxsIGhhdmUgdG8gYmUgc2V0IHVwIHRvXG5cdFx0XHQvLyAgZGVhbCB3aXRoIGF0dGFjaGVkIGZpZWxkcyBwcm9wZXJseS5cblxuXHRcdFx0Ly8gVGhlc2UgYXJlIG5vdCBzdWJmaWVsZHMuLi4gdGhlcmUgbWF5IG5vdCBiZSBhbnkgbW9yZSB0aGFuIGp1c3QgbWV0YWRhdGEuXG5cdFx0XHQvLyAgbWV0YSBzZWVtcyBtb3N0IGFwcGxpY2FibGUgdG8gdGhlIFJlc291cmNlIHN5c3RlbSwgYW5kIGdldCBhbmQgc2V0IHdpbGwgYmUgdXNlZnVsXG5cdFx0XHQvLyAgbWV0aG9kcyBmb3IgaW50ZXJhY3Rpbmcgd2l0aCB0aGUgcmVzb3VyY2UgaXRzZWxmLiBUaGUgbmFtZSBjb3VsZCBwb3NzaWJseSBiZSBhdmFpbGFibGVcblx0XHRcdC8vICAgdGhyb3VnaCBub24tbWV0YSwgYnV0IHRoYXQgY291bGQgcG9zc2libHkgaGF2ZSBzZWN1cml0eSAvIHJlbGlhYmlsaXR5IGlzc3Vlcy5cblxuXHRcdFx0dGhpcy5pdGVyYXRlX2luZGV4ZXMoZnVuY3Rpb24oaW5kZXgpIHtcblx0XHRcdFx0Ly8gYSBwcm9ibGVtIGl0ZXJhdGluZyB0aGUgaW5kZXhlcy5cblx0XHRcdFx0Ly8gSXQgc2VlbXMgbGlrZSB0aGUgaW5kZXhlcyB3ZXJlIG5vdCBzZXQgdXAuXG5cdFx0XHRcdC8vY29uc29sZS5sb2coJzIpIGlpIGluZGV4ICcgKyBzdHJpbmdpZnkoaW5kZXgpKTtcblx0XHRcdFx0Ly8gd2hlbiBhZGRpbmcgYW4gb2JqZWN0IHRvIGFuIGluZGV4LCBpdCBjb3VsZCByYWlzZSBhblxuXHRcdFx0XHQvLyBlcnJvci5cblx0XHRcdFx0Ly8gbWF5IGJlIGJlc3QgdG8gY2hlY2sgYWxsIGluZGV4ZXMgZmlyc3QgdG8gc2VlIGlmIHRoZVxuXHRcdFx0XHQvLyBvYmplY3Qgd2lsbCBiZSBhZGRhYmxlLlxuXHRcdFx0XHRpbmRleC51bnNhZmVfYWRkX29iamVjdChvYmopO1xuXHRcdFx0fSk7XG5cblx0XHR9LFxuXHRcdFxuXHRcdFxuXHRcdCdyZW1vdmUnOiBmdW5jdGlvbihvYmopIHtcblx0XHRcdC8vIHdhcyByZW1vdmVfb2JqZWN0XG5cdFx0XHRcblx0XHRcdC8vIG5lZWQgdG8gbG9jYXRlIHRoZSBvYmplY3QuXG5cdFx0XHQvLyBpdCBtYXkgYmUgaW4gYWxsIGluZGV4ZXMuXG5cdFx0XHRcblx0XHRcdC8vIHRlbGwgYWxsIGluZGV4ZXMgdG8gcmVtb3ZlIHRoYXQgb2JqZWN0LCBpZiB0aGV5IGhhdmUgaXQuXG5cdFx0XHRcblx0XHRcdHRoaXMuaXRlcmF0ZV9pbmRleGVzKGZ1bmN0aW9uKGluZGV4KSB7XG5cdFx0XHRcdGluZGV4LnJlbW92ZShvYmopO1xuXHRcdFx0XHRcblx0XHRcdH0pO1xuXHRcdFx0Ly8gcmVtb3ZlIGl0IGZyb20gdGhlIHNvcnRlZF9rdnMuXG5cdFx0fSxcblx0XHQvLyBUaGlzIGlzIGdvaW5nIHRvIGJlIGNoYW5nZWQgdG8gY29sbGVjdGlvbl9jb25zdHJhaW50c1xuXHRcdCdhY2NlcHRzJzogZnAoZnVuY3Rpb24oYSwgc2lnKSB7XG5cdFx0XHQvLyBtYXkgYmUgZXhwcmVzc2VkIGluIHRlcm1zIG9mIGEgRGF0YV9PYmplY3Rcblx0XHRcdGlmIChzaWcgPT0gJ1tEXScpIHtcblx0XHRcdFx0Ly8gd2Ugc2V0IHRoZSBhY2NlcHRhbmNlIGNyaXRlcmlhIHRvIHRoZSBEYXRhX09iamVjdC4gRXZlcnkgb2JqZWN0IHRoYXQgZ2V0cyBwb3RlbnRpYWxseSBhZGRlZCB0byB0aGlzIGdldHMgY2hlY2tlZCBhZ2FpbnN0XG5cdFx0XHRcdC8vICB0aGUgRGF0YV9PYmplY3QncyBjaGVjayBhY2NlcHRhbmNlIGNyaXRlcmlhIG1ldGhvZCAodGhvdWdoIHRoaXMgbWF5IGNhbGwgb3RoZXIsIG5vbi1vbyBtZXRob2RzKVxuXHRcdFx0XHR0aGlzLl9hY2NlcHRzID0gYVswXTtcblx0XHRcdFx0Ly8gY291bGQgY2hlY2sgYWxsIGV4aXN0aW5nIGl0ZW1zIGFnYWluc3QgYWNjZXB0YW5jZSBjcml0ZXJpYSAoZmlyc3QpP1xuXHRcdFx0XHRcblx0XHRcdH1cblx0XHRcdC8vIGlmIGl0J3MgYW4gb2JqZWN0LCBjb3VsZCBzYXZlIHRoYXQgb2JqZWN0PyB0ZXN0IGFnYWluc3QgdGhhdD9cblx0XHRcdFxuXHRcdFx0aWYgKHNpZyA9PSAnW29dJykge1xuXHRcdFx0XHR0aHJvdyAnTWFwIG9iamVjdCBhcyBhY2NlcHRhbmNlIGNyaXRlcmlhIG5vdCB5ZXQgc3VwcG9ydGVkIGluIENvbGxlY3Rpb24nO1xuXHRcdFx0XHRcblx0XHRcdH1cblx0XHR9KVxuXHRcdFxuXHRcdC8qXG5cdFx0J2NsZWFyJyA6IGZ1bmN0aW9uKCkge1xuXG5cdFx0fVxuXHRcdCovXG5cdFx0XG5cdFx0Ly8gYSBmdW5jdGlvbiB0byBnZXQgdGhlIGFwcHJvcHJpYXRlIGluZGV4IGZvciB0aGUgZ2l2ZW4gZmllbGRzLlxuXHRcdC8vICBjaGVjayBpZiBpdCBoYXMgc3VjaCBhbiBpbmRleD9cblxuXHQvLyBlbnN1cmUgaW5kZXggYnkgdHlwZSBhbmQgcm93cy5cblxuXHR9KTtcblxuXHR2YXIgQ29sbGVjdGlvbl9JbmRleCA9IHtcblx0XHQnU3lzdGVtJzogQ29sbGVjdGlvbl9JbmRleF9TeXN0ZW0sXG5cdFx0J1NvcnRlZCc6IFNvcnRlZF9Db2xsZWN0aW9uX0luZGV4XG5cdH1cblxuXHQvL3JldHVybiBDb2xsZWN0aW9uX0luZGV4O1xubW9kdWxlLmV4cG9ydHMgPSBDb2xsZWN0aW9uX0luZGV4O1xuXG4vL30pO1xuIiwiXG4vKiAqIEBtb2R1bGUgY29yZS9jb2xsZWN0aW9uICovXG5cbi8qXG5pZiAodHlwZW9mIGRlZmluZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBkZWZpbmUgPSByZXF1aXJlKCdhbWRlZmluZScpKG1vZHVsZSk7XG59XG5cbmRlZmluZShbXCIuL2pzZ3VpLWxhbmctZXNzZW50aWFsc1wiLCBcIi4vanNndWktZGF0YS1zdHJ1Y3R1cmVzXCIsIFwiLi9kYXRhLW9iamVjdFwiLCBcIi4vZGF0YS1vYmplY3QtZmllbGRzLWNvbGxlY3Rpb25cIiwgXCIuL2NvbnN0cmFpbnRcIixcblx0XCIuL2NvbGxlY3Rpb24taW5kZXhcIl0sXG5cdCovXG5cbnZhciBqc2d1aSA9IHJlcXVpcmUoJy4vanNndWktbGFuZy1lc3NlbnRpYWxzJyk7XG52YXIgRGF0YV9TdHJ1Y3R1cmVzID0gcmVxdWlyZSgnLi9qc2d1aS1kYXRhLXN0cnVjdHVyZXMnKTtcbnZhciBEYXRhX1ZhbHVlID0gcmVxdWlyZSgnLi9kYXRhLXZhbHVlJyk7XG52YXIgRGF0YV9PYmplY3QgPSByZXF1aXJlKCcuL2RhdGEtb2JqZWN0Jyk7XG52YXIgRGF0YV9PYmplY3RfRmllbGRfQ29sbGVjdGlvbiA9IHJlcXVpcmUoJy4vZGF0YS1vYmplY3QtZmllbGRzLWNvbGxlY3Rpb24nKTtcbnZhciBDb25zdHJhaW50ID0gcmVxdWlyZSgnLi9jb25zdHJhaW50Jyk7XG52YXIgQ29sbGVjdGlvbl9JbmRleCA9IHJlcXVpcmUoJy4vY29sbGVjdGlvbi1pbmRleCcpO1xuLy9cblxuLy9mdW5jdGlvbihqc2d1aSwgRGF0YV9TdHJ1Y3R1cmVzLCBEYXRhX09iamVjdCwgRGF0YV9PYmplY3RfRmllbGRfQ29sbGVjdGlvbiwgQ29uc3RyYWludCwgQ29sbGVjdGlvbl9JbmRleCkge1xuXG4vLyBDb2xsZWN0aW9uLi4uIHVzZSBzbGlnbnRseSBtb3JlIHRoYW4gZXNzZW50aWFscz9cbnZhciBDb2xsZWN0aW9uX0luZGV4X1N5c3RlbSA9IENvbGxlY3Rpb25fSW5kZXguU3lzdGVtO1xudmFyIFNvcnRlZF9Db2xsZWN0aW9uX0luZGV4ID0gQ29sbGVjdGlvbl9JbmRleC5Tb3J0ZWQ7XG5cbnZhciBqID0ganNndWk7XG52YXIgQ2xhc3MgPSBqLkNsYXNzO1xudmFyIGVhY2ggPSBqLmVhY2g7XG52YXIgZWFjID0gai5lYWM7XG52YXIgaXNfYXJyYXkgPSBqLmlzX2FycmF5O1xudmFyIGlzX2RvbV9ub2RlID0gai5pc19kb21fbm9kZTtcbnZhciBpc19jdHJsID0gai5pc19jdHJsO1xudmFyIGV4dGVuZCA9IGouZXh0ZW5kO1xudmFyIGNsb25lID0gai5jbG9uZTtcbnZhciB4X2Nsb25lcyA9IGoueF9jbG9uZXM7XG52YXIgZ2V0X3RydXRoX21hcF9mcm9tX2FyciA9IGouZ2V0X3RydXRoX21hcF9mcm9tX2FycjtcbnZhciBnZXRfbWFwX2Zyb21fYXJyID0gai5nZXRfbWFwX2Zyb21fYXJyO1xudmFyIGFycl9saWtlX3RvX2FyciA9IGouYXJyX2xpa2VfdG9fYXJyO1xudmFyIHRvZiA9IGoudG9mO1xudmFyIGlzX2RlZmluZWQgPSBqLmlzX2RlZmluZWQ7XG52YXIgc3RyaW5naWZ5ID0gai5zdHJpbmdpZnk7XG52YXIgZnVuY3Rpb25hbF9wb2x5bW9ycGhpc20gPSBqLmZ1bmN0aW9uYWxfcG9seW1vcnBoaXNtO1xudmFyIGZwID0gai5mcDtcbnZhciBhcnJheWlmeSA9IGouYXJyYXlpZnk7XG52YXIgbWFwaWZ5ID0gai5tYXBpZnk7XG52YXIgYXJlX2VxdWFsID0gai5hcmVfZXF1YWw7XG52YXIgZ2V0X2l0ZW1fc2lnID0gai5nZXRfaXRlbV9zaWc7XG52YXIgc2V0X3ZhbHMgPSBqLnNldF92YWxzO1xudmFyIHRydXRoID0gai50cnV0aDtcbnZhciB0cmltX3NpZ19icmFja2V0cyA9IGoudHJpbV9zaWdfYnJhY2tldHM7XG52YXIgaXRlcmF0ZV9hbmNlc3Rvcl9jbGFzc2VzID0gai5pdGVyYXRlX2FuY2VzdG9yX2NsYXNzZXM7XG52YXIgaXNfY29uc3RydWN0b3JfZm4gPSBqLmlzX2NvbnN0cnVjdG9yX2ZuO1xuXG52YXIgaXNfYXJyX29mX3N0cnMgPSBqLmlzX2Fycl9vZl9zdHJzO1xudmFyIGlzX2Fycl9vZl9hcnJzID0gai5pc19hcnJfb2ZfYXJycztcblxudmFyIFNvcnRlZF9LVlMgPSBEYXRhX1N0cnVjdHVyZXMuU29ydGVkX0tWUztcbnZhciBkb2JqID0gRGF0YV9PYmplY3QuZG9iajtcblxudmFyIGlucHV0X3Byb2Nlc3NvcnMgPSBqLmlucHV0X3Byb2Nlc3NvcnM7XG5cbnZhciBjb25zdHJhaW50X2Zyb21fb2JqID0gQ29uc3RyYWludC5mcm9tX29iajtcbnZhciBuYXRpdmVfY29uc3RydWN0b3JfdG9mID0ganNndWkubmF0aXZlX2NvbnN0cnVjdG9yX3RvZjtcblxudmFyIGRvcCA9IERhdGFfT2JqZWN0LnByb3RvdHlwZTtcblxuLy8gd3JhcCB0aGUgb2xkIHNldF9maWVsZCBmdW5jdGlvblxudmFyIG9sZF9zZXRfZmllbGQgPSBkb3Auc2V0X2ZpZWxkO1xuXG52YXIgbmV3X3NldF9maWVsZCA9IGZwKGZ1bmN0aW9uKGEsIHNpZykge1xuICAgIC8vIHNvbWUgcG9seW1vcnBoaWMgY2FzZXMgd2hpY2ggYXJlIG5vdCBjaGVja2VkIGJ5IHRoZSBvbGQgb25lLlxuICAgIGlmIChzaWcgPT0gJ1tzLFtmXV0nKSB7XG4gICAgICAgIC8vIEl0J3MgYSBjb25zdHJhaW50IC8gZmllbGQgdGhhdCBpcyBhIGNvbGxlY3Rpb24uXG4gICAgICAgIC8vICBUaGUgY29sbGVjdGlvbiBhY3R1YWxseSBnZXRzIGNyZWF0ZWQsIF8uZmllbGRfbmFtZSBzZXQgdG8gYmUgdGhhdCBjb2xsZWN0aW9uLlxuXG4gICAgICAgIC8vY29uc29sZS5sb2coJ25ld19zZXRfZmllbGQgc2lnICcgKyBzaWcpO1xuXG4gICAgICAgIC8vIHRoZW4gY3JlYXRlIHRoZSBkYXRhIHR5cGUgY29uc3RyYWludC4uLlxuICAgICAgICAvLyAgdGhlIGRhdGEgdHlwZSBmb3IgdGhhdCBmaWVsZCBpcyBhIGNvbGxlY3Rpb24sIGFuZCB0aGF0IGNvbGxlY3Rpb24gaGFzIGEgZ2l2ZW4gdHlwZSB0aGF0IGl0IGFjY2VwdHMuXG4gICAgICAgIHZhciBmaWVsZF9uYW1lID0gYVswXTtcbiAgICAgICAgLy9jb25zb2xlLmxvZygnZmllbGRfbmFtZSAnICsgZmllbGRfbmFtZSk7XG4gICAgICAgIHZhciBkdF9jb25zdHJ1Y3RvciA9IGFbMV1bMF07XG5cbiAgICAgICAgLy9jb25zb2xlLmxvZygnZHRfY29uc3RydWN0b3IgJyArIGR0X2NvbnN0cnVjdG9yKTtcblxuICAgICAgICB2YXIgY29sbCA9IG5ldyBDb2xsZWN0aW9uKGR0X2NvbnN0cnVjdG9yKTtcbiAgICAgICAgY29sbC5fZGF0YV90eXBlX2NvbnN0cmFpbnQgPSBuZXcgQ29uc3RyYWludC5Db2xsZWN0aW9uX0RhdGFfVHlwZShkdF9jb25zdHJ1Y3Rvcik7XG4gICAgICAgIHRoaXMuc2V0KGZpZWxkX25hbWUsIGNvbGwpO1xuXG4gICAgICAgIC8vdGhyb3cgJzEyKSBuZXdfc2V0X2ZpZWxkIHN0b3AnO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG9sZF9zZXRfZmllbGQuYXBwbHkodGhpcywgYSk7XG4gICAgfVxufSk7XG5cbmRvcC5zZXRfZmllbGQgPSBuZXdfc2V0X2ZpZWxkO1xuXG4vKipcbiogQHBhcmFtIG9ialxuKiBAcGFyYW0gcXVlcnlcbiovXG52YXIgb2JqX21hdGNoZXNfcXVlcnlfb2JqID0gZnVuY3Rpb24ob2JqLCBxdWVyeSkge1xuICAgIC8vY29uc29sZS5sb2coJ29ial9tYXRjaGVzX3F1ZXJ5X29iaicpO1xuICAgIC8vY29uc29sZS5sb2coJ29iaiAnICsgc3RyaW5naWZ5KG9iaikpO1xuICAgIC8vY29uc29sZS5sb2coJ3F1ZXJ5ICcgKyBzdHJpbmdpZnkocXVlcnkpKTtcblxuICAgIHZhciBtYXRjaGVzID0gdHJ1ZTtcbiAgICBlYWNoKHF1ZXJ5LCBmdW5jdGlvbihmaWVsZE5hbWUsIGZpZWxkRGVmKSB7XG4gICAgICAgIHZhciB0ZmQgPSB0b2YoZmllbGREZWYpO1xuICAgICAgICAvL2NvbnNvbGUubG9nKCdmaWVsZE5hbWUgJyArIGZpZWxkTmFtZSk7XG4gICAgICAgIC8vY29uc29sZS5sb2coJ3RmZCAnICsgdGZkKTtcblxuICAgICAgICBpZiAodGZkID09ICdzdHJpbmcnIHx8IHRmZCA9PSAnYm9vbGVhbicgfHwgdGZkID09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBtYXRjaGVzID0gbWF0Y2hlcyAmJiBvYmpbZmllbGROYW1lXSA9PT0gZmllbGREZWY7XG4gICAgICAgICAgICAvL2lmICghbWF0Y2hlcykgc3RvcCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgJ25lZWQgbW9yZSB3b3JrIG9uIG1vcmUgY29tcGxleCBxdWVyaWVzIGZvciBjb2xsZWN0aW9uIGZpbmQsIGl0ZXJhdGl2ZSBzZWFyY2gnXG4gICAgICAgIH1cbiAgICB9KVxuICAgIHJldHVybiBtYXRjaGVzO1xufVxuXG5cbi8vIEluIHRoZSBkZWZpbml0aW9uIG9mIGEgY29udHJvbCdzIGV4dGVuc2lvbiwgd2UgbWF5IGluY2x1ZGUgYSAnZGF0YV90eXBlJy5cbi8vICBUaGF0IHdpbGwgdHJhbnNsYXRlIHRvIGEgX2RhdGFfdHlwZV9jb25zdHJhaW50IGJlaW5nIGFwcGxpZWQgdG8gYWxsIGNvbGxlY3Rpb25zXG4vLyAgIG9mIHRoYXQgZGVmaW5lZCB0eXBlLlxuLy8gIGNvbnN0cmFpbnQoRCk7XG5cbi8vIE1heSBuZWVkIHRvIG1ha2UgYSBuZXcgZXh0ZW5kIGZ1bmN0aW9uIHRvIGhhbmRsZSAnZGF0YV90eXBlJyBiZWluZyBzcGVjaWZpZWQgYXQgdGhlIHRvcFxuLy8gIGxldmVsIG9mIHRoZSBkZWZpbml0aW9uLCBzaW1pbGFyIHRvICdmaWVsZHMnLlxuXG4vLyBNYXkgYWRkIHNvbWUgcGFyYW1ldGVycyBpbnRvIGV4dGVuZCwgc28gdGhhdCB0aGlzIHdpbGwgYWNjZXB0IGEgZnVuY3Rpb24gdGhhdCBwcm9jZXNzZXNcbi8vICB0aGlzIHZhbHVlIHVwb24gaW5pdGlhbGl6YXRpb24uXG5cbi8vIDI4LURlYy0yMDEzXG4vLyAgVGhpcyBsYWNrcyBpbnNlcnRfYXQuIFRoYXQgc2VlbXMgbGlrZSBhbiBpbXBvcnRhbnQgcGFydCBvZiBhIGNvbGxlY3Rpb24uXG4vLyAgTWF5YmUgbm90IGltcG9ydGFudCB3aXRoIHZhcmlvdXMgaW5kZXhpbmcgc3lzdGVtcywgYnV0IGltcG9ydGFudCBmb3IgYmFzaWMgdXNhZ2UuXG4vLyAgIExpa2UgaW5zZXJ0aW5nIGEgY29udHJvbCBpbnRvIGFub3RoZXIgY29udHJvbCdzIGNvbnRlbnRzIGFzIHRoZSBmaXJzdC5cblxuXG4vKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cblxuLyoqXG4qIEEgbW9kdWxlIHJlcHJlc2VudGluZyBhIGNvbGxlY3Rpb24uXG4qIEBleHBvcnRzIGNvcmUvY29sbGVjdGlvblxuKi9cbnZhciBDb2xsZWN0aW9uID0gRGF0YV9PYmplY3QuZXh0ZW5kKHtcblxuICAgICdpbml0JzogZnVuY3Rpb24oc3BlYywgYXJyX3ZhbHVlcykge1xuICAgICAgICAvL2NvbnNvbGUubG9nKCdDb2xsZWN0aW9uIGluaXQnKTtcbiAgICAgICAgLy9jb25zb2xlLmxvZygnc3BlYyAnICsgc3RyaW5naWZ5KHNwZWMpKVxuICAgICAgICBzcGVjID0gc3BlYyB8fCB7fTtcbiAgICAgICAgLy8gUHJvYmFibHkgc2hvdWxkIGFjdCBkaWZmZXJlbnRseSBmb3IgYW4gYWJzdHJhY3QgY29sbGVjdGlvbi5cbiAgICAgICAgdGhpcy5fX3R5cGUgPSAnY29sbGVjdGlvbic7XG4gICAgICAgIGlmIChzcGVjLmFic3RyYWN0ID09PSB0cnVlKSB7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdpbml0IGFic3RyYWN0IGNvbGxlY3Rpb24nKTtcblxuICAgICAgICAgICAgLy8gQW4gYWJzdHJhY3QgY29sbGVjdGlvbiBkb2VzIG5vIGhhdmUgYW4gaW5kZXggc3lzdGVtIC0gdGhvdWdoIG1heWJlIGhhcyBnb3QgYWJzdHJhY3QgaW5kZXhlcz9cbiAgICAgICAgICAgIC8vIFdlIG1heSBpbml0aWFsaXNlIGl0IHVzaW5nIGEgY29uc3RydWN0b3IgZm9yIGFub3RoZXIgZnVuY3Rpb24uXG4gICAgICAgICAgICAvLyAgZWcgQ29sbGVjdGlvbihUYWJsZSlcblxuICAgICAgICAgICAgLy8gSW4gdGhpcyBjYXNlIGhvbGQgdGhlIGl0ZW0gdHlwZS5cbiAgICAgICAgICAgIC8vICBJdCBpcyBhIGNvbnN0cmFpbnQuXG4gICAgICAgICAgICAvLyAgQW55IG9iamVjdHMgaW4gdGhlIGNvbGxlY3Rpb24gbXVzdCBiZSBhbiBpbnN0YW5jZU9mIHRoZSB0eXBlIGdpdmVuLlxuXG5cbiAgICAgICAgICAgIC8vIEp1c3QgbWVhbmluZyBpdCBpcyBhIGNvbGxlY3Rpb24gb2YgYSBjZXJ0YWluIHR5cGUuXG4gICAgICAgICAgICAvLyAgRmllbGRzIHdpbGwgZ2V0IGRlY2xhcmVkIGluIHRoZSBhYnN0cmFjdCwgZWcgd2hlbiBkZWZpbmluZyBhIERhdGFiYXNlIGNsYXNzLCBpdCBoYXMgdGFibGVzIGFzIGEgZmllbGQuXG5cbiAgICAgICAgICAgIC8vIFdpbGwgZG8gdGhpcyBhcyB0aGUgY29sbGVjdGlvbiBoYXZpbmcgYSBkYXRhIHR5cGUgY29uc3RyYWludC5cblxuICAgICAgICAgICAgdmFyIHRzcGVjID0gdG9mKHNwZWMpO1xuICAgICAgICAgICAgaWYgKHRzcGVjID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25zdHJhaW50KHNwZWMpO1xuICAgICAgICAgICAgfVxuXG5cblxuICAgICAgICAgICAgLy8gQWJzdHJhY3QgY29sbGVjdGlvbiBvZiB0eXBlLlxuXG4gICAgICAgICAgICAvLyBXaWxsIG5vdCBoYXZlIGFuIGFjdHVhbCBpbmRleCBzeXN0ZW0gaW4gYWJzdHJhY3QgbW9kZS5cblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcmVsYXRpb25zaGlwcyA9IHRoaXMuX3JlbGF0aW9uc2hpcHMgfHwge307XG4gICAgICAgICAgICB0aGlzLl9hcnJfaWR4ID0gMDtcbiAgICAgICAgICAgIHRoaXMuX2FyciA9IFtdO1xuXG4gICAgICAgICAgICAvLyBNYXliZSBzb21lIGNvbGxlY3Rpb25zIGRvbid0IG5lZWQgaW5kZXhpbmc/XG4gICAgICAgICAgICB0aGlzLmluZGV4X3N5c3RlbSA9IG5ldyBDb2xsZWN0aW9uX0luZGV4X1N5c3RlbSh7XG4gICAgICAgICAgICAgICAgLy8gVGhlIGNvbGxlY3Rpb24gaW5kZXggc3lzdGVtIGNvdWxkIGhhdmUgZGlmZmVyZW50IGRlZmF1bHQgd2F5cyBvZiBpbmRleGluZyBpdGVtcy5cbiAgICAgICAgICAgICAgICAvLyAgRWFjaCBpdGVtIHRoYXQgZ2V0cyBpbmRleGVkIGNvdWxkIGdldCBpbmRleGVkIGluIGEgZGlmZmVyZW50IHdheS5cbiAgICAgICAgICAgICAgICAnY29sbGVjdGlvbicgOiB0aGlzXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdmFyIHNwZWMgPSBzcGVjIHx8IHt9O1xuXG4gICAgICAgICAgICBpZiAodG9mKHNwZWMpID09ICdhcnJheScpIHtcbiAgICAgICAgICAgICAgICBzcGVjID0ge1xuICAgICAgICAgICAgICAgICAgICAnbG9hZF9hcnJheSc6IHNwZWNcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodG9mKHNwZWMpID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNwZWMuYWJzdHJhY3QgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vdGhyb3cgJ0NvbGxlY3Rpb24gd2l0aCBhYnN0cmFjdCBzcGVjIGZ1bmN0aW9uJztcblxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWJzdHJhY3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNfY29uc3RydWN0b3JfZm4oc3BlYykpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjaGFpbmVkX2ZpZWxkcyA9IERhdGFfT2JqZWN0LmdldF9jaGFpbmVkX2ZpZWxkcyhzcGVjKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjaGFpbmVkX2ZpZWxkc19saXN0ID0gRGF0YV9PYmplY3QuY2hhaW5lZF9maWVsZHNfdG9fZmllbGRzX2xpc3QoY2hhaW5lZF9maWVsZHMpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnKioqKiogY2hhaW5lZF9maWVsZHNfbGlzdCAnICsgc3RyaW5naWZ5KGNoYWluZWRfZmllbGRzX2xpc3QpKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbmRleF9maWVsZF9uYW1lcyA9IFtdLCBmaWVsZF9uYW1lLCBmaWVsZF90ZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVhY2goY2hhaW5lZF9maWVsZHNfbGlzdCwgZnVuY3Rpb24oaSwgdikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWVsZF9uYW1lID0gdlswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmllbGRfdGV4dCA9IHZbMV07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlzSW5kZXhlZCA9IGZpZWxkX3RleHQuaW5kZXhPZignaW5kZXhlZCcpID4gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpc1VuaXF1ZSA9IGZpZWxkX3RleHQuaW5kZXhPZigndW5pcXVlJykgPiAtMVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0luZGV4ZWQgfHwgaXNVbmlxdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4X2ZpZWxkX25hbWVzLnB1c2goW2ZpZWxkX25hbWVdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU28sIHRoYXQgZG9lcyBpdCA6KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvbGRfc3BlYyA9IHNwZWM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3BlYyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2NvbnN0cmFpbnQnOiBzcGVjXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvbGRfc3BlYyA9PSBTdHJpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3BlYy5pbmRleF9ieSA9ICd2YWx1ZSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4X2ZpZWxkX25hbWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3BlYy5pbmRleF9ieSA9IGluZGV4X2ZpZWxkX25hbWVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodG9mKHNwZWMpID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE1heSBiZSBsaWtlIHdpdGggdGhlIGNvbnN0cmFpbnQgYWJvdmUuXG4gICAgICAgICAgICAgICAgICAgIC8vIHN0aWxsIG5lZWQgdG8gc2V0IHVwIHRoZSBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cblxuICAgICAgICAgICAgICAgICAgICB2YXIgbWFwX25hdGl2ZV9jb25zdHJ1Y3RvcnMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnYXJyYXknOiBBcnJheSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdib29sZWFuJzogQm9vbGVhbixcbiAgICAgICAgICAgICAgICAgICAgICAgICdudW1iZXInOiBOdW1iZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAnc3RyaW5nJzogU3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29iamVjdCc6IE9iamVjdFxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIG5jID0gbWFwX25hdGl2ZV9jb25zdHJ1Y3RvcnNbc3BlY107XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG5jKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcGVjID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdjb25zdHJhaW50JzogbmNcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmMgPT0gU3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3BlYy5pbmRleF9ieSA9ICd2YWx1ZSc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpc19kZWZpbmVkKHNwZWMuaXRlbXMpKSB7XG4gICAgICAgICAgICAgICAgc3BlYy5sb2FkX2FycmF5ID0gc3BlYy5sb2FkX2FycmF5IHx8IHNwZWMuaXRlbXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYXJyX3ZhbHVlcykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdsb2FkIGFycl92YWx1ZXMgLS0tLS0tLS0tLS0tJyk7XG4gICAgICAgICAgICAgICAgc3BlYy5sb2FkX2FycmF5ID0gYXJyX3ZhbHVlcztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8ga2VlcGluZyB0aGVzZSB0aGluZ3MgYmVsb3cgdGhlIGV4cGVjdGVkIHB1YmxpYyBpbnRlcmZhY2UuXG4gICAgICAgICAgICBpZiAoaXNfZGVmaW5lZChzcGVjLmFjY2VwdHMpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWNjZXB0cyA9IHNwZWMuYWNjZXB0cztcbiAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICBpZiAoanNndWkuX19kYXRhX2lkX21ldGhvZCA9PSAnaW5pdCcpIHtcbiAgICAgICAgICAgICAgICAvLyBidXQgbWF5YmUgdGhlcmUgd2lsbCBhbHdheXMgYmUgYSBjb250ZXh0LiBNYXkgc2F2ZSBkb3dubG9hZCBzaXplIG9uIGNsaWVudCB0b28uXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2NvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2lkID0gdGhpcy5fY29udGV4dC5uZXdfaWQodGhpcy5fX3R5cGVfbmFtZSB8fCB0aGlzLl9fdHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRleHQubWFwX29iamVjdHNbdGhpcy5fX2lkXSA9IHRoaXM7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZG9uJ3QgdGhpbmsgd2Ugd2FudCBhIHdob2xlIGJ1bmNoIG9mIG9iamVjdHMgbWFwcGVkIGxpa2UgdGhpcy4uLi5cbiAgICAgICAgICAgICAgICAgICAgLy8gIElEcyB3aWxsIGJlIHZlcnkgdXNlZnVsIHdoZW4gdGhleSBhcmUgY29udHJvbHMuLi4gYnV0IG1heWJlIG5vdCBhbHdheXMgbmVlZGVkLlxuXG4gICAgICAgICAgICAgICAgICAgIC8vdGhpcy5fX2lkID0gbmV3X2NvbGxlY3Rpb25faWQoKTtcbiAgICAgICAgICAgICAgICAgICAgLy9tYXBfanNndWlfaWRzW3RoaXMuX19pZF0gPSB0aGlzO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXRoaXMuX190eXBlKSB7XG5cblxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cblxuICAgICAgICB0aGlzLl9zdXBlcihzcGVjKTtcbiAgICB9LFxuXG4gICAgLy8gbWF5YmUgdXNlIGZwLCBhbmQgb3RoZXJ3aXNlIGFwcGx5IHdpdGggdGhlIHNhbWUgcGFyYW1zIGFuZCBjb250ZXh0LlxuXG4gICAvKipcbiAgICAqIEBmdW5jXG4gICAgKiBAcGFyYW0gdmFsdWVcbiAgICAqL1xuICAgICdzZXQnOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAvLyBnZXQgdGhlIHRvZih2YWx1ZSlcbiAgICAgICAgdmFyIHR2YWwgPSB0b2YodmFsdWUpO1xuXG4gICAgICAgIC8vY29uc29sZS5sb2coJ3R2YWwgJyArIHR2YWwpO1xuICAgICAgICAvL3Rocm93KCdzdG9wJyk7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgaWYgKHR2YWwgPT0gJ2RhdGFfb2JqZWN0Jykge1xuICAgICAgICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHVzaCh2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHZhbCA9PSAnYXJyYXknKSB7XG4gICAgICAgICAgICAvLyBmb3IgYW4gYXJyYXkuLi4gY2xlYXIsIHRoZW4gYWRkIGVhY2guXG5cbiAgICAgICAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgICAgICAgIC8vIE5vdCBzdXJlIGFib3V0IG1ha2luZyBhIG5ldyBjb2xsZWN0aW9uIGhlcmUuLi4gYnV0IG1heWJlIHdlIGNvdWxkIGdldCBpdCBkZWZpbmVkIGFzIGEgbm9ybWFsIHBvaW50LlxuXG4gICAgICAgICAgICAvLyBCdXQgd2UgY291bGQgbWFrZSBhIERhdGFWYWx1ZSBmb3IgdGhlIHBvaW50cy5cbiAgICAgICAgICAgIC8vICBDb3VsZCBzcGVjaWZ5IHRoYXQgcG9pbnRzIGFyZSBzdG9yZWQgYXMgRGF0YV9WYWx1ZXMuXG4gICAgICAgICAgICAvLyAgIE1heWJlIGZpeGVkIGxlbmd0aCBvZiAyLlxuXG4gICAgICAgICAgICBlYWNoKHZhbHVlLCBmdW5jdGlvbihpLCB2KSB7XG4gICAgICAgICAgICAgICAgdGhhdC5wdXNoKHYpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0dmFsID09ICdjb2xsZWN0aW9uJykge1xuICAgICAgICAgICAgICAgIC8vIG5lZWQgdG8gcmVpbmRleCAtIHRob3VnaCBjb3VsZCBoYXZlIG9wdGltaXphdGlvbiB0aGF0IGNoZWNrcyB0byBzZWUgaWYgdGhlIGluZGV4ZXMgYXJlIHRoZSBzYW1lLi4uXG4gICAgICAgICAgICAgICAgdGhyb3cgJ3N0b3AnO1xuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICB2YWx1ZS5lYWNoKGZ1bmN0aW9uKGksIHYpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5wdXNoKHYpO1xuICAgICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N1cGVyKHZhbHVlKTtcbiAgICAgICAgICAgIH1cblxuXG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgIC8qKlxuICAgICogQGZ1bmNcbiAgICAqL1xuICAgICdjbGVhcic6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9hcnJfaWR4ID0gMDtcbiAgICAgICAgdGhpcy5fYXJyID0gW107XG5cbiAgICAgICAgdGhpcy5pbmRleF9zeXN0ZW0gPSBuZXcgQ29sbGVjdGlvbl9JbmRleF9TeXN0ZW0oe1xuICAgICAgICAgICAgLy8gVGhlIGNvbGxlY3Rpb24gaW5kZXggc3lzdGVtIGNvdWxkIGhhdmUgZGlmZmVyZW50IGRlZmF1bHQgd2F5cyBvZiBpbmRleGluZyBpdGVtcy5cbiAgICAgICAgICAgIC8vICBFYWNoIGl0ZW0gdGhhdCBnZXRzIGluZGV4ZWQgY291bGQgZ2V0IGluZGV4ZWQgaW4gYSBkaWZmZXJlbnQgd2F5LlxuICAgICAgICAgICAgJ2NvbGxlY3Rpb24nIDogdGhpc1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLnRyaWdnZXIoJ2NoYW5nZScsIHtcbiAgICAgICAgICAgICd0eXBlJzogJ2NsZWFyJ1xuICAgICAgICB9KVxuICAgIH0sXG5cbiAgIC8qKlxuICAgICogQGZ1bmNcbiAgICAqL1xuICAgICdzdHJpbmdpZnknOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJlcyA9IFtdO1xuICAgICAgICBpZiAodGhpcy5fYWJzdHJhY3QpIHtcbiAgICAgICAgICAgIC8vIHRoZW4gd2UgY2FuIGhvcGVmdWxseSBnZXQgdGhlIGRhdGF0eXBlIG5hbWVcblxuICAgICAgICAgICAgLy8gaWYgaXQncyBhYnN0cmFjdCB3ZSBkZXRlY3QgaXQsIG90aGVyd2lzZSBpdCBzaG91bGQgYmUgaW4gdGhlcmUuXG4gICAgICAgICAgICB2YXIgbmN0byA9IG5hdGl2ZV9jb25zdHJ1Y3Rvcl90b2YodGhpcy5fdHlwZV9jb25zdHJ1Y3Rvcik7XG5cbiAgICAgICAgICAgIHJlcy5wdXNoKCd+Q29sbGVjdGlvbignKVxuICAgICAgICAgICAgaWYgKG5jdG8pIHtcbiAgICAgICAgICAgICAgICByZXMucHVzaChuY3RvKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcy5wdXNoKCcpJyk7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlcy5wdXNoKCdDb2xsZWN0aW9uKCcpO1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnb2JqLl9hcnIgJyArIHN0cmluZ2lmeShvYmouX2FycikpO1xuXG4gICAgICAgICAgICB2YXIgZmlyc3QgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uKGksIHYpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWZpcnN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcy5wdXNoKCcsICcpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlcy5wdXNoKHN0cmluZ2lmeSh2KSk7XG5cbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgIHJlcy5wdXNoKCcpJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcy5qb2luKCcnKTtcbiAgICB9LFxuXG4gICAvKipcbiAgICAqIEBmdW5jXG4gICAgKi9cbiAgICAndG9TdHJpbmcnOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZ2lmeSh0aGlzLl9hcnIpO1xuXG4gICAgfSxcblxuICAgLyoqXG4gICAgKiBAZnVuY1xuICAgICovXG4gICAgJ3RvT2JqZWN0JzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZXMgPSBbXTtcbiAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uKGksIHYpIHtcbiAgICAgICAgICAgIHJlcy5wdXNoKHYudG9PYmplY3QoKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH0sXG5cbiAgIC8qKlxuICAgICogQGZ1bmNcbiAgICAqIEBwYXJhbSAuLi5cbiAgICAqL1xuICAgICdlYWNoJyA6IGZwKGZ1bmN0aW9uKGEsIHNpZykge1xuICAgICAgICAvLyB3YXMgY2FsbGJhY2ssIGNvbnRleHRcbiAgICAgICAgLy8gZXZlciBnaXZlbiB0aGUgY29udGV4dD9cblxuICAgICAgICBpZiAoc2lnID09ICdbZl0nKSB7XG4gICAgICAgICAgICByZXR1cm4gZWFjaCh0aGlzLl9hcnIsIGFbMF0pO1xuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICBpZiAoc2lnID09ICdbWCxmXScpIHtcbiAgICAgICAgICAgICAgICAvLyBYIGZvciBpbmRleFxuXG4gICAgICAgICAgICAgICAgLy8gd2UgdXNlIHRoZSBvcmRlciBvZiB0aGUgaW5kZXguXG4gICAgICAgICAgICAgICAgLy8gIHBvc3NpYmx5IHdlIGNhbiBpdGVyYXRlIHVzaW5nIHRoZSBpbmRleCBpdHNlbGYsIG1heWJlIHdpdGggdGhhdCBzYW1lIGNhbGxiYWNrLlxuXG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gYVswXTtcbiAgICAgICAgICAgICAgICB2YXIgY2FsbGJhY2sgPSBhWzFdO1xuICAgICAgICAgICAgICAgIHJldHVybiBpbmRleC5lYWNoKGNhbGxiYWNrKTtcblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoYS5sID09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVhY2godGhpcy5fYXJyLCBhWzBdLCBhWzFdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KSxcblxuICAgICdlYWMnIDogZnAoZnVuY3Rpb24oYSwgc2lnKSB7XG4gICAgICAgIC8vIHdhcyBjYWxsYmFjaywgY29udGV4dFxuICAgICAgICAvLyBldmVyIGdpdmVuIHRoZSBjb250ZXh0P1xuXG4gICAgICAgIGlmIChzaWcgPT0gJ1tmXScpIHtcbiAgICAgICAgICAgIHJldHVybiBlYWModGhpcy5fYXJyLCBhWzBdKTtcbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgaWYgKHNpZyA9PSAnW1gsZl0nKSB7XG4gICAgICAgICAgICAgICAgLy8gWCBmb3IgaW5kZXhcblxuICAgICAgICAgICAgICAgIC8vIHdlIHVzZSB0aGUgb3JkZXIgb2YgdGhlIGluZGV4LlxuICAgICAgICAgICAgICAgIC8vICBwb3NzaWJseSB3ZSBjYW4gaXRlcmF0ZSB1c2luZyB0aGUgaW5kZXggaXRzZWxmLCBtYXliZSB3aXRoIHRoYXQgc2FtZSBjYWxsYmFjay5cblxuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IGFbMF07XG4gICAgICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gYVsxXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXguZWFjKGNhbGxiYWNrKTtcblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoYS5sID09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVhYyh0aGlzLl9hcnIsIGFbMF0sIGFbMV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pLFxuXG5cbiAgIC8qKlxuICAgICogQGZ1bmNcbiAgICAqL1xuICAgICdfaWQnIDogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIGdldHMgdGhlIGlkLlxuXG5cbiAgICAgICAgaWYgKHRoaXMuX2NvbnRleHQpIHtcbiAgICAgICAgICAgIHRoaXMuX19pZCA9IHRoaXMuX2NvbnRleHQubmV3X2lkKHRoaXMuX190eXBlX25hbWUgfHwgdGhpcy5fX3R5cGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFpc19kZWZpbmVkKHRoaXMuX19pZCkpIHtcblxuICAgICAgICAgICAgICAgIC8vIGdldCBhIHRlbXBvcmFyeSBpZCBmcm9tIHNvbWV3aGVyZT9cbiAgICAgICAgICAgICAgICAvLyAgYnV0IHRoZSBjb2xsZWN0aW9uIHNob3VsZCByZWFsbHkgaGF2ZSBhIGNvbnRleHQuLi5cbiAgICAgICAgICAgICAgICAvLyAgb3Igd2l0aG91dCBhIGNvbnRleHQsIHRoZSBjb2xsZWN0aW9uIGlzIGl0cyBvd24gY29udGV4dD9cblxuICAgICAgICAgICAgICAgIC8vIFdvbid0IGdvIHNldHRpbmcgdGhlIElEIGZvciB0aGUgbW9tZW50LlxuXG4gICAgICAgICAgICAgICAgLy90aGlzLl9faWQgPSBuZXdfY29sbGVjdGlvbl9pZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9faWQ7XG5cbiAgICB9LFxuXG5cbiAgIC8qKlxuICAgICogQGZ1bmNcbiAgICAqL1xuICAgICdsZW5ndGgnOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Fyci5sZW5ndGg7XG4gICAgfSxcblxuXG4gICAvKipcbiAgICAqIEBmdW5jXG4gICAgKiBAcGFyYW0gLi4uXG4gICAgKi9cbiAgICAnZmluZCc6IGZwKGZ1bmN0aW9uKGEsIHNpZykge1xuXG5cbiAgICAgICAgLy8gdmFyIGZvdW5kID0gY29sbF9wcmVzaWRlbnRzLmZpbmQoW1snbmFtZScsICdGcmFua2xpbiBQaWVyY2UnXSwgWydwYXJ0eScsICdSZXB1YmxpY2FuJ11dKTtcblxuICAgICAgICAvLyBpdCBjYW4gYmUgYW4gYXJyYXkgb2YgZmllbGRzLlxuICAgICAgICAvL2NvbnNvbGUubG9nKCdjb2xsZWN0aW9uIGZpbmQgJyArIHNpZyk7XG4gICAgICAgIC8vY29uc29sZS5sb2coJ2EgJyArIHN0cmluZ2lmeShhKSk7XG4gICAgICAgIGlmIChhLmwgPT0gMSkge1xuXG4gICAgICAgICAgICAvLyBNYWtlIGl0IHNvIHRoYXQgaW5kZXhfc3lzdGVtIGhhbmRsZXMgb2JqZWN0IHF1ZXJpZXMuLi5cbiAgICAgICAgICAgIC8vICBmaWVsZDogdmFsdWVcblxuICAgICAgICAgICAgdmFyIGluZGV4X3N5c3RlbV9maW5kX3JlcyA9IHRoaXMuaW5kZXhfc3lzdGVtLmZpbmQoYVswXSk7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdpbmRleF9zeXN0ZW1fZmluZF9yZXMgJyArIGluZGV4X3N5c3RlbV9maW5kX3Jlcyk7XG5cbiAgICAgICAgICAgIC8vIEhvdyB0byBrbm93IGlmIHRoZXNlIGhhdmUgYmVlbiBpbmRleGVkIG9yIG5vdC5cbiAgICAgICAgICAgIC8vICBQZXJoYXBzIHRoZSBpbmRleCBzeXN0ZW0gd2lsbCBvbmx5IGRvIGNlcnRhaW4gcXVlcmllcy5cbiAgICAgICAgICAgIC8vICBpbmRleF9zeXN0ZW0uY2FuX2ZpbmQgd291bGQgaGVscC5cbiAgICAgICAgICAgIGlmIChpbmRleF9zeXN0ZW1fZmluZF9yZXMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgLy8gbGV0J3MgZG8gdGhlIHNlYXJjaCBvdXJzZWxmLlxuICAgICAgICAgICAgICAgIC8vIG5lZWQgdG8gZ28gdGhyb3VnaCBldmVyeSBvYmplY3QgdG8gc2VlIGlmIGl0IG1hdGNoZXMgdGhlIHNlYXJjaCBxdWVyeS5cbiAgICAgICAgICAgICAgICAvLyBUaG91Z2ggdGhlIHJlc3VsdHMgbWF5IGJlIGJldHRlciByZXR1cm5lZCBhcyBhIGNvbGxlY3Rpb24uXG4gICAgICAgICAgICAgICAgdmFyIGZvdW5kSXRlbXMgPSBbXTtcbiAgICAgICAgICAgICAgICBlYWNoKHRoaXMsIGZ1bmN0aW9uKGluZGV4LCBpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2luZGV4ICcgKyBpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2l0ZW0gJyArIHN0cmluZ2lmeShpdGVtKSk7XG5cblxuICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayBlYWNoIGRhdGEgaXRlbSBmb3IgdGhlIG1hdGNoLlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyAnc3RvcCc7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4X3N5c3RlbV9maW5kX3JlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIG9ubHkgb25lIGluZGV4IGluIHRoZSBzeXN0ZW0gdGhlbiB0aGUgc2VhcmNoIHdpbGwgYmUgc2ltcGxlLlxuICAgICAgICB9XG5cbiAgICAgICAgLy8gW28sc11cbiAgICAgICAgLy8gIGZpbmRpbmcgYSBzdHJpbmcgdmFsdWUgdGhhdCdzIGJlZW4gc3BlY2lmaWVkIHVzaW5nIGFuIG9iamVjdC5cbiAgICAgICAgLy8gICBJdCBtYXkgaW5kaWNhdGUgYW4gYXR0YWNoZWQgZmllbGQuXG4gICAgICAgIC8vICAgV2UnbGwgc3RpbGwgYmUgYXNraW5nIHRoZSBpbmRleF9zeXN0ZW0gdG8gZmluZCBpdC5cbiAgICAgICAgLy8gICBOZWVkIHRvIGJlIHN1cmUgdGhhdCBbbyxzXSBmaWVsZHMgZ2V0IGluZGV4ZWQgcHJvcGVybHksIGFuZCBvdGhlciBpbmRleGVzIHdobydzIGZpZWxkc1xuICAgICAgICAvLyAgICBhcmUgc3BlY2lmaWVkIGJ5IGFuIG9iamVjdC5cbiAgICAgICAgLy8gICB7ZmllbGROYW1lOiB7fX0gZXF1aXZhbGVudCB0byAnZmllbGROYW1lJ1xuICAgICAgICAvLyAgICB0aGlzIHdpbGwgYWxsb3cgZXh0ZW5kZWQgaW5mb3JtYXRpb24gdG8gYmUgYWRkZWQuXG4gICAgICAgIC8vICAgV2Ugd2lsbCBiZSBhd2FyZSBvZiB3aGF0IHdlIGFyZSBpbmRleGluZywgc3VjaCBhcyBhdHRhY2hlZCBmaWVsZCBuYW1lcy5cbiAgICAgICAgLy8gICAgQ29kZSB3aGVuIHRoZSBpbmRleCBnZXRzIGNyZWF0ZWRcbiAgICAgICAgLy8gICAgQ29kZSB3aGVuIGFuIGl0ZW0gZ2V0cyBhZGRlZCB0byB0aGF0IGluZGV4LlxuICAgICAgICAvLyAgICAgV2lsbCBuZWVkIHRvIGNoZWNrIGF0dGFjaGVkIG9iamVjdHMuXG5cbiAgICAgICAgaWYgKHNpZyA9PSAnW28sc10nKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbmRleF9zeXN0ZW0uZmluZChhWzBdLCBhWzFdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vXG5cblxuXG5cbiAgICAgICAgLy8gYW5kIGlmIGxvb2tpbmcgZm9yIG1vcmUgdGhhbiBvbmUgdGhpbmcuLi5cbiAgICAgICAgaWYgKHNpZyA9PSAnW3Msc10nKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbmRleF9zeXN0ZW0uZmluZChhWzBdLCBhWzFdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2lnID09ICdbYSxzXScpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmluZGV4X3N5c3RlbS5maW5kKGFbMF0sIGFbMV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaWcgPT0gJ1tzLG9dJykge1xuICAgICAgICAgICAgdmFyIHByb3BlcnR5TmFtZSA9IGFbMF07XG4gICAgICAgICAgICB2YXIgcXVlcnkgPSBhWzFdO1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygncHJvcGVydHlOYW1lICcgKyBwcm9wZXJ0eU5hbWUpO1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygncXVlcnkgJyArIHN0cmluZ2lmeShxdWVyeSkpO1xuICAgICAgICAgICAgLy8gTWF5YmUgcmV0dXJuIGEgQ29sbGVjdGlvbiwgbm90IGFuIGFycmF5LlxuICAgICAgICAgICAgLy8gZG9uJ3QgY29uc3VsdCB0aGUgaW5kZXggc3lzdGVtLlxuICAgICAgICAgICAgdmFyIGZvdW5kSXRlbXMgPSBbXTtcbiAgICAgICAgICAgIC8vIGZvciBlYWNoIG9iamVjdCB3ZSBuZWVkIHRvIGdvIGRlZXBlciBpbnRvIHRoZSBmaWVsZHMuXG4gICAgICAgICAgICBlYWNoKHRoaXMsIGZ1bmN0aW9uKGluZGV4LCBpdGVtKSB7XG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnaW5kZXggJyArIGluZGV4KTtcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdpdGVtICcgKyBzdHJpbmdpZnkoaXRlbSkpO1xuXG4gICAgICAgICAgICAgICAgLy92YXIgbWF0Y2hlcyA9IGl0ZW0ubWF0Y2gocXVlcnkpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGl0ZW1Qcm9wZXJ0eSA9IGl0ZW0uZ2V0KHByb3BlcnR5TmFtZSk7XG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnaXRlbVByb3BlcnR5ICcgKyBzdHJpbmdpZnkoaXRlbVByb3BlcnR5KSk7XG5cbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCd0b2YoaXRlbVByb3BlcnR5KSAnICsgdG9mKGl0ZW1Qcm9wZXJ0eSkpO1xuICAgICAgICAgICAgICAgIHZhciB0aXAgPSB0b2YoaXRlbVByb3BlcnR5KTtcblxuICAgICAgICAgICAgICAgIGlmICh0aXAgPT0gJ2FycmF5Jykge1xuICAgICAgICAgICAgICAgICAgICAvLyBwb3NzaWJseSBzaG91bGQgYmUgYSBjb2xsZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgIGVhY2goaXRlbVByb3BlcnR5LCBmdW5jdGlvbihpLCB2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCd2ICcgKyBzdHJpbmdpZnkodikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1hdGNoZXMgPSBvYmpfbWF0Y2hlc19xdWVyeV9vYmoodiwgcXVlcnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnbWF0Y2hlcyAnICsgbWF0Y2hlcyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm91bmRJdGVtcy5wdXNoKHYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBjaGVjayBlYWNoIGRhdGEgaXRlbSBmb3IgdGhlIG1hdGNoLlxuICAgICAgICAgICAgICAgIC8vdGhyb3cgJyFzdG9wJztcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbGxlY3Rpb24oZm91bmRJdGVtcyk7XG4gICAgICAgIH1cbiAgICB9KSxcbiAgICAvLyBnZXQgc2VlbXMgbGlrZSB0aGUgd2F5IHRvIGdldCB1bmlxdWUgdmFsdWVzLlxuXG5cbiAgIC8qKlxuICAgICogQGZ1bmNcbiAgICAqIEBwYXJhbSAuLi5cbiAgICAqL1xuICAgICdnZXQnIDogZnAoZnVuY3Rpb24oYSwgc2lnLCBfc3VwZXIpIHtcblxuXG5cblxuICAgICAgICAvLyBpbnRlZ2VyLi4uIHJldHVybiB0aGUgaXRlbSBmcm9tIHRoZSBjb2xsZWN0aW9uLlxuICAgICAgICAvL2NvbnNvbGUubG9nKCdjb2xsZWN0aW9uIGdldCBzaWcgJyArIHNpZyk7XG4gICAgICAgIGlmIChzaWcgPT0gJ1tuXScgfHwgc2lnID09ICdbaV0nKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYXJyW2FbMF1dO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZ2V0dGluZyBieSBpdCdzIHVuaXF1ZSBpbmRleD9cbiAgICAgICAgLy8gIHRoaXMgbWF5IGFnYWluIHJlZmVyIHRvIGdldHRpbmcgYSBwcm9wZXJ0eS5cblxuICAgICAgICBpZiAoc2lnID09ICdbc10nKSB7XG5cbiAgICAgICAgICAgIHZhciBpeF9zeXMgPSB0aGlzLmluZGV4X3N5c3RlbTtcbiAgICAgICAgICAgIHZhciByZXM7XG4gICAgICAgICAgICBpZiAoaXhfc3lzKSB7XG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnaXhfc3lzJywgaXhfc3lzKTtcbiAgICAgICAgICAgICAgICB2YXIgcHVpID0gaXhfc3lzLl9wcmltYXJ5X3VuaXF1ZV9pbmRleDtcbiAgICAgICAgICAgICAgICByZXMgPSBwdWkuZ2V0KGFbMF0pWzBdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocmVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgIH1cblxuXG5cbiAgICAgICAgICAgIC8vIFdvcmtzIGRpZmZlcmVudGx5IHdoZW4gZ2V0dGluZyBmcm9tIGFuIGluZGV4ZWQgY29sbGVjdGlvbi5cbiAgICAgICAgICAgIC8vICBOZWVkIHRvIGxvb2sgaW50byB0aGUgaW5kZXhfc3lzdGVtXG4gICAgICAgICAgICAvLyAgdGhlcmUgbWF5IGJlIGEgcHJpbWFyeV91bmlxdWVfaW5kZXhcblxuXG5cblxuICAgICAgICAgICAgcmV0dXJuIERhdGFfT2JqZWN0LnByb3RvdHlwZS5nZXQuYXBwbHkodGhpcywgYSk7XG5cbiAgICAgICAgfVxuICAgICAgICAvLyBtYXkgdGFrZSBtdWx0aXBsZSBwYXJhbXMsIHNwZWNpZnlpbmcgdGhlIGZpZWxkcyBpbiB0aGVcbiAgICAgICAgLy8gdW5pcXVlIGluZGV4LlxuXG4gICAgfSksXG5cblxuICAgIC8vIGluc2VydF9iZWZvcmUgY291bGQgYmUgdXNlZnVsLlxuICAgIC8vICBJbiBzb21lIEhUTUwgY29udHJvbHMgd2FudCB0byBpbnNlcnQgb25lIGNvbnRyb2wgYmVmb3JlIGFub3RoZXIgb25lLlxuXG5cbiAgICAvLyBXaWxsIGEgY29udHJvbCBhbHdheXMga25vdyB3aGF0IHBvc2l0aW9uIGl0J3MgaW4/XG5cbiAgIC8qKlxuICAgICogQGZ1bmNcbiAgICAqIEBwYXJhbSAuLi5cbiAgICAqL1xuICAgICdpbnNlcnQnOiBmdW5jdGlvbihpdGVtLCBwb3MpIHtcbiAgICAgICAgLy8gdXNlIGFycmF5IHNwbGljZS4uLlxuICAgICAgICAvLyAgdGhlbiBtb2RpZnkgdGhlIGluZGV4IHNvbWVob3cuXG4gICAgICAgIC8vICBwZXJoYXBzIGFkZCAxIHRvIGVhY2ggaXRlbSdzIHBvc2l0aW9uIHBhc3QgdGhhdCBwb2ludC5cbiAgICAgICAgLy8gIG1heSBtZWFuIG4gb3BlcmF0aW9ucyBvbiB0aGUgaW5kZXguXG4gICAgICAgIC8vICAgc29tZSBraW5kIG9mIG9mZnNldCB0cmVlIGNvdWxkIGJlIHVzZWZ1bCBmb3IgZmFzdCBjaGFuZ2VzIGFuZCBrZWVwaW5nIGFjY3VyYXRlIGxvb2t1cHMuXG5cbiAgICAgICAgdGhpcy5fYXJyLnNwbGljZShwb3MsIDAsIGl0ZW0pO1xuXG4gICAgICAgIC8vIGluZGV4IHN5c3RlbSBub3RpZnlfaW5zZXJ0aW9uXG4gICAgICAgIC8vICBzbyB0aGUgaW5kZXggc3lzdGVtIGNhbiBtYWtlIHRoZSBhZGp1c3RtZW50cyB0byB0aGUgb3RoZXIgaXRlbXMuXG5cblxuICAgICAgICAvLyB0aGVuIGNhbGwgdGhlIGNoYW5nZSBldmVudC5cbiAgICAgICAgLy8gIGFuZCBoYXZlIGV2ZW50IGRldGFpbHMgc2F5aW5nIGFuIGl0ZW0gaSBoYXMgYmVlbiBpbnNlcnRlZCBhdCBwb3NpdGlvbiBwLlxuICAgICAgICAvLyAgIGZvciBjb250cm9scywgdGhhdCBzaG91bGQgYmUgZW5vdWdoIHRvIHJlbmRlciB0aGF0IGNvbnRyb2wgYW5kIHB1dCBpdCBvbnRvIHRoZSBzY3JlZW5cbiAgICAgICAgLy8gICBpZiB0aGUgY29udGV4dCBpcyBhY3RpdmUuXG5cbiAgICAgICAgdGhpcy5pbmRleF9zeXN0ZW0ubm90aWZ5X2luc2VydGlvbihwb3MpO1xuXG5cbiAgICAgICAgdGhpcy50cmlnZ2VyKCdjaGFuZ2UnLCB7XG4gICAgICAgICAgICAnbmFtZSc6ICdpbnNlcnQnLFxuICAgICAgICAgICAgJ2l0ZW0nOiBpdGVtLFxuICAgICAgICAgICAgJ3Bvcyc6IHBvc1xuICAgICAgICB9KTtcblxuXG5cblxuICAgIH0sXG5cbiAgICAvLyBtYXkgaGF2ZSBlZmZpY2llbmNpZXMgZm9yIGFkZGluZyBhbmQgcmVtb3ZpbmcgbXVsdGlwbGUgaXRlbXMgYXQgb25jZS5cbiAgICAvLyAgY2FuIGJlIHNvcnRlZCBmb3IgaW5zZXJ0aW9uIGludG8gaW5kZXggd2l0aCBtb3JlIHJhcGlkIGFsZ29yaXRobWljIHRpbWUuXG5cbiAgIC8qKlxuICAgICogQGZ1bmNcbiAgICAqIEBwYXJhbSAuLi5cbiAgICAqL1xuICAgICdyZW1vdmUnOiBmcChmdW5jdGlvbihhLCBzaWcpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgICAgIC8vY29uc29sZS5sb2coJ3NpZyAnICsgc2lnKTtcbiAgICAgICAgLy90aHJvdyAnc3RvcCc7XG5cbiAgICAgICAgaWYgKHNpZyA9PSAnW25dJykge1xuXG4gICAgICAgICAgICB2YXIgb3duX2lkID0gdGhpcy5faWQoKTtcblxuICAgICAgICAgICAgLy8gcmVtb3ZlIHRoZSBpdGVtIGF0IHRoYXQgcG9zaXRpb24uXG5cbiAgICAgICAgICAgIHZhciBwb3MgPSBhWzBdO1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSB0aGlzLl9hcnJbcG9zXTtcblxuICAgICAgICAgICAgdmFyIG9faXRlbSA9IGl0ZW07XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCcqJyk7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdpdGVtICcgKyBzdHJpbmdpZnkoaXRlbSkpO1xuXG4gICAgICAgICAgICB2YXIgc3BsaWNlZF9wb3MgPSBwb3M7XG4gICAgICAgICAgICB0aGlzLl9hcnIuc3BsaWNlKHBvcywgMSk7XG4gICAgICAgICAgICB0aGlzLl9hcnJfaWR4LS07XG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gdGhpcy5fYXJyLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlIChwb3MgPCBsZW5ndGgpIHtcblxuICAgICAgICAgICAgICAgIC8vIHJlYXNzaWduIHRoZSBzdG9yZWQgcG9zaXRpb24gb2YgdGhlIGl0ZW1cblxuICAgICAgICAgICAgICAgIHZhciBpdGVtID0gdGhpcy5fYXJyW3Bvc107XG5cbiAgICAgICAgICAgICAgICBpdGVtLnJlbGF0aW9uc2hpcHNbb3duX2lkXSA9IFt0aGF0LCBwb3NdO1xuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJycpO1xuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2l0ZW0uX3BhcmVudHNbb3duX2lkXSAnICsgc3RyaW5naWZ5KGl0ZW0uX3BhcmVudHNbb3duX2lkXSkpO1xuICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBuZWVkIHRvIHJlbW92ZSB0aGF0IGl0ZW0gZnJvbSB0aGUgaW5kZXggc3lzdGVtIGFzIHdlbGwuXG5cbiAgICAgICAgICAgIHRoaXMuaW5kZXhfc3lzdGVtLnJlbW92ZShvX2l0ZW0pO1xuICAgICAgICAgICAgLy8gYnV0IGlzIGl0IG5vIGxvbmdlciBhY3R1YWxseSB0aGVyZT9cbiAgICAgICAgICAgIC8vICBzZWVtcyB0byBiZSBnb25lIG5vdy5cblxuICAgICAgICAgICAgdmFyIGUgPSB7XG4gICAgICAgICAgICAgICAgJ3RhcmdldCc6IHRoaXMsXG4gICAgICAgICAgICAgICAgJ2l0ZW0nOiBpdGVtLFxuICAgICAgICAgICAgICAgICdwb3NpdGlvbic6IHNwbGljZWRfcG9zXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMucmFpc2VfZXZlbnQodGhhdCwgJ3JlbW92ZScsIGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYW5kIGlmIHdlIGFyZSByZW1vdmluZyBieSBhIHN0cmluZyBrZXkuLi5cblxuICAgICAgICBpZiAoc2lnID09ICdbc10nKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gYVswXTtcblxuICAgICAgICAgICAgLy8gZ2V0IHRoZSBvYmplY3QuLi5cblxuICAgICAgICAgICAgdmFyIG9iaiA9IHRoaXMuaW5kZXhfc3lzdGVtLmZpbmQoW1sndmFsdWUnLCBrZXldXSk7XG5cbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ29iaiAnICsgc3RyaW5naWZ5KG9iaikpO1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygndG9mKG9iaikgJyArIHRvZihvYmopKTtcbiAgICAgICAgICAgIC8vdGhyb3cgJ3N0b3AnXG5cbiAgICAgICAgICAgIC8vIGFuZCBnZXQgdGhlIHBvc2l0aW9uIHdpdGhpbiB0aGUgcGFyZW50LlxuXG4gICAgICAgICAgICB2YXIgbXlfaWQgPSB0aGlzLl9faWQ7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdteV9pZCAnICsgbXlfaWQpO1xuICAgICAgICAgICAgLy90aHJvdyAnc3RvcCc7XG5cbiAgICAgICAgICAgIHZhciBpdGVtX3Bvc193aXRoaW5fdGhpcyA9IG9ialswXS5fcmVsYXRpb25zaGlwc1tteV9pZF07XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdpdGVtX3Bvc193aXRoaW5fdGhpcyAnICsgaXRlbV9wb3Nfd2l0aGluX3RoaXMpO1xuICAgICAgICAgICAgLy90aHJvdyAnc3RvcCc7XG5cbiAgICAgICAgICAgIHRoaXMuaW5kZXhfc3lzdGVtLnJlbW92ZShrZXkpO1xuICAgICAgICAgICAgdGhpcy5fYXJyLnNwbGljZShpdGVtX3Bvc193aXRoaW5fdGhpcywgMSk7XG5cbiAgICAgICAgICAgIC8vIHRoZW4gYWRqdXN0IHRoZSBwb3NpdGlvbnMgZG93bndhcmRzIGZvciBlYWNoIGl0ZW0gYWZ0ZXJ3YXJkcy5cblxuXG5cbiAgICAgICAgICAgIGZvciAodmFyIGMgPSBpdGVtX3Bvc193aXRoaW5fdGhpcywgbCA9IHRoaXMuX2Fyci5sZW5ndGg7IGMgPCBsOyBjKyspIHtcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdjICcgKyBjKTtcbiAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IHRoaXMuX2FycltjXTtcbiAgICAgICAgICAgICAgICBpdGVtLl9yZWxhdGlvbnNoaXBzW215X2lkXS0tO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZSA9IHtcbiAgICAgICAgICAgICAgICAndGFyZ2V0JzogdGhpcyxcbiAgICAgICAgICAgICAgICAnaXRlbSc6IG9ialswXSxcbiAgICAgICAgICAgICAgICAncG9zaXRpb24nOiBpdGVtX3Bvc193aXRoaW5fdGhpc1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnJhaXNlX2V2ZW50KHRoYXQsICdyZW1vdmUnLCBlKTtcblxuICAgICAgICB9XG5cbiAgICB9KSxcblxuICAgLyoqXG4gICAgKiBAZnVuY1xuICAgICogQHBhcmFtIG9ial9rZXlcbiAgICAqL1xuICAgICdoYXMnOiBmdW5jdGlvbihvYmpfa2V5KSB7XG4gICAgICAgIC8vIHdpbGwgb3BlcmF0ZSBkaWZmZXJlbnRseSBkZXBlbmRpbmcgb24gaG93IHRoZSBjb2xsZWN0aW9uIGlzIGJlaW5nIHVzZWQuXG4gICAgICAgIC8vY29uc29sZS5sb2coJ3RoaXMuX2RhdGFfdHlwZV9jb25zdHJhaW50ICcgKyBzdHJpbmdpZnkodGhpcy5fZGF0YV90eXBlX2NvbnN0cmFpbnQpKTtcbiAgICAgICAgaWYgKHRoaXMuX2RhdGFfdHlwZV9jb25zdHJhaW50KSB7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCd0aGlzLl9kYXRhX3R5cGVfY29uc3RyYWludC5kYXRhX3R5cGVfY29uc3RydWN0b3IgJyArIHN0cmluZ2lmeSh0aGlzLl9kYXRhX3R5cGVfY29uc3RyYWludC5kYXRhX3R5cGVfY29uc3RydWN0b3IpKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9kYXRhX3R5cGVfY29uc3RyYWludC5kYXRhX3R5cGVfY29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgICAgICBpZih0aGlzLl9kYXRhX3R5cGVfY29uc3RyYWludC5kYXRhX3R5cGVfY29uc3RydWN0b3IgPT09IFN0cmluZykge1xuICAgICAgICAgICAgICAgICAgICAvLyBjb2xsZWN0aW9uIG9mIHN0cmluZ3MgLSBkb2VzIGl0IGhhdmUgdGhhdCBzdHJpbmc/XG4gICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3RoaXMuaW5kZXhfc3lzdGVtICcgKyBzdHJpbmdpZnkodGhpcy5pbmRleF9zeXN0ZW0pKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZvdW5kID0gdGhpcy5pbmRleF9zeXN0ZW0uZmluZCgndmFsdWUnLCBvYmpfa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnZm91bmQgJyArIHN0cmluZ2lmeShmb3VuZCkpO1xuICAgICAgICAgICAgICAgICAgICAvL3Rocm93ICdzdG9wJztcbiAgICAgICAgICAgICAgICAgICAgLy9yZXR1cm4gISFmb3VuZDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZvdW5kLmxlbmd0aCA+IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8vIFNldCBzdGlsbCBvcGVyYXRlcyBhcyBpdCBkb2VzIGZyb20gdGhlIERhdGFfT2JqZWN0LlxuXG4gICAgLy8gVW5pcXVlIGluZGV4IGJlaW5nIHJlcGxhY2VkIHdpdGggYSBjb25zdHJhaW50LCBhbmQgaXQgYWxzbyBtYWtlcyB0aGUgaW5kZXggd2hlbiB0aGUgY29uc3RyYWludCBpcyBwdXQgaW4gcGxhY2UgaWYgdGhlIGluZGV4IGlzIG5vdCBhbHJlYWR5IHRoZXJlLlxuXG5cbiAgIC8qKlxuICAgICogQGZ1bmNcbiAgICAqIEBwYXJhbSAuLi5cbiAgICAqL1xuICAgICdnZXRfaW5kZXgnOiBmcChmdW5jdGlvbihhLCBzaWcpIHtcbiAgICAgICAgaWYgKHNpZyA9PSAnW3NdJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXhfc3lzdGVtLnNlYXJjaChhWzBdKTtcbiAgICAgICAgfVxuXG4gICAgfSksXG5cbiAgICAvLyBoYXNfaW5kZXggbWF5IGJlIHVzZWZ1bC4uLiBwZXJoYXBzIHRoaXMgc2hvdWxkIGJlIGNoYW5nZWQgdG8gaW5kZXhfYnk/XG4gICAgLy8gIG90aGVyIHBlb3BsZSBtYXkgdGhpbmsgdGhpcyBtZWFucyBpdCBoYXMgYW4gaW5kZXggKGludCkgYW5kIHJldHVybnMgdGhhdC5cblxuICAgIC8vIGp1c3QgbmVlZCB0byBiZSB2ZXJ5IGNsZWFyIGFib3V0IHdoYXQgdGhpcyBmdW5jdGlvbiBkb2VzLCBjb3VsZCBoYXZlIGFuIGluZGV4X2J5IGZ1bmN0aW9uIHRvby5cblxuICAgIC8vXG5cbiAgICAvLyByZW5hbWVkIGluZGV4KCksIHdhcyBpbmRleF9ieSgpXG5cbiAgICAvLyAnaW5kZXgnIGlzIGFjdHVhbGx5IGdvaW5nIHRvIGJlIHNldHRpbmcgdXAgY29uc3RyYWludHMuXG4gICAgLy8gIC8vIGRlYWxpbmcgd2l0aCBhIGxheWVyIG9mIGNvbnN0cmFpbnRzIG1heSBtYWtlIHNlbnNlLCBidXQgaXQgc2hvdWxkIHByb2JhYmx5IGJlIGV4cG9zaW5nIHRoZSBpbmRleGVzLlxuXG4gICAgLy8gRG9uJ3Qgd2FudCB0byBjaGFuZ2UgdGhlIHN5bnRheCwgYW5kIG1ha2UgZGV2ZWxvcGVycyBoYXZlIHRvIHR5cGUgJ0NvbnN0cmFpbnQnIGFsbCB0aGUgdGltZSwgYnV0IEkgdGhpbmsgdGhhdCBDb25zdHJhaW50cyBpcyB0aGUgcmlnaHRcbiAgICAvLyAgd2F5IG9mIGV4cHJlc3NpbmcgdGhlIHVuZGVybHlpbmcgc3lzdGVtLCBwYXJ0bHkgdG8gYWlkIHRyYW5zaXRpb25zIHRvIGRhdGFiYXNlcywgYW5kIGl0cyBwcm92ZW4gdG8gYmUgYSBmbGV4aWJsZSAoaW5mbGV4aWJsZSkgbW9kZWwuXG5cbiAgIC8qKlxuICAgICogQGZ1bmNcbiAgICAqIEBwYXJhbSBmaWVsZFxuICAgICovXG4gICAgJ2ZpbmRfdW5pcXVlX2NvbnN0cmFpbnQnOiBmdW5jdGlvbihmaWVsZCkge1xuICAgICAgICAvLyBjYW4gYmUgb25lIGZpZWxkLCBvciBhbiBhcnJheS5cblxuICAgICAgICAvLyBQZXJoYXBzIHRoZSBvcmRlciBvZiB0aGUgZmllbGRzIGhlcmUgc2hvdWxkIGJlIHJlYXJyYW5nZWQgdG8gYWxwaGFiZXRpY2FsP1xuICAgICAgICAvLyAgSW4gYSBjb25zdHJhaW50LCB0aGUgb3JkZXIgb2YgdGhlIGZpZWxkcyBzaG91bGQgbm90IG1hdHRlciAtIGV4Y2VwdCBpdCB3b3VsZCBzZXQgdXAgYW4gaW5kZXggdXNpbmcgdGhlIG9yZGVyIG9mIHRoZSBmaWVsZHMgc3BlY2lmaWVkLlxuICAgICAgICAvLyAgdGhlIGNvbnN0cmFpbnQgY291bGQgaGF2ZSB0aGUgZmllbGRzIHJlYXJyYW5nZWQgaW4gYWxwaGFiZXRpY2FsIG9yZGVyLlxuXG4gICAgICAgIC8vIFRoZXJlIHdpbGwgYmUgYSBiaXQgb2YgY29kZSBibG9hdCBpbiBzb21lIGxvd2VyIGxldmVsIGNvbXBvbmVudHMgYmVjYXVzZSB0aGV5IGFyZSBub3QgdXNpbmcgRGF0YV9PYmplY3QgYW5kIENvbnN0cmFpbnQgY2xhc3NlcyB0aGVtc2VsdmVzLlxuICAgICAgICAvLyAgRmluZGluZyB0aGUgcmlnaHQgY29uc3RyYWludCBvdXQgb2YgdGhlIGV4aXN0aW5nIGNvbnN0cmFpbnRzIGlzIG5lY2Vzc2FyeSB3aGVuIHBvdGVudGlhbGx5IGFkZGluZyBhIG5ldyBjb25zdHJhaW50LlxuICAgICAgICAvLyAgQ29uc3RyYWludHMgaGF2aW5nIGFuIGFscGhhYmV0aWNhbGx5IHNvcnRlZCBsaXN0IG9mIGZpZWxkcz9cbiAgICAgICAgLy8gIEl0IGlzIGFzIHRob3VnaCB3ZSBjYW4ndCB1c2UgdW5pcXVlIGNvbnN0cmFpbnQgY29kZSBmb3IgdGhpcyB3aGVyZSBvdGhlcndpc2UgaXQgY291bGQgaGF2ZSBiZWVuIHVzZWQuXG5cbiAgICAgICAgLy8gZmllbGRzIGluIGFscGhhYmV0aWNhbCBvcmRlci4uLlxuXG4gICAgICAgIC8vIHdhbnQgdG8gYmUgYWJsZSB0byBicmVhayBvdXQgb2YgZWFjaCBsb29wcyBhcyB3ZWxsLlxuICAgICAgICAvLyAgcG9zaWJseSAoaSwgdiwgYnJlYWspIGFuZCBjYWxsIHRoZSBicmVhayBmdW5jdGlvbj9cblxuICAgICAgICB2YXIgaXRlbSA9IG51bGw7XG5cbiAgICAgICAgaWYgKHRvZihmaWVsZCkgPT0gJ2FycmF5Jykge1xuXG4gICAgICAgIH0gZWxzZSBpZiAodG9mKGZpZWxkKSA9PSAnc3RyaW5nJyl7XG4gICAgICAgICAgICAvLyBpdCdzIGp1c3Qgb25lIHN0cmluZy5cbiAgICAgICAgICAgIGVhY2godGhpcy5fdW5pcXVlX2NvbnN0cmFpbnRzLCBmdW5jdGlvbihpLCB2LCBzdG9wKSB7XG4gICAgICAgICAgICAgICAgLy8gZG9lcyBpdCBtYXRjaCB0aGUgZmllbGQ/XG4gICAgICAgICAgICAgICAgaWYgKHYuZmllbGRzID09PSBmaWVsZCkge1xuICAgICAgICAgICAgICAgICAgICBpdGVtID0gdjtcbiAgICAgICAgICAgICAgICAgICAgc3RvcCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgICAgLy9jb25zb2xlLmxvZygnaXRlbSAnICsgaXRlbSk7XG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgIH0sXG5cbiAgICAvLyBUaGUgY29uc3RyYWludHMgd2lsbCBhbHNvIGJlIGF2YWlsYWJsZSwgYnV0IHRoZXkgd2lsbCBsaWtlbHkgbWFrZSBmb3IgYSBsZXNzIHVzZXItZnJpZW5kbHkgaW50ZXJmYWNlIHRoYW4gZmllbGRzLlxuXG5cbiAgIC8qKlxuICAgICogQGZ1bmNcbiAgICAqIEBwYXJhbSAuLi5cbiAgICAqL1xuICAgICdmaWVsZHMnOiBmcChmdW5jdGlvbihhLCBzaWcpIHtcblxuICAgICAgICAvL2NvbnNvbGUubG9nKCdDb2xsZWN0aW9uIGZpZWxkcyBzaWcgJyArIHNpZyk7XG4gICAgICAgIC8vY29uc29sZS5sb2coJ0NvbGxlY3Rpb24gZmllbGRzIGEgJyArIHN0cmluZ2lmeShhKSk7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgLy8gdGhpcyB3aWxsIHJlZmVyIHRvIHRoZSBmaWVsZHMgb2YgdGhlIGRhdGFfb2JqZWN0X2NvbnN0cmFpbnQuXG5cbiAgICAgICAgaWYgKHNpZyA9PSAnW29dJykge1xuICAgICAgICAgICAgLy8gdXNlIGEgZmllbGQgZGVmaW5pdGlvbiBjb25zdHJhaW50XG4gICAgICAgICAgICAvLyAgKGEgZGlmZmVyZW50IHdheSBvZiBkb2luZyB0aGUgY29uc3RyYWludCwgdXNpbmcganNvbi1saWtlIG9iamVjdCwgbm90IHVzaW5nIGEgRGF0YV9PYmplY3QgY29uc3RydWN0b3IuXG5cbiAgICAgICAgICAgIGVhY2goYVswXSwgZnVuY3Rpb24oaSwgdikge1xuICAgICAgICAgICAgICAgIHRoYXQuc2V0X2ZpZWxkKGksIHYpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIHNldCB0aGUgY29uc3RyYWludHNcblxuICAgICAgICAgICAgdGhhdC5jb25zdHJhaW50KGFbMF0pO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2RhdGFfb2JqZWN0X2NvbnN0cmFpbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kYXRhX29iamVjdF9jb25zdHJhaW50ID0gQ29uc3RyYWludC5mcm9tX29iaihuZXcgRGF0YV9PYmplY3QoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZG9jID0gdGhpcy5fZGF0YV9vYmplY3RfY29uc3RyYWludDtcblxuICAgICAgICAgICAgaWYgKGEubCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvYy5kYXRhX29iamVjdC5mYy5nZXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIGdpdmVuIGFuIGFycmF5LCBzZXQgdGhlIGZpZWxkcy5cblxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnYS5sICcgKyBhLmwpO1xuXG4gICAgICAgICAgICBpZiAoYS5sID09IDEgJiYgdG9mKGFbMF0gPT0gJ2FycmF5JykpIHtcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdhcnJheSAxJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvYy5kYXRhX29iamVjdC5mYy5zZXQoYVswXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuXG4gICAgfSksXG5cbiAgICAvLyBHZXR0aW5nIHF1aXRlIGluIGRlcHRoIHdpdGggZ2VuZXJhbGl0eSBhbmQgcG9seW1vcnBoaXNtIGhlcmUuXG4gICAgLy9cbiAgICAvLyAgUGVyaGFwcyB0aGVyZSBzaG91bGQgYmUgYSBfZmllbGRzIG9iamVjdC5cbiAgICAvLyAgU28gZmFyIHdlIGhhdmUgdXNlZCBjb25zdHJhaW50cyAtIHRoZXJlIHdpbGwgYmUgZmllbGQgY29uc3RyYWludHMgd2hlbiBmaWVsZHMgYXJlIHNwZWNpZmllZC5cbiAgICAvLyAgIE1heWJlIGl0IG1ha2VzIHNlbnNlLi4uIGEgJ2ZpZWxkJyBtYXkgY29ycmVzcG9uZCB3aXRoIGluZGV4ZXMgYXMgd2VsbC5cblxuICAgIC8vIE1heSBiZSB0aGUgZmllbGRzIGZyb20gdGhlIHByb3RvdHlwZSwgYXMgd2VsbCBhcyBmaWVsZHMgdGhhdCBoYXZlIGJlZW4gYWRkZWQuXG5cbiAgIC8qKlxuICAgICogQGZ1bmNcbiAgICAqIEBwYXJhbSAuLi5cbiAgICAqL1xuICAgICdzZXRfZmllbGQnOiBmcChmdW5jdGlvbihhLCBzaWcpIHtcbiAgICAgICAgLy9jb25zb2xlLmxvZygnc2V0X2ZpZWxkJyk7XG4gICAgICAgIC8vIHNldHMgYSBmaWVsZD9cbiAgICAgICAgLy8gIG1heWJlICdzZXQnIGlzIGEgYmV0dGVyIHdvcmQgYmVjYXVzZSBpdCB3b3VsZCBvdmVyd3JpdGUgZXhpc3RpbmcgZmllbGRzLlxuXG4gICAgICAgIC8vIHdpbGwgYmUgYWJsZSB0byBhZGQgYW4gaW5kaXZpZHVhbCBmaWVsZFxuICAgICAgICAvLyAgbmFtZSBhbmQgZmllbGQgdHlwZSBhcyBzdHJpbmcuLi5cbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICAvLyB3ZSBtYXkgaGF2ZSBhIGRhdGFfZGVmX2NvbnN0cmFpbnQ/XG4gICAgICAgIC8vdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgICAgIC8vIEZpZWxkcyBnZXQgY3JlYXRlZCB1c2luZyBjb25zdHJhaW50cy5cblxuXG4gICAgICAgIC8vIENvbnN0cmFpbnQgZnJvbSBhIG5ldyBEYXRhX09iamVjdD9cbiAgICAgICAgLy8gIE5vdCBzdXJlIG9mIHRoZSBuZWVkIG9mIHRoaXMuXG4gICAgICAgIHZhciBkb2MgPSB0aGF0Ll9kYXRhX29iamVjdF9jb25zdHJhaW50ID0gdGhhdC5fZGF0YV9vYmplY3RfY29uc3RyYWludCB8fCBDb25zdHJhaW50LmZyb21fb2JqKG5ldyBEYXRhX09iamVjdCgpKTtcblxuXG4gICAgICAgIC8vdmFyIGRvYyA9IHRoYXQuX2RhdGFfb2JqZWN0X2NvbnN0cmFpbnQgfHxcbiAgICAgICAgLy9jb25zb2xlLmxvZygnZG9jICcgKyBzdHJpbmdpZnkoZG9jKSk7XG5cblxuXG4gICAgICAgIC8vY29uc29sZS5sb2coJ3NldF9maWVsZCBzaWcgJyArIHNpZyk7XG4gICAgICAgIC8vY29uc29sZS5sb2coJ3NldF9maWVsZCBhICcgKyBzdHJpbmdpZnkoYSkpO1xuXG4gICAgICAgIC8vIFNldHRpbmcgYSBmaWVsZCBvbiBhIGNvbGxlY3Rpb24uLi5cbiAgICAgICAgLy8gIFNldHRpbmcgYSBjb25zdHJpbmF0P1xuXG5cbiAgICAgICAgLy9pZiAoZG9jKSB7XG4gICAgICAgICAgICBpZihhLmwgPT0gMiAmJiB0b2YoYVswXSkgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBkb2MuZGF0YV9vYmplY3QuZmMgPSBkb2MuZGF0YV9vYmplY3QuZmMgfHwgbmV3IERhdGFfT2JqZWN0X0ZpZWxkX0NvbGxlY3Rpb24oKTtcblxuICAgICAgICAgICAgICAgIC8vIE1heSBuZWVkIHRvIHNldCB1cCBpbmRleGluZyBvbiB0aGUgZmllbGRzIGFzIHdlbGwuXG5cblxuICAgICAgICAgICAgICAgIHJldHVybiBkb2MuZGF0YV9vYmplY3QuZmMuc2V0KGFbMF0sIGFbMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAvL31cblxuXG4gICAgfSksXG5cblxuICAgLyoqXG4gICAgKiBAZnVuY1xuICAgICogQHBhcmFtIC4uLlxuICAgICovXG4gICAgJ3JlbW92ZV9maWVsZCc6IGZwKGZ1bmN0aW9uKGEsIHNpZykge1xuICAgICAgICB2YXIgZG9jID0gdGhpcy5fZGF0YV9vYmplY3RfY29uc3RyYWludDtcblxuICAgICAgICBpZiAoZG9jKSB7XG4gICAgICAgICAgICBpZiAoc2lnID09ICdbc10nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvYy5kYXRhX29iamVjdC5mYy5vdXQoYVswXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuXG4gICAgfSksXG4gICAgLy8gQSBjb25zdHJhaW50IG1heSByZWZlcmVuY2UgYW4gaW5kZXguXG4gICAgLy8gSXQgbWF5IG5lZWQgdG8gY3JlYXRlIHRoZSBpbmRleCBpZiBpdCBkb2VzIG5vdCBhbHJlYWR5IGV4aXN0LlxuXG4gICAgLy8gR2l2ZSBhIGRhdGEgdHlwZSB0byBnaXZlIGEgdHlwZSBjb25zdHJhaW50LlxuXG4gICAvKipcbiAgICAqIEBmdW5jXG4gICAgKi9cbiAgICAnZ2V0X2RhdGFfdHlwZV9jb25zdHJhaW50JzogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIHRoZXJlIG1heSBqdXN0IGJlIG9uZSAuX2RhdGFfdHlwZV9jb25zdHJhaW50LlxuICAgICAgICAvLyAgbm90IGhhdmluZyBhbGwgdGhlIGNvbnN0cmFpbnRzIGxpc3RlZCB0b2dldGhlci5cblxuICAgICAgICByZXR1cm4gdGhpcy5fZGF0YV90eXBlX2NvbnN0cmFpbnQ7XG5cblxuICAgIH0sXG5cbiAgIC8qKlxuICAgICogQGZ1bmNcbiAgICAqIEBwYXJhbSAuLi5cbiAgICAqL1xuICAgICdjb25zdHJhaW50JzogZnAoZnVuY3Rpb24oYSwgc2lnKSB7XG4gICAgICAgIGlmIChzaWcgPT0gJ1tdJykge1xuICAgICAgICAgICAgLy8gR2V0IGFsbCBvZiB0aGUgY29uc3RyYWludHMuXG5cbiAgICAgICAgICAgIC8vIGlmIG5vIGNvbnN0cmFpbnRzLCByZXR1cm4gbnVsbC5cbiAgICAgICAgICAgIHZhciByZXMgPSBudWxsO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5fZGF0YV90eXBlX2NvbnN0cmFpbnQpIHtcbiAgICAgICAgICAgICAgICByZXMgPSB7XG4gICAgICAgICAgICAgICAgICAgICdkYXRhX3R5cGUnOiB0aGlzLl9kYXRhX3R5cGVfY29uc3RyYWludFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9kYXRhX29iamVjdF9jb25zdHJhaW50KSB7XG4gICAgICAgICAgICAgICAgcmVzID0gcmVzIHx8IHt9O1xuICAgICAgICAgICAgICAgIHJlcy5kYXRhX29iamVjdCA9IHRoaXMuX2RhdGFfb2JqZWN0X2NvbnN0cmFpbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fZGF0YV9kZWZfY29uc3RyYWludCkge1xuICAgICAgICAgICAgICAgIHJlcyA9IHJlcyB8fCB7fTtcbiAgICAgICAgICAgICAgICByZXMuZGF0YV9kZWYgPSB0aGlzLl9kYXRhX2RlZl9jb25zdHJhaW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzaWcgPT0gJ1tvXScpIHtcbiAgICAgICAgICAgIHRoaXMuX2RhdGFfZGVmX2NvbnN0cmFpbnQgPSBuZXcgQ29uc3RyYWludC5Db2xsZWN0aW9uX0RhdGFfRGVmKGFbMF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNpZyA9PSAnW2ZdJykge1xuICAgICAgICAgICAgaWYgKGFbMF0gPT09IE51bWJlcikge1xuICAgICAgICAgICAgICAgIC8vdmFyIGNkdGMgPSBuZXcgQ29uc3RyYWludC5Db2xsZWN0aW9uX0RhdGFfVHlwZShhWzBdKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9kYXRhX3R5cGVfY29uc3RyYWludCA9IG5ldyBDb25zdHJhaW50LkNvbGxlY3Rpb25fRGF0YV9UeXBlKGFbMF0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhX3R5cGVfY29uc3RyYWludDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhWzBdID09PSBTdHJpbmcpIHtcbiAgICAgICAgICAgICAgICAvL3ZhciBjZHRjID0gbmV3IENvbnN0cmFpbnQuQ29sbGVjdGlvbl9EYXRhX1R5cGUoU3RyaW5nKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9kYXRhX3R5cGVfY29uc3RyYWludCA9IG5ldyBDb25zdHJhaW50LkNvbGxlY3Rpb25fRGF0YV9UeXBlKGFbMF0pO1xuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3RoaXMuX2RhdGFfdHlwZV9jb25zdHJhaW50ICcgKyB0aGlzLl9kYXRhX3R5cGVfY29uc3RyYWludCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGFfdHlwZV9jb25zdHJhaW50O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc19jb25zdHJ1Y3Rvcl9mbihhWzBdKSkge1xuXG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnaXNfY29uc3RydWN0b3JfZm4gJyk7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGFfdHlwZV9jb25zdHJ1Y3RvciA9IGFbMF07XG4gICAgICAgICAgICAgICAgLy8gc2V0IHVwIHRoZSBkYXRhIHR5cGUgY29uc3RyYWludC5cbiAgICAgICAgICAgICAgICAvLyAgY2FuIGhhdmUgYSBUeXBlX0NvbnN0cmFpbnQgb24gYSBjb2xsZWN0aW9uLi4uIGVhY2ggb2JqZWN0IGluIHRoZSBjb2xsZWN0aW9uIG11c3Qgc2F0aXNmeSB0aGF0IHR5cGUuXG4gICAgICAgICAgICAgICAgLy8gICBkaWZmZXJlbnQgdG8gaGF2aW5nIGl0IHNhdGlzZnkgYSBwYXJ0aWN1bGFyIGRhdGFfb2JqZWN0J3MgY29uc3RyYWludHMuXG4gICAgICAgICAgICAgICAgdmFyIGR0YyA9IHRoaXMuX2RhdGFfdHlwZV9jb25zdHJhaW50O1xuICAgICAgICAgICAgICAgIGlmIChkdGMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNkdGMgPSB0aGlzLl9kYXRhX3R5cGVfY29uc3RyYWludC5kYXRhX3R5cGVfY29uc3RydWN0b3I7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjZHRjICYmIGNkdGMgPT09IGRhdGFfdHlwZV9jb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygncmV0dXJuaW5nIGR0YycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGR0YztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9kYXRhX3R5cGVfY29uc3RyYWludCA9IG5ldyBDb25zdHJhaW50LkNvbGxlY3Rpb25fRGF0YV9UeXBlKGRhdGFfdHlwZV9jb25zdHJ1Y3Rvcik7XG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygndGhpcy5fZGF0YV90eXBlX2NvbnN0cmFpbnQgJyArIHRoaXMuX2RhdGFfdHlwZV9jb25zdHJhaW50KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YV90eXBlX2NvbnN0cmFpbnQ7XG4gICAgICAgICAgICAgICAgLy8gaGF2ZSBhIGxvb2sgYXQgdGhlIGV4aXN0aW5nIGRhdGFfdHlwZV9jb25zdHJhaW50XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBbJ3VuaXF1ZScsICdpc2JuLTEzJ11cbiAgICAgICAgLy8gWyd1bmlxdWUnLCBbJ3NjaG9vbF9pZCcsICdzY2hvb2xfYXNzaWduZWRfc3R1ZGVudF9pZCddXVxuXG4gICAgICAgIC8vIHdpbGwgbmVlZCB0byBlbnN1cmUgdGhlcmUgaXMgYW4gaW5kZXggZm9yIHRoYXQgc2V0IG9mIGZpZWxkcy5cblxuICAgICAgICAvLyBpcyBpdCBhbiBhcnJheT9cbiAgICAgICAgLy8gIGNvdWxkIGJlIGFuIGFycmF5IG9mIGRpZmZlcmVudCBjb25zdHJhaW50c1xuXG4gICAgICAgIGlmIChzaWcgPT0gJ1tEXScpIHtcbiAgICAgICAgICAgIHZhciBjb25zdHJhaW50ID0gY29uc3RyYWludF9mcm9tX29iaihhWzBdKTtcbiAgICAgICAgICAgIHRoaXMuX2RhdGFfb2JqZWN0X2NvbnN0cmFpbnQgPSBjb25zdHJhaW50O1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaWcgPT0gJ1tbcyxzXV0nKSB7XG4gICAgICAgICAgICAvLyBBIHNpbmdsZSBjb25zdHJhaW50LCB3aXRoIG9uZSBzdHJpbmcgcGFyYW1ldGVyIChwcm9iYWJseSBpdHMgZmllbGQpXG5cbiAgICAgICAgICAgIHZhciBjb25zdHJhaW50X2RlZiA9IGFbMF07XG4gICAgICAgICAgICB2YXIgY29uc3RyYWludCA9IGNvbnN0cmFpbnRfZnJvbV9vYmooY29uc3RyYWludF9kZWYpO1xuXG4gICAgICAgICAgICB2YXIgY190eXBlID0gY29uc3RyYWludC5fY29uc3RyYWludF90eXBlO1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnY190eXBlICcgKyBjX3R5cGUpO1xuXG4gICAgICAgICAgICBpZiAoY190eXBlID09ICd1bmlxdWUnKSB7XG4gICAgICAgICAgICAgICAgLy8gZW5zdXJlIGl0IGhhcyB0aGF0IHVuaXF1ZSBjb25zdHJhaW50LlxuICAgICAgICAgICAgICAgIC8vICB0aGlzIHdpbGwgbWVhbiBnb2luZyB0aHJvdWdoIGFsbCB1bmlxdWUgY29uc3RyYWludHMsIG9yIGNoZWNraW5nIGl0cyBvd24gaW5kZXggb2YgdGhlbVxuICAgICAgICAgICAgICAgIC8vICBtYXkgaGF2ZSBhIGJpdCBvZiBvcHRpbWl6YXRpb24gaGVyZSwgYnV0IG5vdCB1c2luZyBjb2xsZWN0aW9ucyB0byBpbXBsZW1lbnQgdGhpcy5cbiAgICAgICAgICAgICAgICAvLyAgY29sbGVjdGlvbnMgd2lsbCBiZSB1c2VkIGluIG1hbnkgb3RoZXIgdGhpbmdzIHRob3VnaC4gV2lsbCBiZSB1c2VmdWwgZm9yIHJlcHJlc2VudGluZyBkYXRhIG1vZGVscyBhcyB3ZWxsLlxuXG4gICAgICAgICAgICAgICAgLy8gdW5pcXVlIGNvbnN0cmFpbnRzLFxuICAgICAgICAgICAgICAgIC8vIE5PVCBOVUxMLFxuICAgICAgICAgICAgICAgIC8vIFJlbGF0aW9uc2hpcFxuICAgICAgICAgICAgICAgIC8vIENoZWNrXG5cbiAgICAgICAgICAgICAgICAvLyBUaGUgcmVsYXRpb25zaGlwIGNvbnN0cmFpbnRzLCB3aGVuIHNldCB1cCwgd2lsbCBhc3Npc3QgaW4gY3JlYXRpbmcgdGhlIGRhdGEgbW9kZWxzIHRoYXQgYWNjdXJhdGx5IG1vZGVsIHRob3NlIHJlbGF0aW9uc2hpcHMuXG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgaXQgYWxyZWFkeSBoYXMgdGhhdCB1bmlxdWUgY29uc3RyYWludC5cbiAgICAgICAgICAgICAgICB0aGlzLl91bmlxdWVfY29uc3RyYWludHMgPSB0aGlzLl91bmlxdWVfY29uc3RyYWludHMgfHwgW107XG4gICAgICAgICAgICAgICAgLy8gZ2V0IHRoZSBpbmRleC4uLlxuICAgICAgICAgICAgICAgIC8vIGluZGV4X3N5c3RlbS5maW5kX2luZGV4ZXNfd2l0aF9maWVsZHNcbiAgICAgICAgICAgICAgICAvLyBnZXRfdW5pcXVlX2NvbnN0cmFpbnQ/XG4gICAgICAgICAgICAgICAgLy8gZmluZF91bmlxdWVfY29uc3RyYWludChmaWVsZHMpXG4gICAgICAgICAgICAgICAgLy8gIHRoYXQgd2lsbCBiZSBhIGZ1bmN0aW9uIHRoYXQgZG9lcyB0aGUgc3BlY2lmaWMgc2VhcmNoIGZvciBhbiBleGlzdGluZyB1bmlxdWUgY29uc3RyYWludCB3aXRoIHRob3NlIGZpZWxkcy5cbiAgICAgICAgICAgICAgICAvLyAgcmV0dXJucyBmYWxzZSBpZiBub3QgZm91bmQuXG4gICAgICAgICAgICAgICAgLy8gd2lsbCB1c2UgZmluZF91bmlxdWVfY29uc3RyYWludCB0byBzZWUgaWYgdGhlcmUgYXJlIGFscmVhZHkgbWF0Y2hpbmcgdW5pcXVlIGNvbnN0cmFpbnRzLlxuICAgICAgICAgICAgICAgIHZhciBmaWVsZF9uYW1lID0gY29uc3RyYWludF9kZWZbMV07XG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnZmllbGRfbmFtZSAnICsgZmllbGRfbmFtZSk7XG4gICAgICAgICAgICAgICAgdmFyIGV4aXN0aW5nX3VuaXF1ZV9jb25zdHJhaW50ID0gdGhpcy5maW5kX3VuaXF1ZV9jb25zdHJhaW50KGZpZWxkX25hbWUpO1xuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2V4aXN0aW5nX3VuaXF1ZV9jb25zdHJhaW50ICcgKyBleGlzdGluZ191bmlxdWVfY29uc3RyYWludCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmdfdW5pcXVlX2NvbnN0cmFpbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV4aXN0aW5nX3VuaXF1ZV9jb25zdHJhaW50O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gbG9vayB0byBzZWUgaWYgdGhlcmUgaXMgYW4gaW5kZXggdGhhdCBzdXBwb3J0cyB0aGUgY29uc3RyYWludC5cbiAgICAgICAgICAgICAgICAgICAgLy8gIGRvZXMgbm90IGhhdmUgdG8gYmUgYSBzb3J0ZWQgaW5kZXgsIG5lY2Vzc2FyaWx5LlxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGxldCdzIGdldCBhbiBpbmRleCwgd2l0aCB0aG9zZSBmaWVsZHMuXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gaXQgbWF5IGJlIHdvcnRoIGhhdmluZyB0aGUgZmllbGRzIG9mIHZhcmlvdXMgaW5kZXhlcyBzb3J0ZWQgYnkgbmFtZSBhdXRvbWF0aWNhbGx5LlxuICAgICAgICAgICAgICAgICAgICAvLyAgd291bGQgYmUgdXNlZnVsIGZvciBxdWljayBhbGdvcml0aG1pYyBjb21wYXJpc29uIG9mIHdoaWNoIGZpZWxkcyB0aGV5IGFyZSBpbmRleGluZy5cblxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgb3B0aW1hbCBvbmUgd291bGQgYmUgdGhlIGluZGV4IGluIHRoZSBzYW1lIG9yZGVyLCBidXQgZmFpbGluZyB0aGF0LCBhbiBpbmRleCB3aXRoIHRoZSBmaWVsZHMgaW4gYSBkaWZmZXJlbnQgb3JkZXIgY2FuIGJlIHVzZWQuXG4gICAgICAgICAgICAgICAgICAgIC8vICBUaGUgb3JkZXIgb24gdGhlIGNvbnN0cmFpbnRzIGRvZXMgbm90IG1hdHRlciBzbyBtdWNoLCBidXQgaXQgaXMgbmljZSB0byBwcmVzZXJ2ZSB3aGljaGV2ZXIgb3JkZXIgdGhlIHVzZXIgc3BlY2lmaWVkIGluaXRpYWxseS5cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyB3aWxsIHRha2UgbW9yZSB0aW1lIGFuZCBlZmZvcnQuLi4gYnV0IG5vdCBhIG1hc3NpdmUgYW1vdW50IGJlZm9yZSB0aGUgc3lzdGVtIGlzIHJlYWR5IHRvIGJlIHVzZWQuXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSSB0aGluayBJIHNob3VsZCBnZXQgbXkgc2l0ZSBydW5uaW5nIHNvIGl0IGNhbiBob3N0IGRpc2N1c3Npb24gYWJvdXQgdGhlIHN5c3RlbS5cbiAgICAgICAgICAgICAgICAgICAgLy8gIEhhdmluZyBkb2N1bWVudGF0aW9uIG9uIG15IHNpdGUgd291bGQgYmUgdmVyeSBnb29kLiBJdCB3b3VsZCBiZSBuaWNlIHRvIG1lYXN1cmUgdGhlIHRyYWZmaWMgYW5kIGludGVyZXN0LlxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZXJlIHdpbGwgYmUgc29tZSBmZWF0dXJlcyBhYm91dCBkb2luZyBzb21lIHNwZWNpZmljIHRoaW5ncy5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KSxcblxuICAgIC8vIGFsc28gY291bGQgYmUgZXhwcmVzc2VkIGFzIGEgY29uc3RyYWludCBhbmQgdGhlbiB0aGUgaW5kZXggaXMgYXV0b21hdGljYWxseSBwdXQgaW4gcGxhY2UuXG4gICAgLy8gSG93ZXZlciwgd2hlbiBhbiBpbmRleCBpcyBzZXQsIGl0J3Mgbm90IHNldHRpbmcgYSB1bmlxdWUgY29uc3RyYWludCBhdXRvbWF0aWNhbGx5LlxuXG4gICAgLy8gYmFzaWNhbGx5IGVuc3VyZV9pbmRleCBmb3IgdGhlIG1vbWVudC5cbiAgICAvLyAgaG93ZXZlciwgd2lsbCBhbHNvIHJldHVybiB0aGUgaW5kZXgsIGFuZCB3aXRoIG5vIHBhcmFtcyB3aWxsIGdldCBhbGwgaW5kZXhlcy5cbiAgICAvLyAgd2lsbCBoYXZlIG5pY2Ugc3ludGF4IHdpdGggZW5zdXJpbmcgbXVsdGlwbGUgaW5kZXhlcyBhdCBvbmNlLlxuXG4gICAgLy8gU2hvdWxkIHBvc3NpYmx5IHByZXNlbnQgbmljZXIgc3ludGF4IHRvIE1vbmdvREIgd2l0aCBhIHdyYXBwZXIuXG4gICAgLy8gIE1heSBoYXZlIHNvbWUgZGlmZmVyZW50IGRhdGEgd2lyaW5nIC8gY29ubmVjdGlvbiBvcHRpb25zLlxuICAgIC8vIExpa2VseSB0byBiZSBiZXN0IHRvIGRvIGEgbG90IGluIHRoZSBhYnN0cmFjdCBzbyBjaGFuZ2VzIGNhbiBiZSB2aWV3ZWQgYmVmb3JlIGJlaW5nIG1hZGUuXG5cbiAgIC8qKlxuICAgICogQGZ1bmNcbiAgICAqIEBwYXJhbSBmaWVsZHNcbiAgICAqL1xuICAgICdnZXRfdW5pcXVlX2NvbnN0cmFpbnQnOiBmdW5jdGlvbihmaWVsZHMpIHtcbiAgICAgICAgaWYgKHRvZihmaWVsZHMpID09ICdzdHJpbmcnKSBmaWVsZHMgPSBbZmllbGRzXTtcbiAgICAgICAgZWFjaCh0aGlzLl91bmlxdWVfY29uc3RyYWludHMsIGZ1bmN0aW9uKGksIHVuaXF1ZV9jb25zdHJhaW50KSB7XG4gICAgICAgICAgICB2YXIgdWNfZmllbGRzID0gdW5pcXVlX2NvbnN0cmFpbnQuZmllbGRzO1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygndWNfZmllbGRzICcgKyBzdHJpbmdpZnkodWNfZmllbGRzKSk7XG5cbiAgICAgICAgICAgIGlmIChhcmVfZXF1YWwodWNfZmllbGRzLCBmaWVsZHMpKSByZXR1cm4gdW5pcXVlX2NvbnN0cmFpbnQ7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgIC8qKlxuICAgICogQGZ1bmNcbiAgICAqIEBwYXJhbSAuLi5cbiAgICAqL1xuICAgICd1bmlxdWUnOiBmcChmdW5jdGlvbihhLCBzaWcpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICAvL2NvbnNvbGUubG9nKCdhWzBdICcgKyBzdHJpbmdpZnkoYVswXSkpO1xuXG4gICAgICAgIGlmIChzaWcgPT0gJ1tzXScpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVuaXF1ZShbYVswXV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b2YoYVswXSkgPT0gJ2FycmF5Jykge1xuICAgICAgICAgICAgaWYgKGlzX2Fycl9vZl9hcnJzKGFbMF0pKSB7XG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnaXNfYXJyX29mX2FycnMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc19hcnJfb2Zfc3RycyhhWzBdKSkge1xuICAgICAgICAgICAgICAgIHZhciBleGlzdGluZ191YyA9IHRoaXMuZ2V0X3VuaXF1ZV9jb25zdHJhaW50KGFbMF0pO1xuICAgICAgICAgICAgICAgIGlmIChleGlzdGluZ191YykgcmV0dXJuIGV4aXN0aW5nX3VjO1xuICAgICAgICAgICAgICAgIHZhciBuZXdfdWMgPSBuZXcgQ29uc3RyYWludC5VbmlxdWUoe1xuICAgICAgICAgICAgICAgICAgICAnZmllbGRzJzogYVswXVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuX3VuaXF1ZV9jb25zdHJhaW50cyA9IHRoaXMuX3VuaXF1ZV9jb25zdHJhaW50cyB8fCBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLl91bmlxdWVfY29uc3RyYWludHMucHVzaChuZXdfdWMpO1xuICAgICAgICAgICAgICAgIHZhciBpZHggPSB0aGlzLmluZGV4KGFbMF0pO1xuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJycpO1xuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2lkeCAnICsgc3RyaW5naWZ5KGlkeCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSksXG5cbiAgICAvLyBpbmRleGVzXG4gICAgLy8gIHdpbGwgZ2V0IGFsbCB0aGUgaW5kZXhlcy4uLiBtYXkgc2V0IGEgcGFydGljdWxhciBpbmRleD8gT3IgcmVwbGFjZSB0aGUgaW5kZXhlcz9cblxuICAgLyoqXG4gICAgKiBAZnVuY1xuICAgICogQHBhcmFtIC4uLlxuICAgICovXG4gICAgJ2luZGV4ZXMnOiBmcChmdW5jdGlvbihhLCBzaWcpIHtcbiAgICAgICAgaWYgKGEubCA9PSAwKSB7XG4gICAgICAgICAgICAvLyBnZXQgYWxsIGluZGV4ZXMuXG4gICAgICAgICAgICAvLyB3aWxsIGxvb2sgYXQgdGhlIGluZGV4IHN5c3RlbSwgYW5kIGdldCB0aGUgaW5kZXhlcyBmcm9tIHRoYXQuXG4gICAgICAgICAgICB2YXIgaW5kZXhfc3lzdGVtID0gdGhpcy5pbmRleF9zeXN0ZW07XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdpbmRleF9zeXN0ZW0gJyArIGluZGV4X3N5c3RlbSk7XG4gICAgICAgICAgICB2YXIgaW5kZXhlcyA9IGluZGV4X3N5c3RlbS5pbmRleGVzKCk7XG4gICAgICAgICAgICByZXR1cm4gaW5kZXhlcztcbiAgICAgICAgfVxuICAgIH0pLFxuICAgIC8vIGluZGV4X2J5IC0gaXQgc291bmRzIG5pY2UsIHJlYWRzIHdlbGwgaW4gY29kZSAvIHNhbXBsZXMuXG4gICAgLy8gIG1heSBqdXN0IHVzZSB0aGUgaW5kZXgoKSBtZXRob2QsIGJ1dCB0aGF0IGNvdWxkIGNhbGwgaW5kZXhfYnkgdG8gbWFrZSB0aGluZ3MgYSBiaXQgY2xlYXJlci5cblxuXG4gICAvKipcbiAgICAqIEBmdW5jXG4gICAgKiBAcGFyYW0gLi4uXG4gICAgKi9cbiAgICAnaW5kZXhfYnknOiBmcChmdW5jdGlvbihhLCBzaWcpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICAvL2NvbnNvbGUubG9nKCdpbmRleF9ieSBhICcgKyBzdHJpbmdpZnkoYSkpO1xuICAgICAgICAvL2NvbnNvbGUubG9nKCdhLmwgJyArIGEubCk7XG4gICAgICAgIC8vY29uc29sZS5sb2coJ2luZGV4X2J5IHNpZyAnICsgc2lnKTtcbiAgICAgICAgLy9jb25zb2xlLmxvZygnYScsIGEpO1xuICAgICAgICAvL3Rocm93KCdzdG9wJyk7XG4gICAgICAgIC8vY29uc29sZS5sb2coJ3RvZihhWzBdKSAnICsgdG9mKGFbMF0pKTtcbiAgICAgICAgLy9pZiAoYS5sID09IDEgJiYgdG9mKGFbMF0pID09ICdhcnJheScpIHtcbiAgICAgICAgaWYgKHNpZyA9PSAnW2FdJykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ2FbMF0gJyArIHN0cmluZ2lmeShhWzBdKSk7XG5cbiAgICAgICAgICAgIGlmIChpc19hcnJfb2Zfc3RycyhhWzBdKSkge1xuICAgICAgICAgICAgICAgIC8vIHRoZW4gaXQncyBhIHNpbmdsZSBpbmRleC5cbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdpc19hcnJfb2Zfc3RycyAnICsgc3RyaW5naWZ5KGFbMF0pKTtcbiAgICAgICAgICAgICAgICB2YXIgcmVsZXZhbnRfaW5kZXggPSB0aGlzLmluZGV4X3N5c3RlbS5nZXRfaW5kZXhfc3RhcnRpbmcoYVswXSk7XG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygncmVsZXZhbnRfaW5kZXggJyArIHJlbGV2YW50X2luZGV4KTtcbiAgICAgICAgICAgICAgICBpZiAocmVsZXZhbnRfaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlbGV2YW50X2luZGV4O1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4X3NwZWMgPSBhWzBdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3X2luZGV4ID0gdGhpcy5pbmRleF9zeXN0ZW0uZW5zdXJlX2luZGV4KGluZGV4X3NwZWMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3X2luZGV4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIGl0J3MgYW4gYXJyYXkgb2YgYXJyYXlzLi4uIGl0J3MgYW4gYXJyYXkgb2YgaW5kZXhlcy5cbiAgICAgICAgICAgIGlmIChpc19hcnJfb2ZfYXJycyhhWzBdKSkge1xuICAgICAgICAgICAgICAgIC8vIGRlYWwgd2l0aCBlYWNoIG9mIHRoZW0gaW4gdHVybi5cbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdpdCBpc19hcnJfb2ZfYXJycycpO1xuICAgICAgICAgICAgICAgIGVhY2goYVswXSwgZnVuY3Rpb24oaSwgc3BlY2lmaWVkX2luZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQuaW5kZXgoc3BlY2lmaWVkX2luZGV4KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG90aGVyd2lzZSwgd2UnbGwgYmUgdGFraW5nIGEgbWFwIG9mIHdoYXQgdG8gaW5kZXggYW5kIHdoYXQgdHlwZSBvZiBpbmRleCB0byB1c2UgdGhlcmUuXG5cbiAgICAgICAgLy8gZ2V0IHRoZSBpbmRleCwgYmFzZWQgb24gdGhhdCBuYW1lP1xuICAgICAgICBpZiAoc2lnID09ICdbc10nKSB7XG5cbiAgICAgICAgICAgIC8vIFRlbGwgdGhlIGluZGV4IHRvIHNvcnQgaXRzZWxmIGJhc2VkIG9uIHRoYXQgdmFsdWUuXG5cblxuXG4gICAgICAgICAgICByZXR1cm4gdGhhdC5pbmRleCh7XG4gICAgICAgICAgICAgICAgJ3NvcnRlZCc6IFtbYVswXV1dXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzaWcgPT0gJ1tvXScpIHtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ29iamVjdCBzaWcnKTtcblxuICAgICAgICAgICAgdmFyIGluZGV4X21hcCA9IGFbMF07XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdpbmRleF9tYXAgJyArIHN0cmluZ2lmeShpbmRleF9tYXApKTtcblxuICAgICAgICAgICAgZWFjaChpbmRleF9tYXAsIGZ1bmN0aW9uKGluZGV4X3R5cGUsIGluZGV4X2RlZmluaXRpb24pIHtcblxuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2luZGV4X2RlZmluaXRpb24nLCBpbmRleF9kZWZpbml0aW9uKTtcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdpbmRleF90eXBlICcgKyBpbmRleF90eXBlKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXhfdHlwZSA9PSAnc29ydGVkJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBzZXQgdXAgdGhlIGluZGl2aWR1YWwgaW5kZXggb2YgdGhlIHNwZWNpZmllZCB0eXBlLlxuXG4gICAgICAgICAgICAgICAgICAgIC8vaWYgKGluZGV4X3R5cGUgPT0gJ3NvcnRlZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnaW5kZXhfZGVmaW5pdGlvbiAnICsgc3RyaW5naWZ5KGluZGV4X2RlZmluaXRpb24pKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRvZihpbmRleF9kZWZpbml0aW9uKSA9PSAnYXJyYXknKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpcyBpdCBhbiBhcnJheSBvZiBzdHJpbmdzPyB0aGVuIGl0IGlzIHRoZSBmaWVsZHM/XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpcyBpdCBhbiBhcnJheSBvZiBhcnJheXM/XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNfYXJyX29mX2FycnMoaW5kZXhfZGVmaW5pdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlYWNoIGluZGV4LCBlYWNoIGZpZWxkIGluIHRoZSBpbmRleFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbmRleGVzID0gW107XG5cblxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWFjaChpbmRleF9kZWZpbml0aW9uLCBmdW5jdGlvbihpLCBpbmRpdmlkdWFsX2luZGV4X2ZpZWxkcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGVuIHdpbGwgaGF2ZSBhIGJ1bmNoIG9mIGZpZWxkc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdpbmRpdmlkdWFsX2luZGV4X2ZpZWxkcyAnICsgc3RyaW5naWZ5KGluZGl2aWR1YWxfaW5kZXhfZmllbGRzKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2V0dGluZyB0aGUgZmllbGRzIG9mIGEgQ29sbGVjdGlvbl9JbmRleC4uLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgbmVlZCB0byBiZSBjYXJlZnVsIHdoZW4gdGhlIGZpZWxkIGlzIGFuIGF0dGFjaGVkIG9iamVjdC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICBtYXkgdXNlIEpTT04gbm90YXRpb24gZm9yIHRoZSBhdHRhY2hlbWVudC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICBsaWtlbHkgdG8gZGlzYWxsb3cgcXVvdGVzIGFuZCAoc3F1YXJlKSBicmFja2V0cyBpbiBmaWVsZCBuYW1lcy5cblxuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWFrZSBpdCBzbyBTb3J0ZWRfQ29sbGVjdGlvbl9JbmRleCBjYW4gaGFuZGxlIGF0dGFjaGVkIG9iamVjdHMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICBmaWVsZHMgc2V0IGxpa2UgW3tcImF0dGFjaGVkXCI6IHtcIm1ldGFcIjogXCJuYW1lXCJ9fV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gIHdoZXJlIGEgZmllbGQgaXMgc3BlY2lmaWVkIGFzIGFuIG9iamVjdCxcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTbyB0aGUgaW5kZXggZ2V0cyBjcmVhdGVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgSXQgaGFzIHRob3NlIGZpZWxkcy4uLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgIHdoZXJlIHRvIHRoZXkgZ2V0IG1hZGUgd2l0aGluIHRoZSBTb3J0ZWRfQ29sbGVjdGlvbl9JbmRleCBjb25zdHJ1Y3Rvcj9cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdpbmRpdmlkdWFsX2luZGV4X2ZpZWxkcycsIGluZGl2aWR1YWxfaW5kZXhfZmllbGRzKTtcblxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IG5ldyBTb3J0ZWRfQ29sbGVjdGlvbl9JbmRleCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZmllbGRzJyA6IGluZGl2aWR1YWxfaW5kZXhfZmllbGRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZXNlIGNvbGxlY3Rpb24gaW5kZXhlcyBzaG91bGQgaGF2ZSBhICdnZXQnIGZ1bmN0aW9uLlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuaW5kZXhfc3lzdGVtLnNldF9pbmRleChpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ZXMucHVzaChpbmRleCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2luZGV4ZXMnLCBpbmRleGVzKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuaW5kZXhfc3lzdGVtLl9wcmltYXJ5X3VuaXF1ZV9pbmRleCA9IGluZGV4ZXNbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4ZXNbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNfYXJyX29mX3N0cnMoaW5kZXhfZGVmaW5pdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvbmUgaW5kZXgsIHdpdGggZmllbGRzXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9KSxcblxuICAgLyoqXG4gICAgKiBAZnVuY1xuICAgICogQHBhcmFtIC4uLlxuICAgICovXG4gICAgJ2luZGV4JzogZnAoZnVuY3Rpb24oYSwgc2lnKSB7XG5cbiAgICAgICAgaWYgKGEubCA9PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbmRleF9ieShhWzBdKTtcbiAgICAgICAgfVxuXG5cbiAgICB9KSxcblxuXG4gICAvKipcbiAgICAqIEBmdW5jXG4gICAgKiBAcGFyYW0gb2JqXG4gICAgKi9cbiAgICAndGVzdF9vYmplY3RfYWdhaW5zdF9jb25zdHJhaW50cyc6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAvLyB3aWxsIGRvIHRoZSB0ZXN0IGZvciB0aGUgdmFyaW91cyBjb25zdHJhaW50c1xuICAgICAgICAvL2NvbnNvbGUubG9nKCd0ZXN0X29iamVjdF9hZ2FpbnN0X2NvbnN0cmFpbnRzJyk7XG4gICAgICAgIC8vdmFyIHJlc190ZXN0X2RhdGFfb2JqZWN0X2NvbnN0cmFpbnQgPVxuICAgICAgICAvL2NvbnNvbGUubG9nKCd0aGlzLl90eXBlX2NvbnN0cnVjdG9yICcgKyB0aGlzLl90eXBlX2NvbnN0cnVjdG9yKTtcbiAgICAgICAgLy9jb25zb2xlLmxvZygndGhpcy5fZGF0YV9vYmplY3RfY29uc3RyYWludCAnICsgc3RyaW5naWZ5KHRoaXMuX2RhdGFfb2JqZWN0X2NvbnN0cmFpbnQpKTtcbiAgICAgICAgLy9jb25zb2xlLmxvZygndGhpcy5fZGF0YV90eXBlX2NvbnN0cmFpbnQgJyArIHN0cmluZ2lmeSh0aGlzLl9kYXRhX3R5cGVfY29uc3RyYWludCkpO1xuXG4gICAgICAgIC8vY29uc29sZS5sb2coJ29iaiAnICsgc3RyaW5naWZ5KG9iaikpO1xuICAgICAgICAvLyBDb3VsZCBhbHNvIGhhdmUgYSBjb25zdHJ1Y3RvciB0eXBlIC0gY2FuIGNoZWNrIGluc3RhbmNlIG9mXG5cbiAgICAgICAgaWYgKHRoaXMuX3R5cGVfY29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgIGlmICghb2JqIGluc3RhbmNlb2YgdGhpcy5fdHlwZV9jb25zdHJ1Y3RvcikgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2RhdGFfb2JqZWN0X2NvbnN0cmFpbnQpIHtcbiAgICAgICAgICAgIC8vIG5vdCBzdXJlIHdoeSB0aGlzIHdpbGwgaGF2ZSBhIF9kYXRhX29iamVjdF9jb25zdHJhaW50IGluIHZhcmlvdXMgY2FzZXMuXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCd0aGlzLl9kYXRhX29iamVjdF9jb25zdHJhaW50JywgdGhpcy5fZGF0YV9vYmplY3RfY29uc3RyYWludCk7XG5cbiAgICAgICAgICAgIGlmICghdGhpcy5fZGF0YV9vYmplY3RfY29uc3RyYWludC5tYXRjaChvYmopKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fZGF0YV90eXBlX2NvbnN0cmFpbnQpIHtcbiAgICAgICAgICAgIC8vIHRlc3QgYWdhaW5zdCB0aGF0IGNvbnN0cmFpbnRcbiAgICAgICAgICAgIGlmICghdGhpcy5fZGF0YV90eXBlX2NvbnN0cmFpbnQubWF0Y2gob2JqKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgICAgIHZhciByZXMgPSB0cnVlO1xuICAgICAgICBlYWNoKHRoaXMuX3VuaXF1ZV9jb25zdHJhaW50cywgZnVuY3Rpb24oaSwgdW5pcXVlX2NvbnN0cmFpbnQpIHtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3VuaXF1ZV9jb25zdHJhaW50ICcgKyBzdHJpbmdpZnkodW5pcXVlX2NvbnN0cmFpbnQpKTtcbiAgICAgICAgICAgIC8vIHRoZW4gdGVzdCBhZ2FpbnN0IHRoYXQgdW5pcXVlIGNvbnN0cmFpbnQuXG5cbiAgICAgICAgICAgIC8vIGdldCB0aGUgZmllbGRzIG9mIHRoZSBjb25zdHJhaW50LCB0aGVuIHRyeSB0byBnZXQgYSByZWNvcmQgd2l0aCB0aG9zZSBmaWVsZHNcblxuICAgICAgICAgICAgdmFyIHVjX2ZpZWxkcyA9IHVuaXF1ZV9jb25zdHJhaW50LmZpZWxkcztcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3VjX2ZpZWxkcyAnICsgc3RyaW5naWZ5KHVjX2ZpZWxkcykpO1xuXG4gICAgICAgICAgICAvLyB0aGVuIGF0dGVtcHQgdG8gJ2dldCcsIHVzaW5nIHRoZXNlIGZpZWxkcy5cbiAgICAgICAgICAgIC8vICBwZXJmb3JtaW5nIGEgcmVjb3JkIGNvdW50IHdvdWxkIGJlIG1vcmUgZWZmaWNpZW50IHRob3VnaC5cbiAgICAgICAgICAgIC8vICAnaGFzJyBzZWFyY2gsIHJldHVybnMgYm9vbGVhblxuXG4gICAgICAgICAgICB2YXIgZmluZF9wYXJhbXMgPSBbXTtcbiAgICAgICAgICAgIGVhY2godWNfZmllbGRzLCBmdW5jdGlvbihpLCBmaWVsZF9uYW1lKSB7XG4gICAgICAgICAgICAgICAgLy8gZ2V0IHRoZSB2YWx1ZVxuXG4gICAgICAgICAgICAgICAgdmFyIGZpZWxkX3ZhbHVlID0gb2JqLmdldChmaWVsZF9uYW1lKTtcbiAgICAgICAgICAgICAgICBmaW5kX3BhcmFtcy5wdXNoKFtmaWVsZF9uYW1lLCBmaWVsZF92YWx1ZV0pO1xuXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2ZpbmRfcGFyYW1zICcgKyBzdHJpbmdpZnkoZmluZF9wYXJhbXMpKTtcblxuICAgICAgICAgICAgdmFyIGZvdW5kID0gdGhhdC5maW5kKGZpbmRfcGFyYW1zKTtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2ZvdW5kICcgKyBzdHJpbmdpZnkoZm91bmQpKTtcblxuICAgICAgICAgICAgaWYgKGZvdW5kICYmIGZvdW5kLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICByZXMgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfSxcblxuXG4gICAvKipcbiAgICAqIEBmdW5jXG4gICAgKiBAcGFyYW0gdmFsdWVcbiAgICAqL1xuXG4gICAgLy8gU29tZXRpbWVzIHdyYXAgYSBub3JtYWwgSlMgb2JqIGFzIGEgRGF0YV9WYWx1ZSwgRGF0YV9PYmplY3Qgb3IgQ29sbGVjdGlvbj9cblxuXG5cbiAgICAncHVzaCc6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cbiAgICAgICAgdmFyIHR2ID0gdG9mKHZhbHVlKTtcbiAgICAgICAgLy9jb25zb2xlLmxvZygnMSkgY29sbGVjdGlvbiBwdXNoIHZhbHVlOiAnICsgc3RyaW5naWZ5KHZhbHVlKSk7XG4gICAgICAgIC8vY29uc29sZS5sb2coJy0tLS0tLS0tLS0tLS0tLS0tLS0tJylcbiAgICAgICAgLy9jb25zb2xlLmxvZygncHVzaCB0diAnICsgdHYpO1xuXG4gICAgICAgIGlmICh0diA9PSAnb2JqZWN0Jykge1xuXG4gICAgICAgICAgICB2YXIgZHRjID0gdGhpcy5fZGF0YV90eXBlX2NvbnN0cmFpbnQ7XG4gICAgICAgICAgICAvLyAgYnV0IHdlIGNhbiBoYXZlIGFuIG9iamVjdCBkZWZpbml0aW9uIGNvbnN0cmFpbnQ/XG4gICAgICAgICAgICAvLyAgaXMgdGhhdCBhIHR5cGUgb2YgZGF0YV90eXBlX2NvbnN0cmFpbnQ/XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdkdGMgJyArIGR0Yyk7XG5cbiAgICAgICAgICAgIGlmIChkdGMpIHtcbiAgICAgICAgICAgICAgICB2YXIgZHRjb24gPSBkdGMuZGF0YV90eXBlX2NvbnN0cnVjdG9yO1xuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2R0Y29uICcgKyBkdGNvbik7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBuZXcgZHRjb24odmFsdWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgZGRjID0gdGhpcy5fZGF0YV9kZWZfY29uc3RyYWludDtcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdkZGMgJyArIHN0cmluZ2lmeShkZGMpKTtcblxuICAgICAgICAgICAgICAgIC8vIG5lZWQgdG8gc2VlIGlmIGl0IG1hdGNoZXMgdGhlIGNvbnN0cmFpbnQuXG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygndmFsdWUgJyArIHN0cmluZ2lmeSh2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIC8vIFdpbGwgbmVlZCBzb21ldGhpbmcgcmVjdXJzaXZlIHRvIHNlZSBpZiBzb21ldGhpbmcgbWF0Y2hlcyBhIGRhdGFfZGVmLlxuICAgICAgICAgICAgICAgIC8vICBpbiB0aGUgZGF0YV9kZWZfY29uc3RyaW50IGNvZGUuXG4gICAgICAgICAgICAgICAgdmFyIG1hdGNoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoZGRjKSBtYXRjaCA9IGRkYy5tYXRjaCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnbWF0Y2ggJyArIG1hdGNoKTtcblxuICAgICAgICAgICAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgJ0RvZXMgbm90IG1hdGNoIGRhdGFfZGVmIGNvbnN0cmFpbnQnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG5lZWQgdG8gY3JlYXRlIGEgbmV3IGRhdGFfb2JqZWN0IHdpdGggdGhhdCBkYXRhX2RlZj9cbiAgICAgICAgICAgICAgICAgICAgLy8gIG9yIGNvdWxkIHNldCB0aGUgZmllbGRzP1xuICAgICAgICAgICAgICAgICAgICAvLyAgRmllbGRzIGNvdWxkIHJlc3BvbmQgdG8gZGF0YV9kZWYuXG4gICAgICAgICAgICAgICAgICAgIC8vICAgQnV0IGRhdGFfZGVmIGNvdWxkIGVuY29tcGFzcyBtb3JlIHRoYW4ganVzdCBmaWVsZHMuXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQW5kIGEgRGF0YV9PYmplY3QgY291bGQgaGF2ZSBhIGRhdGFfZGVmX2NvbnN0cmFpbnQgdG9vLlxuICAgICAgICAgICAgICAgICAgICAvLyAgVGhhdCB3b3VsZCBhbHNvIHNldCBpdHMgZmllbGRzLlxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFdpbGwganVzdCBzZXQgdGhlIGZpZWxkcyB3aXRoIHRoZSBkYXRhX2RlZiBmb3Igbm93Pz8/XG4gICAgICAgICAgICAgICAgICAgIC8vdmFsdWUgPSBkb2JqKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gV291bGQgYmUgYmV0dGVyIHRvIG1ha2UgYW4gZW5oYW5jZWRfZGF0YV9vYmplY3QgaGVyZVxuXG4gICAgICAgICAgICAgICAgICAgIC8vdmFsdWUgPSBuZXdcbiAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnKiB2YWx1ZSAnICsgc3RyaW5naWZ5KHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZGMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gZG9iaih2YWx1ZSwgZGRjLmRhdGFfZGVmKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gZG9iaih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygndmFsdWUgJyArIHN0cmluZ2lmeSh2YWx1ZSkpO1xuICAgICAgICAgICAgICAgICAgICAvLyBzZXQgaXRzIGNvbnN0cmFpbnRzLi4uXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLmNvbnN0cmFpbnRzKGRkYyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFVzaW5nIHRoZSBjb2xsZWN0aW9uIGRhdGEgZGVmaW5pdGlvbiBjb25zdHJhaW50LCBzaG91bGQgYmUgYWJsZSB0byBzZXQgdGhlIGlubmVyIGNvbnN0YWludCBvZiB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gIGRhdGFfb2JqZWN0LiBNYXkganVzdCB1c2UgdGhlIHNhbWUgb2JqZWN0IHJhdGhlciB0aGFuIGNsb25pbmcgaXQuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy92YWx1ZSA9IGRvYmoodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHYgPSB0b2YodmFsdWUpO1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygndHYgJyArIHR2KTtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3ZhbHVlICcgKyB2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvL2NvbnNvbGUubG9nKCdjb2xsZWN0aW9uIHB1c2ggdHY6ICcgKyB0dik7XG4gICAgICAgIC8vY29uc29sZS5sb2coJzIpIGNvbGxlY3Rpb24gcHVzaCB2YWx1ZTogJyArIHN0cmluZ2lmeSh2YWx1ZSkpO1xuICAgICAgICAvLyBzbywgYSBkYXRhX2l0ZW0gZ2V0cyBhZGRlZCBhdCB0aGlzLl9hcnJfaWR4XG5cbiAgICAgICAgLy8gYWxzbyBuZWVkIHRvIGJlIGFkZCBhIGNvbGxlY3Rpb24gdG8gdGhlIGNvbGxlY3Rpb24uXG4gICAgICAgIC8vICB0aGF0IHdpbGwgYmUgYSBsb3QgbGlrZSB3aXRoIERhdGFfT2JqZWN0LlxuICAgICAgICAvLyAgIFRoZXJlIGNhbid0IHJlYWxseSBiZSBmdWxsIGF1dG9tYXRpYyBpbmRleGluZyBoZXJlLlxuXG4gICAgICAgIGlmICh0diA9PSAnY29sbGVjdGlvbicpIHtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJzEpIHByZSB0ZXN0X29iamVjdF9hZ2FpbnN0X2NvbnN0cmFpbnRzJyk7XG4gICAgICAgICAgICB2YXIgY29uc3RyYWludHNfdGVzdF9yZXMgPSB0aGlzLnRlc3Rfb2JqZWN0X2FnYWluc3RfY29uc3RyYWludHModmFsdWUpO1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnY29uc3RyYWludHNfdGVzdF9yZXMgJyArIGNvbnN0cmFpbnRzX3Rlc3RfcmVzKTtcbiAgICAgICAgICAgIGlmIChjb25zdHJhaW50c190ZXN0X3Jlcykge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXhfc3lzdGVtLnVuc2FmZV9hZGRfb2JqZWN0KHZhbHVlKTtcbiAgICAgICAgICAgICAgICB2YXIgcG9zID0gdGhpcy5fYXJyLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB0aGlzLl9hcnIucHVzaCh2YWx1ZSk7XG5cbiAgICAgICAgICAgICAgICAvLyBidXQgZG9lcyB0aGlzIGhhdmUgYSBjb250ZXh0P1xuICAgICAgICAgICAgICAgIC8vICBBIGNvbnRlbnQgY29sbGVjdGlvbiBzaG91bGQgaGF2ZSB0aGUgc2FtZSBjb250ZXh0IGFzIHRoZSBjb250cm9sIGl0J3MgaW4uXG4gICAgICAgICAgICAgICAgdmFsdWUucGFyZW50KHRoaXMsIHBvcyk7XG5cbiAgICAgICAgICAgICAgICB2YXIgZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgJ3RhcmdldCc6IHRoaXMsXG4gICAgICAgICAgICAgICAgICAgICdpdGVtJzogdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICdwb3NpdGlvbic6IHBvcyxcbiAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiAnaW5zZXJ0J1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdhZGRpbmcgY29sbGVjdGlvbiB0byBjb2xsZWN0aW9uIGV2ZW50IGJlaW5nIHJhaXNlZCcpO1xuICAgICAgICAgICAgICAgIC8vIHJhaXNlIGEgY2hhbmdlIGV2ZW50LlxuICAgICAgICAgICAgICAgIC8vICBoYXZlIGEgY2hhbmdlIHR5cGUsIGxpa2UgYWRkIG9yIGluc2VydC5cblxuICAgICAgICAgICAgICAgIC8vdGhpcy5yYWlzZV9ldmVudCgnYWRkJywgZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5yYWlzZV9ldmVudCgnY2hhbmdlJywgZSk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9hcnJfaWR4Kys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBzdGFjayA9IG5ldyBFcnJvcigpLnN0YWNrXG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyggc3RhY2sgKTtcbiAgICAgICAgICAgICAgICB0aHJvdygnQ29sbGVjdGlvbiBjb25zdHJhaW50KHMpIG5vdCBzYXRpc2ZpZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodHYgPT0gJ2RhdGFfb2JqZWN0JyB8fCB0diA9PSAnY29udHJvbCcpIHtcblxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygncHJlIGNvbnN0cmFpbnRzIHRlc3QnKTtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJzIpIHByZSB0ZXN0X29iamVjdF9hZ2FpbnN0X2NvbnN0cmFpbnRzJyk7XG4gICAgICAgICAgICB2YXIgY29uc3RyYWludHNfdGVzdF9yZXMgPSB0aGlzLnRlc3Rfb2JqZWN0X2FnYWluc3RfY29uc3RyYWludHModmFsdWUpO1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygncG9zdCBjb25zdHJhaW50cyB0ZXN0Jyk7XG4gICAgICAgICAgICAvLyB0aGUgdW5pcXVlbmVzcyB0ZXN0IGlzIGFuIGltcG9ydGFudCBvbmUgdG9vLlxuICAgICAgICAgICAgLy8gIHdoZW4gYSB1bmlxdWUgY29uc3RyYWludCBpcyBzZXQgdXAsIHRoZSBpbmRleCBzaG91bGQgYmUgY3JlYXRlZC5cbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2NvbnN0cmFpbnRzX3Rlc3RfcmVzICcgKyBjb25zdHJhaW50c190ZXN0X3Jlcyk7XG4gICAgICAgICAgICAvLyB3b3VsZCBiZSB0ZXN0aW5nIGFnYWluc3QgYSB1bmlxdWUgY29uc3RyYWludC5cbiAgICAgICAgICAgIC8vICBjYW4gdGVzdCB0byBzZWUgaWYgYSBuZXcgb2JqZWN0IHdvdWxkIHZpb2xhdGUgYSBjb2xsZWN0aW9uIGNvbnN0cmFpbnQ/XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdjb25zdHJhaW50c190ZXN0X3JlcyAnICsgY29uc3RyYWludHNfdGVzdF9yZXMpO1xuICAgICAgICAgICAgaWYgKGNvbnN0cmFpbnRzX3Rlc3RfcmVzKSB7XG5cbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdwcmUgdW5zYWZlX2FkZF9vYmplY3QgdmFsdWUnLCBzdHJpbmdpZnkodmFsdWUpKTtcblxuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3ByZSB0aGlzLmluZGV4X3N5c3RlbS51bnNhZmVfYWRkX29iamVjdCcpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleF9zeXN0ZW0udW5zYWZlX2FkZF9vYmplY3QodmFsdWUpO1xuXG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygncG9zdCB0aGlzLmluZGV4X3N5c3RlbS51bnNhZmVfYWRkX29iamVjdCcpO1xuICAgICAgICAgICAgICAgIC8vIGdldHMgYWRkZWQgdG8gdGhlIGluZGV4Li4uIGJ1dCBpcyBpdHMgcG9zaXRpb24gd2l0aGluIHRoaXMgY29sbGVjdGlvbiBzdG9yZWQgdG9vP1xuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3Bvc3QgdW5zYWZlX2FkZF9vYmplY3QnKTtcbiAgICAgICAgICAgICAgICAvLyBUaGluZ3MgZG8gZ2V0IGEgYml0IGNvbXBsaWNhdGVkIHdpdGggbmVlZGluZyB0aGUgcG9zaXRpb25zIHdpdGhpbiB0aGUgY29sbGVjdGlvbiB0byBkbyB2YXJpb3VzIHRoaW5ncy5cbiAgICAgICAgICAgICAgICAvLyBEb24ndCB3YW50IHRvIHJlbHkgb24gaXQgYWx3YXlzIGJlaW5nIHN0b3JlZCBpbiB0aGUgaW5kZXhlcyB0aG91Z2guXG5cbiAgICAgICAgICAgICAgICB2YXIgcG9zID0gdGhpcy5fYXJyLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB0aGlzLl9hcnIucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgLy8gdGhlIHBvc2l0aW9uIHdpdGhpbiB0aGUgcGFyZW50IC8gdGhlIHBhcmVudCdzIGFycmF5LlxuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3BvcyAnICsgcG9zKTtcbiAgICAgICAgICAgICAgICB2YXIgZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgJ3RhcmdldCc6IHRoaXMsXG4gICAgICAgICAgICAgICAgICAgICdpdGVtJzogdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICdwb3NpdGlvbic6IHBvcyxcbiAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiAnaW5zZXJ0J1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvL3ZhbHVlLl9yZWxhdGlvbnNoaXBzW3RoaXMuX2lkKCldID0gdGhpcy5fYXJyX2lkeDtcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdhZGRpbmcgZGF0YV9vYmplY3QgdG8gY29sbGVjdGlvbiBldmVudCBiZWluZyByYWlzZWQnKTtcbiAgICAgICAgICAgICAgICAvLyB0aGlzLCBhbmQgdGhlIHBvc2l0aW9uIGl0J3MgZ29pbmcgdG8uXG5cblxuICAgICAgICAgICAgICAgIC8vIFNob3VsZCBzZXQgdGhlIHBhcmVudCBhbmQgdGhlIHBvc2l0aW9uIHdpdGhpbiB0aGUgcGFyZW50LlxuICAgICAgICAgICAgICAgIC8vICBfX2luZGV4IHBlcmhhcHM/XG5cbiAgICAgICAgICAgICAgICB2YWx1ZS5wYXJlbnQodGhpcywgcG9zKTtcblxuICAgICAgICAgICAgICAgIC8vIGl0ZW0gY2FuIGhhdmUgbXVsdGlwbGUgcGFyZW50cy4uLiB0aGF0IHNob3VsZCBiZSBwb3NzaWJsZS5cbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdwcmUgcmFpc2UgYWRkIGV2ZW50Jyk7XG5cbiAgICAgICAgICAgICAgICAvLyBUaGlzIGJpdCBpcyB0YWtpbmcgYSB3aGlsZS5cbiAgICAgICAgICAgICAgICAvLyAgTm90IHN1cmUgd2h5ISEhIEhhcyB0byBkbyB3aXRoIG9iamVjdHMgYmVpbmcgcHV0IGluIGEgbGFyZ2UgY29sbGVjdGlvbiBwcm9iYWJseS5cbiAgICAgICAgICAgICAgICAvLyAgVG9vIG1hbnkgdGhpbmdzLCBpbiB0aGUgd3JvbmcgY29udGV4dCwgZ2V0dGluZyBub3RpZmllZC5cbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdwcmUgY29sbGVjdGlvbiByYWlzZSBjaGFuZ2UgZXZlbnQnKTtcblxuICAgICAgICAgICAgICAgIHRoaXMucmFpc2VfZXZlbnQoJ2NoYW5nZScsIGUpO1xuICAgICAgICAgICAgICAgIC8vIHJhaXNlIGV2ZW50IGJlaW5nIGNhbGxlZCwgYnV0IG5vdCBmaXJlZCBhcyBleHBlY3RlZD8/P1xuXG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygncG9zdCByYWlzZSBjaGFuZ2UgZXZlbnQnKTtcblxuXG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygncG9zdCByYWlzZSBhZGQgZXZlbnQnKTtcbiAgICAgICAgICAgICAgICAvLyBhY2Nlc3NlZCB1c2luZyBhICdwYXJlbnQnIGFycmF5IC8gbWluaS1jb2xsZWN0aW9uP1xuICAgICAgICAgICAgICAgIC8vIG1pbmktY29sbGVjdGlvbiwgaGFuZGxpbmcgY29sbGVjdGlvbnMgd2l0aG91dCB0aGUgYmVsbHMgYW5kIHdoaXN0bGVzP1xuICAgICAgICAgICAgICAgIC8vICBvciBjb2xsZWN0aW9ucyB3aXRoIHNvbWUgdGhpbmdzIGRpc2FibGVkP1xuXG4gICAgICAgICAgICAgICAgLy8gdmFsdWUucGFyZW50KHRoaXMpXG5cbiAgICAgICAgICAgICAgICAvLyBsb2NhdGlvbiB3aXRoaW4gcGFyZW50Li4uXG4gICAgICAgICAgICAgICAgLy8gIHNob3VsZCBwcm9iYWJseSAvIHBvc3NpYmx5IG1ha2UgdGhpcyBjbGVhcmVyIGluIGNvZGU/XG4gICAgICAgICAgICAgICAgLy8gIG5vdCBzbyBzdXJlIHRoYXQgdGhlIHBvc2l0aW9uIHRyYWNraW5nIHdpbGwgd29yayBhbGwgdGhlIHRpbWVzLlxuICAgICAgICAgICAgICAgIC8vICBtYXkgYmUgYmVzdCB0byBzZXBhcmF0ZSB0aGUgcG9zaXRpb24sIG9yIGdpdmUgaXQgc29tZSBraW5kIG9mIHZhcmlhYmxlIG5hbWUuXG4gICAgICAgICAgICAgICAgLy8gd2lsbCBkbyBtb3JlIHdvcmsgYW5kIHRlc3Rpbmcgb24gdGhpcyBsYXRlci5cbiAgICAgICAgICAgICAgICB0aGlzLl9hcnJfaWR4Kys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBzdGFjayA9IG5ldyBFcnJvcigpLnN0YWNrXG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyggc3RhY2sgKTtcbiAgICAgICAgICAgICAgICB0aHJvdygnQ29sbGVjdGlvbiBjb25zdHJhaW50KHMpIG5vdCBzYXRpc2ZpZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZSBpbmRleCBzeXN0ZW0gY2FuIGFkZCB0aGUgb2JqZWN0LlxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR2ID09ICdhcnJheScpIHtcbiAgICAgICAgICAgIC8vIHdyYXAgaXQgb3Igbm90PyBjb3VsZCBwdXQgaXQgaW4gYW5vdGhlciBjb2xsZWN0aW9uLlxuICAgICAgICAgICAgLy8gIHdpbGwgdGhhdCBiZSB1c2VmdWwgZm9yIGEgZnVuY3Rpb24ncyBwYXJhbWV0ZXJzP1xuICAgICAgICAgICAgLy8gIHRoYXQgd291bGQgbWFpbnRhaW4gdGhlIHdob2xlIHN5c3RlbSB3aXRoIHRoZSB3cmFwcGVyIGFuZCByZWxhdGlvbnNoaXBzLlxuICAgICAgICAgICAgLy8gSSB0aGluayB3ZSBkbyB0aGF0Li4uIHR1cm4gaXQgaW50byBhIG5ldyBjb2xsZWN0aW9uIGFuZCBwdXQgaXQgaW4gdGhlcmUuXG4gICAgICAgICAgICAvLyAgV2lsbCBnZXQgZm9yIHNvbWUgbW9yZSBjb21wbGV4IGJlaGF2aW91cnMsIGJ1dCB0aGV5IGNvdWxkIHByb3ZlIHByZXR0eSB1c2VmdWwuXG4gICAgICAgICAgICAvLyBDb3VsZCBtYWtlIGEgY29weWxlZnQgbGljZW5jZSB3cmFwcGVyIC0gYW55IGNvZGUgdGhhdCBydW5zIGl0IG5lZWRzIHRvIGJlIHdyYXBwZWQgYnkgdGhhdCBmdW5jdGlvbi5cbiAgICAgICAgICAgIC8vIGZvciB0aGUgbW9tZW50LCBJIHRoaW5rIHdlIGNyZWF0ZSBhIG5ldyBjb2xsZWN0aW9uIHdyYXBwZXIgdG8gaG9sZCB0aGUgYXJyYXkuXG4gICAgICAgICAgICAvLyBuZWVkIHRvIGJhc2ljYWxseSBhZGQgYW4gYXJyYXkgb2JqZWN0IHRvIHRoZSBjb2xsZWN0aW9uLCBidXQgaGF2ZSBpdCB3cmFwcGVkLlxuXG4gICAgICAgICAgICAvL3ZhciBjb2xsID0gbmV3IENvbGxlY3Rpb24odmFsdWUpO1xuICAgICAgICAgICAgLy9yZXR1cm4gdGhpcy5wdXNoKGNvbGwpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHVzaChuZXcgQ29sbGVjdGlvbih2YWx1ZSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR2ID09ICdzdHJpbmcnIHx8IHR2ID09ICdudW1iZXInKSB7XG5cbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3R2ICcgKyB0dik7XG4gICAgICAgICAgICAvLyBzdGlsbCBuZWVkIHRvIGNoZWNrIGlmIGl0IG1hdGNoZWQgdGhlIGNvbGxlY3Rpb24gY29uc3RyYWludChzKS5cbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJzMpIHByZSB0ZXN0X29iamVjdF9hZ2FpbnN0X2NvbnN0cmFpbnRzJyk7XG5cblxuXG4gICAgICAgICAgICB2YXIgY29uc3RyYWludHNfdGVzdF9yZXMgPSB0aGlzLnRlc3Rfb2JqZWN0X2FnYWluc3RfY29uc3RyYWludHModmFsdWUpO1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnY29uc3RyYWludHNfdGVzdF9yZXMgJyArIGNvbnN0cmFpbnRzX3Rlc3RfcmVzKTtcbiAgICAgICAgICAgIGlmIChjb25zdHJhaW50c190ZXN0X3Jlcykge1xuICAgICAgICAgICAgICAgIHZhciBkdiA9IG5ldyBEYXRhX1ZhbHVlKHsndmFsdWUnOiB2YWx1ZX0pO1xuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2R2ICcgKyBzdHJpbmdpZnkoZHYpKTtcbiAgICAgICAgICAgICAgICB2YXIgcG9zID0gdGhpcy5fYXJyLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAvLyBTaG91bGQgbm90IG5lZWQgYSBjb250ZXh0IG9yIElEIGp1c3QgdG8gYmUgcHV0IGluIHBsYWNlLlxuICAgICAgICAgICAgICAgIHRoaXMuX2Fyci5wdXNoKGR2KTtcbiAgICAgICAgICAgICAgICB2YXIgZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgJ3RhcmdldCc6IHRoaXMsXG4gICAgICAgICAgICAgICAgICAgICdpdGVtJzogZHYsXG4gICAgICAgICAgICAgICAgICAgICdwb3NpdGlvbic6IHBvcyxcbiAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiAnaW5zZXJ0J1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnJhaXNlX2V2ZW50KCdjaGFuZ2UnLCBlKTtcblxuICAgICAgICAgICAgICAgIGlmICh0diA9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBpbmRleGluZyB0aGUgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRleF9zeXN0ZW0udW5zYWZlX2FkZF9vYmplY3QoZHYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS50cmFjZSgpO1xuICAgICAgICAgICAgICAgIHRocm93KCd3cm9uZyBkYXRhIHR5cGUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvL3RoaXMuX2Fycl9pZHgrKztcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG5cblxuICAgLyoqXG4gICAgKiBAZnVuY1xuICAgICogQHBhcmFtIHZhbHVlXG4gICAgKi9cbiAgICAvLydhZGQnOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIC8vICAgIHJldHVybiB0aGlzLnB1c2godmFsdWUpO1xuICAgIC8vfSxcblxuXG4gICAvKipcbiAgICAqIEBmdW5jXG4gICAgKiBAcGFyYW0gYXJyXG4gICAgKi9cbiAgICAnbG9hZF9hcnJheSc6IGZ1bmN0aW9uKGFycikge1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgIC8vY29uc29sZS5sb2coJ2xvYWRfYXJyYXkgYXJyICcgKyBzdHJpbmdpZnkoYXJyKSk7XG4gICAgICAgIC8vIHRoZXJlIGNvdWxkIGJlIGEgZGF0YSB0eXBlIHRoYXQgdGhpcyBpcyBleHBlY3RpbmcuLi4gYSBjb25zdHJhaW50P1xuICAgICAgICAvLyAgY291bGQgaGF2ZSBhIGRhdGEgdHlwZSBjb25zdHJ1Y3Rvci5cbiAgICAgICAgLy8gc28sIGlmIHRoZSBpdGVtIGdpdmVuIGlzIG5vdCBhIERhdGFfT2JqZWN0LCB3ZSBjYW4gdHJ5IG1ha2luZyB0aGUgRGF0YV9PYmplY3QsIGFuZCBwdXR0aW5nIGl0IGluIHBsYWNlLlxuICAgICAgICB2YXIgZHRjID0gdGhpcy5fZGF0YV90eXBlX2NvbnN0cmFpbnQ7XG4gICAgICAgIC8vY29uc29sZS5sb2coJ2R0YyAnICsgZHRjKTtcblxuICAgICAgICAvLyBNYXkgYWxzbyBuZWVkIHRvIGNoYW5nZSBJRCB2YWx1ZXMgb24gdGhlIG9iamVjdHM/XG4gICAgICAgIC8vICBDcmVhdGUgY2xvbmVzIG9mIHRoZSBvYmplY3RzIHdpdGggZGlmZmVyZW50IElEIHZhbHVlcz9cblxuICAgICAgICAvLyBCZSBhYmxlIHRvIGFjY2VwdCBpdGVtcyBiZWluZyBwdXNoZWQgdGhhdCB3aWxsIGhhdmUgSURzIGNoYW5nZWQ/XG5cbiAgICAgICAgLy8gU2hvdWxkIGhhdmUgYSBkYXRhX3R5cGVfY29uc3RydWN0b3Igd2l0aCB0eXBlZCBjb2xsZWN0aW9ucy5cblxuXG5cbiAgICAgICAgaWYgKGR0Yykge1xuICAgICAgICAgICAgLy8gaXMgYSBDb2xsZWN0aW9uX0RhdGFfVHlwZV9Db25zdHJhaW50XG4gICAgICAgICAgICB2YXIgZGF0YV90eXBlX2NvbnN0cnVjdG9yID0gZHRjLmRhdGFfdHlwZV9jb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2RhdGFfdHlwZV9jb25zdHJ1Y3RvciAnICsgZGF0YV90eXBlX2NvbnN0cnVjdG9yKTtcblxuICAgICAgICAgICAgLypcbiAgICAgICAgICAgIGVhY2goYXJyLCBmdW5jdGlvbihpLCB2KSB7XG4gICAgICAgICAgICAgICAgdGhhdC5wdXNoKHYpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgZm9yICh2YXIgYyA9IDAsIGwgPSBhcnIubGVuZ3RoOyBjIDwgbDsgYysrKSB7XG4gICAgICAgICAgICAgICAgdGhhdC5wdXNoKGFycltjXSk7XG4gICAgICAgICAgICB9XG5cblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgIGVhY2goYXJyLCBmdW5jdGlvbihpLCB2KSB7XG5cbiAgICAgICAgICAgICAgICB0aGF0LnB1c2godik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICovXG4gICAgICAgICAgICBmb3IgKHZhciBjID0gMCwgbCA9IGFyci5sZW5ndGg7IGMgPCBsOyBjKyspIHtcbiAgICAgICAgICAgICAgICB0aGF0LnB1c2goYXJyW2NdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJhaXNlX2V2ZW50KCdsb2FkJyk7XG4gICAgfSxcblxuXG4gICAvKipcbiAgICAqIHBvbHltb3JwaGljIHZlcnNpb25cbiAgICAqIEBuYW1lIHZhbHVlc1xuICAgICogQGZ1bmNcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJtMSAtIHBhcmFtIGRlc2NyaXB0aW9uXG4gICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvcmUvY29sbGVjdGlvblxuICAgICogQGlubmVyXG4gICAgKi9cblxuICAgLyoqXG4gICAgKiBAZnVuY1xuICAgICogQHBhcmFtIC4uLlxuICAgICogQHZhcmlhdGlvbiAyXG4gICAgKi9cbiAgICAndmFsdWVzJzogZnAoZnVuY3Rpb24oYSwgc2lnKSB7XG4gICAgICAgIGlmIChhLmwgPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FycjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBzdGFjayA9IG5ldyBFcnJvcigpLnN0YWNrO1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhzdGFjayk7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCcnKTtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3NpZyAnICsgc2lnKTtcbiAgICAgICAgICAgIC8vIHNob3VsZCBiZSBzZXR0aW5nIHRoZSB2YWx1ZXMuXG4gICAgICAgICAgICB0aHJvdyAnbm90IHlldCBpbXBsZW1lbnRlZCc7XG4gICAgICAgIH1cbiAgICB9KSxcblxuXG4gICAvKipcbiAgICAqIEBmdW5jXG4gICAgKi9cbiAgICAndmFsdWUnOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJlcyA9IFtdO1xuICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24oaSwgdikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2LnZhbHVlID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAvL3Jlc1tpXSA9IHYudmFsdWUoKTtcbiAgICAgICAgICAgICAgICByZXMucHVzaCh2LnZhbHVlKCkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXMucHVzaCh2KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICAvLyBpbnNlcnRfYXQgc2VlbXMgdmVyeSBpbXBvcnRhbnQuXG5cblxuXG4gICAgLy8gYWxsIHRoZSBjb2xsZWN0aW9uJ3MgdmFsdWVzXG4gICAgLy8gdmFsdWVzKCkgd2lsbCBnZXQgb3Igc2V0IGFsbCB0aGUgdmFsdWVzLlxuXG4vLyBDb3VsZCB1c2UgYSAobmV3KSBleHRlbnNpb24gb2YgRGF0YV9PYmplY3QuZXh0ZW5kLlxuLy8gIFdlIHdhbnQgaXQgc28gdGhhdCB3ZSBjYW4gc3BlY2lmeSBhICdkYXRhX29iamVjdCcgd2hlbiBkZWZpbmluZyBhIGNsYXNzLCBhbmQgdGhpc1xuLy8gICBzZXRzIHVwIGEgLl9kYXRhX29iamVjdF9jb25zdHJhaW50IHVzaW5nIC5jb25zdHJhaW50KEQpXG4vLyAgICB0aG91Z2ggd2UgYXJlIGdpdmluZyBpdCBhIERhdGFfT2JqZWN0IHN1YmNsYXNzIGNvbnN0cnVjdG9yLlxuXG5cblxuXG5cbn0pO1xuXG52YXIgcCA9IENvbGxlY3Rpb24ucHJvdG90eXBlO1xucC5hZGQgPSBwLnB1c2g7XG5cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBzdGF0aWNcbiAqL1xuQ29sbGVjdGlvbi5leHRlbmQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYSA9IGFyZ3VtZW50cztcbiAgICB2YXIgYXJncyA9IFthWzBdXTtcbiAgICAvLyBjYWxsIERhdGFfT2JqZWN0LmV4dGVuZCB3aXRoIGFub3RoZXIgZnVuY3Rpb24gZm9yIHBvc3QtaW5pdGlhbGl6YXRpb24/XG5cbiAgICBpZiAoYVswXS5kYXRhX29iamVjdCkge1xuICAgICAgICAvL2NvbnNvbGUubG9nKCdleHRlbmRpbmcgYSBDb2xsZWN0aW9uIHdpdGggLmRhdGFfb2JqZWN0Jyk7XG4gICAgICAgIGFyZ3MucHVzaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIHBvc3QtaW5pdCBmdW5jdGlvbiB0byBnZXQgY2FsbGVkIGFmdGVyIHRoZSBpbml0IGZ1bmN0aW9uLlxuXG4gICAgICAgICAgICB0aGlzLmNvbnN0cmFpbnQoYVswXS5kYXRhX29iamVjdCk7XG4gICAgICAgIH0pXG4gICAgICAgIC8vdGhyb3cgJ3N0b3AnO1xuICAgIH1cbiAgICAvLyBleGVjdXRlIGEgcG9zdC1pbml0IGZ1bmN0aW9uIGluIG9yZGVyIHRvIHNldCB0aGUgY29uc3RyYWludCBpbiBzb21lIGNpcmN1bXN0YW5jZXM/XG4gICAgLy92YXIgYXJncyA9IFthWzBdXVxuXG5cbiAgICB2YXIgcmVzID0gRGF0YV9PYmplY3QuZXh0ZW5kLmFwcGx5KHRoaXMsIGFyZ3MpO1xuXG5cbiAgICByZXR1cm4gcmVzO1xuXG59XG5cbm1vZHVsZS5leHBvcnRzID0gQ29sbGVjdGlvbjtcblxuXHQvL3JldHVybiBDb2xsZWN0aW9uO1xuLy99KTtcbiIsIi8qXHJcblxyXG5pZiAodHlwZW9mIGRlZmluZSAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgdmFyIGRlZmluZSA9IHJlcXVpcmUoJ2FtZGVmaW5lJykobW9kdWxlKTtcclxufVxyXG5cclxuXHJcbmRlZmluZShbXCIuL2pzZ3VpLWxhbmctZXNzZW50aWFsc1wiXSwgZnVuY3Rpb24oanNndWkpIHtcclxuXHRcclxuICAgICovXHJcbiAgICB2YXIganNndWkgPSByZXF1aXJlKCcuL2pzZ3VpLWxhbmctZXNzZW50aWFscycpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBDb25zdHJhaW50cyBtb2R1bGUuXHJcbiAgICAqXHJcbiAgICAqICAjIyMjIyAgQ2xhc3NlcyBoaWVyYXJjaHk6XHJcbiAgICAqXHJcbiAgICAqICZuYnNwOyZuYnNwOyZuYnNwOyAgICAgIHtAbGluayBtb2R1bGU6Y29yZS9jb25zdHJhaW50LkNvbnN0cmFpbnR8Q29uc3RyYWludH0gPGJyIC8+XHJcbiAgICAqICZuYnNwOyZuYnNwOyZuYnNwOyAmbmJzcDsmbmJzcDsmbmJzcDsgICAgICAgPG1hcms+ICB7QGxpbmsgbW9kdWxlOmNvcmUvY29uc3RyYWludC5EYXRhX09iamVjdF9Db25zdHJhaW50fERhdGFfT2JqZWN0X0NvbnN0cmFpbnR9IDwvbWFyaz48YnIgLz5cclxuICAgICogJm5ic3A7Jm5ic3A7Jm5ic3A7ICZuYnNwOyZuYnNwOyZuYnNwOyAgICAgICAgIHtAbGluayBtb2R1bGU6Y29yZS9jb25zdHJhaW50LkRhdGFfT2JqZWN0X0RlZl9Db25zdHJhaW50fERhdGFfT2JqZWN0X0RlZl9Db25zdHJhaW50fSA8c3Ryb25nPkRhdGFfT2JqZWN0X0RlZl9Db25zdHJhaW50PC9zdHJvbmc+IDxiciAvPlxyXG4gICAgKiAmbmJzcDsmbmJzcDsmbmJzcDsgJm5ic3A7Jm5ic3A7Jm5ic3A7ICAgICAgICAge0BsaW5rIG1vZHVsZTpjb3JlL2NvbnN0cmFpbnQuRmllbGRfQ29uc3RyYWludHxGaWVsZF9Db25zdHJhaW50fSAgPGJyIC8+XHJcbiAgICAqICZuYnNwOyZuYnNwOyZuYnNwOyAmbmJzcDsmbmJzcDsmbmJzcDsgJm5ic3A7Jm5ic3A7Jm5ic3A7ICAgICAgICAgICAge0BsaW5rIG1vZHVsZTpjb3JlL2NvbnN0cmFpbnQuTm90X051bGxfQ29uc3RyYWludHxOb3RfTnVsbF9Db25zdHJhaW50fSA8c3Ryb25nPk5vdF9OdWxsPC9zdHJvbmc+IDxiciAvPlxyXG4gICAgKiAmbmJzcDsmbmJzcDsmbmJzcDsgJm5ic3A7Jm5ic3A7Jm5ic3A7ICZuYnNwOyZuYnNwOyZuYnNwOyAgICAgICAgICAgIHtAbGluayBtb2R1bGU6Y29yZS9jb25zdHJhaW50LkZpZWxkX0RhdGFfVHlwZV9Db25zdHJhaW50fEZpZWxkX0RhdGFfVHlwZV9Db25zdHJhaW50fSA8c3Ryb25nPkZpZWxkX0RhdGFfVHlwZTwvc3Ryb25nPiA8YnIgLz5cclxuICAgICogJm5ic3A7Jm5ic3A7Jm5ic3A7ICZuYnNwOyZuYnNwOyZuYnNwOyAmbmJzcDsmbmJzcDsmbmJzcDsgJm5ic3A7Jm5ic3A7Jm5ic3A7ICAgICAgICAgICAgICAge0BsaW5rIG1vZHVsZTpjb3JlL2NvbnN0cmFpbnQuVGV4dF9Db25zdHJhaW50fFRleHRfQ29uc3RyYWludH0gPGJyIC8+XHJcbiAgICAqICZuYnNwOyZuYnNwOyZuYnNwOyAmbmJzcDsmbmJzcDsmbmJzcDsgJm5ic3A7Jm5ic3A7Jm5ic3A7ICZuYnNwOyZuYnNwOyZuYnNwOyAgICAgICAgICAgICAgIHtAbGluayBtb2R1bGU6Y29yZS9jb25zdHJhaW50Lkd1aWRfQ29uc3RyYWludHxHdWlkX0NvbnN0cmFpbnR9IDxzdHJvbmc+R3VpZDwvc3Ryb25nPiA8YnIgLz5cclxuICAgICogJm5ic3A7Jm5ic3A7Jm5ic3A7ICZuYnNwOyZuYnNwOyZuYnNwOyAmbmJzcDsmbmJzcDsmbmJzcDsgJm5ic3A7Jm5ic3A7Jm5ic3A7ICAgICAgICAgICAgICAge0BsaW5rIG1vZHVsZTpjb3JlL2NvbnN0cmFpbnQuTnVtYmVyX0NvbnN0cmFpbnR8TnVtYmVyX0NvbnN0cmFpbnR9IDxiciAvPlxyXG4gICAgKiAmbmJzcDsmbmJzcDsmbmJzcDsgJm5ic3A7Jm5ic3A7Jm5ic3A7ICZuYnNwOyZuYnNwOyZuYnNwOyAmbmJzcDsmbmJzcDsmbmJzcDsgJm5ic3A7Jm5ic3A7Jm5ic3A7ICAgICAgICAgICAgICAgICAge0BsaW5rIG1vZHVsZTpjb3JlL2NvbnN0cmFpbnQuSW50X0NvbnN0cmFpbnR8SW50X0NvbnN0cmFpbnR9IDxiciAvPlxyXG4gICAgKiAmbmJzcDsmbmJzcDsmbmJzcDsgJm5ic3A7Jm5ic3A7Jm5ic3A7ICAgICAgICAge0BsaW5rIG1vZHVsZTpjb3JlL2NvbnN0cmFpbnQuQ29sbGVjdGlvbl9Db25zdHJhaW50fENvbGxlY3Rpb25fQ29uc3RyYWludH0gPGJyIC8+XHJcbiAgICAqICZuYnNwOyZuYnNwOyZuYnNwOyAmbmJzcDsmbmJzcDsmbmJzcDsgJm5ic3A7Jm5ic3A7Jm5ic3A7ICAgICAgICAgICAge0BsaW5rIG1vZHVsZTpjb3JlL2NvbnN0cmFpbnQuQ29sbGVjdGlvbl9EYXRhX0RlZl9Db25zdHJhaW50fENvbGxlY3Rpb25fRGF0YV9EZWZfQ29uc3RyYWludH0gPHN0cm9uZz5Db2xsZWN0aW9uX0RhdGFfRGVmPC9zdHJvbmc+IDxiciAvPlxyXG4gICAgKiAmbmJzcDsmbmJzcDsmbmJzcDsgJm5ic3A7Jm5ic3A7Jm5ic3A7ICZuYnNwOyZuYnNwOyZuYnNwOyAgICAgICAgICAgIHtAbGluayBtb2R1bGU6Y29yZS9jb25zdHJhaW50LkNvbGxlY3Rpb25fRGF0YV9UeXBlX0NvbnN0cmFpbnR8Q29sbGVjdGlvbl9EYXRhX1R5cGVfQ29uc3RyYWludH0gPHN0cm9uZz5Db2xsZWN0aW9uX0RhdGFfVHlwZTwvc3Ryb25nPiA8YnIgLz5cclxuICAgICogJm5ic3A7Jm5ic3A7Jm5ic3A7ICZuYnNwOyZuYnNwOyZuYnNwOyAmbmJzcDsmbmJzcDsmbmJzcDsgICAgICAgICAgICB7QGxpbmsgbW9kdWxlOmNvcmUvY29uc3RyYWludC5VbmlxdWVfQ29uc3RyYWludHxVbmlxdWVfQ29uc3RyYWludH0gPHN0cm9uZz5VbmlxdWU8L3N0cm9uZz4gPGJyIC8+XHJcbiAgICAqXHJcbiAgICAqIEBtb2R1bGUgY29yZS9jb25zdHJhaW50XHJcbiAgICAqIEBleHBvcnRzIENvbnN0cmFpbnRcclxuICAgICovXHJcblxyXG5cclxuXHJcblx0Ly8gVGhpcyB3aWxsIGRlZmluZSBzb21lIGNvbnN0cmFpbnQgaXRlbXMuXHJcblx0Ly8gIE5vdCBzbyBzdXJlIGFib3V0IGFkZGluZyBtb3JlIHRoaW5ncyB0byB0aGUganNndWkgbmFtZXNwYWNlLCBwZXJoYXBzIGJlc3QganVzdCB0byBwcm92aWRlIHRoZSBDb25zdHJhaW50IG9iamVjdFxyXG5cdFxyXG5cdFxyXG5cdC8vIENvbnN0cmFpbnQgd29uJ3QgYmUgb3IgdXNlIGEgRGF0YV9PYmplY3QuLi5cclxuXHQvLyAgVGhlcmUgbWF5IGJlIHNvbWUgY29kZSB0aGF0IHdpbGwgbWFrZSB1c2Ugb2YgRGF0YV9PYmplY3QgaW50ZXJmYWNlcywgbm90IHN1cmUuXHJcblx0Ly8gIE1haW5seSwgdGhpcyB3aWxsIGJlIGZvciB2YWxpZGF0aW5nIEphdmFTY3JpcHQgdmFsdWVzIGFnYWluc3QgZWFjaCBvdGhlciBmb3IgdXNlIGluIHRoZSBEYXRhX09iamVjdCwgQ29sbGVjdGlvbiwgYW5kIG90aGVyIHRoaW5ncy5cclxuXHRcclxuXHQvLyBIYXZpbmcgdGhpcyBzbyBpdCBkb2VzIG5vdCB1c2UgYSBsb3Qgb2Ygb3RoZXIgcmVmZXJlbmNlcyB3aWxsIGJlIGhlbHBmdWwgaW4ga2VlcGluZyB0aGluZ3MgbW9kdWxhcixcclxuXHQvLyAgYW5kIHF1aWNrbHkgYmVpbmcgYWJsZSB0byB1c2Ugc29tZSB2YWxpZGF0aW9uIGNvZGUgd2l0aG91dCB0b28gbXVjaCBzdXBwb3J0aW5nIGl0LlxyXG5cdFxyXG5cclxuXHJcblx0dmFyIGogPSBqc2d1aTtcclxuXHR2YXIgQ2xhc3MgPSBqLkNsYXNzO1xyXG5cdHZhciBlYWNoID0gai5lYWNoO1xyXG5cdHZhciBpc19hcnJheSA9IGouaXNfYXJyYXk7XHJcblx0dmFyIGlzX2RvbV9ub2RlID0gai5pc19kb21fbm9kZTtcclxuXHR2YXIgaXNfY3RybCA9IGouaXNfY3RybDtcclxuXHR2YXIgZXh0ZW5kID0gai5leHRlbmQ7XHJcblx0dmFyIGNsb25lID0gai5jbG9uZTtcclxuXHR2YXIgeF9jbG9uZXMgPSBqLnhfY2xvbmVzO1xyXG5cdHZhciBnZXRfdHJ1dGhfbWFwX2Zyb21fYXJyID0gai5nZXRfdHJ1dGhfbWFwX2Zyb21fYXJyO1xyXG5cdHZhciBnZXRfbWFwX2Zyb21fYXJyID0gai5nZXRfbWFwX2Zyb21fYXJyO1xyXG5cdHZhciBhcnJfbGlrZV90b19hcnIgPSBqLmFycl9saWtlX3RvX2FycjtcclxuXHR2YXIgdG9mID0gai50b2Y7XHJcblx0dmFyIGlzX2RlZmluZWQgPSBqLmlzX2RlZmluZWQ7XHJcblx0dmFyIHN0cmluZ2lmeSA9IGouc3RyaW5naWZ5O1xyXG5cdHZhciBmdW5jdGlvbmFsX3BvbHltb3JwaGlzbSA9IGouZnVuY3Rpb25hbF9wb2x5bW9ycGhpc207XHJcblx0dmFyIGZwID0gai5mcDtcclxuXHR2YXIgYXJyYXlpZnkgPSBqLmFycmF5aWZ5O1xyXG5cdHZhciBtYXBpZnkgPSBqLm1hcGlmeTtcclxuXHR2YXIgYXJlX2VxdWFsID0gai5hcmVfZXF1YWw7XHJcblx0dmFyIGdldF9pdGVtX3NpZyA9IGouZ2V0X2l0ZW1fc2lnO1xyXG5cdHZhciBzZXRfdmFscyA9IGouc2V0X3ZhbHM7XHJcblx0dmFyIHRydXRoID0gai50cnV0aDtcclxuXHR2YXIgdHJpbV9zaWdfYnJhY2tldHMgPSBqLnRyaW1fc2lnX2JyYWNrZXRzO1xyXG5cdHZhciBsbF9zZXQgPSBqLmxsX3NldDtcclxuXHR2YXIgbGxfZ2V0ID0gai5sbF9nZXQ7XHJcblx0dmFyIGlzX2NvbnN0cnVjdG9yX2ZuID0gai5pc19jb25zdHJ1Y3Rvcl9mbjtcclxuXHRcclxuXHQvLyBEYXRhIFR5cGVzIGFyZSBhbHNvIHNpbWlsYXIgdG8gY29uc3RyYWludHMuXHJcblx0Ly8gIFRoZXkgYXJlIGJlaW5nIHVzZWQgaW4gdGhlIG5lc3RlZCBzeXN0ZW0gd2l0aCBIVE1MLlxyXG5cdC8vICBGb3IgdGhlIG1vbWVudCwgSSB3YW50IHRvIGNvbnN0aW51ZSB0byBkZXZlbG9wIHRoZSBDb25zdHJhaW50cyBzeXN0ZW0uXHJcblx0Ly8gICBUaGV5IHdpbGwgYmUgdXNpbmcgc29tZXRoaW5nIHNpbWlsYXIgdG8gRGF0YV9UeXBlIHNwZWNpZmljYXRpb25zIGZvciBwdXR0aW5nIHRvZ2V0aGVyIHRoZSBtb3JlIGNvbXBsaWFjdGVkIGNvbnN0cmFpbnRzLlxyXG5cdFxyXG5cdC8vIEZvciB0aGUgbW9tZW50LCB0aGVzZSBjb25zdHJhaW50cyB3aWxsIGJlIHVzZWQgaW4gcHJlcGFyYXRpb24gb2YgbWFwcGluZyB0byBhIGRhdGFiYXNlIChub3QgbmVzdGVkLCBzbyBmYXIpXHJcblx0Ly8gIEF0IGEgbGF0ZXIgc3RhZ2UgdGhleSB3aWxsIHRoZW4gYmUgYWRhcHRlZCBmdXJ0aGVyIGZvciB0aGUgbmVzdGVkIHJlcXVpcmVtZW50cyBvZiBIVE1MIGNvcnJlY3Rpb24gYW5kIGludGVycHJldGF0aW9uLlxyXG5cdFxyXG5cdC8vIFBlcmhhcHMgdGhlIGNvbnN0cmFpbnRzLCBsaWtlIGZvciBSR0IsIHdvdWxkIGJlIHVzZWZ1bCB3aGVuIHB1dHRpbmcgdGhpbmdzIGluIGEgREIuXHJcblx0Ly8gIE5vdCBzdXJlIGhvdyBtdWNoIG9mIHRoZSB0cmFuc2xhdGlvbiB3b3VsZCBiZSBkb25lIGluIHRoZSBEQiBsYXllciwgYnV0IGl0IGNvdWxkIGJlIGRvbmUgaW4gSmF2YVNjcmlwdCwgd2l0aCB0aGUgZGF0YWJhc2UgYWNjZXB0aW5nXHJcblx0Ly8gICBsZXNzIGZsZXhpYmxlIGRhdGEuXHJcblx0XHJcblx0Ly8gSG93ZXZlciwgbW9yZSBmbGV4aWJpbGl0eSBhbmQgcG9seW1vcnBoaXNtIGluIHRoZSBkYXRhYmFzZSBjb3VsZCBiZSBkZXZlbG9wZWQuXHJcblx0Ly8gIFdlIGFscmVhZHkgaGF2ZSBhIGJpdCwgYnV0IGl0J3Mgbm90IHBhcnNpbmcgUkdCIHZhbHVlcy4gTm90IHRoYXQga2VlbiBvbiBnZXR0aW5nIGludG8gdGhlIFNRTCBjb2RpbmcsIGJ1dCB0aGVyZSBjb3VsZFxyXG5cdC8vICAgYmUgdmFyaW91cyBmdW5jdGlvbnMgdGhhdCBhcmUgbWFkZSwgbGlicmFyeSBmdW5jdGlvbnMsIHRoYXQgZ2V0IHB1dCBpbi5cclxuXHRcclxuXHRcclxuXHQvLyBJIGFsc28gdGhpbmsgdGhlIHdob2xlIHN5c3RlbSBjb3VsZCBydW4gYXMgYSBKYXZhU2NyaXB0IGZpbGUsIGJ1dCBhbHNvIGhhdmUgYSBodWdlIGRlY2xhcmF0aXZlIEpTT04gc2VjdGlvbiB3aGVuIGEgbGFyZ2UgYXBwbGljYXRpb24gaXMgcnVubmluZyBvbiB0aGVcclxuXHQvLyAgc2VydmVyLlxyXG5cdC8vICBOb3Qgc3VyZS5cclxuXHRcclxuXHQvLyBGb3IgdGhlIG1vbWVudCwgdGhpcyB3aWxsIGJlIHVuaWZ5aW5nIHdoYXQgaGFzIGJlZW4gZG9uZSBvbiBEYXRhX09iamVjdHMgYW5kIG5lc3RlZCBvYmplY3RzLCBhbmQgc2VydmluZyBhcyBhIGdlbmVyYWwgYmFzaXNcclxuXHQvLyAgZm9yIFJEQiBhbmQgb3RoZXIgREIgYWJzdHJhY3Rpb25zLCBhbmQgc2NoZW1hcy5cclxuXHQvLyBDb3VsZCBiZSB2ZXJ5IHVzZWZ1bCBmb3IgdmFsaWRhdGluZyBYTUwgc2NoZW1hcywgZm9yIGV4YW1wbGUuXHJcblx0XHJcblx0Ly8gU29tZSBjb25zdHJhaW50cyB0aGF0IGFwcGx5IHRvIGNvbGxlY3Rpb25zIG1heSBub3QgYXBwbHkgdG8gZGF0YWJhc2UgdGFibGVzLlxyXG5cdC8vICBBbiBleGFtcGxlIGlzIGlmIGEgY29sbGVjdGlvbiBuZWVkcyB0byBoYXZlIDEgb3IgbW9yZSBlbGVtZW50LiBJbiBhIERCIHRoZXJlIGNhbiBiZSBhbiBlbXB0eSB0YWJsZSwgYnV0IHNvbWUgY29sbGVjdGlvbnMgbWF5IHNwZWNpZnkgaXQgbmVlZHNcclxuXHQvLyAgIG9uZSBvciBtb3JlIG9iamVjdCB0byBiZSB2YWxpZCAoYnV0IG5vdCB0byBleGlzdCwgbmVjZXNzYXJpbHk/KVxyXG5cdFxyXG5cdC8vIEdldHRpbmcgdGhlc2Ugd29ya2luZywgdGhlbiBtYXBwaW5nIG92ZXIgdG8gZGF0YWJhc2VzIGlzIHF1aXRlIGEgYml0IG9mIGNvZGUuXHJcblx0Ly8gIFdpbGwgYmUgYSB1c2VmdWwgYmFzaXMgZm9yIHRyYW5zbGF0aW5nIHRvIGFic3RyYWN0IFJCQlxyXG5cdFxyXG5cdC8vIEkgdGhpbmsgYW4gYWJzdHJhY3QgUkRCIHNldCBvZiBjbGFzc2VzIHdvdWxkIGJlIHF1aXRlIHVzZWZ1bC5cclxuXHRcclxuXHQvLyBQb3N0Z3JlcyBSREIgY2xhc3NlcyBjb3VsZCBpbmhlcml0IGZyb20gbWFueSBvZiB0aGVtLCBmb3IgZXhhbXBsZS5cclxuXHRcclxuXHQvLyBUaGVyZSB3b3VsZCBhbHNvIGJlIGEgZnVuY3Rpb24gdG8gdHJhbnNsYXRlIGZyb20gZ2VuZXJpYyBSREIgY2xhc3NlcyB0byBQb3N0Z3JlcyBvbmVzLlxyXG5cdC8vICBBbmQgdG8gdHJhbnNsYXRlIGJhY2sgdG9vLlxyXG5cdFxyXG5cdC8vIFRoZW4gdGhlIFBvc3RncmVzIGNsYXNzZXMgYXJlIHVzZWQgdG8gZ2VuZXJhdGUgY29kZSwgYW5kIGZ1bmN0aW9ucyB0aGF0IG1hbmlwdWxhdGUgdGhvc2UgdGFibGVzIC8gb2JqZWN0cyBpbiB0aGUgREIsIHdoaWNoIGdlbmVyYXRlIGNvZGVcclxuXHRcclxuXHQvLyBBZHZhbmNlZCBPUk0gaXMgb25lIG9mIHRoZSB0aGluZ3MgdGhhdCB0aGlzIHN5c3RlbSByZWFsbHkgbmVlZHMuIEl0J3MgZ29pbmcgdG8gYmUgb2J0YWluaW5nIGRhdGEgYW5kIGRhdGEgbW9kZWxzIGZyb20gb3RoZXIgc3lzdGVtcy5cclxuXHQvLyAgUG9zc2libHkgd291bGQgYmUgcnVuIHRvIHF1aWNrbHkgaW50ZXJvcGVyYXRlIC8gaW1wb3J0IGFuZCBleHBvcnQgZGF0YSB0byAvIGZyb20gZXhpc3Rpbmcgc3lzdGVtcy5cclxuXHQvLyBDb3VsZCBwb3NzaWJseSBoYXZlIGV4dHJhICh2ZXJ5IHVzZXIgZnJpZW5kbHkpIG1vZHVsZXMgb3BlcmF0aW5nIG92ZXIgYSBsZWdhY3kgZGF0YWJhc2UgYXBwbGljYXRpb24uXHJcblx0Ly8gIENvdWxkIGRvIHZlcnkgc3BlY2lmaWMgdGhpbmdzLCBhcyByZXF1aXJlZCBmb3IgbmV3IGZ1bmN0aW9uYWxpdHkuIFdvdWxkIHRoZW4gYmUgaW4gYSBwb3NpdGlvbiBmb3IgdGhlIGpzZ3VpL21ldGFiZW5jaCBzeXN0ZW1cclxuXHQvLyAgdG8gYmUgZnVsbHkgYWN0aXZhdGVkIGFuZCByZXBsYWNlIGEgbGVnYWN5IHN5c3RlbSwgZWl0aGVyIGtlZXBpbmcgdGhlIGV4aXN0aW5nIGRhdGFiYXNlLCBvciBoYXZpbmcgZXhwb3J0ZWQgYW5kIG1pcnJvcmVkIGV2ZXJ5dGhpbmcsXHJcblx0Ly8gICBjb3VsZCBzd2l0Y2ggdG8gTW9uZ28gb3Igb3RoZXIgREIgZGVzaWduZWQgYnkgLyB1c2luZyB0aGUgYXBwbGljYXRpb24sIG9yIGNvbnRpbnVlIG1pcnJvcmluZyBjaGFuZ2VzLlxyXG5cdFxyXG5cdC8vIFRoZSB3aG9sZSBtaWRkbGV3YXJlIHNpZGUgb2YgdGhpbmdzIHdpbGwgbWFrZSBpbnRlZ3JhdGlvbiB0YXNrcyB2ZXJ5IHF1aWNrLlxyXG5cdC8vICBUaGUgUmVzb3VyY2Ugc3lzdGVtIGFuZCBpbnRlcmZhY2Ugd2lsbCBiZSB1c2VkIGZvciBtdWNoIG9mIHRoaXMuXHJcblx0XHJcblx0XHJcblx0XHJcblx0XHJcblx0Ly8gQ29uc3RyYWludHMgY291bGQgYXBwbHkgdG8gdmFyaW91cyBkaWZmZXJlbnQgdGhpbmdzLlxyXG5cdC8vICBHZW5lcmFsbHkgdGhleSB3aWxsIGFwcGx5IHRvIGEgdmFsdWUuXHJcblx0Ly8gIFRoZXkgd2lsbCBiZSB0ZXN0YWJsZSBhZ2FpbnN0IHZhbHVlcyB0byBzZWUgd2hlcmUgdGhvc2UgdmFsdWVzIGRvIG9yIGRvIG5vdCBjb21wbHkgd2l0aCB0aGUgY29uc3RyYWludHMuXHJcblx0Ly8gIE5vdCBzdXJlIGlmIGl0IHdvdWxkIGJlIHdvcnRoIHVzaW5nIHRoaXMgc3lzdGVtIHRvIHRlc3QgYWdhaW5zdCBYTUwgc2NoZW1hcy4gSXQgY291bGQgbWFrZSBzZW5zZS4gUGVyaGFwcyB0aGUgc3lzdGVtIGZvciB0ZXN0aW5nIHRoZSBYTUxcclxuXHQvLyAgIHNjaGVtYXMgd291bGQgYmUgdXNpbmcgdGhpcywgcGVyaGFwcyBpdCB3b3VsZCBldmVuIGRpcmVjdGx5IGJlIHRoaXMgYnV0IHdpdGggdGhlIGNvcnJlY3Qgb3B0aW9ucyBzZXQuXHJcblx0XHJcblx0Ly8gVGhpcyBjb3VsZCBnZXQgcXVpdGUgbGFyZ2UsIHNvIHRoaXMgd2lsbCByZWFsbHkgYmUgYSBjb3JlIGNvbnN0cmFpbnQgdGVzdGVyLlxyXG5cdC8vICBJdCB3aWxsIGJlIHBhcnQgb2YgdGhlIGNvcmUsIGJ1dCBub3QgdGhlIGVzc2VudGlhbHMuIFRoZXkgd2lsbCBiZSB1c2VmdWwgZm9yIG90aGVyIHByb2dyYW1zIGluIHZhcmlvdXMgcGxhY2VzLCBhbmQgd2lsbCBiZSByZWFsbHkgc21hbGwgd2hlblxyXG5cdC8vICBjb21wcmVzc2VkLiBJbiB0aGlzIGNhc2UsIEknbGwgaGF2ZSBhIGxhcmdlciBjb3JlLiBUaGVyZSB3aWxsIGJlIGJ1aWxkcyAvIGRpc3RyaWJ1dGlvbnMgYXZhaWxhYmxlIGZvciBjbGllbnRzLlxyXG5cdC8vIFNvbWUgd2lsbCBoYXZlIGNsaWVudC1zaWRlIHNoaW1zIGJ1aWx0IGluLCBsaWtlIGFuIElFNi03IGJ1aWxkIHBlcmhhcHMuXHJcblx0XHJcbiAgICAvKipcclxuICAgICogQ3JlYXRlcyB0aGUgQ29uc3RyYWludC5cclxuICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAqIEBjbGFzc2Rlc2MgQmFzZSBjbGFzcyBmb3IgdGhlIGNvbnN0cmFpbnRzLlxyXG4gICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvcmUvY29uc3RyYWludFxyXG4gICAgKi9cclxuICAgIFxyXG5cdHZhciBDb25zdHJhaW50ID0gQ2xhc3MuZXh0ZW5kKHtcclxuXHRcdCdpbml0JzogZnVuY3Rpb24oc3BlYykge1xyXG5cdFx0XHQvLyBpZiB0aGUgc3BlYyBpcyBhIHN0cmluZywgdGhlbiBwYXJzZSB0aGUgc3RyaW5nLlxyXG5cdFx0XHRcclxuXHRcdFx0Ly8gaXQgbWF5IG1ha2UgcmVmZXJlbmNlIHRvIHZhcmlvdXMgZGF0YSB0eXBlcy5cclxuXHRcdFx0Ly8gIHRleHQsIHJlc3RyaWN0ZWQgb3IgdW5yZXN0cmljdGVkIGxlbmd0aFxyXG5cdFx0XHQvLyAgaW50cywgbnVtYmVycywgZXRjXHJcblx0XHRcdC8vICB2YXJpb3VzIHRlc3RzIHdpbGwgYmUgY2FycmllZCBvdXQsIGJleW9uZCB0b2YuXHJcblx0XHRcdFxyXG5cdFx0XHRpZiAodG9mKHNwZWMpID09ICdzdHJpbmcnKSB7XHJcblx0XHRcdFx0XHJcblx0XHRcdH1cclxuXHRcdFx0XHJcblx0XHRcdC8vIEEgY29uc3RyYWludCBjYW4gYmUgLyBjb250YWluIG11bHRpcGxlIG90aGVyIGNvbnN0cmFpbnRzLlxyXG5cdFx0XHQvLyAgTWF5YmUgaXQgc2hvdWxkIGhhdmUgdGhhdCBsb2dpYyBpbnNpZGUgaXQsIGFuZCB0aGVzZSBvdGhlciBjb25zdHJhaW50cyBjYW4gYmUgcGFydGljdWxhciBvbmVzLlxyXG5cdFx0XHRcclxuXHRcdFx0Ly8gQ29kZSBleGVjdXRpb24gcGF0aC4uLiBtYXkgYmUgaW1wb3J0YW50IGdldHRpbmcgdGhhdCB3b3JraW5nIGJlZm9yZSBsb25nLCBidXQgbm93IGl0IGRvZXMgc2VlbSB0aGF0IHNwZWNpZnlpbmcgYW5kXHJcblx0XHRcdC8vICB2YWxpZGF0aW5nIHRoZXNlIHZhcmlvdXMgdHlwZXMgaW4gSmF2YVNjcmlwdCBzZWVtcyBsaWtlIGFuIGltcG9ydGFudCB0aGluZyB0byBkby5cclxuXHRcdFx0XHJcblx0XHRcdC8vIFxyXG5cdFx0XHRcclxuXHRcdFx0XHJcblx0XHR9XHJcblx0Ly8gJ21hdGNoZXMnXHJcblx0XHRcclxuXHRcclxuXHR9KVxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBgb2JqYCB2YWx1ZSBtYXRjaGVzIHRoZSBgY29uc3RyYWludGAgZGVmaW5pdGlvbi5cclxuICAgICogQGZ1bmNcclxuICAgICogQHBhcmFtIHtvYmplY3R9IG9iaiAtIG9iamVjdCB0byBjaGVja1xyXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gY29uc3RyYWludCAtIGNvbnN0cmFpbnQgZGVmaW5pdGlvblxyXG4gICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvcmUvY29uc3RyYWludFxyXG4gICAgKiBAZXhhbXBsZVxyXG4gICAgKiBvYmpfbWF0Y2hlc19jb25zdHJhaW50KDEsIFwiaW50XCIpID09PiB0cnVlXHJcbiAgICAqIG9ial9tYXRjaGVzX2NvbnN0cmFpbnQoXCIxXCIsIFwiaW50XCIpID09PiBmYWxzZVxyXG4gICAgKiBvYmpfbWF0Y2hlc19jb25zdHJhaW50KFwiMVwiLCBcInRleHQoMylcIikgPT0+IHRydWVcclxuICAgICovXHJcblx0dmFyIG9ial9tYXRjaGVzX2NvbnN0cmFpbnQgPSBmdW5jdGlvbiAob2JqLCBjb25zdHJhaW50KSB7XHJcblx0XHQvL2NvbnNvbGUubG9nKCdvYmpfbWF0Y2hlc19jb25zdHJhaW50ICcpO1xyXG5cdFx0Ly90aHJvdygnc3RvcCcpO1xyXG5cdFx0XHJcblx0XHRpZiAodG9mKGNvbnN0cmFpbnQpID09ICdzdHJpbmcnKSB7XHJcblx0XHRcdGNvbnN0cmFpbnQgPSBjb25zdHJhaW50X2Zyb21fc3RyKGNvbnN0cmFpbnQpO1xyXG5cdFx0XHRcclxuXHRcdFx0cmV0dXJuIGNvbnN0cmFpbnQubWF0Y2gob2JqKTtcclxuXHRcdH1cclxuXHRcdFxyXG5cdH1cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIENyZWF0ZXMgdGhlIGRhdGEgb2JqZWN0IGNvbnN0cmFpbnQuXHJcbiAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgKiBAY2xhc3NkZXNjIDxtYXJrPnRoZSBjbGFzcyBkb2VzIG5vdGhpbmcsIGFuZCBub3QgcHVibGljLjwvbWFyaz4uXHJcbiAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29yZS9jb25zdHJhaW50XHJcbiAgICAqL1xyXG4gICAgLy8gRGF0YV9PYmplY3RfQ29uc3RyYWludFxyXG5cclxuICAgIC8vIE9yIGluY2x1ZGUgdGhpcyBpbiBEYXRhX09iamVjdD9cclxuICAgIC8vIE1heSBiZSBiZXN0IHRvIG1ha2UgaXRzIG93biBtb2R1bGUgYXMgd2Ugc2hvdWxkIG5vdCByZXF1aXJlIERhdGFfT2JqZWN0IGhlcmU/XHJcblxyXG5cclxuXHJcbiAgICAvL3ZhciBEYXRhX09iamVjdCA9IHJlcXVpcmUoJy4vZGF0YS1vYmplY3QnKTtcclxuXHJcblx0dmFyIERhdGFfT2JqZWN0X0NvbnN0cmFpbnQgPSBDb25zdHJhaW50LmV4dGVuZCh7XHJcblx0ICAgICdpbml0JzogZnVuY3Rpb24gKHNwZWMpIHtcclxuXHQgICAgICAgIHRoaXMuX19kYXRhX3R5cGUgPSAnZGF0YV9vYmplY3RfY29uc3RyYWludCc7XHJcblx0ICAgIH0sXHJcbiAgICAgICAgJ21hdGNoJzogZnVuY3Rpb24ob2JqKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBEb24ndCBoYXZlIERhdGFfT2JqZWN0IGhlcmU/PywgYXMgRGF0YV9PYmplY3QgaXMgdXNlZCBieSB0aGlzXHJcbiAgICAgICAgICAgIC8vdmFyIHJlcyA9IG9iaiBpbnN0YW5jZW9mIERhdGFfT2JqZWN0LmNvbnN0cnVjdG9yO1xyXG5cclxuICAgICAgICAgICAgdmFyIHJlcyA9IHRvZihvYmopID09ICdkYXRhX29iamVjdCc7XHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3JlcycsIHJlcyk7XHJcbiAgICAgICAgICAgIHJldHVybiAocmVzKTtcclxuICAgICAgICB9XHJcblx0fSk7XHJcblxyXG5cclxuXHJcblxyXG5cdHZhciBEYXRhX09iamVjdF9EZWZfQ29uc3RyYWludCA9IENvbnN0cmFpbnQuZXh0ZW5kKHtcclxuXHJcblx0ICAgIC8qKiBcclxuICAgICAgICAqIEBjbGFzc2Rlc2MgRGF0YSBvYmplY3QgZGVmaW5pdGlvbiBjb25zdHJhaW50LlxyXG4gICAgICAgICogQGNvbnN0cnVjdHMgbW9kdWxlOmNvcmUvY29uc3RyYWludC5EYXRhX09iamVjdF9EZWZfQ29uc3RyYWludCBcclxuICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzcGVjIC0gZGF0YSBkZWZpbml0aW9uXHJcbiAgICAgICAgKiBcclxuICAgICAgICAqL1xyXG5cdFx0J2luaXQnOiBmdW5jdGlvbihzcGVjKSB7XHJcblx0XHQgICAgdGhpcy5fX2RhdGFfdHlwZSA9ICdkYXRhX29iamVjdF9kZWZfY29uc3RyYWludCc7XHJcblx0XHQgICAgLy9cclxuXHRcdCAgICBpZiAodG9mKHNwZWMpID09PSAnb2JqZWN0Jykge1xyXG5cdFx0ICAgICAgICB0aGlzLmRhdGFfZGVmID0gc3BlYztcclxuXHRcdCAgICB9XHJcblx0XHR9LFxyXG5cclxuXHQgICAgLyoqXHJcbiAgICAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYHZhbHVlYCBtYXRjaGVzIHRoZSBjb25zdHJhaW50LlxyXG4gICAgICAgICogQHBhcmFtIHtvYmplY3R9IHZhbHVlIC0gb2JqZWN0IHRvIGNoZWNrXHJcbiAgICAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvcmUvY29uc3RyYWludC5EYXRhX09iamVjdF9EZWZfQ29uc3RyYWludFxyXG4gICAgICAgICogQGluc3RhbmNlXHJcbiAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICogdmFyIGMgPSBuZXcgQ29uc3RyYWludC5EYXRhX09iamVjdF9EZWZfQ29uc3RyYWludCh7IG5hbWU6IFwic3RyaW5nXCIsIGFnZTogXCJudW1iZXJcIiB9KTtcclxuICAgICAgICAqIGMubWF0Y2goeyBuYW1lOiBcIkpvaG5cIiwgYWdlOiAyNSB9KSAgPT0+IHRydWVcclxuICAgICAgICAqIGMubWF0Y2goeyBuYW1lOiBcIkpvaG5cIiwgYWdlOiBcIjI1XCIgfSkgID09PiBmYWxzZVxyXG4gICAgICAgICogYy5tYXRjaCh7IG5hbWU6IFwiSm9oblwiIH0pICA9PT4gZmFsc2VcclxuICAgICAgICAqL1xyXG5cdFx0J21hdGNoJzogZnVuY3Rpb24gKHZhbHVlKSB7XHJcblx0XHRcdC8vIHZhbHVlIG11c3QgYmUgYW4gb2JqZWN0P1xyXG5cdFx0XHR2YXIgdGhhdCA9IHRoaXM7XHJcblxyXG5cdFx0XHR2YXIgdHYgPSB0b2YodmFsdWUpO1xyXG5cdFx0XHRpZiAodHYgPT0gJ29iamVjdCcpIHtcclxuXHRcdFx0XHQvL2NvbnNvbGUubG9nKCd2YWx1ZSAnICsgc3RyaW5naWZ5KHZhbHVlKSk7XHJcblxyXG5cdFx0XHRcdC8vIG5lZWQgdG8gc2VlIGlmIHRoZSB2YWx1ZSBtYXRjaGVzIHRoZSBpdGVtcyBpbiB0aGUgZGF0YV9kZWYuXHJcblx0XHRcdFx0dmFyIGFsbE1hdGNoID0gdHJ1ZTtcclxuXHJcblx0XHRcdFx0ZWFjaCh0aGlzLmRhdGFfZGVmLCBmdW5jdGlvbihmaWVsZF9uYW1lLCBmaWVsZF9kZWYsIHN0b3ApIHtcclxuXHRcdFx0XHRcdHZhciBtYXRjaCA9IG9iamVjdF9tYXRjaGVzX2RlZih2YWx1ZVtmaWVsZF9uYW1lXSwgZmllbGRfZGVmKTtcclxuXHRcdFx0XHRcdC8vY29uc29sZS5sb2coJ21hdGNoICcgKyBtYXRjaCk7XHJcblxyXG5cdFx0XHRcdFx0YWxsTWF0Y2ggPSBhbGxNYXRjaCAmJiBtYXRjaDtcclxuXHRcdFx0XHRcdGlmICghYWxsTWF0Y2gpIHN0b3AoKTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0XHRyZXR1cm4gYWxsTWF0Y2g7XHJcblx0XHRcdFx0Ly90aHJvdyAnc3RvcCc7XHJcblx0XHRcdH1cclxuICAgICAgICAgICAgLy9cclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0fSBcclxuXHR9KTtcclxuXHJcblxyXG5cclxuXHQvLyBEYXRhX09iamVjdF9EZWZfQ29uc3RyYWludFxyXG5cdC8vICBUaG91Z2ggcHV0dGluZyB0aGVtIGluIGFzIGluZGl2aWR1YWwgZmllbGQgY29uc3RyYWludHMgbWF5IG1ha2Ugc2Vuc2UuLi5cclxuXHQvLyAgIEJ1dCB0aGUgZmllbGQgY29uc3RyYWludHMgc291bmQgbW9yZSBsaWtlIGNvbnN0cmFpbnRzIG9uIGluZGl2aWR1YWwgZmllbGRzLiBVc2VmdWwgdG8gdmFsaWRhdGUgYSBwYXJ0aWN1bGFyIGZpZWxkLFxyXG5cdC8vICAgIGJ1dCB0aGUgb2JqZWN0IHZhbGlkYXRpb24gbWF5IHdvcmsgZGlmZmVyZW50bHkuXHJcblxyXG5cdFxyXG5cdHZhciBGaWVsZF9Db25zdHJhaW50ID0gQ29uc3RyYWludC5leHRlbmQoe1xyXG5cclxuXHQgICAgLyoqIFxyXG4gICAgICAgICogQGNsYXNzZGVzYyBGaWVsZCBjb25zdHJhaW50IGJhc2UgY2xhc3MuIFRoZSBjbGFzcyBpcyBwcml2YXRlLlxyXG4gICAgICAgICogQGNvbnN0cnVjdHMgbW9kdWxlOmNvcmUvY29uc3RyYWludC5GaWVsZF9Db25zdHJhaW50IFxyXG4gICAgICAgICogXHJcbiAgICAgICAgKi9cclxuXHQgICAgJ2luaXQnOiBmdW5jdGlvbiAoc3BlYykge1xyXG5cdFx0XHQvLyBpZiB0aGUgc3BlYyBpcyBhIHN0cmluZywgdGhlbiBwYXJzZSB0aGUgc3RyaW5nLlxyXG5cdFx0XHRcclxuXHRcdFx0Ly8gaXQgbWF5IG1ha2UgcmVmZXJlbmNlIHRvIHZhcmlvdXMgZGF0YSB0eXBlcy5cclxuXHRcdFx0Ly8gIHRleHQsIHJlc3RyaWN0ZWQgb3IgdW5yZXN0cmljdGVkIGxlbmd0aFxyXG5cdFx0XHQvLyAgaW50cywgbnVtYmVycywgZXRjXHJcblx0XHRcdC8vICB2YXJpb3VzIHRlc3RzIHdpbGwgYmUgY2FycmllZCBvdXQsIGJleW9uZCB0b2YuXHJcblx0XHRcdFxyXG5cdFx0XHR0aGlzLl9fZGF0YV90eXBlID0gJ2ZpZWxkX2NvbnN0cmFpbnQnO1xyXG5cdFx0XHRcclxuXHRcdFx0Ly9pZiAodG9mKHNwZWMpID09ICdzdHJpbmcnKSB7XHJcblx0XHRcdFx0XHJcblx0XHRcdC8vfVxyXG5cdFx0XHRcclxuXHRcdFx0Ly8gQSBjb25zdHJhaW50IGNhbiBiZSAvIGNvbnRhaW4gbXVsdGlwbGUgb3RoZXIgY29uc3RyYWludHMuXHJcblx0XHRcdC8vICBNYXliZSBpdCBzaG91bGQgaGF2ZSB0aGF0IGxvZ2ljIGluc2lkZSBpdCwgYW5kIHRoZXNlIG90aGVyIGNvbnN0cmFpbnRzIGNhbiBiZSBwYXJ0aWN1bGFyIG9uZXMuXHJcblx0XHRcdFxyXG5cdFx0XHQvLyBDb2RlIGV4ZWN1dGlvbiBwYXRoLi4uIG1heSBiZSBpbXBvcnRhbnQgZ2V0dGluZyB0aGF0IHdvcmtpbmcgYmVmb3JlIGxvbmcsIGJ1dCBub3cgaXQgZG9lcyBzZWVtIHRoYXQgc3BlY2lmeWluZyBhbmRcclxuXHRcdFx0Ly8gIHZhbGlkYXRpbmcgdGhlc2UgdmFyaW91cyB0eXBlcyBpbiBKYXZhU2NyaXB0IHNlZW1zIGxpa2UgYW4gaW1wb3J0YW50IHRoaW5nIHRvIGRvLlxyXG5cdFx0XHRcclxuXHRcdFx0Ly8gXHJcblx0XHRcdFxyXG5cdFx0XHRcclxuXHRcdH1cclxuXHQvLyAnbWF0Y2hlcydcclxuXHRcdFxyXG5cdFxyXG5cdH0pXHJcblx0XHJcblxyXG5cclxuXHJcblx0Ly8gQSBEYXRhX09iamVjdF9Db25zdHJhaW50IGNvdWxkIGhlbHBcclxuXHJcblx0Ly8gRGF0YV9PYmplY3RfRGVmX0NvbnN0cmFpbnRcclxuXHQvLyAgQSBzaW5nbGUgY29uc3RyYWludCwgd2l0aCB0aGUgZGVmaW5pdGlvbiBvZiB2YXJpb3VzIGZpZWxkcyBnaXZlbiBjb25jaXNlbHkuXHJcblx0Ly8gICBUaGlzIGNvdWxkIGhhdmUgYmV0dGVyIHBlcmZvcm1hbmNlIGFzIGl0J3Mgbm90IGluc3RhdGlhdGluZyBhcyBtYW55IG9iamVjdHMgdG8gY2Fycnkgb3V0IHRoZSBjb25zdHJhaW50cy5cclxuXHQvLyAgICBCdXQgaXQgbWF5IGJlIGEgcHJvYmxlbSB3aXRoIGhhdmluZyBkaWZmZXJlbnQgd2F5cyBvZiBkb2luZyB0aGUgc2FtZSB0aGluZ3MuXHJcblxyXG5cdC8vIERlZmluaW5nIGZpZWxkcyBpbiBtb3JlIGRldGFpbCBtYXkgbWFrZSBzZW5zZSwgdXNpbmcgRmllbGQgb2JqZWN0cy5cclxuXHQvLyAgVGhleSBtYWtlIHNlbnNlIGZvciBEQnNcclxuXHJcblx0Ly8gQnV0IGZvciBvYmplY3QgZGVmaW5pdGlvbnMsIGl0IG1heSBiZSB1c2VmdWwgdG8ganVzdCBqYXZlIHRoZSBzaW1wbGVzdCBmb3JtIG9mIGlucHV0IC0gdGhleSBjb3VsZCBiZSB0cmFuc2xhdGVkIHRvXHJcblx0Ly8gIHRoZSBmaWVsZCBzeXN0ZW0uIFdlIG1heSBoYXZlIHR3byB3YXlzIG9mIG1vZGlmeWluZyB0aGUgc2FtZSBkYXRhLCBhbmQgaGF2ZSB0aGVtIHdvcmtpbmcgdG9nZXRoZXIgd2VsbC5cclxuXHRcclxuXHRcclxuXHQvLyBGaWVsZCBjb25zdHJhaW50cyxcclxuXHQvLyAgV2lsbCB0cmFuc2xhdGUgdG8gZGF0YSB0eXBlcywgYW5kIHBvc3NpYmx5IGZ1cnRoZXIgY2hlY2tzIC8gdmFsaWRhdGlvbiB0aGF0IGlzIGRvbmUgaW4gdGhlIERCIGxheWVyIG9uIGlucHV0XHJcblx0XHJcblx0Ly8gV2lsbCBcclxuXHRcclxuXHRcclxuXHQvLyBDb2xsZWN0aW9uIGNvbnN0cmFpbnRzXHJcblx0Ly8gIFRoZXNlIHdpbGwgdHJhbnNsYXRlIHRvIHRhYmxlIGNvbnN0cmFpbnRzXHJcblx0XHJcblx0XHJcblx0Ly8gZGF0YV90eXBlX2NvbnN0cmFpbnRcclxuXHQvLyBmaWVsZF9kYXRhX3R5cGVfY29uc3RyYWludFxyXG5cdFxyXG5cdC8vICBub3QgbnVsbCBpcyBub3QgKHJlYWxseSkgYSBkYXRhIHR5cGUgY29uc3RyYWludC5cclxuXHQvLyAgc2FtZSB3aXRoIHNvbWUgY2hlY2sgY29uc3RyYWludHMuIERvZXMgbm90IHNlZW0gbGlrZSBhIHZlcnkgZGVmaW5pdGUgYm91bmRhcnkgdGhvdWdoLlxyXG5cdFxyXG5cdHZhciBGaWVsZF9EYXRhX1R5cGVfQ29uc3RyYWludCA9IEZpZWxkX0NvbnN0cmFpbnQuZXh0ZW5kKHtcclxuXHJcblx0ICAgIC8qKiBcclxuICAgICAgICAqIEBjbGFzc2Rlc2MgVHlwZWQgZmllbGQgY29uc3RyYWludCBiYXNlIGNsYXNzLiBcclxuICAgICAgICAqXHJcbiAgICAgICAgKiBUaGUgY2xhc3MgcHVibGljIG5hbWUgaXMgPHN0cm9uZz5GaWVsZF9EYXRhX1R5cGU8L3N0cm9uZz4gKGUuZy4gYG5ldyBDb25zdHJhaW50LkZpZWxkX0RhdGFfVHlwZSgpYCkuXHJcbiAgICAgICAgKiBAY29uc3RydWN0cyBtb2R1bGU6Y29yZS9jb25zdHJhaW50LkZpZWxkX0RhdGFfVHlwZV9Db25zdHJhaW50IFxyXG4gICAgICAgICogXHJcbiAgICAgICAgKi9cclxuXHQgICAgJ2luaXQnOiBmdW5jdGlvbiAoc3BlYykge1xyXG5cdFx0XHRcclxuXHRcdFx0Ly8gYWxzbyBob2xkIHRoZSBkYXRhIHR5cGUgaXRzZWxmLlxyXG5cdFx0XHRcclxuXHRcdFx0XHJcblx0XHRcdFxyXG5cdFx0XHR0aGlzLl9zdXBlcihzcGVjKTtcclxuXHRcdH1cclxuXHR9KTtcclxuXHRcclxuXHRcclxuXHRcclxuXHR2YXIgVGV4dF9Db25zdHJhaW50ID0gRmllbGRfRGF0YV9UeXBlX0NvbnN0cmFpbnQuZXh0ZW5kKHtcclxuXHJcblx0ICAgIC8qKiBcclxuICAgICAgICAqIFRoZSBjb25zdHJ1Y3RvciBpcyBwcml2YXRlLiBVc2UgZnJvbV9vYmooKSBvciB7QGxpbmsgbW9kdWxlOmNvcmUvY29uc3RyYWludC5mcm9tX3N0cnxmcm9tX3N0cigpfSB0byBjcmVhdGUgdGhpcyBjb25zdHJhaW50LlxyXG4gICAgICAgICogQGNsYXNzZGVzYyBUZXh0IGZpZWxkIGNvbnN0cmFpbnQ6IGNoZWNrcyB2YWx1ZSB0eXBlIChzdHJpbmcpIGFuZCBwb3NzaWJseSBtYXggbGVuZ3RoLlxyXG4gICAgICAgICogQGNvbnN0cnVjdHMgbW9kdWxlOmNvcmUvY29uc3RyYWludC5UZXh0X0NvbnN0cmFpbnQgXHJcbiAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gc3BlYyAtIGNvbnN0cmFpbnQgcHJvcGVydGllczogYHt9YCBvciBge2xlbmd0aDogbWF4bGVuZ3RofWBcclxuICAgICAgICAqIFxyXG4gICAgICAgICovXHJcblx0ICAgICdpbml0JzogZnVuY3Rpb24gKHNwZWMpIHtcclxuXHRcdFx0Ly8gaWYgdGhlIHNwZWMgaXMgYSBzdHJpbmcsIHRoZW4gcGFyc2UgdGhlIHN0cmluZy5cclxuXHRcdFx0XHJcblx0XHRcdC8vIGl0IG1heSBtYWtlIHJlZmVyZW5jZSB0byB2YXJpb3VzIGRhdGEgdHlwZXMuXHJcblx0XHRcdC8vICB0ZXh0LCByZXN0cmljdGVkIG9yIHVucmVzdHJpY3RlZCBsZW5ndGhcclxuXHRcdFx0Ly8gIGludHMsIG51bWJlcnMsIGV0Y1xyXG5cdFx0XHQvLyAgdmFyaW91cyB0ZXN0cyB3aWxsIGJlIGNhcnJpZWQgb3V0LCBiZXlvbmQgdG9mLlxyXG5cdFx0XHRcclxuXHRcdFx0Ly9pZiAodG9mKHNwZWMpID09ICdzdHJpbmcnKSB7XHJcblx0XHRcdC8vXHRcclxuXHRcdFx0Ly99XHJcblxyXG5cdFx0XHR0aGlzLl9zdXBlcihzcGVjKTtcclxuXHRcdFx0aWYgKGlzX2RlZmluZWQoc3BlYy5sZW5ndGgpKSB7XHJcblx0XHRcdFx0dGhpcy5sZW5ndGggPSBzcGVjLmxlbmd0aDtcclxuXHRcdFx0fVxyXG5cdFx0XHRcclxuXHRcdFx0Ly8gQSBjb25zdHJhaW50IGNhbiBiZSAvIGNvbnRhaW4gbXVsdGlwbGUgb3RoZXIgY29uc3RyYWludHMuXHJcblx0XHRcdC8vICBNYXliZSBpdCBzaG91bGQgaGF2ZSB0aGF0IGxvZ2ljIGluc2lkZSBpdCwgYW5kIHRoZXNlIG90aGVyIGNvbnN0cmFpbnRzIGNhbiBiZSBwYXJ0aWN1bGFyIG9uZXMuXHJcblx0XHRcdFxyXG5cdFx0XHQvLyBDb2RlIGV4ZWN1dGlvbiBwYXRoLi4uIG1heSBiZSBpbXBvcnRhbnQgZ2V0dGluZyB0aGF0IHdvcmtpbmcgYmVmb3JlIGxvbmcsIGJ1dCBub3cgaXQgZG9lcyBzZWVtIHRoYXQgc3BlY2lmeWluZyBhbmRcclxuXHRcdFx0Ly8gIHZhbGlkYXRpbmcgdGhlc2UgdmFyaW91cyB0eXBlcyBpbiBKYXZhU2NyaXB0IHNlZW1zIGxpa2UgYW4gaW1wb3J0YW50IHRoaW5nIHRvIGRvLlxyXG5cdFx0XHRcclxuXHRcdFx0Ly8gXHJcblx0XHRcdFxyXG5cdFx0XHRcclxuXHQgICAgfSxcclxuXHJcblx0ICAgIC8qKlxyXG4gICAgICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGB2YWx1ZWAgbWF0Y2hlcyB0aGUgY29uc3RyYWludC5cclxuICAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgLSB2YWx1ZSB0byBjaGVja1xyXG4gICAgICAgICogQG1lbWJlcm9mIG1vZHVsZTpjb3JlL2NvbnN0cmFpbnQuVGV4dF9Db25zdHJhaW50XHJcbiAgICAgICAgKiBAaW5zdGFuY2VcclxuICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgKiB2YXIgYyA9IENvbnN0cmFpbnQuZnJvbV9vYmooXCJ0ZXh0KDMpXCIpO1xyXG4gICAgICAgICogYy5tYXRjaChcIjEyM1wiKSAgPT0+IHRydWVcclxuICAgICAgICAqIGMubWF0Y2goMTIzKSAgPT0+IGZhbHNlXHJcbiAgICAgICAgKiBjLm1hdGNoKFwiMTIzNFwiKSAgPT0+IGZhbHNlXHJcbiAgICAgICAgKlxyXG4gICAgICAgICogdmFyIGMgPSBDb25zdHJhaW50LmZyb21fb2JqKFwidGV4dFwiKTtcclxuICAgICAgICAqIGMubWF0Y2goXCIxMjM0NTY3ODkwXCIpICA9PT4gdHJ1ZVxyXG4gICAgICAgICovXHJcblx0ICAgICdtYXRjaCc6IGZ1bmN0aW9uICh2KSB7XHJcblx0XHQgICAgaWYgKGlzX2RlZmluZWQodGhpcy5sZW5ndGgpKSB7XHJcblx0XHQgICAgICAgIHJldHVybiAodG9mKHYpID09ICdzdHJpbmcnICYmIHYubGVuZ3RoIDw9IHRoaXMubGVuZ3RoKTtcclxuXHRcdCAgICB9IGVsc2Uge1xyXG5cdFx0ICAgICAgICByZXR1cm4gKHRvZih2KSA9PSAnc3RyaW5nJyk7XHJcblx0XHQgICAgfVxyXG5cdCAgICB9LFxyXG5cclxuXHQgICAgLyoqXHJcbiAgICAgICAgKiBSZXR1cm5zIHRoZSBjb25zdHJhaW50IGluZm9ybWF0aW9uIG9iamVjdC4gVGhlIG9iamVjdCBjYW4gYmUgZm9sbG93aW5nOlxyXG4gICAgICAgICogLSBgW1widGV4dFwiLCBsZW5ndGhdYCAtIGlmIHRoZSBjb25zdHJhaW50IGNvbnRhaW5zIGEgbWF4bGVuZ3RoIHJlc3RyaWN0aW9uXHJcbiAgICAgICAgKiAtIGBcInRleHRcImAgLSBpZiB0aGUgY29uc3RyYWludCBkb2VzIG5vdCBjb250YWlucyBhIG1heGxlbmd0aCByZXN0cmljdGlvblxyXG4gICAgICAgICogQG1lbWJlcm9mIG1vZHVsZTpjb3JlL2NvbnN0cmFpbnQuVGV4dF9Db25zdHJhaW50XHJcbiAgICAgICAgKiBAaW5zdGFuY2VcclxuICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgKiB2YXIgYyA9IENvbnN0cmFpbnQuZnJvbV9vYmooXCJ0ZXh0KDMpXCIpO1xyXG4gICAgICAgICogYy50b19pbmZvX29iaigpICA9PT4gW1widGV4dFwiLCAzXVxyXG4gICAgICAgICpcclxuICAgICAgICAqIHZhciBjID0gQ29uc3RyYWludC5mcm9tX29iaihcInRleHRcIik7XHJcbiAgICAgICAgKiBjLnRvX2luZm9fb2JqKCkgID09PiBcInRleHRcIlxyXG4gICAgICAgICovXHJcblx0ICAgICd0b19pbmZvX29iaic6IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0aWYgKGlzX2RlZmluZWQodGhpcy5sZW5ndGgpKSB7XHJcblx0XHRcdFx0cmV0dXJuIFsndGV4dCcsIHRoaXMubGVuZ3RoXTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRyZXR1cm4gJ3RleHQnO1xyXG5cdFx0XHR9XHJcblx0XHRcdFxyXG5cdFx0XHRcclxuXHRcdH1cclxuXHQvLyAnbWF0Y2hlcydcclxuXHRcdFxyXG5cdH0pXHJcblx0XHJcblx0dmFyIE5vdF9OdWxsX0NvbnN0cmFpbnQgPSBGaWVsZF9Db25zdHJhaW50LmV4dGVuZCh7XHJcblx0XHRcclxuXHQgICAgLyoqIFxyXG4gICAgICAgICogQGNsYXNzZGVzYyBcIk5vdCBudWxsXCIgY29uc3RyYWludDogY2hlY2tzIGEgdmFsdWUgdG8gYmUgbm90IG51bGwuIFxyXG4gICAgICAgICpcclxuICAgICAgICAqIFRoZSBjbGFzcyBwdWJsaWMgbmFtZSBpcyA8c3Ryb25nPk5vdF9OdWxsPC9zdHJvbmc+IChlLmcuIGBuZXcgQ29uc3RyYWludC5Ob3RfTnVsbCgpYCkuXHJcbiAgICAgICAgKiBAY29uc3RydWN0cyBtb2R1bGU6Y29yZS9jb25zdHJhaW50Lk5vdF9OdWxsX0NvbnN0cmFpbnQgXHJcbiAgICAgICAgKi9cclxuXHQgICAgJ2luaXQnOiBmdW5jdGlvbiAoc3BlYykge1xyXG5cdFx0XHQvLyBpZiB0aGUgc3BlYyBpcyBhIHN0cmluZywgdGhlbiBwYXJzZSB0aGUgc3RyaW5nLlxyXG5cdFx0XHR0aGlzLl9zdXBlcihzcGVjKTtcclxuXHRcdFx0XHJcblx0XHRcdFxyXG5cdCAgICB9LFxyXG5cclxuXHQgICAgLyoqXHJcbiAgICAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYHZhbHVlYCBtYXRjaGVzIHRoZSBjb25zdHJhaW50IChpLmUuIHZhbHVlICE9IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPSBudWxsKS5cclxuICAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgLSB2YWx1ZSB0byBjaGVja1xyXG4gICAgICAgICogQG1lbWJlcm9mIG1vZHVsZTpjb3JlL2NvbnN0cmFpbnQuTm90X051bGxfQ29uc3RyYWludFxyXG4gICAgICAgICogQGluc3RhbmNlXHJcbiAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICogdmFyIGMgPSBuZXcgQ29uc3RyYWludC5Ob3RfTnVsbCgpO1xyXG4gICAgICAgICogYy5tYXRjaChcIjEyM1wiKSAgPT0+IHRydWVcclxuICAgICAgICAqIGMubWF0Y2gobnVsbCkgID09PiBmYWxzZVxyXG4gICAgICAgICovXHJcblx0ICAgICdtYXRjaCc6IGZ1bmN0aW9uICh2KSB7XHJcblx0XHRcdHJldHVybiBpc19kZWZpbmVkKHYpICYmIHYgIT0gbnVsbDtcclxuXHRcdH1cclxuXHR9KTtcclxuXHRcclxuXHQvLyBPYmplY3RzIHRoYXQgcmVwcmVzZW50IHRoZSBkYXRhIHR5cGVzIHRoZW1zZWx2ZXM/XHJcblx0Ly8gIFByb2JhYmx5IG5vdCBnb2luZyB0byB1c2UgY2xhc3NlcyBmb3IgdGhhdCwganVzdCBKUyBvYmplY3RzIGxpa2UgYXJyYXlzLCBtYXBzLlxyXG5cdFxyXG5cdHZhciBHdWlkX0NvbnN0cmFpbnQgPSAgRmllbGRfRGF0YV9UeXBlX0NvbnN0cmFpbnQuZXh0ZW5kKHtcclxuXHJcblx0ICAgIC8qKiBcclxuICAgICAgICAqIEBjbGFzc2Rlc2MgR1VJRCBmaWVsZCBjb25zdHJhaW50OiBjaGVja3MgYSB2YWx1ZSB0byBhIEdVSUQgc3RyaW5nIChlLmcuIGBcIns4NkRDQTlBNS0zMUFDLTRGMjAtQjU1Mi00RDE1MDNEMEQxMUN9XCJgKS4gXHJcbiAgICAgICAgKlxyXG4gICAgICAgICogVGhlIGNsYXNzIHB1YmxpYyBuYW1lIGlzIDxzdHJvbmc+R3VpZDwvc3Ryb25nPiAoZS5nLiBgbmV3IENvbnN0cmFpbnQuR3VpZCgpYCkuXHJcbiAgICAgICAgKiBAY29uc3RydWN0cyBtb2R1bGU6Y29yZS9jb25zdHJhaW50Lkd1aWRfQ29uc3RyYWludCBcclxuICAgICAgICAqL1xyXG5cdCAgICAnaW5pdCc6IGZ1bmN0aW9uIChzcGVjKSB7XHJcblx0XHRcdC8vIGlmIHRoZSBzcGVjIGlzIGEgc3RyaW5nLCB0aGVuIHBhcnNlIHRoZSBzdHJpbmcuXHJcblx0XHRcdHRoaXMuX3N1cGVyKHNwZWMpO1xyXG5cdFx0XHRcclxuXHRcdFx0XHJcblx0ICAgIH0sXHJcblxyXG5cdCAgICAvKipcclxuICAgICAgICAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBgdmFsdWVgIG1hdGNoZXMgdGhlIGNvbnN0cmFpbnQgKGkuZS4gdmFsdWUgaXMgYSBHVUlEIHN0cmluZykuXHJcbiAgICAgICAgKiBAcGFyYW0geyp9IHZhbHVlIC0gdmFsdWUgdG8gY2hlY2tcclxuICAgICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29yZS9jb25zdHJhaW50Lkd1aWRfQ29uc3RyYWludFxyXG4gICAgICAgICogQGluc3RhbmNlXHJcbiAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICogdmFyIGMgPSBuZXcgQ29uc3RyYWludC5HdWlkKCk7XHJcbiAgICAgICAgKiBjLm1hdGNoKFwiezg2RENBOUE1LTMxQUMtNEYyMC1CNTUyLTREMTUwM0QwRDExQ31cIikgID09PiB0cnVlXHJcbiAgICAgICAgKiBjLm1hdGNoKFwiODZEQ0E5QTUtMzFBQy00RjIwLUI1NTItNEQxNTAzRDBEMTFDXCIpICA9PT4gZmFsc2VcclxuICAgICAgICAqL1xyXG5cclxuXHQgICAgJ21hdGNoJzogZnVuY3Rpb24gKHYpIHtcclxuXHRcdFx0Ly9yZXR1cm4gdG9mKHYpID09ICdudW1iZXInO1xyXG5cdFx0XHRcclxuXHRcdFx0Ly8gc3RyaW5nIG9mIGEgZ2l2ZW4gbGVuZ3RoLi4uXHJcblx0XHRcdFxyXG5cdFx0XHQvLyAgdGhpcyB3aWxsIHJlYWxseSBiZSBmb3IgdHJhbnNsYXRpbmcgdG8gTW9uZ28gb3IgU1FMIFNlcnZlciBvciBvdGhlciBEQiBHVUlEIHR5cGVzLlxyXG5cdFx0XHRcclxuXHRcdCAgICAvLyBcIns4NkRDQTlBNS0zMUFDLTRGMjAtQjU1Mi00RDE1MDNEMEQxMUN9XCJcclxuXHRcdCAgICBpZiAodG9mKHYpID09PSBcInN0cmluZ1wiKSB7XHJcblx0XHQgICAgICAgIHZhciByZWcgPSAvXntbQS1GYS1mMC05XXs4fS1bQS1GYS1mMC05XXs0fS1bQS1GYS1mMC05XXs0fS1bQS1GYS1mMC05XXs0fS1bQS1GYS1mMC05XXsxMn19JC87XHJcblx0XHQgICAgICAgIHJldHVybiByZWcudGVzdCh2KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvL1xyXG5cdFx0ICAgIHJldHVybiBmYWxzZTtcclxuXHRcdFx0XHJcblx0ICAgIH0sXHJcblxyXG5cdCAgICAvKipcclxuICAgICAgICAqIFJldHVybnMgdGhlIGNvbnN0cmFpbnQgaW5mb3JtYXRpb24gb2JqZWN0IChpLmUuIFwiZ3VpZFwiIHN0cmluZykuXHJcbiAgICAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvcmUvY29uc3RyYWludC5HdWlkX0NvbnN0cmFpbnRcclxuICAgICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAqIHZhciBjID0gQ29uc3RyYWludC5mcm9tX29iaihcImd1aWRcIik7XHJcbiAgICAgICAgKiBjLnRvX2luZm9fb2JqKCkgID09PiBcImd1aWRcIlxyXG4gICAgICAgICovXHJcblx0ICAgICd0b19pbmZvX29iaic6IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0cmV0dXJuICdndWlkJztcclxuXHRcdH1cclxuXHRcdFxyXG5cdH0pXHJcblx0XHJcblx0XHJcblx0dmFyIE51bWJlcl9Db25zdHJhaW50ID0gRmllbGRfRGF0YV9UeXBlX0NvbnN0cmFpbnQuZXh0ZW5kKHtcclxuXHJcblx0ICAgIC8qKiBcclxuICAgICAgICAqIFRoZSBjb25zdHJ1Y3RvciBpcyBwcml2YXRlLiBVc2UgZnJvbV9vYmooKSBvciB7QGxpbmsgbW9kdWxlOmNvcmUvY29uc3RyYWludC5mcm9tX3N0cnxmcm9tX3N0cigpfSB0byBjcmVhdGUgdGhpcyBjb25zdHJhaW50LlxyXG4gICAgICAgICogQGNsYXNzZGVzYyBOdW1iZXIgZmllbGQgY29uc3RyYWludDogY2hlY2tzIHZhbHVlIHRvIGJlIGEgbnVtYmVyLlxyXG4gICAgICAgICogQGNvbnN0cnVjdHMgbW9kdWxlOmNvcmUvY29uc3RyYWludC5OdW1iZXJfQ29uc3RyYWludCBcclxuICAgICAgICAqL1xyXG5cdCAgICAnaW5pdCc6IGZ1bmN0aW9uIChzcGVjKSB7XHJcblx0XHRcdC8vIGlmIHRoZSBzcGVjIGlzIGEgc3RyaW5nLCB0aGVuIHBhcnNlIHRoZSBzdHJpbmcuXHJcblx0XHRcdHRoaXMuX3N1cGVyKHNwZWMpO1xyXG5cdCAgICB9LFxyXG5cclxuXHQgICAgLyoqXHJcbiAgICAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYHZhbHVlYCBtYXRjaGVzIHRoZSBjb25zdHJhaW50IChpLmUuIHZhbHVlIGlzIGEgbnVtYmVyKS5cclxuICAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgLSB2YWx1ZSB0byBjaGVja1xyXG4gICAgICAgICogQG1lbWJlcm9mIG1vZHVsZTpjb3JlL2NvbnN0cmFpbnQuTnVtYmVyX0NvbnN0cmFpbnRcclxuICAgICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAqIHZhciBjID0gQ29uc3RyYWludC5mcm9tX29iaihcIm51bWJlclwiKTtcclxuICAgICAgICAqIGMubWF0Y2goMSkgID09PiB0cnVlXHJcbiAgICAgICAgKiBjLm1hdGNoKFwiMVwiKSAgPT0+IGZhbHNlXHJcbiAgICAgICAgKi9cclxuXHQgICAgJ21hdGNoJzogZnVuY3Rpb24gKHYpIHtcclxuXHRcdFx0cmV0dXJuIHRvZih2KSA9PSAnbnVtYmVyJztcclxuXHRcdH0sXHJcblxyXG5cdCAgICAvKipcclxuICAgICAgICAqIFJldHVybnMgdGhlIGNvbnN0cmFpbnQgaW5mb3JtYXRpb24gb2JqZWN0IChpLmUuIFwibnVtYmVyXCIgc3RyaW5nKS5cclxuICAgICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29yZS9jb25zdHJhaW50Lk51bWJlcl9Db25zdHJhaW50XHJcbiAgICAgICAgKiBAaW5zdGFuY2VcclxuICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgKiB2YXIgYyA9IENvbnN0cmFpbnQuZnJvbV9vYmooXCJudW1iZXJcIik7XHJcbiAgICAgICAgKiBjLnRvX2luZm9fb2JqKCkgID09PiBcIm51bWJlclwiXHJcbiAgICAgICAgKi9cclxuXHRcdCd0b19pbmZvX29iaic6IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0cmV0dXJuICdudW1iZXInO1xyXG5cdFx0fVxyXG5cdFx0XHJcblx0fSlcclxuXHRcclxuXHR2YXIgSW50X0NvbnN0cmFpbnQgPSBOdW1iZXJfQ29uc3RyYWludC5leHRlbmQoe1xyXG5cclxuXHQgICAgLyoqIFxyXG4gICAgICAgICogVGhlIGNvbnN0cnVjdG9yIGlzIHByaXZhdGUuIFVzZSBmcm9tX29iaigpIG9yIHtAbGluayBtb2R1bGU6Y29yZS9jb25zdHJhaW50LmZyb21fc3RyfGZyb21fc3RyKCl9IHRvIGNyZWF0ZSB0aGlzIGNvbnN0cmFpbnQuXHJcbiAgICAgICAgKiBAY2xhc3NkZXNjIEludCBmaWVsZCBjb25zdHJhaW50OiBjaGVja3MgdmFsdWUgdG8gYmUgYW4gaW50ZWdlciBudW1iZXIuXHJcbiAgICAgICAgKiBAY29uc3RydWN0cyBtb2R1bGU6Y29yZS9jb25zdHJhaW50LkludF9Db25zdHJhaW50IFxyXG4gICAgICAgICovXHJcblx0ICAgICdpbml0JzogZnVuY3Rpb24gKHNwZWMpIHtcclxuXHRcdFx0Ly8gaWYgdGhlIHNwZWMgaXMgYSBzdHJpbmcsIHRoZW4gcGFyc2UgdGhlIHN0cmluZy5cclxuXHRcdFx0dGhpcy5fc3VwZXIoc3BlYyk7XHJcblx0ICAgIH0sXHJcblxyXG5cdCAgICAvKipcclxuICAgICAgICAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBgdmFsdWVgIG1hdGNoZXMgdGhlIGNvbnN0cmFpbnQgKGkuZS4gdmFsdWUgaXMgYW4gaW50ZWdlciBudW1iZXIpLlxyXG4gICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSAtIHZhbHVlIHRvIGNoZWNrXHJcbiAgICAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvcmUvY29uc3RyYWludC5JbnRfQ29uc3RyYWludFxyXG4gICAgICAgICogQGluc3RhbmNlXHJcbiAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICogdmFyIGMgPSBDb25zdHJhaW50LmZyb21fb2JqKFwiaW50XCIpO1xyXG4gICAgICAgICogYy5tYXRjaCgxKSAgPT0+IHRydWVcclxuICAgICAgICAqIGMubWF0Y2goMS41KSAgPT0+IGZhbHNlXHJcbiAgICAgICAgKiBjLm1hdGNoKFwiMVwiKSAgPT0+IGZhbHNlXHJcbiAgICAgICAgKi9cclxuXHQgICAgJ21hdGNoJzogZnVuY3Rpb24gKHYpIHtcclxuXHRcdFx0cmV0dXJuIHRvZih2KSA9PSAnbnVtYmVyJyAmJiBwYXJzZUludCh2KSA9PT0gdjtcclxuXHRcdH0sXHJcblxyXG5cdCAgICAvKipcclxuICAgICAgICAqIFJldHVybnMgdGhlIGNvbnN0cmFpbnQgaW5mb3JtYXRpb24gb2JqZWN0IChpLmUuIFwiaW50XCIgc3RyaW5nKS5cclxuICAgICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29yZS9jb25zdHJhaW50LkludF9Db25zdHJhaW50XHJcbiAgICAgICAgKiBAaW5zdGFuY2VcclxuICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgKiB2YXIgYyA9IENvbnN0cmFpbnQuZnJvbV9vYmooXCJpbnRcIik7XHJcbiAgICAgICAgKiBjLnRvX2luZm9fb2JqKCkgID09PiBcImludFwiXHJcbiAgICAgICAgKi9cclxuXHQgICAgJ3RvX2luZm9fb2JqJzogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRyZXR1cm4gJ2ludCc7XHJcblx0XHR9XHJcblx0XHRcclxuXHR9KVxyXG5cdFxyXG5cdFxyXG5cdC8vIFR5cGVfQ29uc3RyYWludFxyXG5cdFxyXG5cdFxyXG5cdC8vIENvbGxlY3Rpb24gY29uc3RyYWludHMgYXMgd2VsbFxyXG5cdC8vICBUaGVzZSBtYXkgbm90IG5lY2Vzc2lyaWx5IGFwcGx5IHRvIEpTR1VJIGNvbGxlY3Rpb25zLCBidXQgY291bGQgYmUgZm9yIHRyYW5zbGF0aW5nIHRvIFRhYmxlIENvbnN0cmFpbnRzIGluIFNRTC5cclxuXHRcclxuXHRcclxuXHQvLyBDb2xsZWN0aW9ucyB3aWxsIGhhdmUgZGlmZmVyZW50IHR5cGVzIG9mIGNvbnN0cmFpbnRzLlxyXG5cdFxyXG5cdC8vIENvdWxkIGJlIHRoYXQgZXZlcnkgaXRlbSBuZWVkcyB0byBmb2xsb3cgYSBzZXQgb2YgZmllbGQgY29uc3RyYWludHMuXHJcblx0Ly8gQ291bGQgYWxzbyBiZSB0aGF0IHRoZXJlIGFyZSB1bmlxdWUga2V5cy5cclxuXHQvLyAgTWF5IGhhdmUgZmllbGRzIHNwZWNpZmllZC5cclxuXHRcclxuXHQvLyBUaGlzIHdpbGwgd29yayB2ZXJ5IHdlbGwgaW5kZWVkIHdoZW4gdGhpcyBpcyBkb25lLiBTaG91bGQgYmUgaW50dWl0aXZlIHRvIGNyZWF0ZSB0aGUgbW9kZWxzLCB0aGVuIHRoZXNlIG1vZGVscyB3aWxsIGJlIHZlcnkgdXNlZnVsIGZvciBcclxuXHQvLyAgdHJhbnNsYXRpbmcgdG8gZGlmZmVyZW50IHRoaW5ncy4gU29tZSBvZiB0aGUgaW5kZXhpbmcgZnVuY3Rpb25hbGl0eSBvZiB0aGUgREIgZ2V0cyByZXBsaWNhdGVkIG9uIHRoZSBjbGllbnQgaW4gYSByZWxhdGl2ZWx5IHNtYWxsIGFtb3VudCBvZiBjb2RlLFxyXG5cdC8vICBhbGxvd2luZyBmb3Igc29tZSB0aGluZ3MgdG8gcnVuIGluIGEgdmVyeSBvcHRpbWl6ZWQgd2F5IGV2ZW4gb24gSUU2LlxyXG5cdFxyXG5cdC8vIEl0IHdpbGwgYmUgbmljZSB0byBzZWUgdGhlIHRoaW5ncyB3b3JraW5nIGZpbmUgaW4gSUU2IGFzIHdlbGwgYXMgbW9kZXJuIGJyb3dzZXJzLlxyXG5cdFxyXG5cdFxyXG5cdFxyXG5cdFxyXG5cdFxyXG5cdHZhciBDb2xsZWN0aW9uX0NvbnN0cmFpbnQgPSBDb25zdHJhaW50LmV4dGVuZCh7XHJcblx0XHRcclxuXHQgICAgLyoqIFxyXG4gICAgICAgICogVGhlIGNsYXNzIGlzIHByaXZhdGUuIFxyXG4gICAgICAgICogQGNsYXNzZGVzYyBDb2xsZWN0aW9uIGNvbnN0cmFpbnRzIGJhc2UgY2xhc3MuXHJcbiAgICAgICAgKiBAY29uc3RydWN0cyBtb2R1bGU6Y29yZS9jb25zdHJhaW50LkNvbGxlY3Rpb25fQ29uc3RyYWludCBcclxuICAgICAgICAqL1xyXG5cdCAgICAnaW5pdCc6IGZ1bmN0aW9uIChzcGVjKSB7XHJcblx0XHRcdC8vIGlmIHRoZSBzcGVjIGlzIGEgc3RyaW5nLCB0aGVuIHBhcnNlIHRoZSBzdHJpbmcuXHJcblx0XHRcdFxyXG5cdFx0XHQvLyBpdCBtYXkgbWFrZSByZWZlcmVuY2UgdG8gdmFyaW91cyBkYXRhIHR5cGVzLlxyXG5cdFx0XHQvLyAgdGV4dCwgcmVzdHJpY3RlZCBvciB1bnJlc3RyaWN0ZWQgbGVuZ3RoXHJcblx0XHRcdC8vICBpbnRzLCBudW1iZXJzLCBldGNcclxuXHRcdFx0Ly8gIHZhcmlvdXMgdGVzdHMgd2lsbCBiZSBjYXJyaWVkIG91dCwgYmV5b25kIHRvZi5cclxuXHRcdFx0dGhpcy5fX2RhdGFfdHlwZSA9ICdjb2xsZWN0aW9uX2NvbnN0cmFpbnQnO1xyXG5cdFx0XHQvL2lmICh0b2Yoc3BlYykgPT0gJ3N0cmluZycpIHtcclxuXHRcdFx0XHRcclxuXHRcdFx0Ly99XHJcblx0XHRcdFxyXG5cdFx0XHQvLyBBIGNvbnN0cmFpbnQgY2FuIGJlIC8gY29udGFpbiBtdWx0aXBsZSBvdGhlciBjb25zdHJhaW50cy5cclxuXHRcdFx0Ly8gIE1heWJlIGl0IHNob3VsZCBoYXZlIHRoYXQgbG9naWMgaW5zaWRlIGl0LCBhbmQgdGhlc2Ugb3RoZXIgY29uc3RyYWludHMgY2FuIGJlIHBhcnRpY3VsYXIgb25lcy5cclxuXHRcdFx0XHJcblx0XHRcdC8vIENvZGUgZXhlY3V0aW9uIHBhdGguLi4gbWF5IGJlIGltcG9ydGFudCBnZXR0aW5nIHRoYXQgd29ya2luZyBiZWZvcmUgbG9uZywgYnV0IG5vdyBpdCBkb2VzIHNlZW0gdGhhdCBzcGVjaWZ5aW5nIGFuZFxyXG5cdFx0XHQvLyAgdmFsaWRhdGluZyB0aGVzZSB2YXJpb3VzIHR5cGVzIGluIEphdmFTY3JpcHQgc2VlbXMgbGlrZSBhbiBpbXBvcnRhbnQgdGhpbmcgdG8gZG8uXHJcblx0XHRcdFxyXG5cdFx0XHQvLyBcclxuXHRcdFx0XHJcblx0XHRcdFxyXG5cdFx0fVxyXG5cdC8vICdtYXRjaGVzJ1xyXG5cdFx0XHJcblx0XHJcblx0fSk7XHJcblx0XHJcblx0Ly8gTm90IHNvIHN1cmUgYWJvdXQgdGhpcyBiZWluZyB0aGUgc2FtZSBEYXRhX1R5cGVfQ29uc3RyYWludCBmb3IgRGF0YV9PYmplY3RzLi4uXHJcblx0XHJcblx0XHJcblx0Ly8gTWF5IGFsc28gaGF2ZSBcclxuXHRcclxuXHQvLyBUaGlzIGNhbiBmb3JjZSBhIGNvbGxlY3Rpb24gdG8gaG9sZCBvbmx5IGEgcGFydGljdWxhciB0eXBlIG9mIG9iamVjdCwgdGVzdGVkIHdpdGggaW5zdGFuY2VvZlxyXG5cdFxyXG5cdC8vICBBbmQgbm90IHVzaW5nIHRoZSBmaWVsZCBzeXN0ZW0/XHJcblx0Ly8gICBTbyB3ZSBjb3VsZCByZXN0cmljdCBhIGNvbGxlY3Rpb24gdG8gb25seSBob2xkaW5nIGEgU3RyaW5nIHRoaXMgd2F5LlxyXG5cdFxyXG5cdHZhciBvYmplY3RfbWF0Y2hlc19kZWYgPSBmdW5jdGlvbih2YWx1ZSwgZGVmKSB7XHJcblx0XHQvL2NvbnNvbGUubG9nKCdvYmplY3RfbWF0Y2hlc19kZWYnKTtcclxuXHRcdC8vY29uc29sZS5sb2coJ3ZhbHVlICcgKyBzdHJpbmdpZnkodmFsdWUpKTtcclxuXHRcdC8vY29uc29sZS5sb2coJ2RlZiAnICsgc3RyaW5naWZ5KGRlZikpO1xyXG5cclxuXHRcdHZhciB0diA9IHRvZih2YWx1ZSk7XHJcblxyXG5cdFx0Ly9pZiAoZGVmID09ICdzdHJpbmcnKSB7XHJcblx0XHQvL1x0cmV0dXJuIHR2ID09ICdzdHJpbmcnXHJcblx0XHQvL31cclxuXHRcdC8vY29uc29sZS5sb2coJ3R2ICcgKyB0dik7XHJcblxyXG5cdFx0aWYgKHR2ID09IGRlZikge1xyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblxyXG5cdH1cclxuXHJcblx0XHJcblx0dmFyIENvbGxlY3Rpb25fRGF0YV9EZWZfQ29uc3RyYWludCA9IENvbGxlY3Rpb25fQ29uc3RyYWludC5leHRlbmQoe1xyXG5cclxuXHQgICAgLyoqIFxyXG4gICAgICAgICogQGNsYXNzZGVzYyBDb2xsZWN0aW9uIGZpZWxkcyBkZWZpbml0aW9uIGNvbnN0cmFpbnQuXHJcbiAgICAgICAgKlxyXG4gICAgICAgICogVGhlIGNsYXNzIHB1YmxpYyBuYW1lIGlzIDxzdHJvbmc+Q29sbGVjdGlvbl9EYXRhX0RlZjwvc3Ryb25nPiAoZS5nLiBgbmV3IENvbnN0cmFpbnQuQ29sbGVjdGlvbl9EYXRhX0RlZih7fSlgKS5cclxuICAgICAgICAqIEBjb25zdHJ1Y3RzIG1vZHVsZTpjb3JlL2NvbnN0cmFpbnQuQ29sbGVjdGlvbl9EYXRhX0RlZl9Db25zdHJhaW50IFxyXG4gICAgICAgICogQHBhcmFtIHtvYmplY3R9IHNwZWMgLSBkYXRhIGRlZmluaXRpb25cclxuICAgICAgICAqIFxyXG4gICAgICAgICovXHJcblx0ICAgICdpbml0JzogZnVuY3Rpb24gKHNwZWMpIHtcclxuXHJcblx0XHQgICAgdGhpcy5fc3VwZXIoKTtcclxuXHJcblx0XHQgICAgLy9pZiAodG9mKHNwZWMpID09ICdmdW5jdGlvbicgJiYgaXNfY29uc3RydWN0b3JfZm4oc3BlYykpIHtcclxuXHRcdFx0Ly9cdHRoaXMuZGF0YV90eXBlX2NvbnN0cnVjdG9yID0gc3BlYztcclxuXHRcdFx0Ly99XHJcblx0XHRcdC8vY29uc29sZS5sb2coJ3RvZihzcGVjKSAnICsgdG9mKHNwZWMpKTtcclxuXHRcdFx0Ly9jb25zb2xlLmxvZygndG9mKFN0cmluZykgJyArIHRvZihTdHJpbmcpKTtcclxuXHRcdFx0XHJcblx0XHRcdGlmICh0b2Yoc3BlYykgPT09ICdvYmplY3QnKSB7XHJcblx0XHRcdFx0dGhpcy5kYXRhX2RlZiA9IHNwZWM7XHJcblx0XHRcdH1cclxuXHRcdFx0XHJcblx0XHRcdC8vIERlZiBpcyBub3QgdGhlIGRhdGFfdHlwZSBpbiB0ZXJtcyBvZiBhIGNvbnN0cnVjdG9yXHJcblx0XHRcdHRoaXMuX2NvbnN0cmFpbnRfdHlwZSA9ICdkYXRhX2RlZic7XHJcblx0XHRcdFxyXG5cdFx0fSxcclxuXHJcblx0ICAgIC8qKlxyXG4gICAgICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGB2YWx1ZWAgbWF0Y2hlcyB0aGUgZmllbGRzIGNvbnN0cmFpbnQuXHJcbiAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gdmFsdWUgLSBvYmplY3QgdG8gY2hlY2tcclxuICAgICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29yZS9jb25zdHJhaW50LkNvbGxlY3Rpb25fRGF0YV9EZWZfQ29uc3RyYWludFxyXG4gICAgICAgICogQGluc3RhbmNlXHJcbiAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICogdmFyIGMgPSBuZXcgQ29uc3RyYWludC5Db2xsZWN0aW9uX0RhdGFfRGVmKHsgbmFtZTogXCJzdHJpbmdcIiwgYWdlOiBcIm51bWJlclwiIH0pO1xyXG4gICAgICAgICogYy5tYXRjaCh7IG5hbWU6IFwiSm9oblwiLCBhZ2U6IDI1IH0pICA9PT4gdHJ1ZVxyXG4gICAgICAgICogYy5tYXRjaCh7IG5hbWU6IFwiSm9oblwiLCBhZ2U6IFwiMjVcIiB9KSAgPT0+IGZhbHNlXHJcbiAgICAgICAgKiBjLm1hdGNoKHsgbmFtZTogXCJKb2huXCIgfSkgID09PiBmYWxzZVxyXG4gICAgICAgICovXHJcblx0ICAgICdtYXRjaCc6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG5cdFx0XHQvLyB2YWx1ZSBtdXN0IGJlIGFuIG9iamVjdD9cclxuXHRcdFx0dmFyIHRoYXQgPSB0aGlzO1xyXG5cclxuXHRcdFx0dmFyIHR2ID0gdG9mKHZhbHVlKTtcclxuXHRcdFx0aWYgKHR2ID09ICdvYmplY3QnKSB7XHJcblx0XHRcdFx0Ly9jb25zb2xlLmxvZygndmFsdWUgJyArIHN0cmluZ2lmeSh2YWx1ZSkpO1xyXG5cclxuXHRcdFx0XHQvLyBuZWVkIHRvIHNlZSBpZiB0aGUgdmFsdWUgbWF0Y2hlcyB0aGUgaXRlbXMgaW4gdGhlIGRhdGFfZGVmLlxyXG5cdFx0XHRcdHZhciBhbGxNYXRjaCA9IHRydWU7XHJcblxyXG5cdFx0XHRcdGVhY2godGhpcy5kYXRhX2RlZiwgZnVuY3Rpb24oZmllbGRfbmFtZSwgZmllbGRfZGVmLCBzdG9wKSB7XHJcblx0XHRcdFx0XHR2YXIgbWF0Y2ggPSBvYmplY3RfbWF0Y2hlc19kZWYodmFsdWVbZmllbGRfbmFtZV0sIGZpZWxkX2RlZik7XHJcblx0XHRcdFx0XHQvL2NvbnNvbGUubG9nKCdtYXRjaCAnICsgbWF0Y2gpO1xyXG5cclxuXHRcdFx0XHRcdGFsbE1hdGNoID0gYWxsTWF0Y2ggJiYgbWF0Y2g7XHJcblx0XHRcdFx0XHQvL2NvbnNvbGUubG9nKCdhbGxNYXRjaCAnICsgYWxsTWF0Y2gpO1xyXG5cdFx0XHRcdFx0aWYgKCFhbGxNYXRjaCkgc3RvcCgpO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHRcdHJldHVybiBhbGxNYXRjaDtcclxuXHRcdFx0XHQvL3Rocm93ICdzdG9wJztcclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gXHJcblx0fSk7XHJcblx0XHJcblx0Ly8gUGVyaGFwcyByZW5hbWUgdG8gQ29sbGVjdGlvbl9EYXRhX1R5cGVfQ29uc3RydWN0b3JfQ29uc3RyYWludFxyXG5cdHZhciBDb2xsZWN0aW9uX0RhdGFfVHlwZV9Db25zdHJhaW50ID0gQ29sbGVjdGlvbl9Db25zdHJhaW50LmV4dGVuZCh7XHJcblxyXG5cdCAgICAvKiogXHJcbiAgICAgICAgKiBAY2xhc3NkZXNjIENvbGxlY3Rpb24gaXRlbSB0eXBlIGNvbnN0cmFpbnQuXHJcbiAgICAgICAgKlxyXG4gICAgICAgICogVGhlIGNsYXNzIHB1YmxpYyBuYW1lIGlzIDxzdHJvbmc+Q29sbGVjdGlvbl9EYXRhX1R5cGU8L3N0cm9uZz4gKGUuZy4gYG5ldyBDb25zdHJhaW50LkNvbGxlY3Rpb25fRGF0YV9UeXBlKE9iamVjdClgKS5cclxuICAgICAgICAqIEBjb25zdHJ1Y3RzIG1vZHVsZTpjb3JlL2NvbnN0cmFpbnQuQ29sbGVjdGlvbl9EYXRhX1R5cGVfQ29uc3RyYWludCBcclxuICAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IHNwZWMgLSBpdGVtIHR5cGUgY29uc3RydWN0b3IgZnVuY3Rpb25cclxuICAgICAgICAqIFxyXG4gICAgICAgICovXHJcblx0ICAgICdpbml0JzogZnVuY3Rpb24gKHNwZWMpIHtcclxuXHJcblx0XHQgICAgdGhpcy5fc3VwZXIoKTtcclxuXHJcblx0XHQgICAgLy9pZiAodG9mKHNwZWMpID09ICdmdW5jdGlvbicgJiYgaXNfY29uc3RydWN0b3JfZm4oc3BlYykpIHtcclxuXHRcdFx0Ly9cdHRoaXMuZGF0YV90eXBlX2NvbnN0cnVjdG9yID0gc3BlYztcclxuXHRcdFx0Ly99XHJcblx0XHRcdC8vY29uc29sZS5sb2coJ3RvZihzcGVjKSAnICsgdG9mKHNwZWMpKTtcclxuXHRcdFx0Ly9jb25zb2xlLmxvZygndG9mKFN0cmluZykgJyArIHRvZihTdHJpbmcpKTtcclxuXHRcdFx0XHJcblx0XHRcdGlmICh0b2Yoc3BlYykgPT09ICdmdW5jdGlvbicpIHtcclxuXHRcdFx0XHR0aGlzLmRhdGFfdHlwZV9jb25zdHJ1Y3RvciA9IHNwZWM7XHJcblx0XHRcdH1cclxuXHRcdFx0XHJcblx0XHRcdHRoaXMuX2NvbnN0cmFpbnRfdHlwZSA9ICdkYXRhX3R5cGUnO1xyXG5cdFx0XHRcclxuXHRcdH0sXHJcblx0ICAgIC8qKlxyXG4gICAgICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGB2YWx1ZWAgbWF0Y2hlcyB0aGUgaXRlbSB0eXBlIGNvbnN0cmFpbnQuXHJcbiAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gdmFsdWUgLSBvYmplY3QgdG8gY2hlY2tcclxuICAgICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29yZS9jb25zdHJhaW50LkNvbGxlY3Rpb25fRGF0YV9UeXBlX0NvbnN0cmFpbnRcclxuICAgICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAqIHZhciBjID0gbmV3IENvbnN0cmFpbnQuQ29sbGVjdGlvbl9EYXRhX1R5cGUoTnVtYmVyKTtcclxuICAgICAgICAqIGMubWF0Y2goMSkgID09PiB0cnVlXHJcbiAgICAgICAgKiBjLm1hdGNoKFwiMVwiKSAgPT0+IGZhbHNlXHJcbiAgICAgICAgKiBcclxuICAgICAgICAqIFxyXG4gICAgICAgICogdmFyIGMyID0gbmV3IENvbnN0cmFpbnQuQ29sbGVjdGlvbl9EYXRhX1R5cGUoTXlCb29rKTtcclxuICAgICAgICAqIGMyLm1hdGNoKG5ldyBNeUJvb2soKSkgID09PiB0cnVlXHJcbiAgICAgICAgKiBjMi5tYXRjaChuZXcgTnVtYmVyKDEpKSAgPT0+IGZhbHNlXHJcbiAgICAgICAgKiBcclxuICAgICAgICAqL1xyXG5cdCAgICAnbWF0Y2gnOiBmcChmdW5jdGlvbiAoYSwgc2lnKSB7XHJcblx0XHRcdC8vY29uc29sZS5sb2coJycpO1xyXG5cdFx0XHQvL2NvbnNvbGUubG9nKCcqICBtYXRjaCBzaWcgJyArIHNpZyk7XHJcblx0XHRcdC8vY29uc29sZS5sb2coJ3RoaXMuZGF0YV90eXBlX2NvbnN0cnVjdG9yICcgKyB0aGlzLmRhdGFfdHlwZV9jb25zdHJ1Y3Rvcik7XHJcblx0XHRcdC8vY29uc29sZS5sb2coJ2FbMF0gJyArIGFbMF0pO1xyXG5cdFx0XHQvL2NvbnNvbGUubG9nKCd0b2YoYVswXSkgJyArIHRvZihhWzBdKSk7XHJcblx0XHRcdC8vY29uc29sZS5sb2coJ2FbMF0gaW5zdGFuY2VvZiB0aGlzLmRhdGFfdHlwZV9jb25zdHJ1Y3RvciAnICsgKGFbMF0gaW5zdGFuY2VvZiB0aGlzLmRhdGFfdHlwZV9jb25zdHJ1Y3RvcikpO1xyXG5cdFx0XHRcclxuXHRcdFx0dmFyIHRhMCA9IHRvZihhWzBdKTtcclxuXHRcdFx0Ly9jb25zb2xlLmxvZygndGEwICcgKyB0YTApO1xyXG5cdFx0XHRpZiAodGEwID09ICdudW1iZXInKSB7XHJcblx0XHRcdFx0Ly9jb25zb2xlLmxvZyh0aGlzLmRhdGFfdHlwZV9jb25zdHJ1Y3RvciA9PT0gTnVtYmVyKTtcclxuXHRcdFx0XHRpZiAodGhpcy5kYXRhX3R5cGVfY29uc3RydWN0b3IgPT09IE51bWJlcikgcmV0dXJuIHRydWU7XHJcblx0XHRcdH1cclxuXHRcdFx0Ly8gQnV0IGNhbiBwZXJmb3JtIGNhc3RpbmcgLyBjb252ZXJzaW9uLlxyXG5cdFx0XHRpZiAodGEwID09ICdzdHJpbmcnKSB7XHJcblx0XHRcdFx0Ly9jb25zb2xlLmxvZyh0aGlzLmRhdGFfdHlwZV9jb25zdHJ1Y3RvciA9PT0gTnVtYmVyKTtcclxuXHRcdFx0XHRpZiAodGhpcy5kYXRhX3R5cGVfY29uc3RydWN0b3IgPT09IFN0cmluZykgcmV0dXJuIHRydWU7XHJcblx0XHRcdH1cclxuXHRcdFx0XHJcblx0XHRcdGlmICh0aGlzLmRhdGFfdHlwZV9jb25zdHJ1Y3RvciAmJiBhWzBdIGluc3RhbmNlb2YgdGhpcy5kYXRhX3R5cGVfY29uc3RydWN0b3IpIHtcclxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdFx0fVxyXG5cdFx0XHRcclxuXHRcdFx0Ly9pZiAoc2lnID09ICdbRF0nKSB7XHJcblx0XHRcdC8vXHQvLyBtYXRjaGluZyBhIERhdGFfT2JqZWN0IGFnYWluc3QgdGhlc2UgY29uc3RyYWludHMuXHJcblx0XHRcdFx0XHJcblx0XHRcdC8vXHQvL3ZhciBjX3JlcyA9IHRoaXMuZGF0YV9vYmplY3Qub2JqX21hdGNoZXNfZmllbGRfY29uc3RyYWludHMoYVswXSk7XHJcblx0XHRcdC8vXHQvL3JldHVybiBjX3JlcztcclxuXHRcdFx0XHRcclxuXHRcdFx0Ly9cdGlmICh0aGlzLmRhdGFfdHlwZV9jb25zdHJ1Y3Rvcikge1xyXG5cdFx0XHQvL1x0XHRyZXR1cm4gYVswXSBpbnN0YW5jZW9mIHRoaXMuZGF0YV90eXBlX2NvbnN0cnVjdG9yO1xyXG5cdFx0XHQvL1x0fVxyXG5cdFx0XHRcdFxyXG5cdFx0XHQvL1x0Ly9yZXR1cm4gXHJcblx0XHRcdFx0XHJcblx0XHRcdC8vfVxyXG5cdFx0XHRcclxuXHRcdFx0Ly8vLyBNYXkgYmUgZ2l2ZW4gYSBjb2xsZWN0aW9uIGhlcmUuXHJcblx0XHRcdC8vaWYgKHNpZyA9PSAnW0NdJykge1xyXG5cdFx0XHQvL1x0Ly8gQSBjb2xsZWN0aW9uIG1heSBob2xkIGNvbnN0cmFpbnRzIGZvciBhIHR5cGUgb2YgY29sbGVjdGlvbi5cclxuXHRcdFx0XHRcclxuXHRcdFx0Ly9cdC8vIERhdGFiYXNlIGhvbGRzIFRhYmxlcyBDb2xsZWN0aW9uLCB3aGljaCBpcyBvZiB0aGUgVGFibGUgaXRlbS5cclxuXHRcdFx0XHRcclxuXHRcdFx0Ly9cdC8vIGxldCdzIGhhdmUgYSBsb29rIGF0IHRoYXQgY29sbGVjdGlvbi5cclxuXHRcdFx0Ly9cdHZhciBvYmogPSBhWzBdO1xyXG5cdFx0XHQvL1x0Ly9jb25zb2xlLmxvZygnb2JqICcgKyBzdHJpbmdpZnkob2JqKSk7XHJcblx0XHRcdFx0XHJcblx0XHRcdC8vXHQvLyBlZyBjb2xsZWN0aW9uIG9mIHRhYmxlcy5cclxuXHRcdFx0Ly9cdC8vLyAgcHJvYmFibHkgc2hvdWxkIGhhdmUgaXRzIGRhdGEgdHlwZSBjb25zdHJhaW50P1xyXG5cdFx0XHRcdFxyXG5cdFx0XHQvL1x0dmFyIG9ial9uYW1lID0gb2JqLmdldCgnbmFtZScpO1xyXG5cdFx0XHQvL1x0Ly9jb25zb2xlLmxvZygnb2JqX25hbWUgJyArIG9ial9uYW1lKTtcclxuXHRcdFx0XHRcclxuXHRcdFx0XHRcclxuXHRcdFx0XHRcclxuXHRcdFx0Ly9cdC8vIHdlIG1heSBiZSBhYmxlIHRvIGdldCB0aGUgZGF0YV90eXBlX2NvbnN0cmFpbnQgb2YgdGhhdCBjb2xsZWN0aW9uLlxyXG5cdFx0XHQvL1x0Ly8gIEl0IG1heSBiZSBhIGR0YyB0aGF0IGltcGxpZXMgaXQgY2FuIHRha2UgYSBjb2xsZWN0aW9uLCBtYXliZSBhIGNvbGxlY3Rpb24gb2YgYSBwYXJ0aWN1bGFyIHR5cGUgb2Ygb2JqZWN0LlxyXG5cdFx0XHRcdFxyXG5cdFx0XHQvL1x0Ly9jb25zb2xlLmxvZygnb2JqLl9kYXRhX3R5cGVfY29uc3RyYWludCAnICsgc3RyaW5naWZ5KG9iai5fZGF0YV90eXBlX2NvbnN0cmFpbnQpKTtcclxuXHRcdFx0Ly9cdC8vIHNvLCBhIGNvbGxlY3Rpb24gd2hlbiBnaXZlbiBhIHR5cGVkIGNvbGxlY3Rpb24gYXMgaXQncyBkYXRhX3R5cGUgd2lsbCBuZWVkIHRvIHJlc3BvbmQgY29ycmVjdGx5LlxyXG5cdFx0XHQvL1x0Ly8gIHNldHRpbmcgaXRzIF9kYXRhX3R5cGVfY29uc3RyYWludFxyXG5cdFx0XHRcdFxyXG5cdFx0XHQvL1x0Ly9jb25zb2xlLmxvZygnb2JqLl9kYXRhX3R5cGVfY29uc3RyYWludC5kYXRhX3R5cGVfY29uc3RydWN0b3IgJyArIHN0cmluZ2lmeShvYmouX2RhdGFfdHlwZV9jb25zdHJhaW50LmRhdGFfdHlwZV9jb25zdHJ1Y3RvcikpO1xyXG5cdFx0XHRcdFxyXG5cdFx0XHQvL1x0Ly9kYXRhX3R5cGVfY29uc3RydWN0b3JcclxuXHRcdFx0XHRcclxuXHRcdFx0Ly9cdC8vY29uc29sZS5sb2coJ3RoaXMuZGF0YV90eXBlX2NvbnN0cnVjdG9yICcgKyBzdHJpbmdpZnkodGhpcy5kYXRhX3R5cGVfY29uc3RydWN0b3IpKTtcclxuXHRcdFx0Ly9cdC8vdmFyIHN0YWNrID0gbmV3IEVycm9yKCkuc3RhY2tcclxuXHRcdFx0Ly9cdC8vY29uc29sZS5sb2coIHN0YWNrIClcdFx0XHRcdFxyXG5cdFx0XHQvL1x0Ly90aHJvdygnMTMpIHN0b3AnKTtcclxuXHRcdFx0XHRcclxuXHRcdFx0Ly9cdC8vdmFyIHJlcyA9IG9iaiBpbnN0YW5jZW9mIG9iai5fZGF0YV90eXBlX2NvbnN0cmFpbnQuZGF0YV90eXBlX2NvbnN0cnVjdG9yO1xyXG5cdFx0XHQvL1x0dmFyIHJlcyA9IG9iaiBpbnN0YW5jZW9mIHRoaXMuZGF0YV90eXBlX2NvbnN0cnVjdG9yO1xyXG5cdFx0XHQvL1x0Ly9jb25zb2xlLmxvZygncmVzICcgKyByZXMpO1xyXG5cdFx0XHQvL1x0Ly8gbmljZSwgc2VlbXMgdG8gd29yay5cclxuXHRcdFx0XHRcclxuXHRcdFx0Ly9cdHJldHVybiByZXM7XHJcblx0XHRcdC8vXHQvLyBzZWUgaWYgdGhlIGNvbGxlY3Rpb24ncyBfZGF0YV90eXBlX2NvbnN0cmFpbnQgbWF0Y2hlcyB0aGUgY29uc3RydWN0b3IgaW4gdGhpcyBjb25zdHJhaW50LlxyXG5cdFx0XHRcdFxyXG5cdFx0XHRcdFxyXG5cdFx0XHQvL1x0Ly8gdGhpcyBkb2VzIGdldCBhIGJpdCBjb21wbGljYXRlZCB3aXRoIHRoZSBzYW1lIGNvZGUgYmVpbmcgdXNlZCBvbiBkaWZmZXJlbnQgbmVzdGVkIGxldmVscy5cclxuXHRcdFx0Ly9cdC8vICBJJ2xsIG5lZWQgdG8gY3V0IGRvd24gb24gZmVhdHVyZSBhZGRpdGlvbiBvbiB0aGlzLCBhbmQgbWFrZSBzdXJlIHRoZSBBUEkgaXMgd29ya2luZyBhbmQgc3RhYmxlLlxyXG5cdFx0XHQvL1x0Ly8gIERvY3VtZW50IGl0IHRvby5cclxuXHRcdFx0XHRcclxuXHRcdFx0Ly9cdC8vIEp1c3QgbmVlZCBpdCB0byBnZW5lcmF0ZSB0aGVzZSByZWxhdGlvbmFsLCBvciBzZW1pLXJlbGF0aW9uYWwgZGF0YWJhc2VzLlxyXG5cdFx0XHQvL1x0Ly8gIE5lZWQgdG8gZ2V0IHRoZSB3aG9sZSB3ZWIgcGxhdGZvcm0gcnVubmluZy5cclxuXHRcdFx0XHRcclxuXHRcdFx0Ly9cdC8vIFRoZSBzeXN0ZW0gaGFzIGdvdCBwcmV0dHkgYmlnLCBzdGlsbCB3aWxsIG5lZWQgYSBiaXQgbW9yZSBmb3IgdGhlIHdob2xlIGRhdGFiYXNlIHN1cHBvcnQuXHJcblx0XHRcdC8vXHQvLyAgV2lsbCBsaWtlbHkgbWFrZSBzb21lIGRhdGFiYXNlIGNvbm5lY3RlZCBleHRlbnNpb25zLi4uIG9yIG1heWJlIG1vcmUgc3luYyBjb2RlIGluIHRoZSAnRGF0YWJhc2UnIGNsYXNzLlxyXG5cdFx0XHRcdFx0XHRcdFx0XHJcblx0XHRcdC8vXHQvL3JldHVybiBcclxuXHRcdFx0Ly99XHJcblx0XHRcdC8vXHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0XHJcblx0XHR9KVxyXG5cdH0pO1xyXG5cdFxyXG5cdC8vIFdpbGwgYmUgdXNlZCBmb3IgY2hlY2tpbmcgZXZlcnkgVGFibGUgdGhhdCBnZXRzIHB1dCBpbnRvIGEgRGF0YWJhc2UgaXMgYSBUYWJsZSBldGMuXHJcblx0Ly8gIFVzZWQgdG8gZW5mb3JjZSBzdHN0aWMgdHlwaW5nLlxyXG5cdFxyXG5cdC8vIFNvbWV0aGluZyB2ZXJ5IHNpbWlsYXIgY291bGQgYmUgdXNlZCB0byBlbmZvcmNlIHN0YXRpYyB0eXBpbmcgb24gRGF0YV9PYmplY3RzLlxyXG5cdC8vICBUaGF0IHdpbGwgcmVzdHJpY3QgdGhlIG9iamVjdHMgdGhhdCBjYW4gZ2V0IHB1dCBpbnRvIERhdGFfT2JqZWN0cyB0byBiZWluZyBhIHBhcnRpY3VsYXIgY2xhc3MgLyBzdWJjbGFzcyBjaGFpbi5cclxuXHRcclxuXHQvLyBDb2xsZWN0aW9uX0RhdGFfT2JqZWN0X0NvbnN0cmFpbnRcclxuXHQvLyAgVXNlZCBmb3IgbWFraW5nIGEgQ29sbGVjdGlvbiBsaWtlIGEgVGFibGUgaW4gYSBEQi5cclxuXHQvLyAgVGhpcyB3YXkgdGhlIENvbGxlY3Rpb24gaXMgY29uc3RyYWluZWQgdG8gc3RvcmluZyBvbmUgdHlwZSBvZiBvYmplY3QuXHJcblx0XHJcblx0Ly8gQ291bGQgYmUgYSBkYXRhIHR5cGUgY29uc3RyYWludC4uLiB1c2VkIGZvciBob2xkaW5nIHRoZSByZXF1aXJlZCBmaWVsZHMuXHJcblx0Ly8gIE5vdCBqdXN0IGZvciBjaGVja2luZyB0aGUgZGF0YV90eXBlLi4uIG11c3QgY2hlY2sgdGhhdCB0aGUgb2JqZWN0cyBjb25mb3JtIHRvIHRoZSBEYXRhX09iamVjdCdzIGNvbnN0cmFpbnRzLlxyXG5cdC8vICBNYXkgYmUgYWJsZSB0byBtYWtlIGEgZGF0YV9vYmplY3QgdGhhdCBjYW4ndCBiZSBjb25zdHJ1Y3RlZCB3aXRob3V0IHRoZSByaWdodCBmaWVsZHMuLi5cclxuXHRcclxuXHQvL3ZhciBDb2xsZWN0aW9uX0RhdGFfT2JqZWN0X0NvbnN0cmFpbnQgPSBDb2xsZWN0aW9uX0NvbnN0cmFpbnQuZXh0ZW5kKHtcclxuXHQvL1x0J2luaXQnOiBmdW5jdGlvbihzcGVjKSB7XHJcblx0Ly9cdFx0aWYgKHRvZihzcGVjKSA9PSAnZGF0YV9vYmplY3QnKSB7XHJcblx0Ly9cdFx0XHR0aGlzLmRhdGFfb2JqZWN0ID0gc3BlYztcclxuXHQvL1x0XHR9XHJcblxyXG5cdC8vXHRcdC8vIE1heSBhbHNvIHdhbnQgdG8gZGVmaW5lIGEgdGFibGUgZGF0YSBvYmplY3QgY29uc3RyYWludCBsaWtlOlxyXG5cdC8vXHRcdC8vICB7XCJhZGRyZXNzXCI6IFwic3RyaW5nXCIsIFwiZmFtaWx5XCI6IFwic3RyaW5nXCIsIFwiaW50ZXJuYWxcIjogXCJib29sZWFuXCJ9XHJcblx0Ly9cdFx0Ly8gIChpcyBpdCBhIGNvbnN0cmFpbnQgcmVhbGx5PyBvciBqdXN0IGEgY29sbGVjdGlvbiBvZiBmaWVsZHM/KVxyXG5cdC8vXHRcdC8vICAgSSB0aGluayBpdCdzIGEgY29uc3RyYWludCBiZWNhdXNlIGl0IHJlc3RyaWN0cyB0aGVpciB0eXBlcy5cclxuXHJcblx0Ly9cdFx0Ly9jb25zb2xlLmxvZygnQ29sbGVjdGlvbl9EYXRhX09iamVjdF9Db25zdHJhaW50IHRvZihzcGVjKSAnICsgdG9mKHNwZWMpKTtcclxuXHJcblxyXG5cdFx0XHRcclxuXHQvL1x0XHR0aGlzLl9jb25zdHJhaW50X3R5cGUgPSAnZGF0YV9vYmplY3QnO1xyXG5cdFx0XHRcclxuXHQvL1x0fSxcclxuXHQvL1x0J21hdGNoJzogZnAoZnVuY3Rpb24oYSwgc2lnKSB7XHJcblx0Ly9cdFx0Ly9jb25zb2xlLmxvZygnbWF0Y2ggc2lnICcgKyBzaWcpO1xyXG5cdC8vXHRcdC8vY29uc29sZS5sb2coJ21hdGNoIGEgJyArIHN0cmluZ2lmeShhKSk7XHJcblx0Ly9cdFx0aWYgKHNpZyA9PSAnW0RdJykge1xyXG5cdC8vXHRcdFx0Ly8gbWF0Y2hpbmcgYSBEYXRhX09iamVjdCBhZ2FpbnN0IHRoZXNlIGNvbnN0cmFpbnRzLlxyXG5cdFx0XHRcdFxyXG5cdC8vXHRcdFx0dmFyIGNfcmVzID0gdGhpcy5kYXRhX29iamVjdC5vYmpfbWF0Y2hlc19maWVsZF9jb25zdHJhaW50cyhhWzBdKTtcclxuXHQvL1x0XHRcdHJldHVybiBjX3JlcztcclxuXHQvL1x0XHR9XHJcblx0XHRcdFxyXG5cdC8vXHRcdC8vIE1heSBiZSBnaXZlbiBhIGNvbGxlY3Rpb24gaGVyZS5cclxuXHQvL1x0XHRpZiAoc2lnID09ICdbQ10nKSB7XHJcblx0Ly9cdFx0XHQvLyBBIGNvbGxlY3Rpb24gbWF5IGhvbGQgY29uc3RyYWludHMgZm9yIGEgdHlwZSBvZiBjb2xsZWN0aW9uLlxyXG5cdFx0XHRcdFxyXG5cdC8vXHRcdFx0Ly8gRGF0YWJhc2UgaG9sZHMgVGFibGVzIENvbGxlY3Rpb24sIHdoaWNoIGlzIG9mIHRoZSBUYWJsZSBpdGVtLlxyXG5cdFx0XHRcdFxyXG5cdC8vXHRcdFx0Ly8gbGV0J3MgaGF2ZSBhIGxvb2sgYXQgdGhhdCBjb2xsZWN0aW9uLlxyXG5cdC8vXHRcdFx0dmFyIG9iaiA9IGFbMF07XHJcblx0Ly9cdFx0XHQvL2NvbnNvbGUubG9nKCdvYmogJyArIHN0cmluZ2lmeShvYmopKTtcclxuXHRcdFx0XHRcclxuXHQvL1x0XHRcdC8vIGdldCB0aGUgY29uc3RyYWludCBmb3IgdGhhdCBmaWVsZC4uLlxyXG5cdC8vXHRcdFx0Ly8gIGl0IHNob3VsZCBoYXZlIGJlZW4gcHV0IGluIHdoZW4gdGhlIGZpZWxkIGdldHMgc3BlY2lmaWVkLlxyXG5cdFx0XHRcdFxyXG5cdC8vXHRcdFx0Ly9lYWNoKG9iaiwgZnVuY3Rpb24oaSwgdikge1xyXG5cdC8vXHRcdFx0Ly9cdGNvbnNvbGUubG9nKCdpICcgKyBpKTtcclxuXHQvL1x0XHRcdC8vXHRjb25zb2xlLmxvZygndiAnICsgdik7XHJcblx0Ly9cdFx0XHQvL30pO1xyXG5cdFx0XHRcdFxyXG5cdC8vXHRcdFx0Ly8gYSBsb3dlciBsZXZlbCBlYWNoP1xyXG5cdC8vXHRcdFx0Ly8gIFRoZSBDb2xsZWN0aW9uIG9iamVjdCBoYXMgZ290IGZhaXJseSBiaWcgYW5kIGNvbXBsaWNhdGVkLlxyXG5cdC8vXHRcdFx0Ly8gIHdhbnQgdG8gYmUgYWJsZSB0byB2aWV3IGFsbCBpdHMgY29uc3RyYWludHMgZWFzaWx5LlxyXG5cdFx0XHRcdFxyXG5cdC8vXHRcdFx0Ly8gaXQgbWF5IGhhdmUgYSBkYXRhX3R5cGVfY29uc3RyYWludC5cclxuXHQvL1x0XHRcdC8qXHJcblx0Ly9cdFx0XHR2YXIgY29sbF9kdGMgPSBvYmouX2RhdGFfdHlwZV9jb25zdHJhaW50O1xyXG5cdC8vXHRcdFx0Y29uc29sZS5sb2coJ2NvbGxfZHRjICcgKyBjb2xsX2R0Yyk7XHJcblx0Ly9cdFx0XHQvL2NvbnNvbGUubG9nKCdjb2xsX2R0YyAnICsgc3RyaW5naWZ5KGNvbGxfZHRjKSk7XHJcblx0XHRcdFx0XHJcblx0XHRcdFx0XHJcblx0XHRcdFx0XHJcblx0XHRcdFx0XHJcblx0Ly9cdFx0XHR2YXIgc3RhY2sgPSBuZXcgRXJyb3IoKS5zdGFja1xyXG5cdC8vXHRcdFx0Y29uc29sZS5sb2coIHN0YWNrIClcclxuXHRcdFx0XHRcclxuXHRcdFx0XHRcclxuXHQvL1x0XHRcdHRocm93KCcxNCkgc3RvcCcpO1xyXG5cdC8vXHRcdFx0Ki9cclxuXHQvL1x0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHRcdFxyXG5cdFx0XHRcdFxyXG5cdC8vXHRcdH1cclxuXHRcdFx0XHJcblx0Ly9cdH0pXHJcblx0XHRcclxuXHQvL30pO1xyXG5cdFxyXG5cdFxyXG5cdFxyXG5cdFxyXG5cdC8vIE9uZSBvZiB0aGVzZSBjYW4gYmUgc2V0IHRvIHByaW1hcnkuIFRoZSBmaXJzdCBvbmUgaXMgYnkgZGVmYXVsdC5cclxuXHQvLyAgVGhlIG9yZGVyIG9mIHRoZSB1bmlxdWUgaW5kZXhlcyBtYXR0ZXJzLlxyXG5cdFxyXG5cdHZhciBVbmlxdWVfQ29uc3RyYWludCA9IENvbGxlY3Rpb25fQ29uc3RyYWludC5leHRlbmQoe1xyXG5cclxuXHQgICAgLyoqIFxyXG4gICAgICAgICogQGNsYXNzZGVzYyBDb2xsZWN0aW9uIHVuaXF1ZSBjb25zdHJhaW50LlxyXG4gICAgICAgICpcclxuICAgICAgICAqIFRoZSBjbGFzcyBkb2VzIG5vdCBwcm92aWRlIHRoZSBgbWF0Y2goKWAgbWV0aG9kLCBidXQgcHJvdmlkZXMgYC5maWVsZHNgIHByb3BlcnR5IGZvciB0aGUgdW5pcXVlIGZpZWxkIG5hbWVzLlxyXG4gICAgICAgICpcclxuICAgICAgICAqIFRoZSBjbGFzcyBwdWJsaWMgbmFtZSBpcyA8c3Ryb25nPlVuaXF1ZTwvc3Ryb25nPiAoZS5nLiBgbmV3IENvbnN0cmFpbnQuVW5pcXVlKClgKS5cclxuICAgICAgICAqIEBjb25zdHJ1Y3RzIG1vZHVsZTpjb3JlL2NvbnN0cmFpbnQuVW5pcXVlX0NvbnN0cmFpbnQgXHJcbiAgICAgICAgKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gc3BlYyAtIHVuaXF1ZSBmaWVsZCBuYW1lKHMpXHJcbiAgICAgICAgKiBcclxuICAgICAgICAqL1xyXG5cdCAgICAnaW5pdCc6IGZ1bmN0aW9uIChzcGVjKSB7XHJcblx0XHRcdHRoaXMuX3N1cGVyKHNwZWMpO1xyXG5cdFx0XHRcclxuXHRcdFx0Ly90aGlzLnNldCgnY29uc3RyYWludF90eXBlJywgJ3VuaXF1ZScpO1xyXG5cdFx0XHRcclxuXHRcdFx0dGhpcy5fY29uc3RyYWludF90eXBlID0gJ3VuaXF1ZSc7XHJcblx0XHRcdFxyXG5cdFx0XHQvLyBmaWVsZCAobmFtZSkgb3IgYWN0dWFsIGZpZWxkIChyZWZlcmVuY2UgdG8gYSBmaWVsZCBjb25zdHJhaW50KS5cclxuXHRcdFx0XHJcblx0XHRcdC8vIGJ1dCBmaWVsZCBjb3VsZCBiZSBwbHVyYWwgdG9vXHJcblx0XHRcdC8vICB3aWxsIGJlIGEgY29udmVudGlvbiB0aGF0IHRoZSBzaW5ndWxhciBoZXJlIGNhbiBzb21ldGltZXMgcmVmZXIgdG8gcGx1cmFsLlxyXG5cdFx0XHQvLyAgbWF5YmUgcGx1cmFsIHdvdWxkIGJlIGJldHRlcj9cclxuXHRcdFx0aWYgKGlzX2RlZmluZWQoc3BlYy5maWVsZHMpKSB0aGlzLmZpZWxkcyA9IHNwZWMuZmllbGRzO1xyXG5cdFx0XHRcclxuXHRcdFx0aWYgKHRvZih0aGlzLmZpZWxkcykgPT0gJ2FycmF5Jykge1xyXG5cdFx0XHRcdHRoaXMuX3NvcnRlZF9maWVsZHMgPSBjbG9uZSh0aGlzLmZpZWxkcykuc29ydCgpO1xyXG5cdFx0XHR9XHRcdFxyXG5cdCAgICB9XHJcblxyXG5cdCAgICAvKiogXHJcbiAgICAgICAgKiBAbmFtZSBmaWVsZHNcclxuICAgICAgICAqIEBtZW1iZXJcclxuICAgICAgICAqIEB0eXBlIHtzdHJpbmd8c3RyaW5nW119XHJcbiAgICAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvcmUvY29uc3RyYWludC5VbmlxdWVfQ29uc3RyYWludFxyXG4gICAgICAgICogQGluc3RhbmNlXHJcbiAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICogdmFyIGMgPSBuZXcgQ29uc3RyYWludC5VbmlxdWUoXCJJRFwiKTtcclxuICAgICAgICAqIGMuZmllbGRzICA9PT4gXCJJRFwiXHJcbiAgICAgICAgKiBcclxuICAgICAgICAqL1xyXG5cclxuXHJcblx0XHQvLyBub3QgcmVhbGx5IHN1cmUgdGhlIGNvbnN0cmFpbnQgd2lsbCBkbyBtdWNoIGhlcmUuLi4gaXQgcmVxdWlyZXMgYW4gaW5kZXggdG8gYmUgc2V0IHVwLlxyXG5cdFx0Ly8gIHBlcmhhcHMgdGVsbHMgdGhlIGluZGV4IG5vdCB0byBhY2NlcHQgZHVwbGljYXRlcz9cclxuXHRcclxuXHRcdC8vIHRlc3QgdGhlIGNvbnN0cmFpbnQ/XHJcblx0XHQvLyAgZG8gdGhhdCBvdXRzaWRlIGZvciB0aGUgbW9tZW50XHJcblx0XHJcblx0XHJcblx0fSk7XHJcblx0XHJcblx0XHJcblx0XHJcblx0XHJcblx0Ly92YXIgUmVsYXRpb25zaGlwX0NvbnN0cmFpbnQgPSBDb2xsZWN0aW9uX0NvbnN0cmFpbnQuZXh0ZW5kKHtcclxuXHQvL1x0J2luaXQnOiBmdW5jdGlvbihzcGVjKSB7XHJcblx0Ly9cdFx0dGhpcy5fc3VwZXIoc3BlYyk7XHJcblx0XHRcdFxyXG5cdC8vXHRcdC8vIHdoaWNoIG90aGVyIGNvbGxlY3Rpb24ocykgYW5kIGZpZWxkKHMpIGRvZXMgaXQgcmVmZXJlbmNlP1xyXG5cdFx0XHRcclxuXHQvL1x0XHQvLyB3aGF0IGZvcm0gZG9lcyB0aGUgcmVsYXRpb25zaGlwIHRha2U/XHJcblx0XHRcdFxyXG5cdC8vXHRcdC8vIGZpbGVzIGluIGEgZm9sZGVyXHJcblx0Ly9cdFx0Ly8gIGFnZ3JlZ2F0aW9uXHJcblx0Ly9cdFx0Ly8gIGhhcyAoY29tcG9zZWQgb2YpXHJcblx0Ly9cdFx0Ly8gIG1hbnktdG8tb25lXHJcblx0Ly9cdFx0Ly8gICBhZ2dyZWdhdGlvbl90b19pdGVtIChidXQgbWF5YmUgd2Ugd291bGQgYmUgc2F5aW5nIHRoZSBmb2xkZXIgJ2hhcycgZmlsZXMpXHJcblx0XHRcdFxyXG5cdFx0XHRcclxuXHQvL1x0XHQvLyBmcmllbmRzXHJcblx0Ly9cdFx0Ly8gIG1hbnktdG8tbWFueVxyXG5cdC8vXHRcdC8vICBhc3NvY2lhdGlvblxyXG5cdC8vXHRcdC8vICBoYXMgKGFzIGZyaWVuZCkgLyBpcyBhc3NvY2lhdGVkIHdpdGhcclxuXHQvL1x0XHQvLyAgIHVzZSBqb2luIHRhYmxlXHJcblx0Ly9cdFx0Ly8gICBhc3NvY2lhdGlvbl9iZXR3ZWVuX2l0ZW1zXHJcblx0XHRcdFxyXG5cdC8vXHRcdC8vIGVtcGxveWVlcy1wcm9qZWN0c1xyXG5cdC8vXHRcdC8vICBtYW55LXRvLW1hbnlcclxuXHQvL1x0XHQvLyAgYXNzb2NpYXRpb25cclxuXHQvL1x0XHQvLyAgaXMgYXNzb2NpYXRlZCB3aXRoIFxyXG5cdC8vXHRcdC8vICAgdXNlIGpvaW4gdGFibGVcclxuXHQvL1x0XHQvLyAgIGFzc29jaWF0aW9uX2JldHdlZW5faXRlbXNcclxuXHRcdFx0XHJcblx0XHRcdFxyXG5cdC8vXHRcdC8vIHVzZXJfcm9sZXNcclxuXHQvL1x0XHQvLyAgYWdncmVnYXRpb24/IFxyXG5cdC8vXHRcdC8vICBtYXliZSBhc3NvY2lhdGlvblxyXG5cdC8vXHRcdC8vICBvbmUtdG8tbWFueVxyXG5cdC8vXHRcdC8vICB1c2VyIGlzIGFzc29jaWF0ZWQgd2l0aCByb2xlc1xyXG5cdFx0XHRcclxuXHQvL1x0XHQvLyBlbXBsb3llZS1wYXlfYmFuZFxyXG5cdC8vXHRcdC8vICBhc3NvY2lhdGlvbj9cclxuXHQvL1x0XHQvLyAgb25lX3RvX29uZVxyXG5cdC8vXHRcdC8vICB1c2VyIGhhcyB0aGF0IHBheSBiYW5kXHJcblx0XHRcdFxyXG5cdC8vXHRcdC8vIENvbXBvc2l0b24gZm9yIHN1Yi1pdGVtcz9cclxuXHRcdFx0XHJcblx0Ly9cdFx0Ly8gTWF5IGJlIGludGVyZXN0ZWQgaW4gbWFwcGluZyBpbmhlcml0YW5jZSBmb3IgdGhpcyBvYmplY3Qgc3lzdGVtXHJcblx0Ly9cdFx0Ly8gIEF0IHRoZSBtb21lbnQsIG5lZWQgdG8ganVzdCBtYXAgdGhlIEphdmFTY3JpcHQgc3RydWN0dXJlcyBpbnRvIHRoZSBkYXRhYmFzZSwgdGhlbiB3ZSdsbCBnZXQgdG8gd29yayB3aXRoXHJcblx0Ly9cdFx0Ly8gIGJ1aWxkaW5nIHVwIHRoZSBkYXRhYmFzZSBhbmQgY29tcG9uZW50cyBvZiBpdCB0aGF0IGRlYWwgd2l0aCB3ZWJzaXRlIGZ1bmN0aW9uYWxpdHkuXHJcblx0XHRcdFxyXG5cdC8vXHRcdC8vIE9uY2UgdGhpbmdzIGNhbiBxdWlja2x5IGJlIGRlY2xhcmVkIGFuZCB0aGVuIGNyZWF0ZWQgaW4gdGhlIGRhdGFiYXNlLCBpdCBzaG91bGQgYmUgcmVsYXRpdmVseSBmYXN0IHRvIGltcGxlbWVudCBwcm9ncmFtbWF0aWNcclxuXHQvL1x0XHQvLyAgY29tcG9uZW50cyB0aGF0IHdvcmsgcXVpY2tseSB3aXRoIHRoZSBEQiBhbmQgYWxzbyBjYW4gYmUgY3JlYXRlZCBxdWlja2x5LlxyXG5cdFx0XHRcclxuXHQvL1x0XHQvLyBUaGVyZSBpcyBzb21lIG1vcmUgdG8gZG8gd2l0aCB0aGlzIHdvcmssIGJ1dCBub3cgaXQgaXMgYXQgYSByZWFsbHkgZ29vZCBzdGFnZSB3aGVyZSBpdCBpcyBhYmxlIHRvIGRvIGEgbG90IG9mIHRoaW5ncyBpbiB0aGUgYmFja2dyb3VuZC5cclxuXHQvL1x0XHQvLyAgV2l0aCBzb21lIG1vcmUgY29kaW5nLCBpdCB3aWxsIGRvIGEgd2hvbGUgYnVuY2ggbW9yZSB0aGluZ3MuXHJcblx0XHRcdFxyXG5cdC8vXHRcdC8vIFdpbGwgZG8gc29tZSBtb3JlIHdvcmsgb24gdGhlIFhNTCAvIEhUTUwgdHJhbnNmb3JtYXRpb24uXHJcblx0Ly9cdFx0Ly8gIFRoYXQgd291bGQgYmUgb25lIG9mIHRoZSByZWFsbHkgYW1hemluZyB0aGluZ3MgaWYgSSB3ZXJlIHRvIHJlbGVhc2UgaXQgd2l0aCB0aGF0LlxyXG5cdFx0XHRcclxuXHQvL1x0XHQvLyBUaGUgZGVjbGFyYXRpdmUgd3JpdGluZyBvZiB0aGVzZSBwYWdlcyB3b3VsZCBiZSB2ZXJ5IGludGVyZXN0aW5nIGFuZCBnZXQgcGVvcGxlIGludGVyZXN0ZWQgd2l0aCB0aGUgSlNHVUkgcGxhdGZvcm0uXHJcblx0Ly9cdFx0Ly8gIFRoYXQgcGFydCBpcyBhbHNvIHNvbWV0aGluZyBpdCB3b3VsZCBiZSBpbnRlcmVzdGluZyB0byBnZXQgd3JpdHRlbiBpbiBDKysgb3IgQy5cclxuXHRcdFx0XHJcblx0Ly9cdFx0Ly8gQWxzbywgd2lsbCBiZSBpbnRlcmVzdGluZyB0byBoYXZlIGJpdHMgYW5kIHBpZWNlcyBhYm91dCB0ZWNobm9sb2d5IG9uIHRoZSB3ZWJzaXRlLlxyXG5cdC8vXHRcdC8vICBQcmVzZW50YXRpb25zLlxyXG5cdFx0XHRcclxuXHQvL1x0XHQvLyBJIHRoaW5rIGl0IGNvdWxkIGJlIHZlcnkgZ29vZCBhZHZlcnRpc2luZyBmb3IgbXkgb3duIHNlcnZpY2VzLCBhbmQgcmVsZWFzaW5nIHRoZSBKU0dVSSBvcGVuIHNvdXJjZSBmcmFtZXdvcmsgd2lsbCBkbyBhIGxvdCB0byBoZWxwIHRoaXMuXHJcblx0Ly9cdFx0Ly8gIEknbSBsaWtlbHkgdG8gcmVsZWFzZSB0aGUgY2xpZW50LXNpZGUgZnJhbWV3b3JrLCBhcyB3ZWxsIGFzIGEgc2VydmVyIGRpc3RyaWJ1dGlvbi5cclxuXHQvL1x0XHQvLyAgSSBkb3VidCBpdCB3b3VsZCBiZSB0aGUgZnVsbCAvIGRldmVsb3BtZW50IC8gaW50ZXJuYWwgZGlzdHJpYnV0aW9uLCBidXQgb25lIHRoYXQgaGFzIHZhcmlvdXMgdmVyeSB1c2VmdWwgZmVhdHVyZXMuXHJcblx0XHRcdFxyXG5cdC8vXHRcdC8vIEkgd291bGQgbGlrZWx5IGxpY2Vuc2UgY29tbWVyY2lhbCBtb2R1bGVzIGFzIHdlbGwsIHN1Y2ggYXMgYSBQb3N0Z3JlcyBDb25uZWN0b3IuXHJcblx0Ly9cdFx0Ly8gIEFsc28gd291bGQgaGF2ZSBhIG1hcmtldHBsYWNlIGZvciB0aG9zZSB3aG8gd2lzaCB0byBzZWxsIHRoZWlyIG93biBjb21wb25lbnRzIC0gYW5kIG1heSB3ZWxsIGJlIHNlbGxpbmcgYWR2ZXJ0aXNpbmcgdG8gdGhvc2Ugd2hvXHJcblx0Ly9cdFx0Ly8gIHdhbnQgdG8gc2VsbCB0aGVpciBvd24gY29tcG9uZW50cyBmb3IgaXQsIHBvc3NpYmx5IHRocm91Z2ggR29vZ2xlLlxyXG5cdFx0XHRcclxuXHQvL1x0XHQvLyBNYXkgZG8gZGVhbHMgd2l0aCBjb21wb25lbnQgbWFrZXMsIGNvdWxkIGhhdmUgc3BvbnNvcmVkIGxpc3RpbmdzPyBcclxuXHRcdFx0XHJcblx0Ly9cdFx0Ly8gVGhlIGJhc2ljIGZyYW1ld29yayBzaG91bGQgcHJvYmFibHkgYmUgcmVsZWFzZWQgYXMgb3Blbi1zb3VyY2UsIHRoZW4gSSBzaG91bGQgYmUgc2V0IGZvciBlbXBsb3lpbmcgcGVvcGxlIGFuZCBnZXR0aW5nIHBhaWQgdG8gZGV2ZWxvcCB0aGlzIGNvZGVcclxuXHQvL1x0XHQvLyAgZnVydGhlciBmb3IgY2xpZW50cyBpbiB0aGVpciBzeXN0ZW1zLlxyXG5cdFx0XHRcclxuXHQvL1x0XHQvLyBJIHRoaW5rIHRoaXMgY291bGQgbWFrZSBpdCBlYXN5IHRvIGdldCBhIGhpZ2ggcGVyZm9ybWFuY2Ugd2ViIHNlcnZlciBydW5uaW5nLlxyXG5cdC8vXHRcdC8vICBUaGF0IHdpbGwgYmUgdmVyeSBuaWNlIGluZGVlZC4gSSB0aGluayBib3RoIHRoZSBlYXNlIG9mIHVzZSBhbmQgY3VzdG9taXphYmlsaXR5IHdpbGwgYmUgaGlnaC5cclxuXHRcdFx0XHJcblx0Ly9cdFx0Ly8gSXQgd2lsbCBiZSB2ZXJ5IG5pY2UgdG8gaGF2ZSBhbiBhZHZhbmNlZCBhZG1pbiBpbnRlcmZhY2UgZ29pbmcgYWxvbmdzaWRlIGl0LlxyXG5cdC8vXHRcdC8vICBXb24ndCByZXF1aXJlIGluc3RhbGxpbmcgZmlsZXMsIGltYWdlcyBldGMsIGNvdWxkIGJlIHVzaW5nIGEgZmV3IHZlY3RvciBpbWFnZXMuXHJcblx0Ly9cdFx0Ly8gIEl0IG1heSBzdXJwcmlzZSBwZW9wbGUgd2hlbiB0aGV5IHNlZSBpdCwgdGhpbmtpbmcsIHdoZXJlIGRpZCB0aGF0IGNvbWUgZnJvbSwgd2hlbiB0aGV5IGFyZSBkb2luZyBzaW1wbGUsIGVhc2lseSxcclxuXHQvL1x0XHQvLyAgIGJ1dCB0aGVyZSBpcyBxdWl0ZSBhIGNvbXBsaWNhdGVkIGVuYWJsaW5nIHN5c3RlbSBhbGxvd2luZyBpdCB0byB3b3JrLlxyXG5cdFx0XHRcclxuXHQvL1x0XHQvLyBBbSBnZXR0aW5nIG11Y2ggY2xvc2VyIHRvIHRoZSBzb2Z0d2FyZSBnb2Fscy5cclxuXHQvL1x0XHQvLyAgVGhpbmsgSSdsbCBnZXQgYSByZWFsbHkgbmljZSBzeXN0ZW0gb25saW5lLiBEb24ndCBrbm93IHF1aXRlIGhvdyBsb25nLlxyXG5cdC8vXHRcdC8vICBJJ2xsIGdldCBhIGxvdCBkb25lIG92ZXIgdGhlIG5leHQgZmV3IGRheXMuXHJcblx0XHRcdFxyXG5cdC8vXHRcdC8vIFRoZXJlIG1heSBiZSBhIGZldyBtb3JlIHRoaW5ncyB0byBnZXQgcmVhbGx5IHJpZ2h0IGFsb25nIHRoZSBleGVjdXRpb24gcGF0aC5cclxuXHQvL1x0XHQvLyAgVGhlcmUgaXMgcXVpdGUgYSBsb3QgdG8gZG8gd2l0aCB0aGUgSFRNTCB0aGF0IG5lZWRzIHRvIHdvcmsuXHJcblx0Ly9cdFx0Ly8gIFNvbWUgb2YgdGhpcyB3aWxsIGJlIGV4cHJlc3NlZCBpbiB0ZXJtcyBvZiBmaWVsZCBjb3JyZWN0aW9ucyBhbmQgY29uc3RyYWludHMuXHJcblx0XHRcdFxyXG5cdC8vXHRcdC8vIFRoZXJlIGlzIG1heWJlIGFub3RoZXIgMzAwMCBtb3JlIGxpbmVzIHRoYXQgbmVlZHMgdG8gYmUgd3JpdHRlbiBmb3IgdGhpcz9cclxuXHRcdFx0XHJcblx0Ly9cdFx0Ly8gVGhlIHNlcnZlciBzaWRlIGxpYnJhcnkgd2lsbCBiZSBiaWcsIGJ1dCB3aWxsIGJlIGZvY3VzZWQgb24gcHJvZHVjaW5nIGVmZmljaWVudCBjbGllbnQtc2lkZSBvdXRwdXRcclxuXHQvL1x0XHQvLyAgSSdsbCBkbyB3b3JrIG9uIGRvY3VtZW50aW5nIGl0LlxyXG5cdFx0XHRcclxuXHQvL1x0XHQvLyBJdCB3b3VsZCBiZSBpbnRlcmVzdGluZyB0byBzZWUgaG93IGJpZyBhIGJ1aWxkIChzZXF1ZW50aWFsbHkgb3JkZXJlZCkgb2YgdGhlIEphdmFTY3JpcHQgZmlsZSBpcy5cclxuXHQvL1x0XHQvLyAgUGVyaGFwcyBzb21lIHRoaW5ncyB3b3VsZCBuZWVkIHRvIGJlIHJlbmFtZWQgc28gdGhhdCBsb3RzIG9mIHZhcnMgaW4gdGhlIGdsb2JhbCBuYW1lc3BhY2Ugd291bGQgd29yayB0b2dldGhlci5cclxuXHQvL1x0XHQvLyAgVGhlcmUgd291bGQgYmUgYSBsYXJnZSBhbW91bnQgb2YgZ2FpbiBwb3NzaWJsZSBpbiB0aGUgYnVpbGQgcHJvY2Vzcy5cclxuXHRcdFx0XHJcblx0Ly9cdFx0Ly8gVGhlIHNpemUgb2YgdGhlIHNtYWxsIGNsaWVudCBsaWJyYXJ5IGlzIG51ZGdpbmcgdXB3YXJkcy4gUGVyaGFwcyBpdCB3aWxsIGJlIGEgMjRLQiBkb3dubG9hZD8gRXZlbiAzMj9cclxuXHQvL1x0XHQvLyAgSXQgd2lsbCBkZWZpbml0ZWx5IGJlIGltcHJlc3NpdmUgdGhvdWdoLCB3aWxsIGVuYWJsZSBsb3RzIG9mIHRoaW5ncywgdXNlZnVsIGJ1c2luZXNzIGludGVyYWN0aW9ucy5cclxuXHRcdFx0XHJcblx0Ly9cdFx0Ly8gQ291bGQgaGF2ZSBhIHZlcnkgdXNlZnVsIHN5c3RlbSBmb3IgY29uZmVyZW5jZSBhdHRlbmRlZXMuXHJcblx0Ly9cdFx0Ly8gIEhvd2V2ZXIsIG5lZWQgdG8gZG8gdGhlIGNvbnN0cmFpbnRzLlxyXG5cdFx0XHRcclxuXHRcdFx0XHJcblx0XHRcdFxyXG5cdFx0XHRcclxuXHQvL1x0XHQvLyBMaWtlbHkgdG8gZ28gaW50byBtb3JlIGRldGFpbCBvbiB0aGUgcmVsYXRpb25zaGlwIGNvbnN0cmFpbnRzIHdoZW4gYWN0dWFsbHkgbWFraW5nIHRoZW0uXHJcblx0Ly9cdFx0Ly8gIFBlcmhhcHMgd2lsbCBiZSByZWxhdGVkIHRvIHNvbWV0aGluZyBpbiB0aGUgc2FtZSBjb2xsZWN0aW9uIG9yIERhdGFfT2JqZWN0P1xyXG5cdFx0XHRcclxuXHRcdFx0XHJcblx0XHRcdFxyXG5cdFx0XHRcclxuXHRcdFx0XHJcblx0XHRcdFxyXG5cdFx0XHRcclxuXHRcdFx0XHJcblx0XHRcdFxyXG5cdFx0XHRcclxuXHRcdFx0XHJcblx0XHRcdFxyXG5cdFx0XHRcclxuXHRcdFx0XHJcblx0XHRcdFxyXG5cdFx0XHRcclxuXHRcdFx0XHJcblx0XHRcdFxyXG5cdFx0XHRcclxuXHRcdFx0XHJcblx0XHRcdFxyXG5cdC8vXHRcdC8vIENvdWxkIHRhbGsgdG8gRCBhYm91dCBzZXR0aW5nIHVwIHRoZSBpbXBsZW1lbnRhdGlvbnMgb2YgaXQuXHJcblx0Ly9cdFx0Ly8gIFxyXG5cdFx0XHRcclxuXHRcdFx0XHJcblx0XHRcdFxyXG5cdFx0XHRcclxuXHRcdFx0XHJcblx0XHRcdFxyXG5cdFx0XHRcclxuXHRcdFx0XHJcblx0XHRcdFxyXG5cdFx0XHRcclxuXHRcdFx0XHJcblx0XHRcdFxyXG5cdFx0XHRcclxuXHRcdFx0XHJcblx0Ly9cdFx0Ly8gQWxzbyBsaWtlIHRoZSBpZGVhIG9mIGhhdmluZyBhIGRvbmF0ZSBmb3IgZmVhdHVyZSBib3guXHJcblx0XHRcdFxyXG5cdFx0XHRcclxuXHRcdFx0XHJcblx0XHRcdFxyXG5cdFx0XHRcclxuXHRcdFx0XHJcblx0XHRcdFxyXG5cdFx0XHRcclxuXHRcdFx0XHJcblx0XHRcdFxyXG5cdFx0XHRcclxuXHRcdFx0XHJcblx0XHRcdFxyXG5cdFx0XHRcclxuXHRcdFx0XHJcblx0Ly9cdFx0LypcclxuXHQvL1x0XHQgKiDvv71FYWNoIE9yZGVyIGlzIGFzc29jaWF0ZWQgd2l0aCBvbmUgb3IgbW9yZSBPcmRlckxpbmVzLu+/vVxyXG5cclxuXHQvL1x0XHRcdO+/vUVhY2ggT3JkZXJMaW5lIGlzIGFzc29jaWF0ZWQgd2l0aCBvbmUgYW5kIG9ubHkgb25lIE9yZGVyLu+/vVxyXG5cdFx0XHRcdFxyXG5cdC8vXHRcdFx077+9RWFjaCBPcmRlckxpbmUgaXMgYXNzb2NpYXRlZCB3aXRoIG9uZSBhbmQgb25seSBvbmUgUHJvZHVjdC7vv71cclxuXHRcdFx0XHRcclxuXHQvL1x0XHRcdO+/vUVhY2ggUHJvZHVjdCBpcyBhc3NvY2lhdGVkIHdpdGggemVybyBvciBtb3JlIE9yZGVyTGluZXMu77+9XHJcblx0Ly9cdFx0ICogXHJcblx0Ly9cdFx0ICovXHJcblx0XHRcdFxyXG5cdFx0XHRcclxuXHRcdFx0XHJcblx0Ly9cdH1cclxuXHQvL1x0Ly8gbm90IHJlYWxseSBzdXJlIHRoZSBjb25zdHJhaW50IHdpbGwgZG8gbXVjaCBoZXJlLi4uIGl0IHJlcXVpcmVzIGFuIGluZGV4IHRvIGJlIHNldCB1cC5cclxuXHQvL1x0Ly8gIHBlcmhhcHMgdGVsbHMgdGhlIGluZGV4IG5vdCB0byBhY2NlcHQgZHVwbGljYXRlcz9cclxuXHQvL30pO1xyXG5cdFxyXG5cdFxyXG5cdC8vIFJlbGF0aW9uc2hpcFxyXG5cdFxyXG5cdC8vIEZvcmVpZ25fS2V5IGNvbnN0cmFpbnQ/XHJcblx0Ly8gIE1heWJlIGNhbGwgdGhpcyBhIFJlZmVyZW5jZSBvciBSZWxhdGlvbnNoaXAgY29uc3RyYWludC5cclxuXHRcclxuXHQvLyBFeHByZXNzZWQgaW4gdGhlIGRhdGEgbW9kZWwsIHRoaXMgY291bGQgZGVzY3JpYmUgYSBtYW55LXRvLW1hbnkgcmVsYXRpb25zaGlwIHRoYXQgZ2V0cyBleHByZXNzZWQgdXNpbmcgYSBsaW5rcyB0YWJsZSBpbiBhbiBSREIuXHJcblx0Ly8gIFBvc3NpYmx5IHVzaW5nIGEgbGlua3MsIG9yIHRoZSBnZW5lcmFsIGxpbmtzIC8gcmVsYXRpb25zaGlwcyB0YWJsZSBpbiBhbiBPREIuXHJcblx0XHJcblx0XHJcblx0XHJcblx0XHJcblx0XHJcblx0Ly8gTm90IHNvIHN1cmUgYWJvdXQgc3BlY2lmeWluZyBwcmltYXJ5IGtleXMgaGVyZS4uLlxyXG5cdC8vICBUaGUgdGhpbmdzIHVzZWQgYXMgUEtzIGluIHRoaXMgc3lzdGVtIG1heSBub3QgYmUgUEtzIGluIHRoZSBkYXRhYmFzZS4gVGhlIFBLcyBtYXkgYWxsIGJlIGluY3JlbWVudGluZyBudW1lcmljIElEcyBpbiB0aGUgZGF0YWJhc2UuXHJcblx0Ly8gICBUaGF0IGNvdWxkIG1ha2UgYSBsb3QgbW9yZSBzZW5zZSwgYnV0IG5vdCBpbiBhbGwgc2l0dWF0aW9ucy5cclxuXHRcclxuXHQvLyBQcmltYXJ5IFVuaXF1ZSBJbmRleCBpbiB0aGlzIHNpdHVhdGlvbi4uLiB0aGF0IHdpbGwgYmUgYSBjb25zdHJhaW50IHRoYXQgZ2V0cyB0cmFuc2xhdGVkIHRvIHVuaXF1ZSBpbmRleC5cclxuXHRcclxuXHRcclxuXHRcclxuXHRcclxuXHRcclxuXHQvLyBXaXRoIGNvbGxlY3Rpb25zLCB0aGV5IHdpbGwgYmUgc2F5aW5nIHRoYXQgcmVjb3JkcyBhcmUgdG8gaGF2ZSBhIHByb3BlcnR5LCBhbmQgc29tZSB1bmlxdWVuZXNzIGNvbmRpdGlvbnMgc2hvdWxkIGJlIHNhdGlzZmllZC5cclxuXHRcclxuXHQvLyBOT1QgTlVMTCAtIGNvbGxlY3Rpb25cclxuXHQvLyBVTklRVUUgLSBjb2xsZWN0aW9uXHJcblx0Ly8gUFJJTUFSWSBLRVkgLSBjb2xsZWN0aW9uXHJcblx0Ly8gRk9SRUlHTiBLRVkgLSBjb2xsZWN0aW9uXHJcblx0Ly8gQ0hFQ0sgLSBmaWVsZCBidXQgbGlrZWx5IGFwcGxpZWQgdGhyb3VnaCB0aGUgY29sbGVjdGlvblxyXG5cdC8vIERFRkFVTFQgLSBmaWVsZCBidXQgbGlrZWx5IGFwcGxpZWQgdGhyb3VnaCB0aGUgY29sbGVjdGlvblxyXG5cdFxyXG5cdC8vIFRoZXJlIGlzIHF1aXRlIGEgYml0IHRvIGRvIHRvIGdldCB0aGlzIGRhdGEgbW9kZWwgd29ya2luZyB3aXRoaW4gSmF2YVNjcmlwdC5cclxuXHQvLyAgVGhlbiBpdCB3aWxsIGJlIGEgcXVlc3Rpb24gb2YgZ2V0dGluZyBpdCB0cmFuc2xhdGluZyBpdHNlbGYgdG8gb3RoZXIgbGFuZ3VhZ2VzLlxyXG5cdC8vICBDcmVhdGluZyB0aGUgUkRCIG1vZGVsLCB0aGVuIHRoZSBQb3N0Z3JlcyBtb2RlbCwgdGhlbiB0aGUgYWN0dWFsIGNvZGUgdXNlZCB0byBjcmVhdGUgaXQsIHRoZW4gcnVubmluZyB0aGF0IGNvZGUuXHJcblx0Ly8gIFRoZXNlIHRyYW5zbGF0aW9uIHN0ZXBzIHdpbGwgcmVzdWx0IGluIGEgZmFpcmx5IHN1YnN0YW50aWFsbHkgc2l6ZWQgcGllY2Ugb2Ygc29mdHdhcmUsIHF1aXRlIHBvd2VyZnVsIHRvby5cclxuXHQvLyAgIFRoZSBmdW5jdGlvbmFsaXR5IGNvdWxkIHN0aWxsIGJlIGZhaXJseSBzbWFsbCBpbiBhIGRvd25sb2FkLlxyXG5cdFxyXG5cdC8vIEkgdGhpbmsgdGhpcyBjb3VsZCBtYWtlIGEgdmVyeSBuaWNlIGFwcCBvbiB0aGUgaVBhZCwgdGhlcmUgd291bGQgYmUgcXVpdGUgYSBsb3QgdGhhdCBjb3VsZCBiZSBtYWRlIGluIHRlcm1zIG9mIGRhdGFiYXNlIGRlc2lnbi5cclxuXHQvLyAgVGhlbiBlbWFpbGluZyB0aGUgc2V0dXAgY29kZSwgbWF5YmUgcnVubmluZyB0aGUgc2V0dXAgY29kZSBmcm9tIHRoZSBpUGFkLlxyXG5cdC8vIEJlaW5nIGFibGUgdG8gdmlldyBhbGwgdGhlIGNvZGUsIGEgZmFpcmx5IGZvY3VzZWQgSURFIGZvciBtYWtpbmcgUG9zdGdyZXMgY29kZS5cclxuXHQvLyAgQ291bGQgZG8gcXVpdGUgYSBsb3Qgb24gdGhlIGlQYWQgd2l0aG91dCBzZWxsaW5nIGFuIGFwcCwgYW5kIHRoZW4gc2VsbCBhbiBhcHAgYXMgd2VsbC5cclxuXHRcclxuXHQvLyBUaGV5IGtpbmQgb2YgYWxsIHJlZmVyIHRvIGZpZWxkcywgYnV0IGl0J3MgdG8gZG8gd2l0aCBob3cgdGhlc2UgZmllbGRzIGludGVyYWN0IHdpdGggb3RoZXIgZmllbGRzIGFuZCBmaWVsZHMgaW4gb3RoZXIgdGFibGVzL2NvbGxlY3Rpb25zIHRoYXRcclxuXHQvLyAgbWFrZSB0aGVtIGVpdGhlciBmaWVsZCBvciBjb2xsZWN0aW9uIGNvbnN0cmFpbnRzXHJcblx0XHJcblx0Ly8gVGV4dF9Db25zdHJhaW50XHJcblx0Ly8gTnVtYmVyX1R5cGVfQ29uc3RyYWludFxyXG5cdC8vIEludGVnZXJfVHlwZV9Db25zdHJhaW50XHJcblx0XHJcblx0Ly8gVGhlc2UgdHlwZSBjb25zdHJhaW50cyBjb3VsZCBhbHNvIGJlIGFibGUgdG8gcGFyc2UgZGF0YSB0aGF0IGRvZXMgbm90IG1hdGNoIHRoZSBjb25zdHJhaW50LlxyXG5cdC8vICBQZXJoYXBzIGEgcmVnZXggY291bGQgYmUgcnVuIG9uIGEgc3RyaW5nIGlmIGl0J3MgZXhwZWN0aW5nIHNvbWV0aGluZyBlbHNlLlxyXG5cdFxyXG5cdC8vIE11bHRpcGxlX0NvbnN0cmFpbnQgKGRpZmZlcmVudCBjb25zdHJhaW50cyBnZXQgc2F0aXNmaWVkKVxyXG5cdFxyXG5cdFxyXG5cdC8vIEluZGV4ZWRfQXJyYXlfQ29uc3RyYWludFxyXG5cdFxyXG5cdC8vIEFsbCBiYXNpY2FsbHkgcnVuIHRlc3RzIG9uIHRoZSBvYmplY3QgdG8gc2VlIGlmIGl0IG1lZXRzIHRoZSBjb25zdHJhaW50IG9yIG5vdC5cclxuXHRcclxuXHQvLyBhbHNvIGdldCB0aGUgY29uc3RyYWludCBmcm9tIGFuIG9iamVjdC5cclxuXHQvLyBzb21lIHRoaW5ncyB3aWxsIGJlIGV4cHJlc3NlZCBhcyAobmVzdGVkKSBKYXZhU2NyaXB0IG9iamVjdHMuXHJcblx0XHJcblx0Ly8gVGhpcywgYXMgd2VsbCBhcyBzb3J0aW5nIG91dCB0aGlzIHBhcnNpbmcgc3lzdGVtIHRvIGJlIGxpa2UgQVNQLk5FVCwgd2lsbCB0YWtlIGEgd2hpbGUgbG9uZ2VyLlxyXG5cdC8vICBPbiB0aGUgc2VydmVyLCBpdCB3aWxsIGJlIHBvc3NpYmxlIHRvIHVzZSBtdWNoIG1vcmUgY29kZSB0byBkbyB3aGF0IGlzIG5lZWRlZC5cclxuXHQvLyAgT24gdGhlIGNsaWVudCwgbWFraW5nIHVzZSBvZiBleGlzdGluZyBET00gcGFyc2luZyB3b3VsZCBtYWtlIG1vcmUgc2Vuc2UuXHJcblx0XHJcblx0XHJcblx0XHJcblx0Ly8gRGlmZmVyZW50IHR5cGVzIG9mIGNvbnN0cmFpbnQuXHJcblx0Ly8gIEkgdGhpbmsgdHlwZXMgbGlrZSBcclxuXHQvKiBmcm9tX29iaiBpbnN0ZWFkXHJcblx0dmFyIHZhbHVlX2FzX2ZpZWxkX2NvbnN0cmFpbnQgPSBmdW5jdGlvbih2YWwpIHtcclxuXHRcdC8vIG1vcmUgZmxleGlibGUgdGhhbiBnZXR0aW5nIGl0IGZyb20gYSBzdHJpbmcuXHJcblx0XHQvLyAgbWF5IGJlIGRlYWxpbmcgd2l0aCBuZXN0ZWQgdGhpbmdzIHRvby5cclxuXHRcdFxyXG5cdFx0XHJcblx0XHRcclxuXHRcdFxyXG5cdH1cclxuXHQqL1xyXG5cclxuXHJcblx0XHJcbiAgICAvKiogXHJcbiAgICAqIENyZWF0ZXMgYSBjb25zdHJhaW50IHVzaW5nIHRoZSBkZWZpbml0aW9uIHN0cmluZy4gU2VlIHtAbGluayBtb2R1bGU6Y29yZS9jb25zdHJhaW50LmZyb21fc3RyfGZyb21fc3RyKCl9IGZvciBwb3NzaWJsZSBkZWZpbml0aW9uIHN0cmluZ3MuXHJcbiAgICAqIEBmdW5jXHJcbiAgICAqIEBuYW1lIGZyb21fb2JqXHJcbiAgICAqIEB2YXJpYXRpb24gMVxyXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIC0gY29uc3RyYWludCBkZWZpbml0aW9uIHN0cmluZ1xyXG4gICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvcmUvY29uc3RyYWludFxyXG4gICAgKiBAZXhhbXBsZVxyXG4gICAgKiBjID0gQ29uc3RyYWludC5mcm9tX29iaihcImludFwiKTtcclxuICAgICogYyA9IENvbnN0cmFpbnQuZnJvbV9vYmooXCJ0ZXh0KDEwKVwiKTtcclxuICAgICovXHJcblxyXG4gICAgLyoqIFxyXG4gICAgKiBDcmVhdGVzIGEgY29uc3RyYWludCB1c2luZyB0aGUgXCJzdHJpbmcgYW5kIG51bWJlclwiIGRlZmluaXRpb24uIFRoZSBmb2xsb3dpbmcgZGVmaW5pdGlvbnMgYXJlIHN1cHBvcnRlZDpcclxuICAgICogLSBgW1widGV4dFwiLCA8bGVuZ3RoPl1gIC0gY3JlYXRlcyB7QGxpbmsgbW9kdWxlOmNvcmUvY29uc3RyYWludC5UZXh0X0NvbnN0cmFpbnR8VGV4dF9Db25zdHJhaW50fSwgd2hlcmUgXCJgPGxlbmd0aD5gXCIgaXMgdGhlIG1heCB0ZXh0IGxlbmd0aCBhbGxvd2VkXHJcbiAgICAqIEBmdW5jXHJcbiAgICAqIEBuYW1lIGZyb21fb2JqXHJcbiAgICAqIEB2YXJpYXRpb24gMlxyXG4gICAgKiBAcGFyYW0ge2FycmF5fSBhcnJfb2Zfc3RyX2FuZF9udW0gLSBjb25zdHJhaW50IGRlZmluaXRpb25cclxuICAgICogQG1lbWJlcm9mIG1vZHVsZTpjb3JlL2NvbnN0cmFpbnRcclxuICAgICogQGV4YW1wbGVcclxuICAgICogYyA9IENvbnN0cmFpbnQuZnJvbV9vYmooW1widGV4dFwiLCAxMF0pO1xyXG4gICAgKi9cclxuXHJcbiAgICAvKiogXHJcbiAgICAqIENyZWF0ZXMgYSBjb25zdHJhaW50IHVzaW5nIHRoZSBcInN0cmluZyBhbmQgc3RyaW5nXCIgZGVmaW5pdGlvbi4gVGhlIGZvbGxvd2luZyBkZWZpbml0aW9ucyBhcmUgc3VwcG9ydGVkOlxyXG4gICAgKiAtIGBbXCJ1bmlxdWVcIiwgPGZpZWxkTmFtZT5dYCAtIGNyZWF0ZXMge0BsaW5rIG1vZHVsZTpjb3JlL2NvbnN0cmFpbnQuVW5pcXVlX0NvbnN0cmFpbnR8VW5pcXVlX0NvbnN0cmFpbnR9LCB3aGVyZSBcImA8ZmllbGROYW1lPmBcIiBpcyB0aGUgdW5pcXVlIGZpZWxkIG5hbWVcclxuICAgICogQGZ1bmNcclxuICAgICogQG5hbWUgZnJvbV9vYmpcclxuICAgICogQHZhcmlhdGlvbiAzXHJcbiAgICAqIEBwYXJhbSB7YXJyYXl9IGFycl9vZl9zdHJfYW5kX3N0ciAtIGNvbnN0cmFpbnQgZGVmaW5pdGlvblxyXG4gICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvcmUvY29uc3RyYWludFxyXG4gICAgKiBAZXhhbXBsZVxyXG4gICAgKiBjID0gQ29uc3RyYWludC5mcm9tX29iaihbXCJ1bmlxdWVcIiwgXCJTb21lSURcIl0pO1xyXG4gICAgKi9cclxuXHJcblxyXG5cclxuXHJcblx0dmFyIGZyb21fb2JqID0gZnAoZnVuY3Rpb24oYSwgc2lnKSB7XHJcblx0XHQvLyBTaG91bGQgYmUgYWJsZSB0byBpbnRlcnByZXQgdGhpbmdzIGFzIGVpdGhlciBGaWVsZCBvciBDb2xsZWN0aW9uIGNvbnN0cmFpbnRzLlxyXG5cdFx0Ly8gIE5pY2UgaG93IEZpZWxkIGNvbnN0cmFpbnRzIHdpbGwgYmUgYXBwbHlhYmxlIHRvIGEgQ29sbGVjdGlvbi5cclxuXHRcdC8vICAgVGhpcyB3aWxsIGJlIGxpa2Ugc2V0dGluZyBjb2x1bW5zIGluIHRoZSBkYXRhYmFzZS5cclxuXHRcdFxyXG5cdFx0Ly8gVGhpcyBzb3BoaXN0aWNhdGVkIGRhdGEgbW9kZWwgd2lsbCBiZSBhcHBsaWNhYmxlIHRvIG1hbnkgZGF0YWJhc2Ugc2l0dWF0aW9ucyAvIHNjZW5hcmlvcy5cclxuXHRcdC8vICBTaG91bGQgbWFrZSBpdCByZWFsbHkgZmFzdCB0byBwcm9kdWNlIGEgZGF0YWJhc2Ugd2l0aCBDUlVEIFNQcy5cclxuXHRcdC8vICBFYXN5IHRvIHRyYW5zbGF0ZSBmcm9tIHRoZSByZXF1aXJlbWVudHMgaW50byB0aGUgZmluaXNoZWQgcHJvZHVjdC5cclxuXHRcdC8vICAgQ29udmVuaWVudCBHVUkgdG9vbHMgZm9yIHNwZWNpZnlpbmcgdGhlIHJlcXVpcmVtZW50cy5cclxuXHRcdFxyXG5cdFx0Ly8gV291bGQgYmUgZ29vZCB0byBkaXJlY3RseSBtb25ldGl6ZSB0aGlzIHNvZnR3YXJlIHByZXR0eSBzb29uLlxyXG5cdFx0Ly8gIEkgY2FuIGdldCBzb21ldGhpbmcgaW1wcmVzc2l2ZSBvbmxpbmUgc29vbiB0aGF0IHdpbGwgZ2V0IG1lIGN1c3RvbWVycyBhbmQgaW5jb21lIGZyb20gYWR2ZXJ0cy5cclxuXHRcdFxyXG5cdFx0Ly8gV2lsbCBkZWZpbml0ZWx5IHB1dCB0b2dldGhlciBhIGdvb2Qgb25saW5lIHByZXNlbmNlLlxyXG5cdFx0XHJcblx0XHQvLyBUb2dldGhlciB3aXRoIHJlc291cmNlcywgT1JNLCBhbmQgSmUtU3VpcyBYTUwuLi4gd2lsbCB0YWtlIHNvbWUgdGltZS5cclxuXHRcdC8vICBBbHNvIG5lZWRpbmcgdGhlIHdlYiBkYXRhYmFzZSBpbnRlcmZhY2UuXHJcblx0XHRcclxuXHRcdC8vIEl0IGFsbCBoYXMgYmVlbiBjb21pbmcgb24gYSBsb3QgdmVyeSByZWNlbnRseS5cclxuXHRcdC8vICBOZWVkIHRvIGRvIG1vcmUgdG8gdHVybiBpdCBpbnRvIGEgY29tcHJlaGVuc2l2ZSB3ZWIgcGxhdGZvcm0uXHJcblx0XHRcclxuXHRcdC8vIFdpbGwgYmUgYSB3aG9sZSBhcHBsaWNhdGlvbiBpbmNsdWRpbmcgQ01TLlxyXG5cdFx0XHJcblx0XHQvLyBGb3IgdGhlIG1vbWVudCwgd2lsbCBjb250aW51ZSB3aXRoIHRoZSBzaW5nbGUgZ29hbCBvZiBnZXR0aW5nIHRoZSBmcmFtZXdvcmsgcnVubmluZywgZnVsbHkgZGlzcGxheWluZyBteSBIVE1MIHdlYnNpdGUuXHJcblx0XHRcclxuXHRcdC8vICBJIGVudmlzYWdlIG15IHdlYnNpdGUgd2lsbCBtYWtlIHVzZSBvZiBzb21lIG5pY2UgYW5pbWF0aW9ucywgYW5kIGhhdmUgc29tZSBuaWNlIGRlbW9zLlxyXG5cdFx0Ly8gIEEgZmV3IGFuaW1hdGlvbnMgaW4gYSBwb3J0Zm9saW8gc2VjdGlvbiB0b28uXHJcblx0XHQvLyAgIFNlY3Rpb24gb24gd29yayBJIGhhdmUgZG9uZSAoaHlwZSBCcmFuZG9uIEdlbmVyYXRvciBhIGxpdHRsZSBiaXQpLlxyXG5cdFx0Ly8gIFRlY2hub2xvZ3kgZGVtb3N0cmF0aW9ucy5cclxuXHRcdFxyXG5cdFx0Ly8gV2lsbCBnZXQgdGhpcyB3aG9sZSB3ZWJzaXRlIHZlcnkgcG9saXNoZWQsIGFuZCB3aWxsIHNlZSBob3cgbWFueSBwZW9wbGUgc3RhcnQgdXNpbmcgaXQuXHJcblx0XHQvLyAgSSB0aGluayBJIGNvdWxkIGdldCBzb21lIG1vcmUgd2lkZXNwcmVhZCB1c2FnZSBvZiB0aGUgbGlicmFyeSwgdGhlbiBnZXQgY29uc3VsdGFuY3kgd29yayByZWdhcmRpbmcgaXQuXHJcblx0XHQvLyBJbnRlcmFjdCB3aXRoIHRoZSBjdXN0b21lcnMgdGhyb3VnaCB0aGUgd2Vic2l0ZS5cclxuXHRcdFxyXG5cdFx0Ly8gT0suLi4gbmVlZCB0byBkbyBtb3JlIG9uIHRoaXMgY29uc3RyYWludCBzeXN0ZW0uXHJcblx0XHRcclxuXHRcdFxyXG5cdFx0XHJcblx0XHRcclxuXHRcdFxyXG5cdFx0XHJcblx0XHRcclxuXHRcdFxyXG5cdFx0XHJcblx0XHRcclxuXHRcdFxyXG5cdFx0XHJcblx0XHRcclxuXHRcdFxyXG5cdFx0XHJcblx0XHQvL2NvbnNvbGUubG9nKCdjb25zdHJhaW50LmpzIGZyb21fb2JqIHNpZyAnICsgc3RyaW5naWZ5KHNpZykpO1xyXG5cdFx0XHJcblx0XHRpZiAoc2lnID09ICdbc10nKSB7XHJcblx0XHRcdHJldHVybiBjb25zdHJhaW50X2Zyb21fc3RyKGFbMF0pO1xyXG5cdFx0XHRcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoc2lnID09ICdbRF0nKSB7XHJcblx0XHRcdC8vcmV0dXJuIGNvbnN0cmFpbnRfZnJvbV9zdHIoYVswXSk7XHJcblxyXG5cdFx0XHQvL2NvbnNvbGUubG9nKCdhWzBdJywgYVswXSk7XHJcblx0XHRcdC8vdGhyb3cgJ3N0b3AnO1xyXG5cclxuXHRcdFx0dmFyIHJlcyA9IG5ldyBEYXRhX09iamVjdF9Db25zdHJhaW50KHt9KTtcclxuXHRcdFx0cmVzLmRhdGFfb2JqZWN0ID0gYVswXTtcclxuXHRcdFx0cmV0dXJuIHJlczsgXHJcblx0XHRcdFxyXG5cdFx0fVxyXG5cdFx0XHJcblx0XHRcclxuXHRcdFxyXG5cdFx0aWYgKGEubCA9PSAxICYmIHRvZihhWzBdKSA9PSAnYXJyYXknKSB7XHJcblx0XHRcdC8vY29uc29sZS5sb2coJ2NvbnN0cmFpbnQuanMgZnJvbV9vYmogc2lnICcgKyBzdHJpbmdpZnkoc2lnKSk7XHJcblx0XHRcdC8vY29uc29sZS5sb2coJ2NvbnN0cmFpbnQuanMgZnJvbV9vYmogb2JqICcgKyBzdHJpbmdpZnkoYVswXSkpO1xyXG5cdFx0XHRcclxuXHRcdFx0dmFyIG9iaiA9IGFbMF07XHJcblx0XHRcdFxyXG5cdFx0XHR2YXIgb2JqX3NpZyA9IGdldF9pdGVtX3NpZyhvYmosIDEpOyAgLy8gd2FzIGdldF9pdGVtX3NpZyhvYmopO1xyXG5cdFx0XHQvL2NvbnNvbGUubG9nKCdvYmpfc2lnICcgKyBvYmpfc2lnKTtcclxuXHRcdFx0Ly9jb25zb2xlLmxvZygnb2JqICcgKyBzdHJpbmdpZnkob2JqKSk7XHJcblx0XHRcdFxyXG5cdFx0XHQvLyBjb3VsZCBiZSBnaXZlbiBbcyxuXVxyXG5cdFx0XHQvLyBlZyBbJ3RleHQnLCAzMl1cclxuXHRcdFx0XHJcblx0XHRcdGlmIChvYmpfc2lnID09ICdbcyxuXScpIHtcclxuXHRcdFx0XHR2YXIgZGF0YV90eXBlX25hbWUgPSBvYmpbMF07XHJcblx0XHRcdFx0dmFyIGxlbmd0aCA9IG9ialsxXTtcclxuXHRcdFx0XHRcclxuXHRcdFx0XHRpZiAoZGF0YV90eXBlX25hbWUgPT0gJ3RleHQnKSB7XHJcblx0XHRcdFx0XHR2YXIgY29uc3RyYWludCA9IG5ldyBUZXh0X0NvbnN0cmFpbnQoeydsZW5ndGgnOiBsZW5ndGh9KTtcclxuXHRcdFx0XHRcdHJldHVybiBjb25zdHJhaW50O1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRcclxuXHRcdFx0fVxyXG5cdFx0XHRcclxuXHRcdFx0XHJcblx0XHRcdGlmIChvYmpfc2lnID09ICdbcyxzXScpIHtcclxuXHRcdFx0XHR2YXIgY29uc3RyYWludF90eXBlID0gb2JqWzBdO1xyXG5cdFx0XHRcdC8vICB0aGVuIGFub3RoZXIgcGFyYW1ldGVyLCBpZiBpdCdzIGEgdW5pcXVlIGNvbnN0cmFpbnQgdGhlbiB0aGUgb3RoZXIgcGFyYW0gaXMgdGhlIGZpZWxkX25hbWVcclxuXHRcdFx0XHQvL2NvbnNvbGUubG9nKCdjb25zdHJhaW50X3R5cGUgJyArIGNvbnN0cmFpbnRfdHlwZSk7XHJcblx0XHRcdFx0aWYgKGNvbnN0cmFpbnRfdHlwZSA9PSAndW5pcXVlJykge1xyXG5cdFx0XHRcdFx0dmFyIGZpZWxkX25hbWUgPSBvYmpbMV07XHJcblx0XHRcdFx0XHRcclxuXHRcdFx0XHRcdC8vIHdlIGRvbid0IGhhdmUgdGhlIGFjdHVhbCBmaWVsZCwgYnV0IGdvdCBpdHMgbmFtZS5cclxuXHRcdFx0XHRcdC8vICB0aGUgbmFtZSB3b3VsZCBkbyBmb3IgdGhlIG1vbWVudC5cclxuXHRcdFx0XHRcdHZhciBjb25zdHJhaW50ID0gbmV3IFVuaXF1ZV9Db25zdHJhaW50KHtcclxuXHRcdFx0XHRcdFx0J2ZpZWxkcyc6IGZpZWxkX25hbWVcclxuXHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdFx0Ly9jb25zb2xlLmxvZygnY29uc3RyYWludCAnICsgY29uc3RyYWludCk7XHJcblx0XHRcdFx0XHRyZXR1cm4gY29uc3RyYWludDtcclxuXHRcdFx0XHRcdFxyXG5cdFx0XHRcdFx0XHJcblx0XHRcdFx0XHRcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0XHJcblx0XHRcdFx0aWYgKGNvbnN0cmFpbnRfdHlwZSA9PSAndGV4dCcpIHtcclxuXHRcdFx0XHRcdFxyXG5cdFx0XHRcdFx0XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdFxyXG5cdFx0XHRcdC8vIGlmIGl0J3MgYSB0ZXh0IGNvbnN0cmFpbnQuLi4gdGhhdCdzIGEgZmllbGQgdHlwZS5cclxuXHRcdFx0XHRcclxuXHRcdFx0XHRcclxuXHRcdFx0XHRcclxuXHRcdFx0XHRcclxuXHRcdFx0XHRcclxuXHRcdFx0XHRcclxuXHRcdFx0fVxyXG5cdFx0XHRcclxuXHRcdFx0XHJcblx0XHRcdFxyXG5cdFx0fVxyXG5cdFx0XHJcblx0XHQvL2lmIChzaWcgPT0gJ1tEXScpIHtcdFx0XHRcclxuXHRcdC8vXHR2YXIgY29uc3RyYWludCA9IG5ldyBDb2xsZWN0aW9uX0RhdGFfT2JqZWN0X0NvbnN0cmFpbnQoYVswXSk7XHJcblx0XHQvL1x0Ly9jb25zb2xlLmxvZygnY29uc3RyYWludCAnICsgY29uc3RyYWludCk7XHJcblx0XHQvL1x0cmV0dXJuIGNvbnN0cmFpbnQ7XHJcblx0XHQvL31cclxuXHRcdFxyXG5cdFx0XHJcblx0XHRcclxuXHRcdFxyXG5cdFx0Ly8gTmVlZCB0byByZWFsbHkgZG8gYSBsb3Qgb24gdGhlIGV4ZWN1dGlvbiBwYXRoIG9mIHRoaXMuXHJcblx0XHQvLyAgSSB0aGluayB0aGUgd2hvbGUgZGF0YWJhc2UgdHJhbnNmb3JtYXRpb24gc3lzdGVtIGlzIG5lY2Vzc2FyeSB0byBnZXQgaXQgdG8gcnVuLCBpdCdzIGFuIGludGVncmFsIHBhcnQgb2YgdGhlIHN5c3RlbS5cclxuXHRcdC8vICBHZXR0aW5nIGFjY2VzcyB0byByZWxhdGlvbmFsIGRhdGFiYXNlcyBpcyBjcml0aWNhbCBmb3IgdGhlIHdob2xlIHNvZnR3YXJlIHRvIHBlcmZvcm0gaXRzIGludGVuZGVkIGZ1bmN0aW9ucy5cclxuXHRcdFxyXG5cdFx0XHJcblx0XHRcclxuXHRcdFxyXG5cdFx0XHJcblx0XHRcclxuXHRcdC8vIGFuIGFycmF5LCAyIHN0cmluZ3MuLi5cclxuXHRcdFxyXG5cdFx0Ly8gbWF5IHdpbmQgdXAgdXNpbmcgYSB2YXJpZXJ5IG9mIGNvbnN0cmFpbnQgZGVmaW5pdGlvbnNcclxuXHRcdC8vICB0aGV5IHdpbGwgYmUgaW50ZXJwcmV0ZWQgaGVyZSBpbnRvIGNvbnN0cmFpbnQgb2JqZWN0cywgd2hpY2ggY2FuIGJlIHB1dCBpbiBjb2xsZWN0aW9ucywgYW5kIHRoZXNlIHVzZWQgdG8gdGVzdCBEYXRhT2JqZWN0cy5cclxuXHRcdFxyXG5cdFx0Ly8gQ2FuIGJlIHVzZWQgZm9yIG1ha2luZyBhYnN0cmFjdCBkZWZpbml0aW9ucyBvZiB0aGluZ3MsIGJlZm9yZSBkYXRhIGdvZXMgaW4uXHJcblx0XHQvLyAgVGhlbiB0aGVzZSBhYnN0cmFjdCBkZWZpbml0aW9ucyBhcmUgdXNlZCBpbiBvcmRlciB0byBjcmVhdGUgdGhlIGRhdGFiYXNlIGFuZCBpbnRlcmFjdCB3aXRoIGl0XHJcblx0XHRcclxuXHRcdC8vIE1hZGUgbG9hZHMgb2YgcHJvZ3Jlc3Mgd2l0aCB0aGUgb2JqZWN0IHN5c3RlbSwgY29uc3RyYWludHMgYXJlIGdvaW5nIHRvIGJlIGEgdmVyeSBwb3dlcmZ1bCBmZWF0dXJlLlxyXG5cdFx0Ly8gIFJlcXVpcmVtZW50cyBtYXkgYWxzbyBiZSB0aGVyZSBhcyBhIGRpZmZlcmVudCBBUEksIHBlcmhhcHMgcmVxdWlyaW5nIGNvbnN0cmFpbnRzIHRvIGJlIG1hdGNoZWQsXHJcblx0XHQvLyAgYWxzbyBzb21lIG1vcmUgYWR2YW5jZWQgcHJvZ3JhbW1hdGljIGNoZWNrcyB0aGF0IHdvdWxkIGdldCBleHByZXNzZWQgaW4gSmF2YVNjcmlwdCwgd2hlcmVhcyB0aGUgY29uc3RyYWludHMgYXJlIFxyXG5cdFx0Ly8gIGEgc3lzdGVtIHRoYXQgd2lsbCBiZSB0cmFuc2xhdGFibGUgaW50byBkaWZmZXJlbnQgcGFydGljdWxhciBtZXRob2RvbG9naWVzLlxyXG5cdFx0XHJcblx0XHRcclxuXHRcdFxyXG5cdFx0XHJcblx0XHRcclxuXHRcdFxyXG5cdFx0XHJcblx0XHRcclxuXHRcdFxyXG5cdFx0XHJcblx0XHRcclxuXHRcdC8vdGhyb3cgKCdzdG9wJyk7XHJcblx0XHRcclxuXHR9KVxyXG5cdFxyXG5cdFxyXG4gICAgLyoqXHJcbiAgICAqIENyZWF0ZXMgYSBjb25zdHJhaW50IHVzaW5nIHRoZSBkZWZpbml0aW9uIHN0cmluZy4gVGhlIGZvbGxvd2luZyBkZWZpbml0aW9ucyBhcmUgc3VwcG9ydGVkOlxyXG4gICAgKiAtIFwiaW50XCIgLSBjcmVhdGVzIHtAbGluayBtb2R1bGU6Y29yZS9jb25zdHJhaW50LkludF9Db25zdHJhaW50fEludF9Db25zdHJhaW50fVxyXG4gICAgKiAtIFwibnVtYmVyXCIgLSBjcmVhdGVzIHtAbGluayBtb2R1bGU6Y29yZS9jb25zdHJhaW50Lk51bWJlcl9Db25zdHJhaW50fE51bWJlcl9Db25zdHJhaW50fVxyXG4gICAgKiAtIFwidGV4dFwiIC0gY3JlYXRlcyB7QGxpbmsgbW9kdWxlOmNvcmUvY29uc3RyYWludC5UZXh0X0NvbnN0cmFpbnR8VGV4dF9Db25zdHJhaW50fSB3aXRob3V0IG1heCBsZW5ndGggcmVzdHJpY3Rpb25cclxuICAgICogLSBcInRleHQoPGxlbmd0aD4pXCIgLSBjcmVhdGVzIHtAbGluayBtb2R1bGU6Y29yZS9jb25zdHJhaW50LlRleHRfQ29uc3RyYWludHxUZXh0X0NvbnN0cmFpbnR9LCB3aGVyZSBcIjxsZW5ndGg+XCIgaXMgdGhlIG1heCB0ZXh0IGxlbmd0aCBhbGxvd2VkXHJcbiAgICAqIC0gXCJndWlkXCIgLSBjcmVhdGVzIHtAbGluayBtb2R1bGU6Y29yZS9jb25zdHJhaW50Lkd1aWRfQ29uc3RyYWludHxHdWlkX0NvbnN0cmFpbnR9XHJcbiAgICAqIEBmdW5jIGZyb21fc3RyXHJcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgLSBjb25zdHJhaW50IGRlZmluaXRpb25cclxuICAgICogQG1lbWJlcm9mIG1vZHVsZTpjb3JlL2NvbnN0cmFpbnRcclxuICAgICogQGV4YW1wbGVcclxuICAgICogYyA9IENvbnN0cmFpbnQuZnJvbV9zdHIoXCJpbnRcIik7XHJcbiAgICAqIGMgPSBDb25zdHJhaW50LmZyb21fc3RyKFwidGV4dCgxMClcIik7XHJcbiAgICAqL1xyXG5cdHZhciBjb25zdHJhaW50X2Zyb21fc3RyID0gZnVuY3Rpb24gKHN0cikge1xyXG5cdFx0Ly9jb25zb2xlLmxvZygnY29uc3RyYWludF9mcm9tX3N0ciBzdHIgJyArIHN0cik7XHJcblx0XHQvLyB3aWxsIGNoZWNrIHRoZSBjYWNoZSBmb3IgaXQgdGhvdWdoLlxyXG5cdFx0XHJcblx0XHQvLyB3aWxsIG5lZWQgdG8gY2hvb3NlIHRoZSB0eXBlIG9mIHRoZSBjb25zdHJhaW50LlxyXG5cdFx0XHJcblx0XHQvLyBpZiBpdCdzIGEgc3RyaW5nIGl0IHdvbid0IGJlIHRoYXQgY29tcGxpY2F0ZWQsIEkgdGhpbmsuXHJcblx0XHQvLyAgbWF5IGJlIGJlc3QgdG8gdXNlIHJlZ3VsYXIgZXhwcmVzc2lvbnMgdG8gZGV0ZWN0IHdoYXQga2luZCBvZiBjb25zdHJhaW50IGl0IGlzLlxyXG5cdFx0XHJcblx0XHQvLyBJdCBtYXkgYmUgYSBzdHJpbmcgd2l0aCBzb21lIHBhcmFtZXRlcnMuXHJcblx0XHQvLyBOb3QgcmVhbGx5IHdhbnRpbmcgZXNzZW50aWFscyB0byBnZXQgYmlnZ2VyLCBidXQgdGhpbmcgc29tZSBleHRyYSBzdHJpbmcgcHJvY2Vzc2luZyBtYXkgYmUgb2YgdXNlIGJlZm9yZSB0aGlzLlxyXG5cdFx0Ly8gIEpzZ3VpLXV0aWwgY3VycmVudGx5IGhhcyB0aGUgZGF0YSB0eXBlcywgc28gdGhhdCBvbmUgaXMgZmFpcmx5IGJpZy5cclxuXHRcdFxyXG5cdFx0Ly8gRnVuY3Rpb25hbGl0eSB3aWxsIGJlIGJyb3VnaHQgb3ZlciBmcm9tIE5lc3RlZC4uLiBleGNlcHQgaXQgd2lsbCB3b3JrIGRpZmZlcmVudGx5XHJcblx0XHQvLyAgSW4gbmVzdGVkLCB0aGVyZSBpcyBhIERhdGFfVHlwZV9JbnN0YW5jZS5cclxuXHRcdC8vICBJbiB0aGlzIGNhc2UsIEkgdGhpbmsgaXQgd2lsbCBiZSBDb25zdHJhaW50cywgYW5kIG1vcmUgZGVjbGFyYXRpdmUgZGVzY3JpcHRpb25zIG9mIHRoZSBkYXRhIHR5cGVzLlxyXG5cdFx0XHJcblx0XHQvLyBJdCB3aWxsIGJlIGludGVuZGVkIHRvIG1pcnJvciBpbiBzb21lIHdheXMgdGhlIGRhdGEgdHlwZXMgYW5kIGNvbnN0cmFpbnRzIHRoYXQgYXJlIGluIGRhdGFiYXNlcy5cclxuXHRcdC8vICBDb25zdHJhaW50cyBjb3VsZCBhcHBseSB0byBjb2xsZWN0aW9ucywgc2F5aW5nIHRoYXQga2V5IHZhbHVlcyBtdXN0IGJlIHVuaXF1ZSwgZWcgbm8gb25lIGhhcyB0aGUgc2FtZSBOSSBudW1iZXIuXHJcblx0XHRcclxuXHRcdFxyXG5cdFx0Ly8gZXhhbXBsZXNcclxuXHRcdC8vICdzdHJpbmcnLCAnaW50JywgJ3RleHQnLCAndGV4dCgzMiknLCBcclxuXHRcdFxyXG5cdFx0Ly8gUGVyaGFwcyB0aGVzZSBhcmUgbGlrZSBEYXRhX1R5cGVfSW5zdGFuY2Ugb2JqZWN0cywgYnV0IHRoZXknbGwgYmUgY2FsbGVkIGNvbnN0cmFpbnRzIGhlcmUuXHJcblx0XHQvLyAgVGhleSBtYXkgbm90IGJlIGxpbWl0ZWQgdG8gYmVpbmcgZGF0YSB0eXBlcywgYnV0IHRoZXkgc2hvdWxkIGRvIHRoZSBzYW1lIGpvYnMuXHJcblx0XHQvLyBUaGUgZGF0YSB0eXBlcyB0aGV5IHJlZmVyZW5jZS4uLiBub3Qgc28gc3VyZSBhYm91dCBtYWtpbmcgRGF0YV9UeXBlX0luc3RhbmNlcyBvciBub3QuXHJcblx0XHQvLyBDb25zdHJhaW50cyBhcyBhIGNvbmNlcHQgbWFrZXMgbW9yZSBzZW5zZSwgZXNwZWNpYWxseSB3aGVuIGRlZmluaW5nIGRhdGFiYXNlcy5cclxuXHRcdFxyXG5cdFx0Ly8gSSB0aGluayB0aGlzIHN5c3RlbSBiZWZvcmUgdG9vIGxvbmcgY291bGQgcHJvZHVjZSBzb21lIHJlYWxseSBhZHZhbmNlZCBmdW5jdGlvbmFsaXR5LlxyXG5cdFx0Ly8gIFdpdGggdGhpcyBhYnN0cmFjdGlvbiBtYWRlIGl0IHdpbGwgYmUgcG9zc2libGUgdG8gZ2V0IGRldmVsb3BtZW50IHdvcmsgdWluZyBpdCBJIGhvcGUuXHJcblx0XHRcclxuXHRcdC8vIE5vdCBxdWl0ZSBzdXJlIGhvdyBvciBpZiB0aGlzIHdpbGwgYmUgY29tcGV0aW5nIHdpdGggYmFja2JvbmUuXHJcblx0XHQvLyAgSSB0aGluayBoYXZpbmcgdGhlIGpzZ3VpIGRvbWFpbiwgaGF2aW5nIGl0IHRoZXJlLCB3aXRoIGEgZGVtbyBhbmQgZGlzY3Vzc2lvbiwgdGFsa2luZyBhYm91dCBpdCBvbiB0d2l0dGVyLFxyXG5cdFx0Ly8gIHNob3dpbmcgdGhlIHR3aXR0ZXIgZmVlZCBvbiB0aGUgd2Vic2l0ZSB1c2luZyBudWNlIFVJIGNvbXBvbmVudHMuLi5cclxuXHRcdFxyXG5cdFx0Ly8gU29tZSBzaW1wbGUgZG93bmxvYWRhYmxlIHBpZWNlcyAvIGJ1aWxkc1xyXG5cdFx0Ly8gQSBzeXN0ZW0gdXNpbmcgbm9kZS5qcyB0aGF0IHdpbGwgcHJvdmlkZSB0aGUgcmlnaHQgSmF2YVNjcmlwdCBjbGllbnQgbGlicmFyeSB0byB0aGUgY2xpZW50c1xyXG5cdFx0Ly8gTWFrZSBpdCBlYXN5IHRvIGdldCBydW5uaW5nIGZyb20gZG93bmxvYWRzLCBlYXN5LXRvLXZpZXcgZXhhbXBsZXMgYW5kIGRvY3VtZW50YXRpb24gd2l0aGluIHRoZSBkb3dubG9hZHMuXHJcblx0XHRcclxuXHRcdC8vIEkgdGhpbmsgaXQgY291bGQgbWFrZSBhIHZlcnkgc29waGlzdGljYXRlZCB3ZWJzaXRlIHN5c3RlbS4gQ291bGQgaGF2ZSBhIGdyYXBoaWNhbCBJREUgd2hlcmUgY29tcG9uZXRzIGNhbiBiZSBwdXQgaW4gcGxhY2UsIGl0IGdlbmVyYXRlcyB0aGUgY29kZSBmb3JcclxuXHRcdC8vICB0aGF0LlxyXG5cdFx0XHJcblx0XHRcclxuXHRcdC8vIEdvIHRocm91Z2gsIGxvb2tpbmcgZm9yIHNvbWUgcGF0dGVybnMgYXMgcmVndWxhciBleHByZXNzaW9ucy5cclxuXHRcdC8vICBJZiB3ZSBoYXZlIGlkZW50aWZpZWQgdGhlbSwgd2UgaGF2ZSB0aGUgdmFsdWVzIG5lZWRlZCBmb3IgdGhlIGNvbnN0cmFpbnQuXHJcblx0XHRcclxuXHRcdHZhciByeF9zcGVjaWZpZWRfbGVuZ3RoX3RleHQgPSAvXnRleHRcXCgoXFxkKylcXCkkLztcclxuXHRcdC8vIHRoZSBkYXRhIHR5cGUgY291bGQgcG9zc2libHkgYmUgaGFuZGxlZCBieSBpbnB1dCBwcm9jZXNzb3JzLlxyXG5cdFx0Ly8gIEkgdGhpbmsgdGhhdCBtYWtlcyBzZW5zZSwgbW92aW5nIGlucHV0X3Byb2Nlc3NvcnMgb3V0IG9mIG5lc3RlZCBhbmQgaW50byBlc3NlbnRpYWxzLlxyXG5cdFx0Ly8gICBJdCdzIGFuIGV4cGFuZGFibGUgc3lzdGVtLCB0aGUgYmFzaXMgZm9yIGl0IHdpbGwgbm90IHRha2UgbXVjaC4gVGhlIHJlbGV2YW50IGlucHV0IHByb2Nlc3NvcnMgY291bGQgYmUgYWRkZWQgYnkgRGF0YV9PYmplY3QsIGJ1dCBcclxuXHRcdC8vICAgdGhlbiBiZSBhdmFpbGFibGUgdGhyb3VnaG91dCB0aGUgc3lzdGVtLCBzdWNoIGFzIGZvciBkZWFsaW5nIHdpdGggZnVuY3Rpb24gY2FsbHMsIG9yIGRhdGEgdHlwZXMgd2hpY2ggY2FuIGhhdmUgYSBsZW5ndGguXHJcblx0XHRcclxuXHRcdFxyXG5cdFx0XHJcblx0XHRcclxuXHRcdFxyXG5cdFx0dmFyIG1hdGNoX3NsdCA9IHN0ci5tYXRjaChyeF9zcGVjaWZpZWRfbGVuZ3RoX3RleHQpO1xyXG5cdFx0XHJcblx0XHQvL2NvbnNvbGUubG9nKCdtYXRjaF9zbHQgJyArIG1hdGNoX3NsdCk7XHJcblx0XHRcclxuXHRcdGlmIChtYXRjaF9zbHQpIHtcclxuXHRcdFx0dmFyIGxlbmd0aCA9IHBhcnNlSW50KG1hdGNoX3NsdFsxXSk7XHJcblx0XHRcdC8vY29uc29sZS5sb2coJ2xlbmd0aCAnICsgdG9mKGxlbmd0aCkpO1xyXG5cdFx0XHR2YXIgY29uc3RyYWludCA9IG5ldyBUZXh0X0NvbnN0cmFpbnQoe1xyXG5cdFx0XHRcdCdsZW5ndGgnOiBsZW5ndGhcclxuXHRcdFx0fSlcclxuXHRcdFx0cmV0dXJuIGNvbnN0cmFpbnQ7XHJcblx0XHR9XHJcblx0XHRcclxuXHRcdGlmIChzdHIgPT09ICd0ZXh0Jykge1xyXG5cdFx0ICAgIHZhciBjb25zdHJhaW50ID0gbmV3IFRleHRfQ29uc3RyYWludCh7fSlcclxuXHRcdCAgICByZXR1cm4gY29uc3RyYWludDtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoc3RyID09PSAnaW50Jykge1xyXG5cdFx0ICAgIHZhciBjb25zdHJhaW50ID0gbmV3IEludF9Db25zdHJhaW50KHt9KVxyXG5cdFx0ICAgIHJldHVybiBjb25zdHJhaW50O1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChzdHIgPT09ICdudW1iZXInKSB7XHJcblx0XHRcdHZhciBjb25zdHJhaW50ID0gbmV3IE51bWJlcl9Db25zdHJhaW50KHt9KVxyXG5cdFx0XHRyZXR1cm4gY29uc3RyYWludDtcclxuXHRcdH1cclxuXHRcdFxyXG5cdFx0aWYgKHN0ciA9PT0gJ2d1aWQnKSB7XHJcblx0XHRcdHZhciBjb25zdHJhaW50ID0gbmV3IEd1aWRfQ29uc3RyYWludCh7fSlcclxuXHRcdFx0cmV0dXJuIGNvbnN0cmFpbnQ7XHJcblx0XHR9XHJcblx0XHRcclxuXHRcdFxyXG5cdFx0XHJcblx0XHRcclxuXHRcdC8vdGhyb3coJ3N0b3AnKTtcclxuXHRcdFxyXG5cdFx0XHJcblx0XHRcclxuXHRcdFxyXG5cdH1cclxuXHRcclxuXHRDb25zdHJhaW50LmZyb21fb2JqID0gZnJvbV9vYmo7XHJcblx0XHJcblx0Q29uc3RyYWludC5mcm9tX3N0ciA9IGNvbnN0cmFpbnRfZnJvbV9zdHI7XHJcblx0Q29uc3RyYWludC5vYmpfbWF0Y2hlc19jb25zdHJhaW50ID0gb2JqX21hdGNoZXNfY29uc3RyYWludDtcclxuXHRcclxuXHRDb25zdHJhaW50Lk5vdF9OdWxsID0gTm90X051bGxfQ29uc3RyYWludDtcclxuXHRDb25zdHJhaW50LlVuaXF1ZSA9IFVuaXF1ZV9Db25zdHJhaW50O1xyXG5cdENvbnN0cmFpbnQuRGF0YV9PYmplY3RfRGVmX0NvbnN0cmFpbnQgPSBEYXRhX09iamVjdF9EZWZfQ29uc3RyYWludDtcclxuXHQvL0NvbnN0cmFpbnQuQ29sbGVjdGlvbl9EYXRhX09iamVjdCA9IENvbGxlY3Rpb25fRGF0YV9PYmplY3RfQ29uc3RyYWludDtcclxuXHRDb25zdHJhaW50LkNvbGxlY3Rpb25fRGF0YV9UeXBlID0gQ29sbGVjdGlvbl9EYXRhX1R5cGVfQ29uc3RyYWludDtcclxuXHRDb25zdHJhaW50LkNvbGxlY3Rpb25fRGF0YV9EZWYgPSBDb2xsZWN0aW9uX0RhdGFfRGVmX0NvbnN0cmFpbnQ7XHJcblx0Q29uc3RyYWludC5GaWVsZF9EYXRhX1R5cGUgPSBGaWVsZF9EYXRhX1R5cGVfQ29uc3RyYWludDtcclxuXHRDb25zdHJhaW50Lkd1aWQgPSBHdWlkX0NvbnN0cmFpbnQ7XHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBDb25zdHJhaW50O1xyXG5cclxuXHQvL3JldHVybiBDb25zdHJhaW50O1xyXG4vL30pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiIsIlxyXG4vKlxyXG5pZiAodHlwZW9mIGRlZmluZSAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgdmFyIGRlZmluZSA9IHJlcXVpcmUoJ2FtZGVmaW5lJykobW9kdWxlKTtcclxufVxyXG5cclxuXHJcbmRlZmluZShbXCIuL2pzZ3VpLWxhbmctZXNzZW50aWFsc1wiLCBcIi4vanNndWktZGF0YS1zdHJ1Y3R1cmVzXCIsIFwiLi9jb25zdHJhaW50XCJdLCBmdW5jdGlvbihqc2d1aSwgRGF0YV9TdHJ1Y3R1cmVzLCBDb25zdHJhaW50KSB7XHJcblx0Ki9cclxudmFyIGpzZ3VpID0gcmVxdWlyZSgnLi9qc2d1aS1sYW5nLWVzc2VudGlhbHMnKTtcclxudmFyIERhdGFfU3RydWN0dXJlcyA9IHJlcXVpcmUoJy4vanNndWktZGF0YS1zdHJ1Y3R1cmVzJyk7XHJcbnZhciBDb25zdHJhaW50ID0gcmVxdWlyZSgnLi9jb25zdHJhaW50Jyk7XHJcblxyXG5cdC8vIE1heSBuZWVkIHRvIHRlc3QgY29udHJvbHMgYW5kIGRhdGEgb2JqZWN0cyBzZXBhcmF0ZWx5IGJlZm9yZSBydW5uaW5nIGEgZG9jdW1lbnQgc2VydmVyIHdpdGggdGhlbS5cclxuXHJcblx0Ly8gQ29uc3RyYWludHMgYXMgd2VsbCBhcyBhIG1vZHVsYXIgYm9sdC1vbj9cclxuXHJcblx0Ly8gQ3JlYXRlcyB0aGUgQ29uc3RyYWludHMgZGF0YSB0eXBlLi4uIHNvIGEgY29uc3RyYWludCBzcGVjaWZpZWQgd2l0aCBhIHN0cmluZyBjYW4gYmUgdGVzdGVkIGFnYWluc3RcclxuXHQvLyAgYWxzbyBhIGNhY2hlIG9mIHRoZSBjb25zdHJhaW50cyB0aGF0IGhhdmUgYmVlbiBtYWRlIHRocm91Z2ggdGhlIHN0cmluZyAtIHF1aWNrIHRvIGdldCB0aGVtIGFnYWluIGZvciByZXVzZSB3aGVuIHRlc3RpbmcuXHJcblxyXG5cdC8vIENvbnN0cmFpbnQgb2JqZWN0cyBjYW4gYmUgc2F2ZXMgYW5kIHVzZWQgaW4gdmFyaW91cyBwbGFjZXMuXHJcblx0Ly8gIFRoZXkgbWF5IG5vdCBhbHdheXMgYmUgcmVmZXJyZWQgdG8gZGlyZWN0bHksIHRoYXQgd291bGQgc2F2ZSBvbiB0aGUgYW1vdW50IG9mIGNvZGUgbmVlZGVkLlxyXG5cclxuXHQvLyBUaGV5IHdpbGwgaGVscCBpbiBtYWtpbmcgYSBtb2RlbCBvZiB3aGF0IGdldHMgcHV0IGludG8gYSBkYXRhYmFzZS5cclxuXHQvLyAgQSBmZXcgY29uc3RyYWludHMgcHV0IGluIHBsYWNlIGluIHRoZSBkb21haW4gbW9kZWwgb3Igc2ltaWxhciB3aWxsIGhlbHAgd2l0aCBpdHMgdHJhbnNsYXRpb24gdG8gYSBkYXRhYmFzZSBtb2RlbC5cclxuXHJcblx0Ly8gVGhlc2Ugd2lkZS1yYW5naW5nIHRoaW5ncyBzaG91bGQgaGVscCBhIGxvdCB3aXRoIGNyZWF0aW5nIGEgd2lkZSByYW5nZSBvZiBwZXJmb3JtYW50IGRhdGFiYXNlcyBxdWlja2x5LlxyXG5cdC8vIEl0IHdpbGwgYWxzbyBiZSBhIGdvb2QgdG9vbCBpbiBpdHNlbGYuXHJcblxyXG5cdC8vIEludGVyYWN0aW9uIGJldHdlZW4gdGhlIGZpZWxkcyBjb2xsZWN0aW9uIGFuZCB0aGUgaW5kZXhlcy4uLlxyXG5cdC8vICBuZWVkIHRvIGhhdmUgaXQgc28gdGhhdCBmaWVsZHMgZ2V0IGluZGV4ZWQgd2hlbiBhcHByb3ByaWF0ZS5cclxuXHQvLyBXaGVuIGNvbnN0cnVjdGluZyBhIERhdGFfT2JqZWN0IG9yIENvbGxlY3Rpb24sIHRoZSBmaWVsZHMgbWF5IGdldCBzZXQsIGFuZCB0aGUgZmllbGRzIG5lZWQgdG8gYmUgaW5kZXhlZCBhY2NvcmRpbmdseS5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cdHZhciBqID0ganNndWk7XHJcblx0dmFyIENsYXNzID0gai5DbGFzcztcclxuXHR2YXIgZWFjaCA9IGouZWFjaDtcclxuXHR2YXIgaXNfYXJyYXkgPSBqLmlzX2FycmF5O1xyXG5cdHZhciBpc19kb21fbm9kZSA9IGouaXNfZG9tX25vZGU7XHJcblx0dmFyIGlzX2N0cmwgPSBqLmlzX2N0cmw7XHJcblx0dmFyIGV4dGVuZCA9IGouZXh0ZW5kO1xyXG5cdHZhciBnZXRfdHJ1dGhfbWFwX2Zyb21fYXJyID0gai5nZXRfdHJ1dGhfbWFwX2Zyb21fYXJyO1xyXG5cdHZhciBnZXRfbWFwX2Zyb21fYXJyID0gai5nZXRfbWFwX2Zyb21fYXJyO1xyXG5cdHZhciBhcnJfbGlrZV90b19hcnIgPSBqLmFycl9saWtlX3RvX2FycjtcclxuXHR2YXIgdG9mID0gai50b2Y7XHJcblx0dmFyIGlzX2RlZmluZWQgPSBqLmlzX2RlZmluZWQ7XHJcblx0dmFyIHN0cmluZ2lmeSA9IGouc3RyaW5naWZ5O1xyXG5cdHZhciBmdW5jdGlvbmFsX3BvbHltb3JwaGlzbSA9IGouZnVuY3Rpb25hbF9wb2x5bW9ycGhpc207XHJcblx0dmFyIGZwID0gai5mcDtcclxuXHR2YXIgYXJyYXlpZnkgPSBqLmFycmF5aWZ5O1xyXG5cdHZhciBtYXBpZnkgPSBqLm1hcGlmeTtcclxuXHR2YXIgYXJlX2VxdWFsID0gai5hcmVfZXF1YWw7XHJcblx0dmFyIGdldF9hX3NpZyA9IGouZ2V0X2Ffc2lnO1xyXG5cdHZhciBnZXRfaXRlbV9zaWcgPSBqLmdldF9pdGVtX3NpZztcclxuXHR2YXIgc2V0X3ZhbHMgPSBqLnNldF92YWxzO1xyXG5cdHZhciB0cnV0aCA9IGoudHJ1dGg7XHJcblx0dmFyIHRyaW1fc2lnX2JyYWNrZXRzID0gai50cmltX3NpZ19icmFja2V0cztcclxuXHR2YXIgbGxfc2V0ID0gai5sbF9zZXQ7XHJcblx0dmFyIGxsX2dldCA9IGoubGxfZ2V0O1xyXG5cdHZhciBpbnB1dF9wcm9jZXNzb3JzID0gai5pbnB1dF9wcm9jZXNzb3JzO1xyXG5cdHZhciBpdGVyYXRlX2FuY2VzdG9yX2NsYXNzZXMgPSBqLml0ZXJhdGVfYW5jZXN0b3JfY2xhc3NlcztcclxuXHR2YXIgaXNfYXJyX29mX2FycnMgPSBqLmlzX2Fycl9vZl9hcnJzO1xyXG5cdHZhciBpc19hcnJfb2Zfc3RycyA9IGouaXNfYXJyX29mX3N0cnM7XHJcblx0dmFyIGlzX2Fycl9vZl90ID0gai5pc19hcnJfb2ZfdDtcclxuXHR2YXIgY2xvbmUgPSBqc2d1aS5jbG9uZTtcclxuXHJcblx0dmFyIGRhdGFfdmFsdWVfaW5kZXggPSAwO1xyXG5cdHZhciBkYXRhX3ZhbHVlX2FiYnJldmlhdGlvbiA9ICd2YWwnO1xyXG5cclxuXHQvLyBkbyBkYXRhIG9iamVjdHMgZ2V0IGFuIElEIHdoZW4gdGhleSBhcmUgaW5pdGlhbGl6ZWQuXHJcblx0anNndWkuX19kYXRhX2lkX21ldGhvZCA9ICdpbml0JztcclxuXHJcblx0dmFyIG9ial9tYXRjaGVzX2NvbnN0cmFpbnQgPSBDb25zdHJhaW50Lm9ial9tYXRjaGVzX2NvbnN0cmFpbnQ7XHJcblx0dmFyIG5hdGl2ZV9jb25zdHJ1Y3Rvcl90b2YgPSBqc2d1aS5uYXRpdmVfY29uc3RydWN0b3JfdG9mO1xyXG5cclxuXHR2YXIgdmFsdWVfYXNfZmllbGRfY29uc3RyYWludCA9IENvbnN0cmFpbnQudmFsdWVfYXNfZmllbGRfY29uc3RyYWludDtcclxuXHJcblx0dmFyIE9yZGVyZWRfU3RyaW5nX0xpc3QgPSBEYXRhX1N0cnVjdHVyZXMuT3JkZXJlZF9TdHJpbmdfTGlzdDtcclxuXHJcblx0Ly8gV2hlbiBzZXR0aW5nIHRoZSBmaWVsZHMsIGluZGV4ZXMgbWF5IG5lZWQgdG8gYmUgc2V0IHRvby4uLlxyXG5cclxuXHJcblx0Ly8gZ2V0cyBhIHZhbHVlIGFzIGEgZmllbGRfY29uc3RyYWludCBvYmplY3QuXHJcblx0Ly92YXIgZW5zdXJlX2RhdGFfdHlwZV9kYXRhX29iamVjdF9jb25zdHJ1Y3RvciA9IGouZW5zdXJlX2RhdGFfdHlwZV9kYXRhX29iamVjdF9jb25zdHJ1Y3RvcjtcclxuXHJcblxyXG5cdC8vIFNvLCBEYXRhX09iamVjdHMgbWF5IGhhdmUgYSBQYWdlX0NvbnRleHQsIEFwcGxpY2F0aW9uX0NvbnRleHQsIG9yIGp1c3QgQ29udGV4dC5cclxuXHQvLyAgVGhlIENvbnRleHQgd291bGQgaW5jbHVkZSBpbmZvIHN1Y2ggYXMgd2hpY2ggYnJvd3NlciBpcyBiZWluZyB1c2VkLlxyXG5cdC8vICAgQ29udHJvbHMgd2lsbCByZW5kZXIgZGlmZmVyZW50bHkgZGVwZW5kaW5nIG9uIHRoZSBjb250ZXh0LlxyXG5cclxuXHQvLyBqc2d1aS5kYXRhX3R5cGVzX2luZm8gYW5kIGRhdGFfdHlwZSB3aWxsIGJlY29tZSBtdWNoIG1vcmUgY2xvc2VseSBpbnRlZ3JhdGVkIGludG8gdGhpcy5cclxuXHQvLyAgUGVyaGFwcyB0aGVyZSBzaG91bGQgYmUgYW5vdGhlciBtb2R1bGUgbGV2ZWwgZm9yIHRoaXMuXHJcblxyXG5cdC8vIE5vdCBzdXJlIGFib3V0IGludHJvZHVjaW5nIGl0IGhlcmUuIE1heWJlIGluIGxhbmctZXNzZW50aWFscz8gRG9uJ3Qgd2FudCB0aGF0IHRvIGdldCB0b28gYmlnLlxyXG5cclxuXHQvLyBEYXRhX09iamVjdCBGbGFncyBpcyB0aGUgbmV4dCB0aGluZyBoZXJlLi4uXHJcblx0Ly8gIEJ1dCB0aGF0IHJlcXVpcmVzIGEgQ29sbGVjdGlvbi5cclxuXHQvLyBDYW4gbWFrZSBFbmhhbmNlZF9EYXRhX09iamVjdD9cclxuXHQvLyAgT3IgbWFrZSBEYXRhX09iamVjdCBlbmhhbmNlIGl0c2VsZiBvbmNlIGl0IGhhcyBhIENvbGxlY3Rpb24uXHJcblx0Ly8gIE9yIGNvdWxkIGRvIEZsYWdzIG9uIGEgbG93ZXIgbGV2ZWwuXHJcblxyXG5cdC8vIFF1aXRlIGEgY29tcGxpY2F0ZWQgcXVlc3Rpb24uXHJcblx0Ly8gIEZsYWdzIHJ1bm5pbmcgYXMgYSBjb2xsZWN0aW9uIG9mIHN0cmluZ3MgbWFrZXMgYSBsb3Qgb2Ygc2Vuc2UuXHJcblx0Ly8gICBXaWxsIGJlIG9yZGVyZWQgZXRjLlxyXG5cclxuXHR2YXIgcGFyc2VfZmllbGRfdGV4dCA9IGZ1bmN0aW9uKGZpZWxkX3RleHQpIHtcclxuXHRcdGZpZWxkX3RleHQgPSBmaWVsZF90ZXh0LnJlcGxhY2UoL25vdCBudWxsL2csICdub3RfbnVsbCcpO1xyXG5cdFx0dmFyIGlzX3VuaXF1ZSA9IGZhbHNlO1xyXG5cdFx0dmFyIGlzX2luZGV4ZWQgPSBmYWxzZTtcclxuXHRcdHZhciBpc19ub3RfbnVsbCA9IGZhbHNlO1xyXG5cdFx0dmFyIGlzX3JlYWRfb25seSA9IGZhbHNlLCBpc19wayA9IGZhbHNlO1xyXG5cdFx0dmFyIGZpZWxkX3dvcmRzID0gZmllbGRfdGV4dC5zcGxpdCgnICcpO1xyXG5cdFx0dmFyIGZsYWdfd29yZHMgPSBbXTtcclxuXHRcdHZhciBzdHJfZGF0YV90eXBlO1xyXG5cdFx0dmFyIHdvcmQ7XHJcblx0XHRmb3IgKHZhciBjID0gMCwgbCA9IGZpZWxkX3dvcmRzLmxlbmd0aDsgYyA8IGw7IGMrKykge1xyXG5cdFx0XHR3b3JkID0gZmllbGRfd29yZHNbY107XHJcblx0XHRcdGlmIChjIDwgbCAtIDEpIHtcclxuXHRcdFx0XHRmbGFnX3dvcmRzLnB1c2god29yZCk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0c3RyX2RhdGFfdHlwZSA9IHdvcmQ7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdGVhY2goZmxhZ193b3JkcywgZnVuY3Rpb24oaSwgdikge1xyXG5cdFx0XHRpZiAodiA9PSAndW5pcXVlJykge1xyXG5cdFx0XHRcdGlzX3VuaXF1ZSA9IHRydWU7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKHYgPT0gJ3BrJykge1xyXG5cdFx0XHRcdGlzX3BrID0gdHJ1ZTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAodiA9PSAnaW5kZXhlZCcpIHtcclxuXHRcdFx0XHRpc19pbmRleGVkID0gdHJ1ZTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAodiA9PSAnbm90X251bGwnKSB7XHJcblx0XHRcdFx0aXNfbm90X251bGwgPSB0cnVlO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmICh2ID09ICdyZWFkb25seScgfHwgdiA9PSAncmVhZF9vbmx5JyB8fCB2ID09ICdyZWFkLW9ubHknKSB7XHJcblx0XHRcdFx0aXNfcmVhZF9vbmx5ID0gdHJ1ZTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0XHR2YXIgZGF0YV90eXBlID0gcGFyc2VfZGF0YV90eXBlKHN0cl9kYXRhX3R5cGUpO1xyXG5cdFx0dmFyIHJlcyA9IHtcclxuXHRcdFx0Ly8naXNfdW5pcXVlJzogaXNfdW5pcXVlLFxyXG5cdFx0XHQvLydpc19pbmRleGVkJzogaXNfaW5kZXhlZCxcclxuXHRcdFx0Ly8naXNfbm90X251bGwnOiBpc19ub3RfbnVsbCxcclxuXHRcdFx0J2RhdGFfdHlwZSc6IGRhdGFfdHlwZVxyXG5cdFx0fVxyXG5cdFx0aWYgKGlzX3JlYWRfb25seSkge1xyXG5cdFx0XHRyZXMucmVhZF9vbmx5ID0gaXNfcmVhZF9vbmx5O1xyXG5cdFx0fVxyXG5cdFx0aWYgKGlzX3BrKSB7XHJcblx0XHRcdHJlcy5wayA9IGlzX3BrO1xyXG5cdFx0fVxyXG5cdFx0aWYgKGlzX3VuaXF1ZSkge1xyXG5cdFx0XHRyZXMudW5pcXVlID0gaXNfdW5pcXVlO1xyXG5cdFx0fVxyXG5cdFx0aWYgKGlzX25vdF9udWxsKSB7XHJcblx0XHRcdHJlcy5ub3RfbnVsbCA9IGlzX25vdF9udWxsO1xyXG5cdFx0fVxyXG5cdFx0aWYgKGlzX2luZGV4ZWQpIHtcclxuXHRcdFx0cmVzLmluZGV4ZWQgPSBpc19pbmRleGVkO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHJlcztcclxuXHR9XHJcblxyXG5cclxuXHR2YXIgcGFyc2VfZGF0YV90eXBlID0gZnVuY3Rpb24oZGF0YV90eXBlX3RleHQpIHtcclxuXHJcblx0XHQvL2NvbnNvbGUubG9nKCdkYXRhX3R5cGVfdGV4dCAnICsgZGF0YV90eXBlX3RleHQpO1xyXG5cdFx0Ly8gd2lsbCByZXR1cm4gdGhlIGRhdGEgdHlwZSBpbmZvIGFzIGFuIG9iamVjdCAvIGFycmF5XHJcblxyXG5cdFx0Ly8gY291bGQganVzdCByZXR1cm4gYSBzdHJpbmdcclxuXHRcdC8vIGNvdWxkIHJldHVybiBbZHRfbmFtZSwgbGVuZ3RoXVxyXG5cclxuXHRcdC8vIHNob3VsZCBub3QgYmVnaW4gd2l0aCBhIG51bWJlclxyXG5cclxuXHRcdC8vdmFyIHJ4X2R0ID0gL14oKFthLXpdfFtBLVpdfF8pXFx3KikoXFwoW2Etel18W0EtWl18X1xcdytcXCkpPyQvO1xyXG5cdFx0dmFyIHJ4X2R0ID0gL14oKFthLXpdfFtBLVpdfF8pXFx3KikoXFwoKFxcZCspXFwpKT8vO1xyXG5cclxuXHRcdC8vIHRoZW4gY2hlY2sgdG8gc2VlIHRoZSBtYXRjaC5cclxuXHJcblx0XHR2YXIgbWF0Y2ggPSBkYXRhX3R5cGVfdGV4dC5tYXRjaChyeF9kdCk7XHJcblxyXG5cclxuXHRcdC8vY29uc29sZS5sb2coJ21hdGNoICcgKyBzdHJpbmdpZnkobWF0Y2gpKTtcclxuXHJcblx0XHRpZiAobWF0Y2gpIHtcclxuXHRcdFx0dmFyIGR0X25hbWUgPSBtYXRjaFsxXTtcclxuXHRcdFx0dmFyIGR0X2xlbmd0aCA9IHBhcnNlSW50KG1hdGNoWzRdKTtcclxuXHJcblx0XHRcdGlmIChpc19kZWZpbmVkKGR0X2xlbmd0aCkgJiEgaXNOYU4oZHRfbGVuZ3RoKSkge1xyXG5cdFx0XHRcdHJldHVybiBbZHRfbmFtZSwgZHRfbGVuZ3RoXTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRyZXR1cm4gZHRfbmFtZTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vdGhyb3coJ3BhcnNlX2RhdGFfdHlwZSBzdG9wJyk7XHJcblx0fVxyXG5cclxuXHJcblx0dmFyIGZpZWxkX29ial90b190ZXh0ID0gZnVuY3Rpb24oZmllbGRfb2JqKSB7XHJcblx0XHQvL3ZhciByZXMgPSBbXTtcclxuXHJcblx0XHR2YXIgd29yZHMgPSBbXTtcclxuXHRcdGlmIChmaWVsZF9vYmoudW5pcXVlKSB7XHJcblx0XHRcdHdvcmRzLnB1c2goJ3VuaXF1ZScpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKGZpZWxkX29iai5waykge1xyXG5cdFx0XHR3b3Jkcy5wdXNoKCdwaycpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKGZpZWxkX29iai5pbmRleGVkKSB7XHJcblx0XHRcdHdvcmRzLnB1c2goJ2luZGV4ZWQnKTtcclxuXHRcdH1cclxuXHRcdGlmIChmaWVsZF9vYmoubm90X251bGwpIHtcclxuXHRcdFx0d29yZHMucHVzaCgnbm90X251bGwnKTtcclxuXHRcdH1cclxuXHRcdGlmIChmaWVsZF9vYmoucmVhZF9vbmx5KSB7XHJcblx0XHRcdHdvcmRzLnB1c2goJ3JlYWRfb25seScpO1xyXG5cdFx0fVxyXG5cclxuXHJcblx0XHQvKlxyXG5cclxuXHRcdGlmIChpc19kZWZpbmVkKGZpZWxkX29iai5sZW5ndGgpKSB7XHJcblx0XHRcdHdvcmRzLnB1c2goZmllbGRfb2JqLmRhdGFfdHlwZSk7XHJcblx0XHRcdHdvcmRzLnB1c2goJygnKTtcclxuXHRcdFx0d29yZHMucHVzaChmaWVsZF9vYmoubGVuZ3RoKTtcclxuXHRcdFx0d29yZHMucHVzaCgnKScpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0d29yZHMucHVzaChmaWVsZF9vYmouZGF0YV90eXBlKTtcclxuXHRcdH1cclxuXHRcdCovXHJcblxyXG5cdFx0aWYgKHRvZihmaWVsZF9vYmopKVxyXG5cclxuXHRcdHJldHVybiB3b3Jkcy5qb2luKCcgJyk7XHJcblx0fVxyXG5cclxuXHJcblx0Ly8gQ291bGQgbWFrZSBhIGJhc2ljIERhdGFfT2JqZWN0IHRvbz9cclxuXHQvLyAgQmFzaWNfQ29sbGVjdGlvbj9cclxuXHJcblx0Ly8gVGhlbiBoYXZlIGRpZmZlcmVudCBsZXZlbHM/XHJcblx0dmFyIEZpZWxkc19Db2xsZWN0aW9uID0gQ2xhc3MuZXh0ZW5kKHtcclxuXHRcdC8vIGEgd2F5IG9mIGdldHRpbmcgYWxsIHRoZSBmaWVsZCBuYW1lcz9cclxuXHJcblx0XHQvLyBUaGUgRmllbGRfQ29sbGVjdGlvbiBjb3VsZCBob2xkIHRoZSBjb250ZXh0IHBlcmhhcHMuXHJcblxyXG5cdFx0J2luaXQnOiBmdW5jdGlvbihzcGVjKSB7XHJcblxyXG5cdFx0XHQvLyBjb3VsZCBoYXZlIGEgbWFwIG9mIHBvc2l0aW9ucyBvZiBmaWVsZHM/XHJcblx0XHRcdC8vICBhbHNvLCBhIExpbmtlZF9MaXN0IG1heSBiZSB1c2VmdWwgaGVyZS5cclxuXHJcblx0XHRcdC8vIFRoYXQgd2F5IGZpZWxkcyBjb3VsZCBiZSBxdWlja2x5IGFkZGVkLiBPcmRlciBnZXRzIG1haW50YWluZWQuXHJcblxyXG5cdFx0XHQvLyBGaWVsZHMgYXJlIHJlYWxseSB1c2VkIGFzIGEgc3lzdGVtIG9mIGluZmx1ZW5jaW5nIHRoZSBsb3dlci1sZXZlbCBjb25zdHJhaW50cyBhbmQgaW5kaWNlcy5cclxuXHRcdFx0Ly8gIFRoZXkgYXJlIGEgY29udmVuaWVudCB3YXkgb2YgcmVwcmVzZW50aW5nIGluZm9ybWF0aW9uIGFib3V0IGEgZmllbGQuXHJcblxyXG5cdFx0XHQvLyBQZXJoYXBzIGFuIE9yZGVyZWRfTGlzdCBtYWtlcyBzZW5zZS5cclxuXHRcdFx0Ly8gIExpa2UgYSBMaW5rZWRfTGlzdCwgYSB3cmFwcGVyIHRoYXQgdXNlcyBhIExpbmtlZCBMaXN0IGZvciB0aGUgT3JkZXJlZCBMaXN0IGZ1bmN0aW9uYWxpdHkuXHJcblxyXG5cdFx0XHQvLyBGaWVsZHMgYXJlIGRlZmluaXRlbHkga2VwdCBpbiBvcmRlciB0aGF0IHdheS5cclxuXHRcdFx0Ly8gIExpbmtlZF9NYXAgc2VlbWluZyBsaWtlIGEgdXNlZnVsIGRhdGEgc3RydWN0dXJlLlxyXG5cclxuXHRcdFx0Ly8gTm90IHN0b3JpbmcgYSBjb250ZXh0IGZvciB0aGUgZmllbGRzP1xyXG5cclxuXHRcdFx0dGhpcy5va3ZzID0gbmV3IERhdGFfU3RydWN0dXJlcy5PcmRlcmVkX0tWUygpO1xyXG5cdFx0XHQvL3RoaXMuY29udGFpbmluZ19vYmplY3QgPSBzcGVjLmNvbnRhaW5pbmdfb2JqZWN0O1xyXG5cclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdCdfZ2V0X2ZpZWxkX2luZGV4JzogZnVuY3Rpb24oZmllbGRfbmFtZSkge1xyXG5cdFx0XHQvL3ZhciByZXMgPSAtMTtcclxuXHRcdFx0Ly9lYWNoKClcclxuXHJcblx0XHRcdC8vIE1heWJlIGEgbGlua2VkIGxpc3Qgd291bGQgd29yayBiZXN0Li4uIHRoYXQgd2F5IHdlIGNhbiBzZWFyY2ggdGhyb3VnaCBpdCAoaXRlcmF0ZSB1bnRpbCBzdG9wKSB0byBmaW5kIHRoZSByZWxldmFudCBpdGVtLlxyXG5cdFx0XHQvLyAgbGlua2VkIGxpc3Qgd2l0aCBhbiBpbmRleCBhcyB3ZWxsPyBtYXAgaG9sZGluZyBhIGxpbmsgdG8gdGhlIG5vZGUgdGhhdCBob2xkcyB0aGUgZmllbGQgaXRlbS5cclxuXHJcblx0XHR9LFxyXG5cclxuXHJcblx0XHQvLyBDb3VsZCBtYXliZSB0ZXN0IGp1c3QgdGhlIGZpZWxkcyBjb2xsZWN0aW9uP1xyXG5cdFx0Ly8gIFNvIHdlIG1ha2UgYSBuZXcgY29sbGVjdGlvbiBvZiBmaWVsZHMgbm90IGFzc29jaWF0ZWQgd2l0aCBhIGNvbnRyb2w/XHJcblxyXG5cclxuXHRcdC8vIE5lZWRzIG1vcmUgd29yayBvbiB0aGlzIHBhcnQuLi5cclxuXHRcdC8vICBNYWtpbmcgaXQgcG9seW1vcnBoaWMgYW5kIGZsZXhpYmxlLCBjb3ZlcmluZyBhbGwgb3IgYXQgbGVhc3QgZW5vdWdoIGNhc2VzLlxyXG5cclxuXHRcdC8vIE5vbiBwb2x5bW9ycGhpYyB2ZXJzaW9uIHdvdWxkIGJlIGEgbG90IGZhc3Rlci5cclxuXHRcdC8vICBQZXJoYXBzIHVzaW5nIGFuIGlubmVyIGZ1bmN0aW9uIGZvciB0aGUgW3N0cmluZywgdmFsdWVdIG9wZXJhdGlvbnMsIGFuZCB0aGVcclxuXHRcdC8vICAgaXRlcmF0aXZlIHZlcnNpb24gbWFrZXMgdXNlIG9mIHRoYXQuXHJcblx0XHQvLydzZXQnOiBmcChmdW5jdGlvbihhLCBzaWcpIHtcclxuXHRcdCdzZXQnOiAoZnVuY3Rpb24oKSB7XHJcblx0ICAgICAgdmFyIGEgPSBhcmd1bWVudHM7XHJcblx0ICAgICAgYS5sID0gYXJndW1lbnRzLmxlbmd0aDtcclxuXHQgICAgICB2YXIgc2lnID0gZ2V0X2Ffc2lnKGFyZ3VtZW50cywgMSk7XHJcblxyXG5cdFx0XHQvLyBQcmltZSBjYW5kaWRhdGUgZm9yIG9wdGltaXphdGlvbiBoZXJlLlxyXG5cclxuXHRcdFx0Ly8gV2hlbiBzZXR0aW5nIGFuIGluZGV4ZWQgYXJyYXkgRGF0YV9PYmplY3QsIGl0IHNldHMgYSBmaWVsZCBjb2xsZWN0aW9uLlxyXG5cdFx0XHQvLyAgVGhpcyBpcyB0aGUgY2FzZSB3aXRoIGEgQ29sb3IgRGF0YV9PYmplY3QuXHJcblx0XHRcdC8vICAgSXQgaGFzIGZpZWxkcyBmb3IgcmVkLCBncmVlbiwgYmx1ZS4gUGVyaGFwcyBhbHBoYS5cclxuXHJcblxyXG5cdFx0XHQvKiBUaGlzIG5lZWRzIHRvIHdvcms6XHJcblxyXG5cdFx0XHQnZmllbGRzJzoge1xyXG5cdFx0XHRcdCdwcm9kdWN0cyc6IFByb2R1Y3RzX0NvbGxlY3Rpb25cclxuXHRcdFx0fSxcclxuXHJcblx0XHRcdCovXHJcblxyXG5cdFx0XHQvLyBbZmllbGQgbmFtZSwgZnVuY3Rpb24gKGNvbnN0cnVjdG9yKV1cclxuXHJcblx0XHRcdC8vIHdpbGwgYWRkIHRoZSBmaWVsZCB0byB0aGUgYXJyYXkuXHJcblxyXG5cdFx0XHQvL2NvbnNvbGUubG9nKCdGaWVsZHNfQ29sbGVjdGlvbiBzZXQgYSAnICsgc3RyaW5naWZ5KGEpKTtcclxuXHRcdFx0Ly9jb25zb2xlLmxvZygnRmllbGRzX0NvbGxlY3Rpb24gc2V0IHNpZzogJyArIHNpZyk7XHJcblx0XHRcdC8vY29uc29sZS5sb2coJ0ZpZWxkc19Db2xsZWN0aW9uIHNldCBhICcgKyBzdHJpbmdpZnkoYSkpO1xyXG5cdFx0XHQvLyBhbmQgd2hlbiB0aGlzIGhhcyAyIHN0cmluZ3MuLi5cclxuXHJcblx0XHRcdC8vdGhyb3cgJ3N0b3AnO1xyXG5cclxuXHRcdFx0Ly9jb25zb2xlLmxvZ1xyXG5cclxuXHRcdFx0Ly8gW1tuLHNdLFtuLGFdXSAtIFRoYXQgbG9va3MgcG9zc2libHkgd3JvbmcgYW55d2F5LlxyXG5cclxuXHRcdFx0Ly8gVXNpbmcgYSAoY29uc3RydWN0b3IpIGZ1bmN0aW9uIGluIHRoZSBmaWVsZCBkZWZpbnRpb24uXHJcblx0XHRcdC8vIFsnbmV0d29ya0ludGVyZmFjZXMnLCBOZXR3b3JrSW50ZXJmYWNlc11cclxuXHJcblx0XHRcdHZhciB0aGF0ID0gdGhpcztcclxuXHRcdFx0Ly92YXIgY29udGFpbmluZ19vYmplY3QgPSB0aGF0LmNvbnRhaW5pbmdfb2JqZWN0O1xyXG5cdFx0XHQvLyBzdHIsIHN0clxyXG5cdFx0XHQvLyAgZmllbGRfbmFtZSwgc3RyX2ZpZWxkX2RlZlxyXG5cdFx0XHQvLyB3aGF0IGFib3V0IHNldHRpbmcgYSBzaW5nbGUgZmllbGQgd2l0aCBhbiBhcnJheT9cclxuXHJcblx0XHRcdC8vIGNhbiBjaGVjayB0aGUgZm9ybWF0cyAtIHN0cmluZywgYW55dGhpbmdcclxuXHJcblx0XHRcdC8vIFdpbGwgaGF2ZSBmYWlybHkgdmVyc2l0aWxlIGZpZWxkIGRlZmluaXRpb25zLlxyXG5cclxuXHRcdCAgICAvLyBbW1snY29udGVudCcsIFsnY29sbGVjdGlvbicsICdjb250cm9sXV1dXVxyXG5cdFx0XHQvL2NvbnNvbGUubG9nKFwiPj4+IHNpZz1cIiArIHNpZyk7XHJcblx0XHRcdGlmIChzaWcgPT0gJ1thXScpIHtcclxuXHJcblx0XHRcdFx0Ly9jb25zb2xlLmxvZygnYS5sICcgKyBhLmwpO1xyXG5cclxuXHRcdFx0XHR2YXIgaXRlbV9vcl9hcnIgPSBhWzBdO1xyXG5cdFx0XHRcdC8vdmFyIGlvYV9zaWcgPSBnZXRfaXRlbV9zaWcoaXRlbV9vcl9hcnIpO1xyXG5cdFx0XHRcdHZhciBpb2Ffc2lnID0gZ2V0X2l0ZW1fc2lnKGl0ZW1fb3JfYXJyLCAyKTtcclxuXHJcblx0XHRcdFx0Ly8gd2FudCB0aGUgc2lnbmF0dXJlIHRoYXQgd2lsbCBnbyBpbnRvIHRoZSBhcnJheS5cclxuXHRcdFx0XHQvLyAgbmVlZCB0byB1c2UgYSBuZXcgb3B0aW9uIG9uIGdldF9pdGVtX3NpZ1xyXG5cdFx0XHRcdC8vY29uc29sZS5sb2coJ2lvYV9zaWcgJyArIGlvYV9zaWcpO1xyXG5cdFx0XHRcdC8vY29uc29sZS5sb2coJ2l0ZW1fb3JfYXJyICcgKyBzdHJpbmdpZnkoaXRlbV9vcl9hcnIpKTtcclxuXHRcdFx0XHQvLyBuZWVkIHRvIHNvcnQgb3V0IHRoaXMgY29kZS4uLlxyXG5cclxuXHRcdFx0XHQvLyBCdXQgd2UgZG9uJ3Qgd2FudCB0byBtaXNpbnRlcnByZXQgYSBzaW5nbGUgZmllbGQgYXMgYW4gYXJyYXkgb2YgZmllbGRzLlxyXG5cclxuXHJcblx0XHRcdFx0Ly8gaW9hX3NpZyBbW3MsfkNdLFtzLHNdLFtzLHNdLFtzLH5DXSxzXVxyXG5cclxuXHRcdFx0XHQvLyBhcnJheSwgc3RyaW5nXHJcblxyXG5cdFx0XHRcdC8vIFthLGFdXHJcblx0XHRcdFx0Ly8gIGRhdGEgdHlwZSBpbmZvIGlzIG9uIHRoZSBsZWZ0LlxyXG5cdFx0XHRcdC8vICB0aGVuIHRoZSB2YWx1ZShzKSBhcmUgb24gdGhlIHJpZ2h0LlxyXG5cclxuXHJcblx0XHRcdFx0Ly9jb25zb2xlLmxvZygnaXRlbV9vcl9hcnIgJyArIHN0cmluZ2lmeShpdGVtX29yX2FycikpO1xyXG5cclxuXHRcdFx0XHRpZiAoaW9hX3NpZyA9PSAnW3Msc10nKSB7XHJcblx0XHRcdFx0XHQvLyBzdHJpbmcgbmFtZSB3aXRoIHN0cmluZyBmaWVsZCByZXByZXNlbnRhdGlvblxyXG5cdFx0XHRcdFx0dmFyIGZpZWxkX25hbWUgPSBpdGVtX29yX2FyclswXTtcclxuXHRcdFx0XHRcdHZhciBmaWVsZF9zdHJfZGVmID0gaXRlbV9vcl9hcnJbMV07XHJcblxyXG5cdFx0XHRcdFx0Ly9jb25zb2xlLmxvZygnZmllbGRfbmFtZSAnICsgZmllbGRfbmFtZSk7XHJcblxyXG5cdFx0XHRcdFx0Ly9jb25zb2xlLmxvZygnKioqICoqKiBmaWVsZF9zdHJfZGVmICcgKyBmaWVsZF9zdHJfZGVmKTtcclxuXHJcblx0XHRcdFx0XHR2YXIgZmllbGRfb2JqID0gcGFyc2VfZmllbGRfdGV4dChmaWVsZF9zdHJfZGVmKTtcclxuXHRcdFx0XHRcdC8vY29uc29sZS5sb2coJ2ZpZWxkX29iaiAnICsgc3RyaW5naWZ5KGZpZWxkX29iaikpO1xyXG5cclxuXHJcblx0XHRcdFx0XHR2YXIgZmllbGRfYXJyID0gW2ZpZWxkX25hbWUsIGZpZWxkX3N0cl9kZWYsIGZpZWxkX29ial07XHJcblxyXG5cdFx0XHRcdFx0Ly9jb25zb2xlLmxvZygnc2V0dGluZyB3aXRoIGZpZWxkX2FyciAnICsgc3RyaW5naWZ5KGZpZWxkX2FycikpO1xyXG5cclxuXHRcdFx0XHRcdHRoaXMuc2V0KGZpZWxkX2Fycik7XHJcblxyXG5cdFx0XHRcdFx0Ly9maWVsZF9vYmoucGFyZW50KGNvbnRhaW5pbmdfb2JqZWN0KTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIGlmIChpb2Ffc2lnID09ICdbcyxmXScpIHtcclxuXHRcdFx0XHRcdC8vIHRoZSBmdW5jdGlvbiBpcyBhIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIChzaG91bGQgYmUgb25lLCBtYXliZSB0ZXN0IHRoaXM/KVxyXG5cclxuXHRcdFx0XHRcdC8vIEEgQ2xhc3MgZmllbGQuXHJcblxyXG5cdFx0XHRcdFx0dmFyIGZpZWxkX25hbWUgPSBpdGVtX29yX2FyclswXTtcclxuXHRcdFx0XHRcdHZhciBmaWVsZF9zdHJfZGVmID0gJ0NsYXNzJztcclxuXHRcdFx0XHRcdHZhciBmaWVsZF9vYmogPSBpdGVtX29yX2FyclsxXTtcclxuXHJcblx0XHRcdFx0XHR2YXIgZmllbGRfYXJyID0gW2ZpZWxkX25hbWUsIGZpZWxkX3N0cl9kZWYsIGZpZWxkX29ial07XHJcblxyXG5cdFx0XHRcdFx0Ly8gdGhlbiBhY3R1YWxseSBkbyB0aGUgc2V0LlxyXG5cclxuXHRcdFx0XHRcdC8vICBmaW5kIHRoZSBpbmRleCBvZiB0aGUgaXRlbVxyXG5cdFx0XHRcdFx0Ly9jb25zb2xlLmxvZygncHV0dGluZyBpbiBva3ZzIGZpZWxkX25hbWU6ICcgKyBmaWVsZF9uYW1lKTtcclxuXHRcdFx0XHRcdC8vY29uc29sZS5sb2coJ3B1dHRpbmcgaW4gb2t2cyBmaWVsZF9uYW1lOiAnICsgZmllbGRfbmFtZSk7XHJcblx0XHRcdFx0XHR0aGlzLm9rdnMucHV0KGZpZWxkX25hbWUsIGZpZWxkX2Fycik7XHJcblxyXG5cdFx0XHRcdFx0Ly90aHJvdyAnaW9hIHN0b3AnO1xyXG5cclxuXHRcdFx0XHR9IGVsc2UgaWYgKGlvYV9zaWcgPT0gJ1tzLHMsb10nKSB7XHJcblx0XHRcdFx0XHQvLyBzdHJpbmcgbmFtZSB3aXRoIHN0cmluZyBmaWVsZCByZXByZXNlbnRhdGlvblxyXG5cdFx0XHRcdFx0dmFyIGZpZWxkX25hbWUgPSBpdGVtX29yX2FyclswXTtcclxuXHRcdFx0XHRcdHZhciBmaWVsZF9zdHJfZGVmID0gaXRlbV9vcl9hcnJbMV07XHJcblx0XHRcdFx0XHR2YXIgZmllbGRfb2JqID0gaXRlbV9vcl9hcnJbMl07XHJcblx0XHRcdFx0XHQvL3ZhciBmaWVsZF9hcnIgPSBbZmllbGRfbmFtZSwgZmllbGRfc3RyX2RlZiwgZmllbGRfb2JqXTtcclxuXHRcdFx0XHRcdC8vdGhpcy5zZXQoZmllbGRfYXJyKTtcclxuXHJcblxyXG5cclxuXHRcdFx0XHRcdHZhciBmaWVsZF9hcnIgPSBbZmllbGRfbmFtZSwgZmllbGRfc3RyX2RlZiwgZmllbGRfb2JqXTtcclxuXHJcblx0XHRcdFx0XHQvLyB0aGVuIGFjdHVhbGx5IGRvIHRoZSBzZXQuXHJcblxyXG5cdFx0XHRcdFx0Ly8gIGZpbmQgdGhlIGluZGV4IG9mIHRoZSBpdGVtXHJcblx0XHRcdFx0XHQvL2NvbnNvbGUubG9nKCdwdXR0aW5nIGluIG9rdnMgZmllbGRfbmFtZTogJyArIGZpZWxkX25hbWUpO1xyXG5cdFx0XHRcdFx0Ly9jb25zb2xlLmxvZygncHV0dGluZyBpbiBva3ZzIGZpZWxkX25hbWU6ICcgKyBmaWVsZF9uYW1lKTtcclxuXHRcdFx0XHRcdHRoaXMub2t2cy5wdXQoZmllbGRfbmFtZSwgZmllbGRfYXJyKTtcclxuXHRcdFx0XHRcdC8vZmllbGRfb2JqLnBhcmVudChjb250YWluaW5nX29iamVjdCk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHQvL2NvbnNvbGUubG9nKCdvdGhlciBhcnJheSwgY2hlY2sgZm9yIGFycl9vZl9hcnJzJyk7XHJcblx0XHRcdFx0XHQvL3ZhciBpb2Ffc2lnID0gZ2V0X2l0ZW1fc2lnKGl0ZW1fb3JfYXJyKTtcclxuXHJcblx0XHRcdFx0XHQvL2NvbnNvbGUubG9nKCdpb2Ffc2lnICcgKyBpb2Ffc2lnKTtcclxuXHJcblx0XHRcdFx0XHQvLyBCdXQgdGhlcmUgY291bGQgYmUgYSBjb2xsZWN0aW9uIC0gcGVyaGFwcyBhbiBhYnN0cmFjdCBjb2xsZWN0aW9uLlxyXG5cdFx0XHRcdFx0Ly8gIEkgdGhpbmsgaW5kaWNhdGUgdHlwZSBhcyB+Q29sbGVjdGlvbi5cclxuXHRcdFx0XHRcdC8vICBhbmQgfkNcclxuXHJcblxyXG5cclxuXHRcdFx0XHRcdC8vIG4scyxzLD8gLSB0aGUgaXRlbSBpbiB0aGUgPyBpcyB0aGUgZGVmYWlsdF92YWx1ZS5cclxuXHJcblx0XHRcdFx0XHQvLyB3aWxsIHVzZSByZWdleCBcXGQgbWF0Y2hpbmcuXHJcblxyXG5cdFx0XHRcdFx0dmFyIHJ4X3Rlc3Rfc2lnX2RlZmF1bHRfdmFsdWUgPSAvXFxbbixcXFtzLHMsXFx3XFxdXFxdLztcclxuXHJcblxyXG5cdFx0XHRcdFx0Ly8gT3JkaW5hbCBwb3NpdGlvbiBvZiBmaWVsZHMuLi5cclxuXHRcdFx0XHRcdC8vICBNYXkgbmVlZCB0byBiZSBjYXJlZnVsIGFib3V0IHRoYXQuXHJcblxyXG5cclxuXHRcdFx0XHRcdGlmIChpb2Ffc2lnID09ICdbbixbcyxzXV0nKSB7XHJcblx0XHRcdFx0XHRcdC8vIGEgbnVtYmVyLCB0aGUgaW5kZXggaW4gYXJyYXkgLyBzZXF1ZW5jZSwgdGhlbiBuYW1lLCB0aGVuIGRhdGFfdHlwZV9uYW1lXHJcblxyXG5cdFx0XHRcdFx0XHQvL2NvbnNvbGUubG9nKCdpdGVtX29yX2FyciAnICsgc3RyaW5naWZ5KGl0ZW1fb3JfYXJyKSk7XHJcblxyXG5cdFx0XHRcdFx0XHR2YXIgZmllbGRfZGVmID0gaXRlbV9vcl9hcnJbMV07XHJcblx0XHRcdFx0XHRcdHZhciBmaWVsZF9uYW1lID0gZmllbGRfZGVmWzBdO1xyXG5cdFx0XHRcdFx0XHR2YXIgZmllbGRfdHlwZV9uYW1lID0gZmllbGRfZGVmWzFdO1xyXG5cclxuXHRcdFx0XHRcdFx0Ly9jb25zb2xlLmxvZygnZmllbGRfbmFtZSAnICsgZmllbGRfbmFtZSk7XHJcblx0XHRcdFx0XHRcdC8vY29uc29sZS5sb2coJ2ZpZWxkX3R5cGVfbmFtZSAnICsgZmllbGRfdHlwZV9uYW1lKTtcclxuXHJcblx0XHRcdFx0XHRcdGlmIChmaWVsZF90eXBlX25hbWUgPT0gJ2NvbGxlY3Rpb24nKSB7XHJcblx0XHRcdFx0XHRcdFx0Ly8gc2hvdWxkIGJlIGEgY29sbGVjdGlvbiBvZiB0aGF0IHR5cGUuXHJcblxyXG5cdFx0XHRcdFx0XHRcdC8vdmFyIGZpZWxkX2FyciA9IFtmaWVsZF9uYW1lLCBmaWVsZF90eXBlX25hbWUsIGZpZWxkX2l0ZW1fdHlwZV9uYW1lXTsjXHJcblx0XHRcdFx0XHRcdFx0aWYgKGZpZWxkX2l0ZW1fdHlwZV9uYW1lKSB7XHJcblx0XHRcdFx0XHRcdFx0XHR2YXIgZmllbGRfYXJyID0gW2ZpZWxkX25hbWUsIFtmaWVsZF90eXBlX25hbWUsIGZpZWxkX2l0ZW1fdHlwZV9uYW1lXV07XHJcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0XHRcdHZhciBmaWVsZF9hcnIgPSBbZmllbGRfbmFtZSwgZmllbGRfdHlwZV9uYW1lXTtcclxuXHRcdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRcdC8vIHRoZW4gYWN0dWFsbHkgZG8gdGhlIHNldC5cclxuXHRcdFx0XHRcdFx0XHQvLyAgZmluZCB0aGUgaW5kZXggb2YgdGhlIGl0ZW1cclxuXHRcdFx0XHRcdFx0XHQvL2NvbnNvbGUubG9nKCdwdXR0aW5nIGluIG9rdnMgZmllbGRfbmFtZTogJyArIGZpZWxkX25hbWUpO1xyXG5cdFx0XHRcdFx0XHRcdHRoaXMub2t2cy5wdXQoZmllbGRfbmFtZSwgZmllbGRfYXJyKTtcclxuXHJcblxyXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0XHQvLyBJIHRoaW5rIHRoZSBmaWVsZCBjb2xsZWN0aW9uIGhlcmUgaXMgcmVhbGx5IGp1c3QgZm9yIHN0b3JpbmcgaW5mbyBhYm91dCB0aGUgZmllbGRzLlxyXG5cdFx0XHRcdFx0XHRcdC8vICBJdCBpcyB3aGVuIHRoZSBvYmplY3RzIHJlcHJlc2VudGVkIGJ5IGZpZWxkcyBhcmUgZ2V0IGFuZCBzZXQgdGhhdCB0aGUgZmllbGQgZnVuY3Rpb25hbGl0eSByZWFsbHkgY29tZXMgaW50byBwbGF5LlxyXG5cclxuXHRcdFx0XHRcdFx0XHQvLyBjYW4gYmUgdGhlIHNhbWUgYXMgd2l0aCBjb2xsZWN0aW9uIVxyXG5cdFx0XHRcdFx0XHRcdC8vICBtYXkgZG8gc29tZSBtb3JlIGNoZWNrcz9cclxuXHJcblx0XHRcdFx0XHRcdFx0dmFyIGZpZWxkX2FyciA9IFtmaWVsZF9uYW1lLCBmaWVsZF90eXBlX25hbWVdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHQvL2NvbnNvbGUubG9nKCdmaWVsZF9hcnIgJyArIHN0cmluZ2lmeShmaWVsZF9hcnIpKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0Ly8gdGhlbiBhY3R1YWxseSBkbyB0aGUgc2V0LlxyXG5cdFx0XHRcdFx0XHRcdC8vICBmaW5kIHRoZSBpbmRleCBvZiB0aGUgaXRlbVxyXG5cdFx0XHRcdFx0XHRcdC8vY29uc29sZS5sb2coJ3B1dHRpbmcgaW4gb2t2cyBmaWVsZF9uYW1lOiAnICsgZmllbGRfbmFtZSk7XHJcblx0XHRcdFx0XHRcdFx0dGhpcy5va3ZzLnB1dChmaWVsZF9uYW1lLCBmaWVsZF9hcnIpO1xyXG5cdFx0XHRcdFx0XHRcdC8vY29uc29sZS5sb2coJ2RvbmUgb2t2cyBwdXQnKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0Ly90aHJvdygnNylzdG9wJyk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoaW9hX3NpZy5tYXRjaChyeF90ZXN0X3NpZ19kZWZhdWx0X3ZhbHVlKSkge1xyXG5cdFx0XHRcdFx0XHQvL2NvbnNvbGUubG9nKCdtYXRjaGVzIHJlZ2V4LCBoYXMgZGVmYXVsdCB2YWx1ZS4nKVxyXG5cdFx0XHRcdFx0XHQvL2NvbnNvbGUubG9nKCdpb2Ffc2lnICcgKyBpb2Ffc2lnKTtcclxuXHRcdFx0XHRcdFx0Ly90aHJvdyAnc3RvcCc7XHJcblx0XHRcdFx0XHRcdHZhciBmaWVsZF9kZWYgPSBpdGVtX29yX2FyclsxXTtcclxuXHRcdFx0XHRcdFx0Ly9jb25zb2xlLmxvZygnaXRlbV9vcl9hcnIgJyArIHN0cmluZ2lmeShpdGVtX29yX2FycikpO1xyXG5cdFx0XHRcdFx0XHR2YXIgZmllbGRfbmFtZSA9IGZpZWxkX2RlZlswXTtcclxuXHRcdFx0XHRcdFx0dmFyIGZpZWxkX3R5cGVfbmFtZSA9IGZpZWxkX2RlZlsxXTtcclxuXHRcdFx0XHRcdFx0dmFyIGZpZWxkX2RlZmF1bHRfdmFsdWUgPSBmaWVsZF9kZWZbMl07XHJcblxyXG5cclxuXHRcdFx0XHRcdFx0aWYgKGZpZWxkX3R5cGVfbmFtZSA9PSAnY29sbGVjdGlvbicpIHtcclxuXHRcdFx0XHRcdFx0XHQvLyBzaG91bGQgYmUgYSBjb2xsZWN0aW9uIG9mIHRoYXQgdHlwZS5cclxuXHRcdFx0XHRcdFx0XHR0aHJvdyAnRGVmYXVsdCB2YWx1ZXMgZm9yIENvbGxlY3Rpb24gbm90IHN1cHBvcnRlZCc7XHJcblx0XHRcdFx0XHRcdFx0Ly92YXIgZmllbGRfYXJyID0gW2ZpZWxkX25hbWUsIGZpZWxkX3R5cGVfbmFtZSwgZmllbGRfaXRlbV90eXBlX25hbWVdOyNcclxuXHRcdFx0XHRcdFx0XHRpZiAoZmllbGRfaXRlbV90eXBlX25hbWUpIHtcclxuXHRcdFx0XHRcdFx0XHRcdHZhciBmaWVsZF9hcnIgPSBbZmllbGRfbmFtZSwgW2ZpZWxkX3R5cGVfbmFtZSwgZmllbGRfaXRlbV90eXBlX25hbWVdXTtcclxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRcdFx0dmFyIGZpZWxkX2FyciA9IFtmaWVsZF9uYW1lLCBmaWVsZF90eXBlX25hbWVdO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdFx0Ly8gdGhlbiBhY3R1YWxseSBkbyB0aGUgc2V0LlxyXG5cdFx0XHRcdFx0XHRcdC8vICBmaW5kIHRoZSBpbmRleCBvZiB0aGUgaXRlbVxyXG5cdFx0XHRcdFx0XHRcdC8vY29uc29sZS5sb2coJ3B1dHRpbmcgaW4gb2t2cyBmaWVsZF9uYW1lOiAnICsgZmllbGRfbmFtZSk7XHJcblx0XHRcdFx0XHRcdFx0dGhpcy5va3ZzLnB1dChmaWVsZF9uYW1lLCBmaWVsZF9hcnIpO1xyXG5cclxuXHJcblx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdC8vIEkgdGhpbmsgdGhlIGZpZWxkIGNvbGxlY3Rpb24gaGVyZSBpcyByZWFsbHkganVzdCBmb3Igc3RvcmluZyBpbmZvIGFib3V0IHRoZSBmaWVsZHMuXHJcblx0XHRcdFx0XHRcdFx0Ly8gIEl0IGlzIHdoZW4gdGhlIG9iamVjdHMgcmVwcmVzZW50ZWQgYnkgZmllbGRzIGFyZSBnZXQgYW5kIHNldCB0aGF0IHRoZSBmaWVsZCBmdW5jdGlvbmFsaXR5IHJlYWxseSBjb21lcyBpbnRvIHBsYXkuXHJcblxyXG5cdFx0XHRcdFx0XHRcdC8vIGNhbiBiZSB0aGUgc2FtZSBhcyB3aXRoIGNvbGxlY3Rpb24hXHJcblx0XHRcdFx0XHRcdFx0Ly8gIG1heSBkbyBzb21lIG1vcmUgY2hlY2tzP1xyXG5cclxuXHRcdFx0XHRcdFx0XHR2YXIgZmllbGRfYXJyID0gW2ZpZWxkX25hbWUsIGZpZWxkX3R5cGVfbmFtZSwgZmllbGRfZGVmYXVsdF92YWx1ZV07XHJcblxyXG5cdFx0XHRcdFx0XHRcdC8vY29uc29sZS5sb2coJ2ZpZWxkX2FyciAnICsgc3RyaW5naWZ5KGZpZWxkX2FycikpO1xyXG5cclxuXHRcdFx0XHRcdFx0XHQvLyB0aGVuIGFjdHVhbGx5IGRvIHRoZSBzZXQuXHJcblx0XHRcdFx0XHRcdFx0Ly8gIGZpbmQgdGhlIGluZGV4IG9mIHRoZSBpdGVtXHJcblx0XHRcdFx0XHRcdFx0Ly9jb25zb2xlLmxvZygncHV0dGluZyBpbiBva3ZzIGZpZWxkX25hbWU6ICcgKyBmaWVsZF9uYW1lKTtcclxuXHRcdFx0XHRcdFx0XHR0aGlzLm9rdnMucHV0KGZpZWxkX25hbWUsIGZpZWxkX2Fycik7XHJcblx0XHRcdFx0XHRcdFx0Ly9jb25zb2xlLmxvZygnZG9uZSBva3ZzIHB1dCcpO1xyXG5cclxuXHRcdFx0XHRcdFx0XHQvL3Rocm93KCc3KXN0b3AnKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHQvLyBpZiBpdCdzIGEgc3RyaW5nIGFuZCBhbiBvYmplY3RcclxuXHJcblxyXG5cdFx0XHRcdFx0aWYgKGlvYV9zaWcgPT0gJ1tzLFtzLHNdXScpIHtcclxuXHRcdFx0XHRcdFx0dmFyIGZpZWxkX25hbWUgPSBpdGVtX29yX2FyclswXTtcclxuXHRcdFx0XHRcdFx0dmFyIGZpZWxkX2RlZiA9IGl0ZW1fb3JfYXJyWzFdO1xyXG5cdFx0XHRcdFx0XHR2YXIgZmllbGRfdHlwZV9uYW1lID0gZmllbGRfZGVmWzBdO1xyXG5cdFx0XHRcdFx0XHR2YXIgZmllbGRfaXRlbV90eXBlX25hbWUgPSBmaWVsZF9kZWZbMV07XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoZmllbGRfdHlwZV9uYW1lID09ICdjb2xsZWN0aW9uJykge1xyXG5cdFx0XHRcdFx0XHRcdC8vIHNob3VsZCBiZSBhIGNvbGxlY3Rpb24gb2YgdGhhdCB0eXBlLlxyXG5cclxuXHRcdFx0XHRcdFx0XHQvL3ZhciBmaWVsZF9hcnIgPSBbZmllbGRfbmFtZSwgZmllbGRfdHlwZV9uYW1lLCBmaWVsZF9pdGVtX3R5cGVfbmFtZV07XHJcblx0XHRcdFx0XHRcdFx0dmFyIGZpZWxkX2FyciA9IFtmaWVsZF9uYW1lLCBbZmllbGRfdHlwZV9uYW1lLCBmaWVsZF9pdGVtX3R5cGVfbmFtZV1dO1xyXG5cdFx0XHRcdFx0XHRcdC8vIHRoZW4gYWN0dWFsbHkgZG8gdGhlIHNldC5cclxuXHRcdFx0XHRcdFx0XHQvLyAgZmluZCB0aGUgaW5kZXggb2YgdGhlIGl0ZW1cclxuXHRcdFx0XHRcdFx0XHQvL2NvbnNvbGUubG9nKCdwdXR0aW5nIGluIG9rdnMgZmllbGRfbmFtZTogJyArIGZpZWxkX25hbWUpO1xyXG5cdFx0XHRcdFx0XHRcdHRoaXMub2t2cy5wdXQoZmllbGRfbmFtZSwgZmllbGRfYXJyKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0Ly9jb25zb2xlLmxvZygnKiBpdGVtX29yX2FyciAnICsgc3RyaW5naWZ5KGl0ZW1fb3JfYXJyKSk7XHJcblx0XHRcdFx0XHRcdC8vY29uc29sZS5sb2coJ2lvYV9zaWcgJyArIGlvYV9zaWcpO1xyXG5cdFx0XHRcdFx0XHQvL2NvbnNvbGUubG9nKCdhICcgKyBzdHJpbmdpZnkoYSkpO1xyXG5cclxuXHRcdFx0XHRcdFx0Ly8gSGF2ZSBjaGFuZ2VkIHRoZSB3YXkgdGhhdCBzaWduYXR1cmVzIHdvcmsuLi4gbm93IGl0J3MgYSBmb3IgYXJyYXkuXHJcblxyXG5cclxuXHRcdFx0XHRcdFx0aWYgKGlvYV9zaWcgPT0gJ1tdJykge1xyXG5cclxuXHJcblx0XHRcdFx0XHRcdH0gaWYgKGlvYV9zaWcgPT0gJ1tvXScpIHtcclxuXHRcdFx0XHRcdFx0XHQvL2NvbnNvbGUubG9nKCdpb2Egc2lnIGlzIGFuIG9iamVjdCAnKTtcclxuXHRcdFx0XHRcdFx0XHQvL2NvbnNvbGUubG9nKCdpdGVtX29yX2FyciAnICsgc3RyaW5naWZ5KGl0ZW1fb3JfYXJyKSk7XHJcblx0XHRcdFx0XHRcdFx0dGhyb3cgJ3N0b3AnO1xyXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRcdC8vY29uc29sZS5sb2coJ3ByZSBzdG9wJyk7XHJcblx0XHRcdFx0XHRcdFx0Ly90aHJvdyAoJzYpc3RvcCcpO1xyXG5cclxuXHJcblxyXG5cdFx0XHRcdFx0XHRcdC8vIFNob3VsZCBoYXZlIGEgbW9yZSBjb21wbGV0ZSBwaWN0dXJlIG9mIHRoZSBmaWVsZHMuLi4gd2hlcmUgZG8gdGhlc2UgY29tZSBmcm9tP1xyXG5cclxuXHRcdFx0XHRcdFx0XHQvLyBbcyxvXSBvYmplY3QgYmVpbmcgYSBtb3JlIGNvbXBsZXggZGVmaW5pdGlvbi5cclxuXHRcdFx0XHRcdFx0XHQvLyAgcG9zc2libHkgYSBjb21wb3VuZCBvYmplY3QuXHJcblxyXG5cdFx0XHRcdFx0XHRcdC8vIEFuIG9iamVjdCB3aXRoIG1vcmUgZmllbGQgZGVmaW5pdGlvbnMgZGVjbGFyZWQgd2l0aGluIGl0LlxyXG5cdFx0XHRcdFx0XHRcdC8vICBXaWxsIG9wdCBmb3IgbGF6eSBsb2FkaW5nIGluIHZhcmlvdXMgY2FzZXMgd2hlcmUgcG9zc2libGUuXHJcblx0XHRcdFx0XHRcdFx0Ly8gICBCdXQgc29tZSBkZWZhdWx0IHZhbHVlcyB3aWxsIG5lZWQgdG8gYmUgbG9hZGVkIGF0IHRpbWVzLlxyXG5cdFx0XHRcdFx0XHRcdC8vICAgIE1heSBhbHNvIG5lZWQgdG8gZ2V0IGxvYWRlZCB1cG9uIHN0cmluZ2lmeS5cclxuXHJcblx0XHRcdFx0XHRcdFx0Ly9cclxuXHJcblxyXG5cclxuXHRcdFx0XHRcdFx0XHQvKlxyXG5cdFx0XHRcdFx0XHRcdFtcIm9iamVjdFwiLCBcImRvbV9hdHRyaWJ1dGVzXCIsIFwic3RyaW5nXCJdXHJcblx0XHRcdFx0XHRcdFx0aW9hX3NpZyBbcyxzLHNdXHJcblx0XHRcdFx0XHRcdFx0Ki9cclxuXHJcblx0XHRcdFx0XHRcdFx0LypcclxuXHRcdFx0XHRcdFx0XHQnbm9kZSc6ICdvYmplY3QnLFxyXG5cdFx0XHRcdFx0XHRcdCdhdHRyaWJ1dGVzJzogJ2RvbV9hdHRyaWJ1dGVzJyxcclxuXHRcdFx0XHRcdFx0XHQndGFnTmFtZSc6ICdzdHJpbmcnXHJcblx0XHRcdFx0XHRcdFx0Ki9cclxuXHJcblx0XHRcdFx0XHRcdFx0Ly8gTWF5YmUgZG8gbW9yZSB0ZXN0aW5nIG9mIERhdGFfT2JqZWN0IG9yIERhdGFfT2JqZWN0IGZpZWxkcy5cclxuXHRcdFx0XHRcdFx0XHQvLyAgV2lsbCB0cnkgYSBzaW5nbGUgZmllbGQgb2YgYSBEYXRhX09iamVjdCB3aXRoIGEgcGFydGljdWxhciB0eXBlLlxyXG5cclxuXHRcdFx0XHRcdFx0XHRpZiAoaW9hX3NpZyA9PSAnW3Msb10nKSB7XHJcblx0XHRcdFx0XHRcdFx0XHQvLyBpdCdzIGEgY29tcG91bmQgZGVmaW5pdGlvbi5cclxuXHRcdFx0XHRcdFx0XHRcdC8vIHdpbGwgbmVlZCB0byBjcmVhdGUgdGhlIG5leHQgbGV2ZWwgZG93biwgaWUgY3JlYXRlIHRoZSBuZXcgRGF0YV9PYmplY3QsIGFuZCBzZXQgaXRzXHJcblx0XHRcdFx0XHRcdFx0XHQvLyAgZmllbGRzLlxyXG5cclxuXHRcdFx0XHRcdFx0XHRcdC8vIEFuIG9iamVjdCBpbmRpY2F0ZXMgaXQncyBhIERhdGFfT2JqZWN0LlxyXG5cdFx0XHRcdFx0XHRcdFx0Ly8gIEl0J3MgYSBmaWVsZCB0aGF0IGdldHMgZGVjbGFyZWQgd2l0aCBhIHBhcnRpY3VsYXIgZGF0YV90eXBlLlxyXG5cdFx0XHRcdFx0XHRcdFx0Ly8gICBUaGF0IGdvZXMgaW50byB0aGUgZmllbGRzIGFuZCBjb25zdHJhaW50cyBmb3IgdGhhdCBvYmplY3QuXHJcblx0XHRcdFx0XHRcdFx0XHR2YXIgZmllbGROYW1lID0gaXRlbV9vcl9hcnJbMF07XHJcblx0XHRcdFx0XHRcdFx0XHR2YXIgZmllbGREZWYgPSBpdGVtX29yX2FyclsxXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHQvLyBTbyB0aGVyZSBpcyBhIGRhdGEgdHlwZSBuYW1lPyBpZSBmaWVsZCBuYW1lLCBhbmQgaXRzIGRhdGEgaW5zaWRlP1xyXG5cdFx0XHRcdFx0XHRcdFx0Ly8gYW55d2F5LCBuZWVkIHRvIG1ha2UgYSBEYXRhX09iamVjdCB3aXRoIHRob3NlIGZpZWxkcy5cclxuXHJcblx0XHRcdFx0XHRcdFx0XHQvLyBOZWVkIHRvIGJlIGFibGUgdG8gbWFrZSBhIERhdGFfT2JqZWN0IHVzaW5nIGZpZWxkcyB0aGF0IGFyZSBzdXBwbGllZCBhcyBhbiBvYmplY3RcclxuXHRcdFx0XHRcdFx0XHRcdC8vICByYXRoZXIgdGhhbiBhbiBhcnJheSBvZiBhcnJheXMuXHJcblxyXG5cclxuXHJcblx0XHRcdFx0XHRcdFx0XHQvL2NvbnNvbGUubG9nKCdmaWVsZERlZiAnICsgc3RyaW5naWZ5KGZpZWxkRGVmKSk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0dmFyIGZpZWxkX2FyciA9IFtmaWVsZE5hbWUsIFsnZGF0YV9vYmplY3QnLCBmaWVsZERlZl1dO1xyXG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5va3ZzLnB1dChmaWVsZE5hbWUsIGZpZWxkX2Fycik7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0Ly8gY2FuIHdlIHB1dCB0aGlzIGluIHJlbGF0aXZlbHkgZWFzaWx5P1xyXG5cdFx0XHRcdFx0XHRcdFx0Ly8gIHRoZSBjb21wbGljYXRlZCBwYXJ0IGlzIGludGVycHJldGluZyB0aGUgZmllbGQuXHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0Ly90aHJvdyAnc3RvcCc7XHJcblxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdFx0Ly9jb25zb2xlLmxvZygnaW9hX3NpZyAnICsgaW9hX3NpZyk7XHJcblx0XHRcdFx0XHRcdFx0Ly9jb25zb2xlLmxvZygnaXRlbV9vcl9hcnIgJyArIHN0cmluZ2lmeShpdGVtX29yX2FycikpO1xyXG5cdFx0XHRcdFx0XHRcdC8vY29uc29sZS5sb2coJ09USEVSIENBU0UhISEhJyk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdC8vIFtzLFtvXV1cclxuXHRcdFx0XHRcdFx0XHQvLyAgbWVhbnMgYSBuYW1lZCBhcnJheS9jb2xsZWN0aW9uIG9mIG9iamVjdHMvZGF0YW9iamVjdHMuXHJcblx0XHRcdFx0XHRcdFx0Ly8gICBpbiB0aGF0IGNhc2UsIHdlIGNyZWF0ZSBhIGNvbGxlY3Rpb24sIGFuZCBnaXZlIGl0IHRoZSB0eXBlIGRlZmluZWQgaW5zaWRlLlxyXG5cclxuXHRcdFx0XHRcdFx0XHRpZiAoaW9hX3NpZyA9PSAnW3MsW29dXScpIHtcclxuXHRcdFx0XHRcdFx0XHRcdHZhciBmaWVsZE5hbWUgPSBpdGVtX29yX2FyclswXTtcclxuXHRcdFx0XHRcdFx0XHRcdHZhciBmaWVsZEl0ZW1EZWYgPSBpdGVtX29yX2FyclsxXVswXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHQvLyBuZWVkcyB0byBtYWtlIGEgY29sbGVjdGlvbiBmaWVsZC5cclxuXHJcblx0XHRcdFx0XHRcdFx0XHQvLyB2YXIgZmllbGRfYXJyID0gW2ZpZWxkX25hbWUsIFtmaWVsZF90eXBlX25hbWUsIGZpZWxkX2l0ZW1fdHlwZV9uYW1lXV07XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0Ly8gQnV0IHdvbid0IGdvIG1ha2luZyBuZXN0ZWQgZGF0YSB0eXBlcz9cclxuXHRcdFx0XHRcdFx0XHRcdC8vICBuZWVkcyB0byBlbnN1cmUgdGhlIHR5cGVzIHNwZWNpZmllZCBpbnNpZGUgbWF0Y2ggT0ssXHJcblx0XHRcdFx0XHRcdFx0XHQvLyAgc28gbmVlZCB0byAocmVjdXJzaXZlbHkpIGdvIGludG8gdGhlIGRlZmluaXRpb24uXHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0Ly9jb25zb2xlLmxvZygnZmllbGRJdGVtRGVmICcgKyBzdHJpbmdpZnkoZmllbGRJdGVtRGVmKSk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0Ly8gaW5jbHVkZSBtb3JlIGRhdGEgaW4gdGhlIGluZm8gYWJvdXQgdGhlIGZpZWxkcz9cclxuXHRcdFx0XHRcdFx0XHRcdC8vICBkbyB0aGF0IHRvIG1ha2UgaXQgd29yayBpbiBhIG1vcmUgZGVlcGx5IG5lc3RlZCB3YXk/XHJcblx0XHRcdFx0XHRcdFx0XHQvLyAgIG9yIHRoaW5rIHNvbWUgbW9yZSBhYm91dCBuZXN0ZWQgZmllbGRzLlxyXG5cclxuXHRcdFx0XHRcdFx0XHRcdC8vIFRoZSBmaWVsZCBuZWVkcyB0byBiZSBkZWZpbmVkIGFzIGJlaW5nIGEgY29sbGVjdGlvbiBvZiB0aGF0IHR5cGUuXHJcblx0XHRcdFx0XHRcdFx0XHQvL3ZhciBmaWVsZF9hcnIgPSBbZmllbGROYW1lLCBbJ2NvbGxlY3Rpb24nLCBmaWVsZF9pdGVtX3R5cGVfbmFtZV1dO1xyXG5cdFx0XHRcdFx0XHRcdFx0dmFyIGZpZWxkX2FyciA9IFtmaWVsZE5hbWUsIFsnY29sbGVjdGlvbicsIGZpZWxkSXRlbURlZl1dO1xyXG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5va3ZzLnB1dChmaWVsZE5hbWUsIGZpZWxkX2Fycik7XHJcblxyXG5cclxuXHRcdFx0XHRcdFx0XHRcdC8vdGhyb3cgJ3N0b3AnO1xyXG5cclxuXHRcdFx0XHRcdFx0XHR9XHJcblxyXG5cclxuXHJcblx0XHRcdFx0XHRcdFx0aWYgKGlvYV9zaWcgPT0gJ1tzLH5DXScpIHtcclxuXHRcdFx0XHRcdFx0XHRcdC8vIHN0cmluZywgYWJzdHJhY3QgY29sbGVjdGlvblxyXG5cclxuXHRcdFx0XHRcdFx0XHRcdC8vIEl0ZW1zIGluIGFuIGFycmF5Li4uXHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0Ly8gbmVlZCB0byBzZXQgdGhlIGZpZWxkIHRvIGhvbGQgYW4gYWJzdHJhY3QgY29sbGVjdGlvbi4uLi5cclxuXHJcblx0XHRcdFx0XHRcdFx0XHQvLyBTZXR0aW5nIGEgZmllbGQgdG8gYW4gYWJzdHJhY3QgY29sbGVjdGlvbiBvZiBzdHJpbmdzLlxyXG5cdFx0XHRcdFx0XHRcdFx0Ly8gIFdlIGhhdmUgc3VwcGxpZWQgdGhlIGFic3RyYWN0IGNvbGxlY3Rpb24gYnV0IHdlIHdhbnQgdGhlcmUgdG8gYmUgYSBjb2xsZWN0aW9uIGluc3RhbmNlLlxyXG5cclxuXHRcdFx0XHRcdFx0XHRcdC8vIE5lZWQgdG8gY3JlYXRlIHRoZSBmaWVsZCBvZiB0aGF0IGFjdHVhbCB0eXBlIHdpdGhpbiB0aGUgZmllbGQgY29sbGVjdGlvbi5cclxuXHJcblx0XHRcdFx0XHRcdFx0XHR2YXIgdF9hYnN0cmFjdCA9IG5hdGl2ZV9jb25zdHJ1Y3Rvcl90b2YoaXRlbV9vcl9hcnJbMV0uX3R5cGVfY29uc3RydWN0b3IpO1xyXG5cdFx0XHRcdFx0XHRcdFx0Ly9jb25zb2xlLmxvZygndF9hYnN0cmFjdCAnICsgdF9hYnN0cmFjdCk7XHJcblx0XHRcdFx0XHRcdFx0XHQvL2NvbnNvbGUubG9nKCdpdGVtX29yX2FyclsxXSAnICsgc3RyaW5naWZ5KGl0ZW1fb3JfYXJyWzFdKSk7XHJcblxyXG5cclxuXHRcdFx0XHRcdFx0XHRcdGlmICh0X2Fic3RyYWN0KSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdHZhciBmaWVsZF9uYW1lID0gaXRlbV9vcl9hcnJbMF07XHJcblx0XHRcdFx0XHRcdFx0XHRcdHZhciBmaWVsZF9hcnIgPSBbZmllbGRfbmFtZSwgWydjb2xsZWN0aW9uJywgdF9hYnN0cmFjdC50b0xvd2VyQ2FzZSgpXV07XHJcblx0XHRcdFx0XHRcdFx0XHRcdC8vY29uc29sZS5sb2coJ2ZpZWxkX25hbWUgJyArIGZpZWxkX25hbWUpO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHQvL2NvbnNvbGUubG9nKCdmaWVsZF9hcnIgJywgZmllbGRfYXJyKTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0dGhpcy5va3ZzLnB1dChmaWVsZF9uYW1lLCBmaWVsZF9hcnIpO1xyXG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIGZpZWxkX25hbWUgPSBpdGVtX29yX2FyclswXTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIGZpZWxkX2FyciA9IFtmaWVsZF9uYW1lLCAnY29sbGVjdGlvbiddO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHQvL2NvbnNvbGUubG9nKCdmaWVsZF9uYW1lICcgKyBmaWVsZF9uYW1lKTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0Ly9jb25zb2xlLmxvZygnZmllbGRfYXJyICcsIGZpZWxkX2Fycik7XHJcblx0XHRcdFx0XHRcdFx0XHRcdHRoaXMub2t2cy5wdXQoZmllbGRfbmFtZSwgZmllbGRfYXJyKTtcclxuXHRcdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdFx0XHQvLyB3ZSBjYW4gbWFrZSBhIG5ldyBmaWVsZCB3aXRob3V0IHRoZSBhYnN0cmFjdCBjb25kaXRpb24gb2YgdGhlIGNvbnN0cnVjdG9yLlxyXG5cdFx0XHRcdFx0XHRcdFx0Ly8gIHdpbGwgdGhlbiBldmVudHVhbGx5IGdldCB0aGVzZSB0YWdzLCBhbmQgY3NzLW1hdGNoZWQgdGFncyBvcGVyYXRpbmcuXHJcblx0XHRcdFx0XHRcdFx0XHQvLyBUaGVuIHdpbGwgYmUgYWJsZSB0byBzZXQgdXAgYmVoYXZpb3VycyByZWxhdGl2ZWx5IGVhc2lseS5cclxuXHJcblx0XHRcdFx0XHRcdFx0XHQvLyBUeXBlZCBjb2xsZWN0aW9ucyBhcyBkYXRhIHR5cGVzIGlzIGFub3RoZXIgdGhpbmcgdG8gY29uc2lkZXIsIGFzIHdlbGwgYXMgdGhlIHN5bnRheCBmb3IgZGVjbGFyaW5nXHJcblx0XHRcdFx0XHRcdFx0XHQvLyAgdGhlIGFic3RyYWN0IHR5cGVkIGNvbGxlY3Rpb25zLlxyXG5cdFx0XHRcdFx0XHRcdFx0Ly8gVGhpcyBob3BlZnVsbHkgd2lsbCBub3QgaW50cm9kdWNlIHRvbyBtdWNoIGNvZGUgYmxvYXQsIGl0IHdpbGwgYmUgdmVyeSBnb29kIHRvIGdldCB0aGlzIHN5c3RlbVxyXG5cdFx0XHRcdFx0XHRcdFx0Ly8gIGNvbXByZXNzZWQgcmlnaHQgZG93biBmb3IgdXNlIGluIGNsaWVudCBhcHBzLiBDb3VsZCBoYXZlIHRoaW5ncyByZWR1Y2VkIGRvd24gdG8gYSBmZXcgS0IgKG1heWJlIDEyPylcclxuXHRcdFx0XHRcdFx0XHRcdC8vICAgYW5kIHRoaXMgd291bGQgYWxzbyBhbGxvdyBmb3IgdmFyaW91cyBhcHBsaWNhdGlvbiBpdGVtcyB0byBiZSB3b3JraW5nIG5pY2VseS5cclxuXHJcblxyXG5cclxuXHRcdFx0XHRcdFx0XHRcdC8vdGhyb3cgJ3N0b3AnO1xyXG5cclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0Ly8gW1tzLFtzLHNdXV1cclxuXHRcdFx0XHRcdC8vIGVnIFsnY29udGVudCcsIFsnY29sbGVjdGlvbicsICdjb250cm9sJ11dXHJcblx0XHRcdFx0XHQvLyBbaXRlbXNdXHJcblx0XHRcdFx0XHQvLyBbW3N0cl9uYW1lLCBzdHJfdHlwZV1dXHJcblxyXG5cdFx0XHRcdFx0Ly8gY291bGQgYmUgYSBjb2xsZWN0aW9uIG9mIHNvbWV0aGluZy5cclxuXHJcblx0XHRcdFx0XHR2YXIgYW9hID0gaXNfYXJyX29mX2FycnMoaXRlbV9vcl9hcnIpO1xyXG5cdFx0XHRcdFx0Ly9jb25zb2xlLmxvZygnYW9hICcgKyBhb2EpO1xyXG5cclxuXHRcdFx0XHRcdGlmIChhb2EpIHtcclxuXHRcdFx0XHRcdFx0dmFyIGMgPSAwLCBsID0gaXRlbV9vcl9hcnIubGVuZ3RoO1xyXG5cdFx0XHRcdFx0XHRmb3IgKGMgPSAwOyBjIDwgbDsgYysrKSB7XHJcblx0XHRcdFx0XHRcdFx0dGhpcy5zZXQoaXRlbV9vcl9hcnJbY10pO1xyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdC8vaWYgKGFvYSkge1xyXG5cdFx0XHRcdFx0Ly9cdGVhY2goaXRlbV9vcl9hcnIsIGZ1bmN0aW9uKGksIHYpIHtcclxuXHRcdFx0XHRcdC8vXHQgICAgdGhhdC5zZXQodik7XHJcblx0XHRcdFx0XHQvL1x0fSk7XHJcblx0XHRcdFx0XHQvL31cclxuXHRcdFx0XHRcdC8qXHJcblx0XHRcdFx0XHRpZiAoYW9hKSB7XHJcblx0XHRcdFx0XHRcdC8vdmFyIHRoaXNfc2V0X2NhbGwgPSB0aGlzLnNldC5jYWxsO1xyXG5cdFx0XHRcdFx0XHR2YXIgdGhpc19zZXQgPSB0aGlzLnNldDtcclxuXHRcdFx0XHRcdFx0Zm9yICh2YXIgYyA9IDAsIGwgPSBpdGVtX29yX2Fyci5sZW5ndGg7IGMgPCBsOyBjKyspIHtcclxuXHRcdFx0XHRcdFx0XHR0aGlzX3NldChpdGVtX29yX2FycltjXSk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdCovXHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdFx0aWYgKHNpZyA9PSAnW29dJykge1xyXG5cdFx0XHRcdC8vIGFkZCBlYWNoIG9uZVxyXG5cdFx0XHRcdC8vdmFyIHRoYXQgPSB0aGlzO1xyXG5cdFx0XHRcdHZhciBhMCA9IGFbMF07XHJcblxyXG5cdFx0XHRcdGlmIChPYmplY3Qua2V5cykge1xyXG5cdFx0XHRcdCAgICAvLyBvYmplY3Qua2V5cyB3aWxsIGhvcGVmdWxseSBiZSBmYXN0ZXIuXHJcblx0XHRcdFx0ICAgIHZhciBhMF9rZXlzID0gT2JqZWN0LmtleXMoYTApO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vXHJcblx0XHRcdFx0ICAgIHZhciBjID0gMCwgbCA9IGEwX2tleXMubGVuZ3RoO1xyXG5cdFx0XHRcdCAgICBmb3IgKGMgPSAwOyBjIDwgbDsgYysrKSB7XHJcblx0XHRcdFx0ICAgICAgICB2YXIgYTBfa2V5ID0gYTBfa2V5c1tjXTtcclxuXHRcdFx0XHQgICAgICAgIHRoaXMuc2V0KFthMF9rZXksIGEwW2EwX2tleV1dKTtcclxuXHRcdFx0XHQgICAgfVxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0ICAgIC8vIE9sZGVyIEpTIGNvZGVcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgaW4gYTApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXQuY2FsbCh0aGlzLCBbaSwgYTBbaV1dKTsgICBcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblx0XHRcdFx0fVxyXG5cclxuXHJcblx0XHRcdFx0LypcclxuXHRcdFx0XHRlYWNoKGFbMF0sIGZ1bmN0aW9uKGZpZWxkX25hbWUsIGZpZWxkX2RlZikge1xyXG5cdFx0XHRcdFx0Ly9jb25zb2xlLmxvZygnaSAnICsgc3RyaW5naWZ5KGkpKTtcclxuXHRcdFx0XHRcdC8vY29uc29sZS5sb2coJ3YgJyArIHN0cmluZ2lmeSh2KSk7XHJcblx0XHRcdFx0XHQvL2NvbnNvbGUubG9nKCcnKTtcclxuXHRcdFx0XHRcdHRoYXQuc2V0KFtmaWVsZF9uYW1lLCBmaWVsZF9kZWZdKTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0XHQqL1xyXG5cclxuXHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyB0aGVuIGZvciBzZXR0aW5nIGluIG90aGVyIHdheXMuLi5cclxuXHRcdFx0Ly8gIG5hbWUgdGhlbiBmaWVsZCBkZWZpbml0aW9uLlxyXG5cclxuXHJcblx0XHRcdGlmIChhLmwgPiAxKSB7XHJcblx0XHRcdFx0Ly9jb25zb2xlLmxvZygnbG9uZ2VyIGEubCcpO1xyXG5cdFx0XHRcdC8vdGhyb3cgJ3N0b3AnO1xyXG5cdFx0XHQgICAgLy90aGlzLnNldChhKTtcclxuXHRcdFx0ICAgIHRoaXMuc2V0KGFycl9saWtlX3RvX2FycihhKSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcblxyXG5cdFx0XHQvKlxyXG5cdFx0XHRpZiAoYS5sID09IDEgJiYgdG9mKGFbMF0pID09ICdhcnJheScpIHtcclxuXHRcdFx0XHRlYWNoKGFbMF0sIGZ1bmN0aW9uKGksIGZpZWxkX2Fycikge1xyXG5cclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fVxyXG5cdFx0XHQqL1xyXG5cdFx0XHQvLyBbcyxbcyxvXV1cclxuXHJcblx0XHRcdC8vIHMsIG9cclxuXHRcdFx0Ly8gb1xyXG5cclxuXHRcdFx0Ly8gdGhlIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhIGZpZWxkLCBjYW4gaGF2ZSB2YXJpb3VzIGZsYWdzLlxyXG5cclxuXHRcdFx0LyogdmFyIHJlcyA9IHtcclxuXHRcdFx0XHQnaXNfdW5pcXVlJzogaXNfdW5pcXVlLFxyXG5cdFx0XHRcdCdpc19pbmRleGVkJzogaXNfaW5kZXhlZCxcclxuXHRcdFx0XHQnaXNfbm90X251bGwnOiBpc19ub3RfbnVsbCxcclxuXHRcdFx0XHQnZGF0YV90eXBlJzogZGF0YV90eXBlXHJcblxyXG5cdFx0XHRcdC8vIHBvc3NpYmx5IG5hbWVcclxuXHJcblx0XHRcdH0gKi9cclxuXHJcblx0XHRcdC8vIHN0ciwgYXJyXHJcblx0XHRcdC8vXHJcblxyXG5cdFx0fSksXHJcblx0XHQnZ2V0JzogZnVuY3Rpb24oYTApIHtcclxuXHRcdFx0Ly9jb25zb2xlLmxvZygnRmllbGRzX0NvbGxlY3Rpb24gZ2V0IHNpZzogJyArIHNpZyk7XHJcblx0XHRcdHZhciB0YTAgPSB0eXBlb2YgYTA7XHJcblx0XHRcdGlmICh0YTAgPT0gJ3VuZGVmaW5lZCcpIHtcclxuXHRcdFx0XHQvLyBnZXQgdGhlbSBhbGxcclxuXHRcdFx0XHQvLyBqdXN0IHRoZSBvYmplY3RzIHRob3VnaD9cclxuXHRcdFx0XHRyZXR1cm4gdGhpcy5va3ZzLnZhbHVlcygpO1xyXG5cdFx0XHR9IGVsc2UgaWYgKHRhMCA9PSAnc3RyaW5nJykge1xyXG5cdFx0XHRcdHJldHVybiB0aGlzLm9rdnMuZ2V0KGEwKTtcclxuXHRcdFx0fVxyXG5cdFx0XHQvKlxyXG5cdFx0XHRpZiAoc2lnID09ICdbc10nKSB7XHJcblx0XHRcdFx0Ly8gZ2V0IGEgc2luZ2xlIGZpZWxkLlxyXG5cdFx0XHRcdC8vY29uc29sZS5sb2coJ2ZjIGdldCAnICsgYVswXSk7XHJcblxyXG5cclxuXHRcdFx0XHQvL2NvbnNvbGUubG9nKCd0aGlzLm9rdnMubGVuZ3RoKCkgJyArIHRoaXMub2t2cy5sZW5ndGgoKSk7XHJcblx0XHRcdFx0Ly8gZG9lcyBpdCBoYXZlIGFueXRoaW5nIHdpdGggdGhhdCBrZXk/XHJcblxyXG5cdFx0XHRcdHZhciByZXMgPSB0aGlzLm9rdnMuZ2V0KGFbMF0pO1xyXG5cclxuXHRcdFx0XHQvL2NvbnNvbGUubG9nKCdhWzBdICcgKyBhWzBdKTtcclxuXHRcdFx0XHQvL2NvbnNvbGUubG9nKCd0aGlzLm9rdnMua2V5cygpICcgKyB0aGlzLm9rdnMua2V5cygpKTtcclxuXHJcblx0XHRcdFx0Ly9jb25zb2xlLmxvZygnRmllbGRzX0NvbGxlY3Rpb24gZ2V0ICoqIHJlcyAnICsgc3RyaW5naWZ5KHJlcykpO1xyXG5cdFx0XHRcdHJldHVybiByZXM7XHJcblx0XHRcdH1cclxuXHRcdFx0Ki9cclxuXHRcdH0sXHJcblx0XHQvKlxyXG5cdFx0J19nZXQnOiBmcChmdW5jdGlvbihhLCBzaWcpIHtcclxuXHRcdFx0Ly9jb25zb2xlLmxvZygnRmllbGRzX0NvbGxlY3Rpb24gZ2V0IHNpZzogJyArIHNpZyk7XHJcblxyXG5cdFx0XHRpZiAoc2lnID09ICdbXScpIHtcclxuXHRcdFx0XHQvLyBnZXQgdGhlbSBhbGxcclxuXHRcdFx0XHQvLyBqdXN0IHRoZSBvYmplY3RzIHRob3VnaD9cclxuXHRcdFx0XHRyZXR1cm4gdGhpcy5va3ZzLnZhbHVlcygpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmIChzaWcgPT0gJ1tzXScpIHtcclxuXHRcdFx0XHQvLyBnZXQgYSBzaW5nbGUgZmllbGQuXHJcblx0XHRcdFx0Ly9jb25zb2xlLmxvZygnZmMgZ2V0ICcgKyBhWzBdKTtcclxuXHJcblxyXG5cdFx0XHRcdC8vY29uc29sZS5sb2coJ3RoaXMub2t2cy5sZW5ndGgoKSAnICsgdGhpcy5va3ZzLmxlbmd0aCgpKTtcclxuXHRcdFx0XHQvLyBkb2VzIGl0IGhhdmUgYW55dGhpbmcgd2l0aCB0aGF0IGtleT9cclxuXHJcblx0XHRcdFx0dmFyIHJlcyA9IHRoaXMub2t2cy5nZXQoYVswXSk7XHJcblxyXG5cdFx0XHRcdC8vY29uc29sZS5sb2coJ2FbMF0gJyArIGFbMF0pO1xyXG5cdFx0XHRcdC8vY29uc29sZS5sb2coJ3RoaXMub2t2cy5rZXlzKCkgJyArIHRoaXMub2t2cy5rZXlzKCkpO1xyXG5cclxuXHRcdFx0XHQvL2NvbnNvbGUubG9nKCdGaWVsZHNfQ29sbGVjdGlvbiBnZXQgKiogcmVzICcgKyBzdHJpbmdpZnkocmVzKSk7XHJcblx0XHRcdFx0cmV0dXJuIHJlcztcclxuXHRcdFx0fVxyXG5cdFx0fSksXHJcblx0XHQqL1xyXG5cdFx0J2ZpZWxkcyc6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5nZXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuXHRcdH0sXHJcblx0XHQvKlxyXG5cdFx0J19maWVsZHMnOiBmcChmdW5jdGlvbihhLCBzaWcpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMuZ2V0LmFwcGx5KHRoaXMsIGEpO1xyXG5cdFx0fSksXHJcblx0XHQqL1xyXG5cclxuXHRcdCdvdXQnOiBmdW5jdGlvbihrZXkpIHtcclxuXHRcdFx0dGhpcy5va3ZzLm91dChrZXkpO1xyXG5cdFx0fSxcclxuXHRcdCdjbGVhcic6IGZ1bmN0aW9uKCkge1xyXG5cclxuXHRcdH1cclxuXHR9KVxyXG5cclxuXHJcblxyXG5cdEZpZWxkc19Db2xsZWN0aW9uLnBhcnNlX2ZpZWxkX3RleHQgPSBwYXJzZV9maWVsZF90ZXh0O1xyXG5cdEZpZWxkc19Db2xsZWN0aW9uLnBhcnNlX2RhdGFfdHlwZSA9IHBhcnNlX2RhdGFfdHlwZTtcclxuXHJcblx0Ly9yZXR1cm4gRmllbGRzX0NvbGxlY3Rpb247XHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IEZpZWxkc19Db2xsZWN0aW9uO1xyXG5cclxuLy99KVxyXG4iLCIvKlxyXG5pZiAodHlwZW9mIGRlZmluZSAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgdmFyIGRlZmluZSA9IHJlcXVpcmUoJ2FtZGVmaW5lJykobW9kdWxlKTtcclxufVxyXG5cclxuXHJcbmRlZmluZShbXCIuL2pzZ3VpLWxhbmctZXNzZW50aWFsc1wiLCBcIi4vanNndWktZGF0YS1zdHJ1Y3R1cmVzXCIsIFwiLi9jb25zdHJhaW50XCIsIFwiLi9kYXRhLW9iamVjdC1maWVsZHMtY29sbGVjdGlvblwiXSxcclxuXHRmdW5jdGlvbihqc2d1aSwgRGF0YV9TdHJ1Y3R1cmVzLCBDb25zdHJhaW50LCBGaWVsZHNfQ29sbGVjdGlvbikge1xyXG5cclxuXHQqL1xyXG52YXIganNndWkgPSByZXF1aXJlKCcuL2pzZ3VpLWxhbmctZXNzZW50aWFscycpO1xyXG52YXIgRGF0YV9TdHJ1Y3R1cmVzID0gcmVxdWlyZSgnLi9qc2d1aS1kYXRhLXN0cnVjdHVyZXMnKTtcclxudmFyIERhdGFfVmFsdWUgPSByZXF1aXJlKCcuL2RhdGEtdmFsdWUnKTtcclxuXHJcbnZhciBDb25zdHJhaW50ID0gcmVxdWlyZSgnLi9jb25zdHJhaW50Jyk7XHJcbnZhciBGaWVsZHNfQ29sbGVjdGlvbiA9IHJlcXVpcmUoJy4vZGF0YS1vYmplY3QtZmllbGRzLWNvbGxlY3Rpb24nKTtcclxudmFyIEV2ZW50ZWRfQ2xhc3MgPSByZXF1aXJlKCcuL2V2ZW50ZWQtY2xhc3MnKTtcclxuXHJcblx0Ly8gQ3JlYXRlcyB0aGUgQ29uc3RyYWludHMgZGF0YSB0eXBlLi4uIHNvIGEgY29uc3RyYWludCBzcGVjaWZpZWQgd2l0aCBhIHN0cmluZyBjYW4gYmUgdGVzdGVkIGFnYWluc3RcclxuXHQvLyAgYWxzbyBhIGNhY2hlIG9mIHRoZSBjb25zdHJhaW50cyB0aGF0IGhhdmUgYmVlbiBtYWRlIHRocm91Z2ggdGhlIHN0cmluZyAtIHF1aWNrIHRvIGdldCB0aGVtIGFnYWluIGZvciByZXVzZSB3aGVuIHRlc3RpbmcuXHJcblxyXG5cdC8vIENvbnN0cmFpbnQgb2JqZWN0cyBjYW4gYmUgc2F2ZWQgYW5kIHVzZWQgaW4gdmFyaW91cyBwbGFjZXMuXHJcblx0Ly8gIFRoZXkgbWF5IG5vdCBhbHdheXMgYmUgcmVmZXJyZWQgdG8gZGlyZWN0bHksIHRoYXQgd291bGQgc2F2ZSBvbiB0aGUgYW1vdW50IG9mIGNvZGUgbmVlZGVkLlxyXG5cclxuXHQvLyBUaGV5IHdpbGwgaGVscCBpbiBtYWtpbmcgYSBtb2RlbCBvZiB3aGF0IGdldHMgcHV0IGludG8gYSBkYXRhYmFzZS5cclxuXHQvLyAgQSBmZXcgY29uc3RyYWludHMgcHV0IGluIHBsYWNlIGluIHRoZSBkb21haW4gbW9kZWwgb3Igc2ltaWxhciB3aWxsIGhlbHAgd2l0aCBpdHMgdHJhbnNsYXRpb24gdG8gYSBkYXRhYmFzZSBtb2RlbC5cclxuXHJcblx0Ly8gVGhlc2Ugd2lkZS1yYW5naW5nIHRoaW5ncyBzaG91bGQgaGVscCBhIGxvdCB3aXRoIGNyZWF0aW5nIGEgd2lkZSByYW5nZSBvZiBwZXJmb3JtYW50IGRhdGFiYXNlcyBxdWlja2x5LlxyXG5cdC8vIEl0IHdpbGwgYWxzbyBiZSBhIGdvb2QgdG9vbCBpbiBpdHNlbGYuXHJcblxyXG5cdC8vIENoYW5nZSBldmVudHNcclxuXHQvLyAtLS0tLS0tLS0tLS0tXHJcblxyXG5cdC8vIFdhbnQgdG8gaGF2ZSBkaWZmZXJlbnQgbGV2ZWxzIG9mIHJlc3BvbmRpbmcgdG8gY2hhbmdlIGV2ZW50cy5cclxuXHQvLyAgSXQgZ2V0cyBhIGJpdCBjb21wbGljYXRlZCB3aXRoIHRoZSBzYW1lIGRhdGEgcmVwcmVzZW50ZWQgaW4gZGlmZmVyZW50IHBsYWNlcyBhbmQgYWxzbyBpbiB0cmFuc21pc3Npb24gYmV0d2VlbiB0aGVtLlxyXG5cdC8vICBEYXRhIHdpbGwgaGF2ZSB2YXJpb3VzIGRpZmZlcmVudCBzdGF0dXNlcy5cclxuXHQvLyAgTmVlZCB0byBiZSBhYmxlIHRvIHJlY2lldmUgZGF0YSBmcm9tIHRoZSBzZXJ2ZXIsIGFuZCB1cGRhdGUgdGhlIGNsaWVudCBkYXRhIG1vZGVscywgYW5kIGFubm91bmNlIGl0IHdpdGhpbiB0aGUgY2xpZW50IGFwcCxcclxuXHQvLyAgIHdpdGhvdXQgdGhlbiB0ZWxsaW5nIHRoZSBzZXJ2ZXIgdGhhdCB0aGUgZGF0YSBoYXMgYmVlbiBjaGFuZ2VkIG9uIHRoZSBjbGllbnQsIHVubGVzcyBpdCBtYWtlcyBpdCBjbGVhciB0byB0aGUgc2VydmVyIHRoYXQgdGhlIGNsaWVudCB3YXNcclxuXHQvLyAgIG1ha2luZyB0aGUgY2hhbmdlIGFzIHRoZSBzZXJ2ZXIgcmVxdWVzdGVkLiBUaGF0IGNoYW5nZSBhY2tub3dsZWRnZW1lbnQgY291bGQgYmUgYSB1c2VmdWwgZmVhdHVyZSBvbiB0aGUgY2xpZW50LlxyXG5cdC8vICAgIERvbid0IHdhbnQgdGhhdCB0byBiZSBtb3JlIHRoYW4gYW4gYWNrbm93bGVkZ2VtZW50IHRob3VnaC5cclxuXHQvLyAgIEFsc28gbmVlZCB0byBkZWFsIHdpdGggY2hhbmdlIGluaXRpYXRpb24gcHJvcGVybHkuXHJcblx0Ly8gICAgVGhlIGNoYW5nZSBjb3VsZCBiZSBpbml0aWF0ZWQgb24gdGhlIGNsaWVudCwgbmVlZHMgdG8gYmUgdXBkYXRlZCBvbiB0aGUgc2VydmVyLCBhbmQgdGhlbiBzZW50IHRvIHRoZSB2YXJpb3VzIGRpZmZlcmVudCBjbGllbnRzLlxyXG5cdC8vICAgICBDb3VsZCBoYXZlIGRpZmZlcmVudCBsZXZlbHMgb2YgcmVjZWlwdCB2YWxpZGF0aW9uIHRoZXJlIHRvbywgc28gdGhhdCB0aGUgY2xpZW50IGtub3dzIG9uY2UgdGhlIGNoYW5nZSBoYXMgYmVlbiByZWNpZXZlZCAoYW5kIHByb2Nlc3NlZD8pIGJ5XHJcblx0Ly8gICAgICB0aGUgb3RoZXIgY2xpZW50cy4gVGhpcyBjb3VsZCBiZSB1c2VmdWwgZm9yIGFtYmVyIGFuZCBncmVlbiBsaWdodHMgaW4gYSBjaGF0IHN5c3RlbSwgZm9yIGV4YW1wbGUuXHJcblx0Ly8vICAgIFJlY2VpcHQgb2YgbWVzc2FnZSB2YWxpZGF0aW9uIHdvdWxkIGFsc28gYmUgdXNlZnVsIGZvciBkYXRhIHN0cnVjdHVyZXMgYW5kIG1ha2luZyB0aGVtIHRyYW5zYWN0aW9uYWwgaWYgcG9zc2libGUuXHJcblxyXG5cdC8vIFNvLCB3ZSBuZWVkIGEgdHlwZSBvZiBzZXQgdGhhdCBpcyBmb3IgdXBkYXRpbmcgdGhlIGRhdGEgZnJvbSBhbiB1cGRhdGVkIGV4dGVybmFsIHNvdXJjZS5cclxuXHJcblx0Ly8gbm90aWZ5X2NoYW5nZV9mcm9tX2V4dGVybmFsXHJcblx0Ly8gIGFuZCB3aGVuIHRoYXQgaGFzIHByb2Nlc3NlZCBpdCBjb3VsZCBzZW5kIGEgcmVjZWlwdCBvZiB1cGRhdGUgbWVzc2FnZSBub3RpZmljYXRpb24gYmFjayB0byB0aGUgc2VydmVyLlxyXG5cdC8vICBUaGF0IHNob3VsZCBwcm9iYWJseSBiZSBvcHRpb25hbC5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG52YXIgaiA9IGpzZ3VpO1xyXG52YXIgQ2xhc3MgPSBqLkNsYXNzO1xyXG52YXIgZWFjaCA9IGouZWFjaDtcclxudmFyIGlzX2FycmF5ID0gai5pc19hcnJheTtcclxudmFyIGlzX2RvbV9ub2RlID0gai5pc19kb21fbm9kZTtcclxudmFyIGlzX2N0cmwgPSBqLmlzX2N0cmw7XHJcbnZhciBleHRlbmQgPSBqLmV4dGVuZDtcclxudmFyIGdldF90cnV0aF9tYXBfZnJvbV9hcnIgPSBqLmdldF90cnV0aF9tYXBfZnJvbV9hcnI7XHJcbnZhciBnZXRfbWFwX2Zyb21fYXJyID0gai5nZXRfbWFwX2Zyb21fYXJyO1xyXG52YXIgYXJyX2xpa2VfdG9fYXJyID0gai5hcnJfbGlrZV90b19hcnI7XHJcbnZhciB0b2YgPSBqLnRvZjtcclxudmFyIGlzX2RlZmluZWQgPSBqLmlzX2RlZmluZWQ7XHJcbnZhciBzdHJpbmdpZnkgPSBqLnN0cmluZ2lmeTtcclxudmFyIGZ1bmN0aW9uYWxfcG9seW1vcnBoaXNtID0gai5mdW5jdGlvbmFsX3BvbHltb3JwaGlzbTtcclxudmFyIGZwID0gai5mcDtcclxudmFyIGFycmF5aWZ5ID0gai5hcnJheWlmeTtcclxudmFyIG1hcGlmeSA9IGoubWFwaWZ5O1xyXG52YXIgYXJlX2VxdWFsID0gai5hcmVfZXF1YWw7XHJcbnZhciBnZXRfaXRlbV9zaWcgPSBqLmdldF9pdGVtX3NpZztcclxudmFyIGdldF9hX3NpZyA9IGouZ2V0X2Ffc2lnO1xyXG52YXIgc2V0X3ZhbHMgPSBqLnNldF92YWxzO1xyXG52YXIgdHJ1dGggPSBqLnRydXRoO1xyXG52YXIgdHJpbV9zaWdfYnJhY2tldHMgPSBqLnRyaW1fc2lnX2JyYWNrZXRzO1xyXG52YXIgbGxfc2V0ID0gai5sbF9zZXQ7XHJcbnZhciBsbF9nZXQgPSBqLmxsX2dldDtcclxudmFyIGlucHV0X3Byb2Nlc3NvcnMgPSBqLmlucHV0X3Byb2Nlc3NvcnM7XHJcbnZhciBpdGVyYXRlX2FuY2VzdG9yX2NsYXNzZXMgPSBqLml0ZXJhdGVfYW5jZXN0b3JfY2xhc3NlcztcclxudmFyIGlzX2Fycl9vZl9hcnJzID0gai5pc19hcnJfb2ZfYXJycztcclxudmFyIGlzX2Fycl9vZl9zdHJzID0gai5pc19hcnJfb2Zfc3RycztcclxudmFyIGlzX2Fycl9vZl90ID0gai5pc19hcnJfb2ZfdDtcclxudmFyIGNsb25lID0ganNndWkuY2xvbmU7XHJcblxyXG52YXIgZGF0YV92YWx1ZV9pbmRleCA9IDA7XHJcbnZhciBkYXRhX3ZhbHVlX2FiYnJldmlhdGlvbiA9ICd2YWwnO1xyXG5cclxuLy8gZG8gZGF0YSBvYmplY3RzIGdldCBhbiBJRCB3aGVuIHRoZXkgYXJlIGluaXRpYWxpemVkLlxyXG5qc2d1aS5fX2RhdGFfaWRfbWV0aG9kID0gJ2luaXQnO1xyXG5cclxudmFyIG9ial9tYXRjaGVzX2NvbnN0cmFpbnQgPSBDb25zdHJhaW50Lm9ial9tYXRjaGVzX2NvbnN0cmFpbnQ7XHJcbnZhciBuYXRpdmVfY29uc3RydWN0b3JfdG9mID0ganNndWkubmF0aXZlX2NvbnN0cnVjdG9yX3RvZjtcclxuXHJcbnZhciB2YWx1ZV9hc19maWVsZF9jb25zdHJhaW50ID0gQ29uc3RyYWludC52YWx1ZV9hc19maWVsZF9jb25zdHJhaW50O1xyXG5cclxudmFyIE9yZGVyZWRfU3RyaW5nX0xpc3QgPSBEYXRhX1N0cnVjdHVyZXMuT3JkZXJlZF9TdHJpbmdfTGlzdDtcclxuXHJcblxyXG4vLyBnZXRzIGEgdmFsdWUgYXMgYSBmaWVsZF9jb25zdHJhaW50IG9iamVjdC5cclxuLy92YXIgZW5zdXJlX2RhdGFfdHlwZV9kYXRhX29iamVjdF9jb25zdHJ1Y3RvciA9IGouZW5zdXJlX2RhdGFfdHlwZV9kYXRhX29iamVjdF9jb25zdHJ1Y3RvcjtcclxuXHJcblxyXG4vLyBTbywgRGF0YV9PYmplY3RzIG1heSBoYXZlIGEgUGFnZV9Db250ZXh0LCBBcHBsaWNhdGlvbl9Db250ZXh0LCBvciBqdXN0IENvbnRleHQuXHJcbi8vICBUaGUgQ29udGV4dCB3b3VsZCBpbmNsdWRlIGluZm8gc3VjaCBhcyB3aGljaCBicm93c2VyIGlzIGJlaW5nIHVzZWQuXHJcbi8vICAgQ29udHJvbHMgd2lsbCByZW5kZXIgZGlmZmVyZW50bHkgZGVwZW5kaW5nIG9uIHRoZSBjb250ZXh0LlxyXG5cclxuLy8ganNndWkuZGF0YV90eXBlc19pbmZvIGFuZCBkYXRhX3R5cGUgd2lsbCBiZWNvbWUgbXVjaCBtb3JlIGNsb3NlbHkgaW50ZWdyYXRlZCBpbnRvIHRoaXMuXHJcbi8vICBQZXJoYXBzIHRoZXJlIHNob3VsZCBiZSBhbm90aGVyIG1vZHVsZSBsZXZlbCBmb3IgdGhpcy5cclxuXHJcbi8vIE5vdCBzdXJlIGFib3V0IGludHJvZHVjaW5nIGl0IGhlcmUuIE1heWJlIGluIGxhbmctZXNzZW50aWFscz8gRG9uJ3Qgd2FudCB0aGF0IHRvIGdldCB0b28gYmlnLlxyXG5cclxuLy8gRGF0YV9PYmplY3QgRmxhZ3MgaXMgdGhlIG5leHQgdGhpbmcgaGVyZS4uLlxyXG4vLyAgQnV0IHRoYXQgcmVxdWlyZXMgYSBDb2xsZWN0aW9uLlxyXG4vLyBDYW4gbWFrZSBFbmhhbmNlZF9EYXRhX09iamVjdD9cclxuLy8gIE9yIG1ha2UgRGF0YV9PYmplY3QgZW5oYW5jZSBpdHNlbGYgb25jZSBpdCBoYXMgYSBDb2xsZWN0aW9uLlxyXG4vLyAgT3IgY291bGQgZG8gRmxhZ3Mgb24gYSBsb3dlciBsZXZlbC5cclxuXHJcbi8vIFF1aXRlIGEgY29tcGxpY2F0ZWQgcXVlc3Rpb24uXHJcbi8vICBGbGFncyBydW5uaW5nIGFzIGEgY29sbGVjdGlvbiBvZiBzdHJpbmdzIG1ha2VzIGEgbG90IG9mIHNlbnNlLlxyXG4vLyAgIFdpbGwgYmUgb3JkZXJlZCBldGMuXHJcblxyXG4vLyBDb3VsZCBtYWtlIGEgYmFzaWMgRGF0YV9PYmplY3QgdG9vP1xyXG4vLyAgQmFzaWNfQ29sbGVjdGlvbj9cclxuXHJcbi8vIFRoZW4gaGF2ZSBkaWZmZXJlbnQgbGV2ZWxzP1xyXG5cclxuXHJcbnZhciBNaW5pX0NvbnRleHQgPSBDbGFzcy5leHRlbmQoe1xyXG5cclxuICAgIC8vIE5lZWQgcXVpdGUgYSBzaW1wbGUgbWVjaGFuc20gdG8gZ2V0IElEcyBmb3Igb2JqZWN0cy5cclxuXHJcbiAgICAvLyBUaGV5IHdpbGwgYmUgdHlwZWQgb2JqZWN0cy9cclxuXHJcbiAgICAnaW5pdCc6IGZ1bmN0aW9uKHNwZWMpIHtcclxuXHJcblxyXG4gICAgICAgIHZhciBtYXBfdHlwZWRfY291bnRzID0ge31cclxuICAgICAgICB2YXIgdHlwZWRfaWQgPSBmdW5jdGlvbihzdHJfdHlwZSkge1xyXG4gICAgICAgICAgICB0aHJvdyAnc3RvcCBNaW5pX0NvbnRleHQgdHlwZWQgaWQnO1xyXG5cclxuICAgICAgICAgICAgdmFyIHJlcztcclxuICAgICAgICAgICAgaWYgKCFtYXBfdHlwZWRfY291bnRzW3N0cl90eXBlXSkge1xyXG4gICAgICAgICAgICAgICAgcmVzID0gc3RyX3R5cGUgKyAnXzAnO1xyXG4gICAgICAgICAgICAgICAgbWFwX3R5cGVkX2NvdW50c1tzdHJfdHlwZV0gPSAxO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmVzID0gc3RyX3R5cGUgKyAnXycgKyBtYXBfdHlwZWRfY291bnRzW3N0cl90eXBlXTtcclxuICAgICAgICAgICAgICAgIG1hcF90eXBlZF9jb3VudHNbc3RyX3R5cGVdKys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJlcztcclxuICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgdmFyIGlUeXBlZElkcyA9IHt9O1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGlUeXBlZElkc1tzdHJfdHlwZV0gPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaVR5cGVkSWRzW3N0cl90eXBlXSA9IDE7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciB0eXBlZF9pZCA9IGZ1bmN0aW9uKHN0cl90eXBlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGlUeXBlZElkc1tzdHJfdHlwZV0gPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaVR5cGVkSWRzW3N0cl90eXBlXSA9IDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVzID0gaVR5cGVkSWRzW3N0cl90eXBlXTtcclxuICAgICAgICAgICAgICAgIGlUeXBlZElkc1tzdHJfdHlwZV0gPSBpVHlwZWRJZHNbc3RyX3R5cGVdICsgMTtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXM7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMucWlkID0gcWlkO1xyXG4gICAgICAgICAgICAqL1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm5ld19pZCA9IHR5cGVkX2lkO1xyXG4gICAgICAgIC8vbmV3X2lkXHJcbiAgICB9LFxyXG5cclxuICAgICdtYWtlJzogZnVuY3Rpb24oYWJzdHJhY3Rfb2JqZWN0KSB7XHJcbiAgICAgICAgaWYgKGFic3RyYWN0X29iamVjdC5fYWJzdHJhY3QpIHtcclxuICAgICAgICAgICAgLy92YXIgcmVzID0gbmV3XHJcbiAgICAgICAgICAgIC8vIHdlIG5lZWQgdGhlIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLlxyXG5cclxuICAgICAgICAgICAgdmFyIGNvbnN0cnVjdG9yID0gYWJzdHJhY3Rfb2JqZWN0LmNvbnN0cnVjdG9yO1xyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdjb25zdHJ1Y3RvciAnICsgY29uc3RydWN0b3IpO1xyXG5cclxuXHJcbiAgICAgICAgICAgIC8vdGhyb3cgJ3N0b3AnO1xyXG5cclxuICAgICAgICAgICAgdmFyIGFvcyA9IGFic3RyYWN0X29iamVjdC5fc3BlYztcclxuXHJcbiAgICAgICAgICAgIC8vIGNvdWxkIHVzZSAnZGVsZXRlPydcclxuICAgICAgICAgICAgYW9zLmFic3RyYWN0ID0gbnVsbDtcclxuICAgICAgICAgICAgLy9hb3MuX2Fic3RyYWN0ID0gbnVsbDtcclxuICAgICAgICAgICAgYW9zLmNvbnRleHQgPSB0aGlzO1xyXG5cclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnYWJzdHJhY3Rfb2JqZWN0Ll9zcGVjICcgKyBzdHJpbmdpZnkoYWJzdHJhY3Rfb2JqZWN0Ll9zcGVjKSk7XHJcbiAgICAgICAgICAgIC8vIE5vdCBzdXJlIGl0IGlzIGNyZWF0aW5nIHRoZSByaWdodCBjb25zdHJ1Y3Rvci5cclxuXHJcblxyXG4gICAgICAgICAgICB2YXIgcmVzID0gbmV3IGNvbnN0cnVjdG9yKGFvcyk7XHJcbiAgICAgICAgICAgIHJcclxuICAgICAgICAgICAgcmV0dXJuIHJlcztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJvdyAnT2JqZWN0IG11c3QgYmUgYWJzdHJhY3QsIGhhdmluZyAuX2Fic3RyYWN0ID09IHRydWUnXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5cclxuLy8gRW5oYW5jZWRfRGF0YV9PYmplY3Qgd2l0aCBmbGFncyBzZWVtcyBsaWtlIG9uZSBvZiB0aGUgYmVzdCBvcHRpb25zLlxyXG4vLyAgVGhlc2UgZmxhZ3MgY2FuIGVhc2lseSBjb3JyZXNwb25kIHRvIENTUyBjbGFzc2VzIGluIGFuIE1WQyBzeXN0ZW0gdG9vLCBDU1Mgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IHVwZGF0ZWQgd2hlbiB0aGUgb2JqZWN0J3MgcHJvcGVydGllcyBjaGFuZ2UuXHJcblxyXG4vLyBBbmQgQ29udHJvbCB3aWxsIGluaGVyaXQgZnJvbSBFbmhhbmNlZF9EYXRhX09iamVjdC5cclxuLy8gIEZsYWdzIGlzIG5vdCBhIG1hc3NpdmUgZW5oYW5jZW1lbnQsIGJ1dCB0aGVyZSBjb3VsZCBiZSBtb3JlLlxyXG4vLyAgQ291bGQgbWFpbnRhaW4gYSBDb2xsZWN0aW9uIG9mIHJlZmVyZW5jZXMgdG8gb3RoZXIgRGF0YV9PYmplY3RzIGFuZCBFbmhhbmNlZF9EYXRhX09iamVjdHMgbW9yZSBjb252ZW5pZW50bHkuXHJcblxyXG5cclxuLy8gV2FudCBlaXRoZXIgZXhwcmVzcy1saWtlIHJvdXRpbmcsIG9yIHRvIGxpZnQgdGhlIHJvdXRpbmcgb3V0IG9mIEV4cHJlc3MuXHJcbi8vICBJdCBtYXkgYmUgd29ydGggaW50ZWdyYXRpbmcgRXhwcmVzcyByaWdodCBpbnRvIHRoaXMsIGZvciB0aGUgdGhpbmdzIHRoYXQgRXhwcmVzcyBkb2VzLlxyXG4vLyAgIFRoZXJlIG1heSBiZSB2YXJpb3VzIHRoaW5ncyB0aGF0IEV4cHJlc3MgZG9lcyBub3QgZG8sIGJ1dCBjb3VsZCBiZSBjYWxsZWQgdXBvbiB0byBhc3Npc3Qgd2l0aC5cclxuLy8gICAgSlNHVUkgc2VlbXMgdmVyeSBtdWNoIGFib3V0IGJ1aWxkaW5nIHRoZSBIVE1MLCBhbmQgYWN0aW5nIGFzIE1WQyBvbiBjbGllbnQgYW5kIHNlcnZlci4gSXQgY291bGQgdXNlIEV4cHJlc3MuXHJcbi8vICAgICBPciBpdCBjb3VsZCBpbmNvcnBvcmF0ZSBFeHByZXNzLlxyXG4vLyAgICAgIFBlcmhhcHMgSlNHVUkgY2FuIGJlIHVzZWQgYnkgRXhwcmVzcyB0byByZW5kZXIgcGFnZXMuXHJcbi8vICAgICAgIFdpbGwgaGF2ZSBpdCBjb21wYXRhYmxlLCBidXQgdGhlcmUgd2lsbCBiZSBzb21lIG92ZXJsYXBwaW5nIGZlYXR1cmVzLlxyXG4vLyAgICAgICBqc2d1aSBjb3VsZCB1c2Ugc29tZSBFeHByZXNzIHJvdXRpbmcgYnkgZGVmYXVsdC5cclxuXHJcbi8vIEhhdmluZyBqZSBzdWlzIFhNTCBydW5uaW5nIHNvb24gd2lsbCBiZSBuaWNlIVxyXG4vLyAgQ291bGQgc2VydmUgZnJvbSBhIGRpcmVjdG9yeS5cclxuLy8gICBXYW50IHRvIGdldCB0aGF0IHdvcmtpbmcgYXMgdGhhdCB3aWxsIHJlYWxseSBiZSB0aGUgY29kZSBwYXRoIHRoYXQgaXMgdGFrZW4uXHJcbi8vICAgQ291bGQgZ2V0IGEgc2l0ZSB1cCBhbmQgcnVubmluZyB1c2luZyB0aGF0IGJlZm9yZSBzbyBsb25nLi4uXHJcbi8vICAgIEJ1dCBhbHNvIHdhbnQgdG8gaGF2ZSB0aGUgZGlzY3Vzc2lvbiBmb3J1bSBydW5uaW5nLiBEb3VidCBJIHdhbnQgYWxsIHRoZSBPUk0gZm9yIHRoYXQsIGJ1dCB3aWxsIGJlIGFibGUgdG8gZ2V0IGl0IHJ1bm5pbmcgaW4gYSBkb2N1bWVudCBkYXRhYmFzZSBiZWZvcmUgdG9vIGxvbmcuXHJcbi8vICAgVGhlbiB0aGUgc3lzdGVtIHdpbGwgZGVmaW5pdGVseSBiZSBxdWl0ZSBmYXN0LlxyXG4vLyAgICBXb3VsZCBub3QgYmUgYWxsIHRoYXQgbXVjaCB1c2VyIGRhdGEsIGJ1dCB3b3VsZCBuZWVkIHRvIHN0YXJ0IHRvIGtlZXAgaXQgYmFja2VkIHVwIC8gY29uc2lzdGVudC5cclxuXHJcbi8vIERhdGFfT2JqZWN0IGlzIG5vdCB1c2luZyAnbmVzdGVkJyBhdCB0aGUgbW9tZW50LlxyXG5cclxuLy8gTmVzdGVkIGhhcyBnb3QgZmFpcmx5IGNvbXBsaWNhdGVkLCBpdCdzIGZhaXJseSBnb29kIHRob3VnaC5cclxuLy8gIFBlcmhhcHMgaXQgd2lsbCB3aW5kIHVwIGJlaW5nIHJlZmFjdG9yZWQgaW50byBEYXRhX09iamVjdCBhbmQgdXNlcyBvZiB0aGF0LlxyXG5cclxuLy8gQ3VycmVudGx5IE5lc3RlZCBpcyBkZWFsaW5nIHdpdGggZGF0YSB0eXBlcy5cclxuXHJcbi8vIFdlIG5lZWQgdG8gZW5zdXJlIHRoYXQgZGF0YSBnZXR0aW5nIHB1dCBpbnRvIERhdGFfT2JqZWN0cyBtZWV0cyBkYXRhIHR5cGUgY3JpdGVyaWEuXHJcbi8vIE5lc3RlZCBhbHNvIGhhcyB0aGUgYWJpbGl0eSBvZiB0cmFuc2Zvcm1pbmcgZGF0YS5cclxuLy8gMSkgTWVldHMgdGhlIGNyaXRlcmlhXHJcbi8vIDIpIE1lZXRzIGNyaXRlcmlhIGZvciB0cmFuc2Zvcm1hdGlvbiBpbnRvIHRoZSBjb3JyZWN0IGRhdGFcclxuXHJcbi8vIFRoZSBkYXRhIHR5cGVzIGNhbiBiZSBkZWFsaW5nIHdpdGggbmVzdGVkIGluZm9ybWF0aW9uIHRvby5cclxuLy8gIEkgdGhpbmsgZGVhbGluZyB3aXRoIG5lc3RlZCBpbmZvcm1hdGlvbiB3aWxsIHdpbmQgdXAgaW4gdGhlIGNvcmUuXHJcbi8vICBUaGUgY29yZSBtYXkgd2luZCB1cCBiZWluZyBhYml0IGJpZywgYnV0IGl0J3MgYWxsIGltcG9ydGFudCBzdHVmZi5cclxuLy8gV2l0aCA0RyBhbmQgdGhlIHVzZSBpbiB2YXJpb3VzIGVudmlyb25tZW50cyBsaWtlIGNvbmZlcmVuY2UgaGFsbHMsIGRvd25sb2FkaW5nIDMyS0Igb250byBhbiBpUGFkIHdvdWxkIG5vdCBiZSBhIHByb2JsZW0uXHJcbi8vICBJIHRoaW5rIHRoZSB3aG9sZSB0aGluZyBjb3VsZCBsb2FkIHZlcnkgcXVpY2tseSwgdGhlbiBwcmVzZW50IHRoZSB1c2VyIHdpdGggYSBwb3dlcmZ1bCBhcHBsaWNhdGlvbi5cclxuXHJcblxyXG5cclxuLy8gVGhlIHNjaGVtYXMgc3lzdGVtIGlzIGdvaW5nIHRvIGJlIG5hbWVzcGFjZWQsIGFuZCB3aWxsIHVzZSBhIE5hbWVzcGFjZWRfRGljdCBvYmplY3QsIHdoaWNoIHdpbGwgdXNlIGEgQisgdHJlZSwgZm9yIHJldHJpZXZhbCBieSBwcmVmaXguXHJcblxyXG4vLyBTaG91bGQgcG9zc2libHkgYmUgY2FsbGVkIGNvbnN0cmludHMuXHJcbi8vIEhhdmluZyBDb25zdHJhaW50cyBidWlsdCByaWdodCBpbnRvIERhdGFfT2JqZWN0IG1heSBiZSB0aGUgbW9zdCBzdWl0YWJsZSB0aGluZyB0byBkby5cclxuXHJcbi8vIEl0IGlzIHRoZSBzYW1lIHRlcm1pbm9sb2d5IGFzIGRhdGFiYXNlcy5cclxuLy8gIEZpZWxkIGNvbnN0cmFpbnRzIG1ha2VzIHNlbnNlIHRvby5cclxuXHJcbi8vIENvbnN0cmFpbnRzIHRoYXQgYXBwbHkgdG8gd2hvbGUgY29sbGVjdGlvbnMgLSB0aGUgc2FtZSBsYW5ndWFnZSB1c2VkIHRvIHRhbGsgYWJvdXQgaW5kZXhlcy5cclxuLy8gIEluZGV4ZXMgd2lsbCBiZSB1c2VkIHRvIHBvd2VyIHVuaXF1ZSBjb25zdHJhaW50cywgc28gaXQnbGwgbWFrZSB1c2Ugb2YgdGhlICdjb25zdHJhaW50JyB0ZXJtaW5vbG9neS5cclxuXHJcbi8vIEJyaW5naW5nIHRoZSBmb2N1cyB0byAnY29uc3RyYWludHMnIHdpbGwgaGVscCBicmlkZ2UgdGhlIGdhcCBpbnRvIHRoZSBkYXRhYmFzZSB3b3JsZC5cclxuLy8gVGhpbmdzIHdpbGwgYmUgZXhwcmVzc2FibGUgaW4gYSB3YXkgdGhhdCBpcyBtb3JlIGNsb3NlbHkgdHJhbnNmZXJyYWJsZSxcclxuLy8gIHRob3VnaCBzb21lIGNvbnN0cmFpbnRzIGluIHRoaXMgc3lzdGVtIHdpbGwgYmUgcmVwcmVzZW50ZWQgdXNpbmcgdHlwZXMgaW4gb3RoZXIgc3lzdGVtcy5cclxuXHJcbi8vIFRoaXMgd2lsbCBwb3NzaWJseSBiZWNvbWUgcXVpdGUgYSB3aWRlbHkgdXNlZCBNVkMgcGFyYWRpZ20uXHJcblxyXG4vLyBJIHRoaW5rIGhhdmluZyBwbGVudHkgb2YgdGVzdHMsIEFQSSBkb2N1bWVudGF0aW9uLCBhbmQgd2VsbC13cml0dGVuIHR1dG9yaWFsIC8gcmVmZXJlbmNlIGRvY3VtZW50YXRpb24gd2lsbCBoZWxwIGEgbG90LlxyXG4vLyAgQ2FuIGhhdmUgcXVpdGUgYSBmZXcgcGFnZXMgb2YgdGhpcyBkb2N1bWVudGF0aW9uIHdpdGggR29vZ2xlIGFkdmVydHMuXHJcbi8vIEkgd291bGQgYmUgaW50ZXJlc3RlZCB0byBzZWUgaG93IG11Y2ggYSBzbWFsbCBhbW91bnQgb2YgYWR2ZXJ0aXNpbmcgb24gdGhlIGRvY3VtZW50YXRpb24gcGFydCBvZiBteSBzaXRlIHdpbGwgbWFrZS5cclxuLy8gIEFsc28sIGFkdmVydGlzaW5nIHdpbGwgbm90IGJlIHNob3duIHRvIHRoZSBwYXlpbmcgY3VzdG9tZXJzLlxyXG5cclxuXHJcblxyXG4vLyBjb25zdHJhaW50IGZ1bmN0aW9uP1xyXG4vLyAgYW5kIGNhbiBnaXZlIGl0IG11bHRpcGxlIGNvbnN0cmFpbnRzP1xyXG5cclxuLy8gYmUgYWJsZSB0byBnZXQgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGNvbnN0cmFpbnRzIHRoYXQgYXJlIGFwcGxpZWQgdG8gYSBEYXRhX09iamVjdCBhcyB3ZWxsLlxyXG4vLyAgUmVtZW1iZXIsIHRoZSBjb25zdHJhaW50cyB3b24ndCBiZSBzdG9yZWQgaW4gYSBjb2xsZWN0aW9uLlxyXG5cclxuXHJcbi8vIFRoZXkgd2lsbCBiZSBjYWxsZWQgY29uc3RyYWludHMuXHJcblxyXG4vLyBjb25zdHJhaW50P1xyXG4vLyBzaW5ndWxhciBkb2VzIG1ha2Ugc2Vuc2UgYmVjYXVzZSB3ZSBkbyBrZWVwIGdpdmluZyB0aGVtIG1hcHMgYW5kIGFycmF5cyB0byBwcm9jZXNzLlxyXG5cclxuLy8gVGhlIGNvbnN0cmFpbnRzIGluIHVzZSBvbiB0aGUgRGF0YV9PYmplY3Qgd2lsbCBiZSBmaWVsZCBjb25zdHJhaW50cy5cclxuXHJcbi8vIERhdGFfT2JqZWN0IG5lZWRzIG1vcmUgd29yayB0byBkbyB3aXRoIHNldHRpbmcsIGdldHRpbmcsIGFuZCBjaGVja2luZyBhZ2FpbnN0IGl0cyBmaWVsZHMuXHJcbi8vICBIYXZlIGNoZWNraW5nIGZvciBjb2xsZWN0aW9ucywgYnV0IG5lZWQgY2hlY2tpbmcgZm9yIGNoYW5naW5nIGEgZmllbGQncyB2YWx1ZS5cclxuXHJcbi8vICBUaGUgZmllbGRzIHN5c3RlbSBoZXJlIHdpbGwgaGF2ZSBjbGVhciwgbG9naWNhbCByZXN1bHRzIHdoZW4gdGVzdGluZy5cclxuLy8gICBQb3NzaWJpbGl0eSBvZiBjb25uZWN0aW9uIGEgZmllbGRzIGNoZWNrIG9udG8gdGhlIG9iamVjdCBjbGFzcywgb3IgaGF2aW5nIG9uZSBmb3IgYWxsIG9iamVjdHMgb2YgdGhhdCBjbGFzcz9cclxuLy8gICBEb24ndCB3YW50IHRvIGJlIGhvbGRpbmcgbG90cyBvZiByZXBlYXRlZCBkYXRhIGFib3V0IGZpZWxkcyBpbiBtZW1vcnksIHRob3VnaCBpdCdzIG5vdCByZWFsbHkgYSBtYWpvciBwcm9ibGVtIHRvIGJlZ2luIHdpdGguXHJcblxyXG5cclxuXHJcbi8vIGVhc3kgYXBpIHdpdGggYWRkX2ZpZWxkIGV0Yy4uLlxyXG4vLyBlbnN1cmVfZmllbGQuXHJcbi8vIHJlbW92ZV9maWVsZFxyXG4vLyAgd291bGQgbmVlZCB0byByZW1vdmUgaW5kZXhlc1xyXG5cclxuXHJcbi8vIHBlcmhhcHMganVzdCBjYWxsIHRoZW0gZmllbGRfY29uc3RyYWludHMgZm9yIHRoZSBtb21lbnQuXHJcbi8vICBzYXlpbmcgYSBmaWVsZCBpcyBpbmRleGVkLi4uIHRoYXQgaGFzIG1vcmUgdG8gZG8gd2l0aCB0aGUgY29sbGVjdGlvbi5cclxuXHJcbi8vIFdpbGwgbm90IHVzZSBhICdGaWVsZCcgb2JqZWN0LlxyXG4vLyAgRmllbGRzIHdpbGwgYmUgaGVsZCBpbiB0aGUgZm9ybSBbbmFtZSwgW3N0cmluZ19yZXByZXNlbnRhdGlvbiwgb2JqX3JlcHJlc2VudGF0aW9uXV1cclxuXHJcbi8vIEZpZWxkc19Db2xsZWN0aW9uP1xyXG4vLyAgVGhpcyBzZWVtcyBsaWtlIGEgbmljZSBlbmNhcHN1bGF0aW9uIG9mIHRoZSBmaWVsZHMgZnVuY3Rpb25hbGl0eSwgc3RvcHBpbmcgdGhlIERhdGFfT2JqZWN0IGZyb20gYmVjb21pbmcgdG9vIGNvbXBsaWNhdGVkIGl0c2VsZi5cclxuLy8gICBUaGUgZmllbGRzIG1heSBoYXZlIHNvbWUgaW5kZXhlcyBhZGRlZCBmb3IgZmFzdGVyIGxvb2t1cCBhdCBhIGxhdGVyIHN0YWdlLCBEYXRhX09iamVjdCBjYW4gZWFzaWx5IHVzZSB0aGUgQVBJLlxyXG4vLyAgc2V0X2ZpZWxkICAoZW5zdXJlX2ZpZWxkKSAvIHNldFxyXG4vLyAgcmVtb3ZlX2ZpZWxkIC8gcmVtb3ZlIC8gb3V0XHJcbi8vICBnZXRfZmllbGQgLyBnZXQoZmllbGRfbmFtZSlcclxuLy8gIGdldF9maWVsZHMgLyBnZXQoKVxyXG4vLyAgc2V0X2ZpZWxkcyAvIHNldChtYXAgb3IgYXJyYXkpXHJcbi8vICAgb3RoZXIgbG93ZXIgbGV2ZWwgdGhpbmdzLCByZW1vdmVfZmllbGRfaW5kZXgoZmllbGRfbmFtZSksIHJlbW92ZV9maWVsZF91bmlxdWUoZmllbGRfbmFtZSksIHJlbW92ZV9maWVsZF9mbGFnKGZpZWxkX25hbWUsIGZsYWdfbmFtZSksIGFkZF9maWVsZF9mbGFnIGV0Y1xyXG4vLyAgICBhbHNvIHdoaWxlIHN1cHByZXNzaW5nIHJhaXNpbmcgb2YgZXZlbnRzICh3aGVuIGFuIGluZGV4IGhhcyBiZWVuIGRlbGV0ZWQsIHRoaXMgd2lsbCBiZSBhYm91dCB1cGRhdGluZyB0aGUgZmllbGQgc28gdGhhdCBpdCBkb2VzIG5vdCByZWZlciB0byB0aGF0IGluZGV4LlxyXG4vLyAgICB0aGVzZSB3aWxsIGJlIGNhcnJpZWQgb3V0IHdoZW4gaW5kZXhlcyBvciBjb25zdHJhaW50cyAodGhhdCByZWZlciB0byBmaWVsZHMpIGFyZSBhZGRlZC9yZW1vdmVkXHJcblxyXG4vLyBXaWxsIGFsc28gcmFpc2UgZXZlbnRzIGZvciB3aGVuIGZpZWxkcyBhcmUgYWRkZWQsIHJlbW92ZWQsIG9yIGNoYW5nZWQuXHJcbi8vICBUaGlzIHdpbGwgZW5hYmxlIG90aGVyIGNvbXBvbmVudHMsIHRoYXQgcmVmZXIgdG8gZmllbGRzLCBzdWNoIGFzIENvbnN0cmFpbnRzIGFuZCBJbmRleGVzLCB0byByZW1haW4gdXBkYXRlZC5cclxuLy8gICBXaGVuIGFkZGluZyAvIHJlbW92aW5nIGNvbnN0cmFpbnRzLCB3aWxsIG5lZWQgdG8gaGF2ZSB0aGF0IHVwZGF0ZSB0aGUgZmllbGQgaW5mbywgbWF5YmUgbW9kaWZ5IGZpZWxkcyB3aGlsZSBzdXBwcmVzc2luZyBldmVudHMuXHJcblxyXG4vLyBBbGwgbG93ZXIgbGV2ZWwgY29sbGVjdGlvbiBzeXN0ZW1zLi4uXHJcbi8vICBub3QgYXJyYW5nZWQgYXJvdW5kIERhdGFfT2JqZWN0c1xyXG5cclxuLy8gVGhlIEluZGV4X1N5c3RlbSBkb2VzIHRoZSBqb2Igd2l0aCBpbmRleGVzIG9uIGEgY29sbGVjdGlvbi5cclxuXHJcblxyXG4vLyBGaWVsZHMgcmVmZXJyaW5nIHRvIHRoZSBmaWVsZCBjb25zdHJhaW50cy5cclxuLy8gIEZpZWxkIGNvbnN0cmFpbnRzIGJlaW5nIHRoZWlyIG93biBjbGFzc2VzLi4uIGZpZWxkcyBub3QgYmVpbmcgc28/XHJcblxyXG4vLyBGaWVsZHMgcmVmZXJyaW5nIHRvIHRoZWlyIGFjdHVhbCBpbmRleGVzLiBDb2xsZWN0aW9uIGhhcyB0aGUgSW5kZXhfU3lzdGVtLCBidXQgd2UgbmVlZCB0byBiZSByZWZlcnJpbmcgdG8gaW5kZXhlcyBmcm9tIHRoZSBmaWVsZD9cclxuLy8gIG9yIGp1c3QgaG9sZCB0aGUgaW5mbyBpbiB0aGUgZmllbGQgdGhhdCBpdCBpcyB0byBiZSBpbmRleGVkLiBNb2RpZnlpbmcgdGhpcyBjYW4gYWxlcnQgdGhlIGNvbGxlY3Rpb24gc28gdGhhdCBpdCByZW1vdmVzIHRoZSBpbmRleCBmcm9tIHRoZSBmaWVsZC5cclxuXHJcbi8vIFNvbWUgY29uc3RyYWludHMgLyBpbmRleGVzIHdpbGwgb25seSBhcHBseSB0byBmaWVsZHMgb2Ygb2JqZWN0cyB3aXRoaW4gYSBjb2xsZWN0aW9uLlxyXG5cclxuXHJcbi8vIENvbnN0cmFpbnRzX0NvbGxlY3Rpb25cclxuLy8gSW5kZXhlc19Db2xsZWN0aW9uP1xyXG5cclxuLy8gW2ZpZWxkX25hbWUsIFtzdHJfcmVwciwgb2JqX3JlcHJdXVxyXG5cclxuLy8gd2lsbCBjb2VyY2UgdGhlIHR5cGVzIGEgbGl0dGxlIC0gZW5zdXJlIGl0IGlzIGFycjNfZmllbGQgZm9ybWF0XHJcbi8vICBbbmFtZSwgc3RyX2RlZiwgb2JqX2RlZl1cclxuXHJcblxyXG4vLyBUaGlzIHdpbGwgaG9sZCBhIGNvbGxlY3Rpb24gb2YgZmllbGRzIHRoYXQgYXJlIHVzZWQgYnkgYW4gb2JqZWN0LlxyXG4vLyAgVGhleSBnZXQgbWFpbnRhaW5lZCBpbiBhIHBhcnRpY3VsYXIgb3JkZXIuXHJcblxyXG4vLyBCdXQgd2hhdCBleGFjdGx5IGFyZSB0aGVzZSBmaWVsZHM/XHJcblxyXG4vLyBTdG9yZXMgYW4gYXJyYXkgb2YgZmllbGRzLi4uP1xyXG5cclxuXHJcbi8vdmFyIG1hcF9qc2d1aV9pZHMgPSB7fTtcclxuXHJcbi8vIFdvbid0IGJlIGEgd2hvbGUgbWFwIG9mIElEcyBmb3IgZXZlcnkgb2JqZWN0IG1hZGUgYnkganNndWkuXHJcbi8vICBUaGV5IHdpbGwgYmUgc3RvcmVkIHdpdGhpbiBhIFBhZ2VfQ29udGV4dC5cclxuLy8gIFRoZXJlIGhhZCBiZWVuIGEgZ3JlYXQgc2xvd2Rvd24gZm9yIHN1YnNlcXVlbnQgcmVxdWVzdHMuIERlZmluaXRlbHkgZG9uJ3Qgd2FudCB0aGF0LlxyXG5cclxuLypcclxuXHJcbnZhciBuZXdfZGF0YV92YWx1ZV9pZCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIHJlcyA9IGRhdGFfdmFsdWVfYWJicmV2aWF0aW9uICsgJ18nICsgZGF0YV92YWx1ZV9pbmRleDtcclxuICAgIGRhdGFfdmFsdWVfaW5kZXgrKztcclxuICAgIHJldHVybiByZXM7XHJcbn07XHJcbiovXHJcblxyXG4vLyBJIHRoaW5rIERhdGFfT2JqZWN0IHdpbGwgYmUgbWFkZSBzbyB0aGF0IGl0IGNhbiBhY3QgYXMgYSBEYXRhX1ZhbHVlLlxyXG4vLyAgSXQgd2lsbCB3b3JrIGluIGEgdmVyeSBjb25zdHJhaW5lZCBtb2RlLCBzdWNoIGFzIG9ubHkgaG9sZGluZyBvbmUgdmFsdWUsIHN1Y2ggYXMgYSBzdHJpbmcuXHJcbi8vICBJdCBtYXkgYWxzbyBob2xkIGEgZmllbGQgbmFtZSBhbmQgYSB2YWx1ZS5cclxuLy8gRGF0YV9PYmplY3QoU3RyaW5nKTtcclxuXHJcbi8vIENvbGxlY3Rpb24gdXNpbmcgYSBEYXRhX1ZhbHVlIGNvbnN0cmFpbnQ/XHJcbi8vICBDb25zdHJpbmF0IHRlc3RpbmcgaXMgYWxyZWFkeSBpbiBEYXRhX09iamVjdC5cclxuXHJcbi8vIERhdGFfVmFsdWUgaXMgbGlrZWx5IHRvIGhhdmUgYSB0eXBlLiBJdCBjb3VsZCBoYXZlIHR5cGUgY2hlY2tpbmcuIE5lZWRzIHRvIGJlIGxpZ2h0d2VpZ2h0IHRob3VnaC5cclxuXHJcbi8vIEkgdGhpbmsgdGhlIERhdGFfVmFsdWUgd2lsbCBhbHNvIGhhdmUgZXZlbnRzLlxyXG4vLyAgQ2hhbmdlIGV2ZW50IGJlaW5nIHRoZSBtYWluIG9uZSBvZiBpbnRlcmVzdCBhdCB0aGUgbW9tZW50LlxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbi8vIFRoaXMgc3lzdGVtIHdpbGwgZXhpc3Qgd2l0aGluIHRoZSBQYWdlX0NvbnRleHRcclxuLy8gIFdlIGRvbid0IHdhbnQgbG9hZHMgb2YgdGhlc2UgY29udHJvbHMgLyBEYXRhX09iamVjdHMgdG8gc3RheSB3aXRoaW4gdGhlIG5vcm1hbCBhcHBsaWNhdGlvbiBtZW1vcnkgYWxsIHRoZSB0aW1lLlxyXG5cclxuXHJcbi8vIENvbnRleHQgd2lsbCBob2xkIHRoZXNlIGluZGV4ZXMuXHJcbi8vICBBIGNvbnRleHQgd2lsbCBiZSBzZXQgdXAgZm9yIGVhY2ggcGFnZSByZXF1ZXN0LlxyXG4vLyAgUmVxdWVzdF9Db250ZXh0P1xyXG4vLyAgUGFnZV9Db250ZXh0IG9uIHRoZSBjbGllbnQ/XHJcblxyXG4vLyBMb3RzIG9mIG9iamVjdHMgd2lsbCBoYXZlIGxpbmtzIHRvIHRoZWlyIGNvbnRleHRzLlxyXG4vLyAgV2lsbCBtYWtlIGl0IGVhc3kgdG8gZ2V0IGluZm8gYWJvdXQgd2hhdCBicm93c2VyIC8gZnJvbnQtZW5kIGNhcGFiaWxpdGllcyB0aGVyZSBhcmUuXHJcblxyXG5cclxuXHJcblxyXG4vKlxyXG5cclxudmFyIGRhdGFfb2JqZWN0X2luZGV4ID0gMDtcclxudmFyIGRhdGFfb2JqZWN0X2FiYnJldmlhdGlvbiA9ICdkbyc7XHJcblxyXG52YXIgbmV3X2RhdGFfb2JqZWN0X2lkID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgcmVzID0gZGF0YV9vYmplY3RfYWJicmV2aWF0aW9uICsgJ18nICsgZGF0YV9vYmplY3RfaW5kZXg7XHJcbiAgICBkYXRhX29iamVjdF9pbmRleCsrO1xyXG4gICAgcmV0dXJuIHJlcztcclxufTtcclxuXHJcbiovXHJcblxyXG4vLyBXaGF0IGFib3V0IHR1cm5pbmcgYSBub3JtYWwgb2JqZWN0IGludG8gYSBEYXRhT2JqZWN0P1xyXG4vL3ZhciB0X2lkX251bSA9IDA7XHJcbi8vIE1heSBiZSBnb29kIGZvciB0ZXN0aW5nIHRoZSBjb2xsZWN0b24gYW5kIGRhdGEgb2JqZWN0LlxyXG5cclxuLy8gRG9uJ3Qgd2FudCB0aGUgRGF0YV9PYmplY3QgdG8gYWx3YXlzIGJlIGJldHRpbmcgSURzIChhZnRlciBhbGwpLlxyXG4vLyAgRG9uJ3Qgd2FudCB0byBhbHdheXMgaGF2ZSB0byBoYXZlIGEgY29udGV4dCAtIHRob3VnaCBmb3IgbWFueSBwdXJwb3NlcyBhIGNvbnRleHQgd2lsbCBoZWxwIHdoZW4gcmVuZGVyaW5nIEhUTUwuXHJcbi8vICAgSGFzIGdvdCBpbiB0aGUgd2F5IG9mIG90aGVyIHNpbXBsZXIgdGhpbmdzLlxyXG5cclxudmFyIGlzX2pzX25hdGl2ZSA9IGZ1bmN0aW9uKG9iaikge1xyXG4gICAgdmFyIHQgPSB0b2Yob2JqKTtcclxuICAgIHJldHVybiB0ID09ICdudW1iZXInIHx8IHQgPT0gJ3N0cmluZycgfHwgdCA9PSAnYm9vbGVhbicgfHwgdCA9PSAnYXJyYXknO1xyXG59XHJcblxyXG5cclxuLy8gU2hvdWxkIG1heWJlIG1ha2UgaXQgZXh0ZW5kIEV2ZW50ZWRfQ2xhc3NcclxuLy8gIERhdGFfVmFsdWUgd291bGQgZXh0ZW5kIHRoYXQgYXMgd2VsbC5cclxuXHJcbi8vIENvbnRyb2wgd291bGQgaGF2ZSBzcGVjaWZpYyBoYW5kbGluZyBmb3IgRE9NIGV2ZW50cy5cclxuXHJcbi8vIFdpdGggRVZlbnRlZF9DbGFzcyBpbiBsYW5nLWVzc2VudGlhbHM/XHJcblxyXG5cclxuXHJcbi8vIERhdGFfT2JqZWN0cyBoYXZlIGNvbnRleHRzLlxyXG4vLyAgTm90IHN1cmUgYWJvdXQgcmVnaXN0ZXJpbmcgZXZlcnkgRGF0YV9PYmplY3Qgd2l0aGluIHRoZSBjb250ZXh0LlxyXG4vLyAgSXQgc2VlbXMgd29ydGh3aGlsZSBoYXZpbmcgQ29udHJvbHMgcmVnaXN0ZXJlZCB3aXRoaW4gYSBQYWdlX0NvbnRleHQuXHJcbi8vICBQZXJoYXBzIGRhdGEsIHJlZ2lzdGVyZWQgd2l0aGluIGEgRGF0YV9Db250ZXh0ICh3aGljaCBJIGFtIHlldCB0byBtYWtlKSBjb3VsZCBlbmFibGUgYSBzcHJlYWRzaGVldCB0byBoYXZlIGNvbXBvbmVudHMgdGhhdCBnZXQgbm90aWZpZWQgYWJvdXQgY2hhbmdlcyB0byB0aGUgZGF0YS5cclxuXHJcbi8vIEkgdGhpbmsgdGhhdCBJIHdpbGwgaGF2ZSBjb250cm9scyByZWdpc3RlciB0aGVtc2VsdmVzIHdpdGhpbiB0aGUgY29udGV4dC5cclxuLy8gIGNhbGwgY29udGV4dC5yZWdpc3Rlcl9jb250cm9sKClcclxuXHJcblxyXG52YXIgRGF0YV9PYmplY3QgPSBFdmVudGVkX0NsYXNzLmV4dGVuZCh7XHJcbiAgICAnaW5pdCc6IGZ1bmN0aW9uKHNwZWMpIHtcclxuICAgICAgICAvLyBidXQgaXQgY291bGQgZG8gYSBkaWZmZXJlbnQgaW5pdGlhbGl6YXRpb24gYXMgYW4gYWJzdHJhY3Qgb2JqZWN0LlxyXG4gICAgICAgIC8vICBDb2xsZWN0aW9uKFN0cmluZykgc2VlbXMgbW9yZSBsaWtlIGFuIGFic3RyYWN0IGNvbGxlY3Rpb24sIG9yIGV2ZW4gYSBuZXdseSBkZWZpbmVkIHR5cGUuXHJcbiAgICAgICAgLy8gIGJlY2F1c2Ugb2YgaXRzIGVhc3kgc3ludGF4LCBDb2xsZWN0aW9uKFN0cmluZykgbWFrZXMgYSBsb3Qgb2Ygc2Vuc2UgdG8gdXNlLlxyXG4gICAgICAgIC8vIGdvaW5nIHdpdGhvdXQgdGhlIG5ldyBrZXl3b3JkIHdoZW4gd2UgYXJlIG5vdCBwYXJ0aWN1bGFybHkgbG9va2luZyBmb3IgYW4gYWN0dWFsIG5ldyBjb2xsZWN0aW9uLFxyXG4gICAgICAgIC8vICBidXQgc29tZXRoaW5nIHRoYXQgc2lnbmlmaWVzIGl0cyB0eXBlIGFzIGEgY29sbGVjdGlvbiBvZiBzdHJpbmdzLlxyXG4gICAgICAgIC8vICAgTWF5IGJlIHBvc3NpYmxlIHRvIGhhdmUgdGhlc2UgcnVubmluZyBpbiBhYnN0cmFjdCAob3Igc2NoZW1hPykgbW9kZS5cclxuICAgICAgICAvLyAgIEkgdGhpbmsgYWJzdHJhY3QgbW9kZSBmaXRzIGluIHdlbGwgd2l0aCBuYW1lcyB3ZSBhbHJlYWR5IGFyZSB1c2luZy5cclxuXHJcbiAgICAgICAgLy9jb25zb2xlLmxvZygnYmVnaW4gRGF0YV9PYmplY3QgaW5pdCcpO1xyXG5cclxuICAgICAgICAvLyBib3VuZF9ldmVudHMgbmVlZHMgdG8gYmUgb3ZlcmhhdWxlZCBxdWl0ZSBhIGxvdC5cclxuICAgICAgICAvLyAgVGhlcmUgaXMgYSBtYWpvciBwcm9ibGVtIHdpdGggaXQgcmlnaHQgbm93LlxyXG5cclxuICAgICAgICAvLyAgSXQncyBub3Qgc3RheWluZyB3aXRoaW4gdGhlIGNvbnRleHQuXHJcbiAgICAgICAgLy8gICBEb24ndCByZWFsbHkgd2FudCB0byBiZSBzdG9yaW5nIHRoZSBpbmRleCBvZiBvYmplY3QgaWRzP1xyXG4gICAgICAgIC8vICAgIGNvdWxkIGJlIHVzZWZ1bCBkdXJpbmcgdGhlIGNyZWF0aW9uIG9mIHRoZSBwYWdlLlxyXG5cclxuXHJcbiAgICAgICAgLy8gY2FuIGhhdmUgJ2Fic3RyYWN0JzogdHJ1ZSBpbiB0aGUgc3BlYyxcclxuICAgICAgICAvLyAgd2Ugd2lsbCBnZXQgdGhpcyBpZiBpdCB3YXMgY2FsbGVkIHdpdGhvdXQgdGhlICduZXcnIGtleXdvcmQgYXMgd2VsbC5cclxuICAgICAgICBpZiAoIXNwZWMpIHNwZWMgPSB7fTtcclxuICAgICAgICAvL2lmICghaXNfZGVmaW5lZChzcGVjKSkge1xyXG4gICAgICAgIC8vXHRzcGVjID0ge307XHJcbiAgICAgICAgLy99O1xyXG5cclxuICAgICAgICAvLyBpZiBpdCdzIGFic3RyYWN0IGNhbGwgdGhlIGFic3RyYWN0X2luaXQuXHJcblxyXG4gICAgICAgIGlmIChzcGVjLmFic3RyYWN0ID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgIC8vdGhyb3cgJ3N0b3AgYWJzdHJhY3QnO1xyXG4gICAgICAgICAgICAvLyB0aGlzIG1heSBuZWVkIHRvIGJlIG1vcmUgbGlnaHR3ZWlnaHQuXHJcblxyXG4gICAgICAgICAgICB0aGlzLl9hYnN0cmFjdCA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICAvLyBpaW5pdCA9IGluc3RhbmNlIGluaXQ/XHJcbiAgICAgICAgICAgIC8vICB3aXRoIGl0IG9ubHkgbmVlZGluZyB0byBzYXZlIHRoZSBzcGVjLCBub3QgZG8gZnVydGhlciBpbml0aWFsaXphdGlvbj9cclxuXHJcblxyXG5cclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygndG9mKHNwZWMpICcgKyB0b2Yoc3BlYykpO1xyXG5cclxuICAgICAgICAgICAgLy8gQW5kIHdpdGggdGhlIHNwZWMgYXMgYSBmdW5jdGlvbiwgd2UnbGwgYmUgYWJsZSB0byBzYXkgdGhhdCBlYWNoIGl0ZW0gbXVzdCBtYXRjaCB0aGF0IGNvbnN0cnVjdG9yXHJcbiAgICAgICAgICAgIC8vICBIb3dldmVyLCB0aGVyZSBhcmUgb25seSBhIGZldyBuYXRpdmUgSmF2YVNjcmlwdCBmdW5jdGlvbnMgdG8gY2hlY2sgdGhpcyBhZ2FpbnN0LlxyXG5cclxuICAgICAgICAgICAgLy8gQXMgYSBmdW5jdGlvbiwgaXQgZ2l2ZXMgYSB0eXBlIGNvbnN0cnVjdG9yLlxyXG4gICAgICAgICAgICAvLyhjb25zb2xlLmxvZygndG9mKHNwZWMpICcgKyB0b2Yoc3BlYykpKTtcclxuICAgICAgICAgICAgdmFyIHRTcGVjID0gdG9mKHNwZWMpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRTcGVjID09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3R5cGVfY29uc3RydWN0b3IgPSBzcGVjO1xyXG4gICAgICAgICAgICAgICAgLy8gY291bGQgcG9zc2libHlcclxuICAgICAgICAgICAgICAgIC8vIGJ1dCBtYXliZSB3YW50IHRvIGtlZXAgdGhpcyBqc29uLWZyaWVuZGx5LlxyXG5cclxuICAgICAgICAgICAgICAgIC8vIHRoZSB0eXBlIGNvbnN0cnVjdG9yIGNvdWxkIGJlIHVzZWQgaW4gYSBjb2xsZWN0aW9uLlxyXG4gICAgICAgICAgICAgICAgLy8gIGNvdWxkIGJlIG1vcmUgbGVpZ2h0d2VpZ2h0IHRoYW4gb3RoZXIgdGhpbmdzPyBzcGVjaWZpYyBjb25zdHJhaW50IG9iamVjdHMuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gQWJzdHJhY3QgY29udHJvbHMgd29uJ3QgYmUgZGVhbGluZyB3aXRoIGV2ZW50cyBmb3IgdGhlIG1vbWVudC5cclxuICAgICAgICAgICAgaWYgKHRTcGVjID09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zcGVjID0gc3BlYztcclxuICAgICAgICAgICAgICAgIC8vIGNvdWxkIHBvc3NpYmx5XHJcbiAgICAgICAgICAgICAgICAvLyBidXQgbWF5YmUgd2FudCB0byBrZWVwIHRoaXMganNvbi1mcmllbmRseS5cclxuXHJcbiAgICAgICAgICAgICAgICAvLyB0aGUgdHlwZSBjb25zdHJ1Y3RvciBjb3VsZCBiZSB1c2VkIGluIGEgY29sbGVjdGlvbi5cclxuICAgICAgICAgICAgICAgIC8vICBjb3VsZCBiZSBtb3JlIGxlaWdodHdlaWdodCB0aGFuIG90aGVyIHRoaW5ncz8gc3BlY2lmaWMgY29uc3RyYWludCBvYmplY3RzLlxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICAgICAgdGhpcy5faW5pdGlhbGl6aW5nID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgIHZhciB0X3NwZWMgPSB0b2Yoc3BlYyk7XHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3Rfc3BlYycsIHRfc3BlYyk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX190eXBlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fdHlwZSA9ICdkYXRhX29iamVjdCc7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIXRoaXMuaGFzT3duUHJvcGVydHkoJ18nKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fID0ge307XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICh0X3NwZWMgPT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgICAgIC8vIE5vcm1hbCBpbml0aWFsaXphdGlvblxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChzcGVjLmNvbnRleHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdzcGVjIGhhcyBjb250ZXh0Jyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRleHQgPSBzcGVjLmNvbnRleHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHNwZWMuX2lkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2lkID0gc3BlYy5faWQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0X3NwZWMgPT0gJ2RhdGFfb2JqZWN0Jykge1xyXG4gICAgICAgICAgICAgICAgLy8gSW5pdGlhbGl6YXRpb24gYnkgRGF0YV9PYmplY3QgdmFsdWUgKGZvciB0aGUgbW9tZW50KVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIE5vdCBzbyBzdXJlIGFib3V0IGNvcHlpbmcgdGhlIGlkIG9mIGFub3RoZXIgb2JqZWN0LlxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChzcGVjLl9jb250ZXh0KSB0aGlzLl9jb250ZXh0ID0gc3BlYy5fY29udGV4dDtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyB0aGVuIGNvcHkgdGhlIHZhbHVlcyBvdmVyIGZyb20gc3BlYy5cclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgc3BlY19rZXlzID0gc3BlYy5rZXlzKCk7XHJcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdzcGVjX2tleXMnLCBzcGVjX2tleXMpO1xyXG5cclxuICAgICAgICAgICAgICAgIGVhY2goc3BlY19rZXlzLCBmdW5jdGlvbihpLCBrZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGF0LnNldChrZXksIHNwZWMuZ2V0KGtleSkpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgIC8vIFdoeSB3b3VsZCB0aGUgc3BlYyBiZSBhIGZ1bmN0aW9uP1xyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbiAgICAgICAgICAgIC8vdGhpcy5fcmVsYXRpb25zaGlwcyA9IHt9O1xyXG5cclxuICAgICAgICAgICAgLy8gd2hlbiBzZXR0aW5nIGEgdmFsdWUgd2l0aCBhbm90aGVyIERhdGFfT2JqZWN0LFxyXG4gICAgICAgICAgICAvLyAgbWFrZSB0aGUgY2hpbGQgb25lIHJlbWVtYmVyIHRoZSBwYXJlbnQgcmVsYXRpb25zaGlwLlxyXG4gICAgICAgICAgICAvLyAgbWF5IGJlIHBvc3NpYmxlIHRvIGhhdmUgbXVsdGlwbGUgcGFyZW50cywgY291bGQgYmUgdGhhdCBhIGRhdGEgc2V0IGlzIHJlZmVycmVkIHRvIGluIHR3byBwbGFjZXMuIFdoZW4gdGhhdCBkYXRhIHNldCBjaGFuZ2VzIGl0IHdpbGwgZ2V0IGNoYW5nZWQgaW5cclxuICAgICAgICAgICAgLy8gICBhbGwgb2YgaXRzIHBhcmVudHMgdG9vLlxyXG5cclxuICAgICAgICAgICAgLy8gbm90IHNvIHF1aWNrLlxyXG4gICAgICAgICAgICAvLyAgRG9uJ3Qgd2FudCB0aGF0IGl0ZW0gYXBwZWFyaW5nIHVubmVjZXNzYXJpbHkuXHJcbiAgICAgICAgICAgIC8vICBNYXkgZW5zdXJlIGl0IGF0IGEgbGF0ZXIgc3RhZ2UuXHJcblxyXG4gICAgICAgICAgICAvL3RoaXMuX3JlcXVpcmVtZW50cyA9IHt9O1xyXG5cclxuICAgICAgICAgICAgLy8gdGhlbiBfX3R5cGVfbmFtZVxyXG4gICAgICAgICAgICAvLyBfX2RhdGFfdHlwZV9vYmo/IChtYXliZSBub3QgbmVlZGVkIGJlY2F1c2Ugb2YgKHF1aWNrKSBsb29rdXAgZnJvbSBuYW1lLCBzZWVtcyBtb3JlIG1lbW9yeSBlZmZpY2llbnQ/KVxyXG5cclxuICAgICAgICAgICAgLy92YXIgY3RyID0gdGhpcy5jYWxsZXI7XHJcbiAgICAgICAgICAgIC8vdmFyIGR0biA9IGN0ci5kYXRhX3R5cGVfbmFtZTtcclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnZHRuICcgKyBkdG4pO1xyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCd0aGlzLl9fdHlwZV9uYW1lICcgKyB0aGlzLl9fdHlwZV9uYW1lKTtcclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygndGhpcy5fX2RhdGFfdHlwZV9pbmZvICcgKyBzdHJpbmdpZnkodGhpcy5fX2RhdGFfdHlwZV9pbmZvKSk7XHJcblxyXG4gICAgICAgICAgICAvLyBhbmQgaWYgYSBkYXRhIHR5cGUgaGFzIGJlZW4gZGVjbGFyZWQsIHdlJ2xsIGJlIHBhcnNpbmcgdGhlIGlucHV0LlxyXG4gICAgICAgICAgICAvLyB3aWxsIGVzc2VudGlhbGx5IGJlIHNldHRpbmcgdGhlICd2YWx1ZScgaW4gdGhlIHNwZWMuXHJcblxyXG4gICAgICAgICAgICAvLyBhbHdheXMgdGhlIGNhc2Ugd2l0aCBjb25zdHJ1Y3RvcnMgd2hlbiBnaXZlbiBhIGRhdGFfdHlwZT9cclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnZG8gdGhpcy5fX3R5cGUgJyArIHRoaXMuX190eXBlKTtcclxuXHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2pzZ3VpLl9fZGF0YV9pZF9tZXRob2QgJyArIGpzZ3VpLl9fZGF0YV9pZF9tZXRob2QpO1xyXG4gICAgICAgICAgICAvL3Rocm93ICdzdG9wJztcclxuXHJcbiAgICAgICAgICAgIGlmICghaXNfZGVmaW5lZCh0aGlzLl9faWQpICYmIGpzZ3VpLl9fZGF0YV9pZF9tZXRob2QgPT0gJ2luaXQnKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSXQgc2hvdWxkIGhhdmUgdGhlIGNvbnRleHQuLi5cclxuICAgICAgICAgICAgICAgIC8vICBCdXQgbWF5YmUgdGhlcmUgY2FuIGJlIGEgZGVmYXVsdCAvIGFwcGxpY2F0aW9uIC8gaW5pdGlhbGl6YXRpb24gY29udGV4dCAobm90IHNlcnZpbmcgYSBwYXJ0aWN1bGFyIHBhZ2UpLlxyXG4gICAgICAgICAgICAgICAgLy8gICBUaGluZ3MgdG8gZG8gd2l0aCBwcm9jZXNzaW5nIGpzZ3VpIHdvdWxkIGJlIGluIHRoYXQgY29udGV4dC5cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fY29udGV4dCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3RoaXMuX2NvbnRleHQgJyArIHRoaXMuX2NvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3NmeSB0aGlzLl9jb250ZXh0ICcgKyBzdHJpbmdpZnkodGhpcy5fY29udGV4dCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX19pZCA9IHRoaXMuX2NvbnRleHQubmV3X2lkKHRoaXMuX190eXBlX25hbWUgfHwgdGhpcy5fX3R5cGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ0RhdGFPYmplY3QgbmV3IElEIGZyb20gY29udGV4dDogJyArIHRoaXMuX19pZCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vdGhpcy5fY29udGV4dC5tYXBfb2JqZWN0c1t0aGlzLl9faWRdID0gdGhpcztcclxuICAgICAgICAgICAgICAgICAgICAvLyBOb3Qga2VlcGluZyBhIG1hcCBvZiBvYmplY3RzIGJ5IGlkIGluIHRoZSBjb250ZXh0LlxyXG5cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFVzZSB0aGUgZGVmYXVsdCBjb250ZXh0LlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHBvc3NpYmx5IG1ha2UgYSBuZXdfZGF0YV9vYmplY3RfaWQgZnVuY3Rpb24/XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIE1heWJlIGRvbid0IG5lZWQgdG8gZ2l2ZSBhbGwgZGF0YSBvYmplY3RzIGlkcy5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy92YXIgY3JlYXRlX2lkID0gZnVuY3Rpb24oKVxyXG4gICAgICAgICAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld19kYXRhX29iamVjdF9pZCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzID0gJ190aWRfJyArIHRfaWRfbnVtO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0X2lkX251bSsrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnbmV3IHRlbXAgaWQgJyArIHJlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnbm8gY29udGV4dCBmb3VuZCAtIGNyZWF0aW5nIG5ldyB0ZW1wIGlkLiBzaG91bGQgaGF2ZSBjb250ZXh0Jyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX19pZCA9IG5ld19kYXRhX29iamVjdF9pZCgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGRvbid0IHRoaW5rIHdlIGtlZXAgYSBtYXAgb2YgYWxsIElEcywgb3Igd2Ugd2lsbCBkbyB3aXRoaW4gYSBQYWdlX0NvbnRleHQuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9tYXBfanNndWlfaWRzW3RoaXMuX19pZF0gPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuZCBtYWtlIHN1cmUgaXQgaXMgd2l0aGluIHRoZSBpbmRleCAvIG1hcCBvZiBqc2d1aSBvYmplY3RzIHdpdGggaWRzLlxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIGRvbid0IGdldCBpdCBmcm9tIHRoZSBwcm90b3R5cGVcclxuICAgICAgICAgICAgLy8gSXQgd2FzIGNvcHlpbmcgb3ZlciBmcm9tIHRoZSBwcm90b3R5cGUuXHJcbiAgICAgICAgICAgIC8vICAwMS8wNy8yMDEyLCBpdCB0b29rIGEgd2hpbGUgdG8gdHJhY2sgdGhpcyBkb3duLlxyXG4gICAgICAgICAgICAvLyAgIENvcHlpbmcgdGhpbmdzIG92ZXIgZnJvbSBhIHByb3RvdHlwZSBjb3VsZCBwcm92ZSB2ZXJ5IHVzZWZ1bC5cclxuICAgICAgICAgICAgLy8gICBNYXkgZG8gbW9yZSB3b3JrIG9uIGEgdHlwZSBzeXN0ZW0sIGFuZCB0aGVuIHJlYnVpbGQgdGhlIHdob2xlIHRoaW5nIGFyb3VuZCBhIHR5cGUgLyBjbGFzcyBzeXN0ZW0gdGhhdCBpcyBkZWZpbml0ZWx5IG1vcmUgYWR2YW5jZWQuXHJcbiAgICAgICAgICAgIC8vXHJcblxyXG4gICAgICAgICAgICAvLyBzbywgbm90IGdldHRpbmcgaXQgdGhyb3VnaCB0aGUgcHJvdG90eXBlIGNoYWluLlxyXG5cclxuXHJcbiAgICAgICAgICAgIC8vIGlzIGFsc28gZ29pbmcgdG8gaGF2ZSBhIF9maWVsZHMgb2JqZWN0LlxyXG4gICAgICAgICAgICAvLyAgdGhlIF9maWVsZHMgd2lsbCBoYXZlIGRpZmZlcmVudCB0aGluZ3MgaW4gdGhlbS5cclxuXHJcbiAgICAgICAgICAgIC8vIE5vdCBzdXJlIGFib3V0IHRoaXMuXHJcblxyXG4gICAgICAgICAgICBpZiAoaXNfZGVmaW5lZCh0aGlzLl9fdHlwZV9uYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgc3BlYyA9IHtcclxuICAgICAgICAgICAgICAgICAgICAnc2V0Jzogc3BlY1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgaWYgKGlzX2RlZmluZWQoc3BlYy5kYXRhX2RlZikpIHtcclxuICAgICAgICAgICAgICAgIC8vc3BlYyA9IHtcclxuICAgICAgICAgICAgICAgIC8vXHQnc2V0Jzogc3BlY1xyXG4gICAgICAgICAgICAgICAgLy99XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5cclxuXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICovXHJcblxyXG4gICAgICAgICAgICAvLyBkYXRhX2RlZlxyXG5cclxuICAgICAgICAgICAgLy90aGlzLl8gPSB0aGlzLl8gfHwge307XHJcbiAgICAgICAgICAgIC8vdmFyIF8gPSB0aGlzLl87XHJcblxyXG4gICAgICAgICAgICAvLyBlbnN1cmUodGhpcywgJ18nKTtcclxuICAgICAgICAgICAgLy92YXIgXyA9IHRoaXMuXyA9IHRoaXMuXyB8fCB7fTtcclxuXHJcblxyXG4gICAgICAgICAgICAvLyBidXQgdGhlIGNvbGxlY3Rpb24gY291bGQgYmUgbWFkZSBpbiB0aGUgcHJvdG90eXBlIElcclxuICAgICAgICAgICAgLy8gdGhpbms/Pz9cclxuXHJcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCd0aGF0Ll9jb2xsZWN0aW9uX25hbWVzICcgK1xyXG4gICAgICAgICAgICAvLyB0aGF0Ll9jb2xsZWN0aW9uX25hbWVzKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFRoZSBjb2xsZWN0aW9uIG5hbWVzLi4uIGNvdWxkIGJlIGRlYWx0IHdpdGggdXNpbmcgdGhlXHJcbiAgICAgICAgICAgIC8vIGRhdGFfdHlwZV9pbnN0YW5jZSBtZXRob2RzLlxyXG5cclxuICAgICAgICAgICAgLy8gSW50ZXJlc3RpbmcuLi4gaGFzIGNvbGxlY3Rpb25zIGluc2lkZS5cclxuXHJcbiAgICAgICAgICAgIC8vIG9rLCBzbyBpdCB3b3JrcyBzbyBmYXIuXHJcblxyXG4gICAgICAgICAgICAvLyBidXQgd2l0aCB0aGUgY29sbGVjdGlvbiBwcm9wZXJ0aWVzIC0gY2FuIHRoZXNlIGJlXHJcbiAgICAgICAgICAgIC8vIGluaXRpYWxpemVkIGhlcmU/XHJcbiAgICAgICAgICAgIC8vIG1heWJlIGRvIHRoYXQgd2l0aGluIHRoZSBjb2xsZWN0aW9uIHByb3BlcnR5Li4uLlxyXG4gICAgICAgICAgICAvLyBidXQgbWF5IG5lZWQgdG8gY2hlY2sgdG9vIG11Y2guXHJcblxyXG4gICAgICAgICAgICAvLyB0aGUgY2hhaW4gb2YgZmllbGRzLi4uIG5vdCBzdXJlIGhvdyB0aGUgY2hhaW4gbmVlZHMgdG8gd29yayBiYWNrd2FyZHMuXHJcbiAgICAgICAgICAgIC8vICBmb3IgcGVyc29uIHJlY29yZGVkOiBbWzAsIFtcImZsYWdzXCIsIH5Db2xsZWN0aW9uKFN0cmluZyldXSwgWzAsIFtcImRvYlwiLCBcImRhdGVcIl1dLCBbMSwgW1wibmFtZVwiLCBcInN0cmluZ1wiXV1dXHJcbiAgICAgICAgICAgIC8vICBtYXliZSBuZWVkIHRvIGpvaW4gdGhlbSB0b2dldGhlciBiZXR0ZXI/IGludG8gYSBmaWVsZHMgbGlzdD9cclxuICAgICAgICAgICAgLy8gIHNvIHdlIHN0YXJ0IHdpdGggdGhlIG1vc3QgcmVjZW50IG9uZXM/XHJcbiAgICAgICAgICAgIC8vICBmaWVsZHMgbWFwIHNvIHdlIGtub3cgd2hhdCB0aGV5IGFyZSBieSBuYW1lLCBzbyBpZ25vcmluZyB0aGUgcmVwZWF0ZWQgb25lcyBnb2luZyBiYWNrLCB3aG8ncyBkZWZpbml0aW9uIHdpbGwgaGF2ZSBiZWVuIG92ZXJ3cml0dGVuLlxyXG4gICAgICAgICAgICAvLyAgVGhlbiB3ZSB1c2UgdGhlIGNoYWluZWQgZmllbGRzIGluIHRoZSByaWdodCBvcmRlci4uLiBzZXQgdGhlIGZpZWxkcyB1cD9cclxuICAgICAgICAgICAgLy8gICBCdXQgSSB0aGluayB3ZSB3YW50IGxhenkgZmllbGQgbG9hZGluZyBhbnl3YXkuXHJcblxyXG4gICAgICAgICAgICAvLyBOZWVkIHRvIGhhdmUgdGhlIGRvbSBmaWVsZCBhdmFpbGFibGUgdG8gSFRNTC5cclxuXHJcbiAgICAgICAgICAgIHZhciBjaGFpbmVkX2ZpZWxkcyA9IGdldF9jaGFpbmVkX2ZpZWxkcyh0aGlzLmNvbnN0cnVjdG9yKTtcclxuICAgICAgICAgICAgdmFyIGNoYWluZWRfZmllbGRzX2xpc3QgPSBjaGFpbmVkX2ZpZWxkc190b19maWVsZHNfbGlzdChjaGFpbmVkX2ZpZWxkcyk7XHJcblxyXG4gICAgICAgICAgICAvL3ZhciBjaGFpbmVkX2ZpZWxkc19saXN0ID0gY2hhaW5lZF9maWVsZHNfdG9fZmllbGRzX2xpc3QoZ2V0X2NoYWluZWRfZmllbGRzKHRoaXMuY29uc3RydWN0b3IpKTtcclxuICAgICAgICAgICAgLy8gbmVlZCB0byBsb29rIGF0IGhvdyB0aGUgY2hhaW5lZCBmaWVsZHMgYXJlIHNldCB1cC5cclxuICAgICAgICAgICAgLy8gIEkgdGhpbmsgdmFyaW91cyAoY2hhaW5lZCkgZmlsZWRzIHdpbGwgZ2V0IHNldCB1cCBkdXJpbmcgdGhlIG5vcm1hbCBpbml0aWFsaXphdGlvbiBvZiB0aGUgbGlicmFyeS5cclxuXHJcblxyXG5cclxuICAgICAgICAgICAgLy8gSXQgbWF5IG5vdCBiZSBzZXR0aW5nIHVwIHRoZSBmaWVsZHMgcmlnaHQgZm9yIENvbG9yLlxyXG4gICAgICAgICAgICAvLyAgVGhlcmUgaXMgYW4gaW5kZXhlZCBhcnJheSBvZiByZWQsIGdyZWVuLCBibHVlLlxyXG5cclxuXHJcblxyXG5cclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnY2hhaW5lZF9maWVsZHMgJyArIHN0cmluZ2lmeShjaGFpbmVkX2ZpZWxkcykpO1xyXG5cclxuXHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJyogY2hhaW5lZF9maWVsZHMgJyArIHN0cmluZ2lmeShjaGFpbmVkX2ZpZWxkcykpO1xyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCcqIGNoYWluZWRfZmllbGRzX2xpc3QgJyArIHN0cmluZ2lmeShjaGFpbmVkX2ZpZWxkc19saXN0KSk7XHJcbiAgICAgICAgICAgIC8vIHRoZSBjaGFpbmVkIGZpZWxkcyBsaXN0IHNlZW0gT0suXHJcblxyXG4gICAgICAgICAgICAvLyBCdXQgbWFraW5nIGp1c3QgYSBsaXN0IG9mIGZpZWxkcyBvdXQgb2YgdGhlIGNoYWluZWQgb25lcy4uLlxyXG4gICAgICAgICAgICAvLyAgaXMgaXQgd29ya2luZyBPSz9cclxuXHJcbiAgICAgICAgICAgIC8vdGhyb3cgJ3N0b3AnO1xyXG5cclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnKiBjaGFpbmVkX2ZpZWxkc19saXN0ICcgKyBzdHJpbmdpZnkoY2hhaW5lZF9maWVsZHNfbGlzdCkpO1xyXG4gICAgICAgICAgICAvL3Rocm93ICdzdG9wJztcclxuICAgICAgICAgICAgLy8gdGhlbiBwcm9jZXNzIHRoZSBjaGFpbmVkIGZpZWxkcyB0byBmaWVsZHMgbGlzdC4uLlxyXG5cclxuICAgICAgICAgICAgLy8gTmVlZCB0byBzZXQgdGhlIENvbnRleHQ/XHJcblxyXG4gICAgICAgICAgICAvLyBJIHRoaW5rIG9ubHkgbWFrZSB0aGUgZmllbGRzIGNvbGxlY3Rpb24gaWYgdGhlcmUgYXJlIGZpZWxkcy5cclxuXHJcbiAgICAgICAgICAgIGlmIChjaGFpbmVkX2ZpZWxkc19saXN0Lmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZmMgPSBuZXcgRmllbGRzX0NvbGxlY3Rpb24oe1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBGaWVsZHMgY29sbGVjdGlvbiBoYXMgYSBjb250ZXh0P1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgICAgIC8vJ2NvbnRhaW5pbmdfb2JqZWN0JzogdGhpc1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gYnV0IHRoZSBmaWVsZCBvYmplY3QgaXRzZWxmIG1heSBiZSBjcmVhdGVkIG9uIGdldC5cclxuICAgICAgICAgICAgICAgIC8vICBuZWVkIHRvIG1ha2Ugc3VyZSBhdCB0aGF0IHRpbWUgaXQgaGFzIGl0cyBwYXJlbnQuXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gbmVlZCB0byBjaGVjayBob3cgdGhpcyBpcyBnZXR0aW5nIHNldCBub3cuXHJcbiAgICAgICAgICAgICAgICAvLyAgVGhpcyBpcyBvbmx5IHJlYWxseSBkZWFsaW5nIHdpdGggc2V0dGluZyB1cCBzb21lIGluZm8gZm9yIHRoZSBmaWVsZHMsIHRoZSBmaWVsZHMgd2lsbCBsaWtlbHkgYmUgZW1wdHkgdW50aWwgdGhleSBhcmUgbmVlZGVkLFxyXG4gICAgICAgICAgICAgICAgLy8gICB1c2luZyBsYXp5IGxvYWRpbmcgdG8gc2F2ZSBtZW1vcnkuXHJcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCcnKTtcclxuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJycpO1xyXG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnKioqIGNoYWluZWRfZmllbGRzX2xpc3QgJyArIHN0cmluZ2lmeShjaGFpbmVkX2ZpZWxkc19saXN0KSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy90aGlzLmZjLnNldChjaGFpbmVkX2ZpZWxkcyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZjLnNldChjaGFpbmVkX2ZpZWxkc19saXN0KTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyB0aGUgZmllbGRzIGNvbGxlY3Rpb24uLi4gdGhhdCBuZWVkcyB0byBoYW5kbGUgZmllbGRzIHRoYXQgYXJlIGdpdmVuXHJcbiAgICAgICAgICAgICAgICAvLyAgYXMgY29uc3RydWN0b3IgZnVuY3Rpb25zLlxyXG4gICAgICAgICAgICAgICAgLy8gICBtYXliZSBhc3N1bWUgYSBmdW5jdGlvbiBpcyBhIGNvbnN0cnVjdG9yIGZ1bmN0aW9uP1xyXG4gICAgICAgICAgICAgICAgLy8gICAgdGhlbiBhICdwcm9kdWN0cycgZmllbGQgdGhhdCBpcyBnaXZlbiBieSBhIGNvbnN0cnVjdG9yIGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAvLyAgICAgd291bGQgdGhlbiBoYXZlIGEgY29ubmVjdGVkIGZpZWxkIHRoYXQgc2V0cyB0aGF0IHZhbHVlLlxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgZG9fY29ubmVjdCA9IHRoaXMudXNpbmdfZmllbGRzX2Nvbm5lY3Rpb24oKTtcclxuICAgICAgICAgICAgICAgIGlmIChkb19jb25uZWN0KSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhcnJfZmllbGRfbmFtZXMgPSBbXSwgZmllbGRfbmFtZTtcclxuICAgICAgICAgICAgICAgICAgICBlYWNoKGNoYWluZWRfZmllbGRzLCBmdW5jdGlvbihpLCBmaWVsZF9pbmZvKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2ZpZWxkX2luZm8gJyArIHN0cmluZ2lmeShmaWVsZF9pbmZvKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWVsZF9uYW1lID0gZmllbGRfaW5mb1sxXVswXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnZmllbGRfbmFtZSAnICsgZmllbGRfbmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFycl9maWVsZF9uYW1lcy5wdXNoKGZpZWxkX25hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBqdXN0IGFuIGFycmF5IG9mIGZpZWxkcy5cclxuICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdhcnJfZmllbGRfbmFtZXMgJyArIHN0cmluZ2lmeShhcnJfZmllbGRfbmFtZXMpKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3RfZmllbGRzKGFycl9maWVsZF9uYW1lcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICAvLyBkb2VzIHNldCB3b3JrIE9LP1xyXG5cclxuXHJcblxyXG4gICAgICAgICAgICAvLyB0aGF0IHNob3VsZCBoYXZlIGRvbmUgaXQuLi5cclxuICAgICAgICAgICAgLy8gIHRoZSBmaWVsZCBjb2xsZWN0aW9uIHNob3VsZCBub3cgaG9sZCBpbmZvIGFib3V0IGFsbCBvZiB0aGUgZmllbGRzLlxyXG5cclxuXHJcbiAgICAgICAgICAgIC8vdGhpcy5maWVsZHMoY2hhaW5lZF9maWVsZHMpO1xyXG5cclxuXHJcblxyXG4gICAgICAgICAgICAvLyBhbHNvLCBpZiB3ZSBoYXZlIGZpZWxkcyAob2J0YWluZWQgdGhyb3VnaCB0aGUgZmllbGQgY2hhaW4gaW4gdGhpcyBjYXNlKSwgd2UgdGhlbiBuZWVkIHRvIGNoZWNrIGlmIHRoZSBmaWVsZHMgZ2V0IGNvbm5lY3RlZC5cclxuICAgICAgICAgICAgLy8gIHRoaXMgaXMgYSBuaWNlIHdheSBvZiBkb2luZyB0aGluZ3MsIG1ha2luZyBpdCBlYXN5IHRvIHNwZWNpZnksIGJ1dCB3aXRob3V0IHRvbyBtdWNoIGdvaW5nIG9uIGF1dG9tYXRpY2FsbHkuXHJcblxyXG4gICAgICAgICAgICAvL1xyXG5cclxuXHJcbiAgICAgICAgICAgIC8vIGhhdmUgc29tZXRoaW5nIGluIHRoZSBwcm90b3R5cGUgdGhhdCBzYXlzIHRoZSBjb2xsZWN0aW9uXHJcbiAgICAgICAgICAgIC8vIG5hbWVzP1xyXG4gICAgICAgICAgICAvLyBvcmRlciBvZiBib3VuZCBldmVudHMgY2FsbGVkIG5vdCBzdHJpY3RseSBzZXQuXHJcblxyXG5cclxuICAgICAgICAgICAgLy8gY291bGQgcG9zc2libHkgZG8gdGhpcyBhdCBhIGxhdGVyIHN0YWdlIG9mIGluaXRpYWxpemF0aW9uLCBvbmNlIHRoZSB2YXJpYWJsZXMgaGF2ZSBiZWVuIHNldCBmb3Igc3VyZS5cclxuICAgICAgICAgICAgLy8gIGNvdWxkIGhhdmUgYWxyZWFkeSBzZXQgdGhlIHZhcmlhYmxlcy5cclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnc3BlYyAnICsgc3RyaW5naWZ5KHNwZWMpKTtcclxuXHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2NoYWluZWRfZmllbGRzX2xpc3QgJyArIHN0cmluZ2lmeShjaGFpbmVkX2ZpZWxkc19saXN0KSk7XHJcblxyXG5cclxuICAgICAgICAgICAgLy92YXIgY2hhaW5lZF9maWVsZHNfbWFwID0gbWFwaWZ5KGNoYWluZWRfZmllbGRzX2xpc3QsIDApO1xyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdjaGFpbmVkX2ZpZWxkc19tYXAgJyArIHN0cmluZ2lmeShjaGFpbmVkX2ZpZWxkc19tYXApKTtcclxuICAgICAgICAgICAgLy9lYWNoKGNoYWluZWRfZmllbGRzX2xpc3QsIGZ1bmN0aW9uKGksIHYpIHtcclxuICAgICAgICAgICAgICAgIC8vY2hhaW5lZF9maWVsZHNfbWFwW3ZbMF1dID0gdlsxXTtcclxuICAgICAgICAgICAgLy99KTtcclxuXHJcbiAgICAgICAgICAgIC8vIGdvIHRocm91Z2ggY2hhaW5lZF9maWVsZHNfbWFwW2ldKSwgc2V0dGluZyB1cCBmaWVsZHMuXHJcblxyXG4gICAgICAgICAgICAvLyBtYXliZSBiZXN0IHRvIHVzZSB0aGUgbGlzdC5cclxuXHJcbiAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgIGVhY2goY2hhaW5lZF9maWVsZHMsIGZ1bmN0aW9uKGksIGNoYWluZWRfZmllbGQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBmaWVsZF9uYW1lID0gY2hhaW5lZF9maWVsZFswXTtcclxuICAgICAgICAgICAgICAgIHZhciBmaWVsZF9kZWYgPSBjaGFpbmVkX2ZpZWxkWzFdO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFRoZSBwb2ludCBpcywgSSB0aGluaywgdGhhdCBJIGFtIG5vdCBtYWtpbmcgZmllbGQgY2xhc3NlcywgYnV0IHByb2Nlc3NpbmcgdGhlbSB1c2luZyBzb21lIG1vcmUgYmFzaWMgdmFyaWFibGUgdHlwZXMuXHJcblxyXG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnZmllbGRfbmFtZSAnICsgZmllbGRfbmFtZSk7XHJcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdmaWVsZF9kZWYgJyArIHN0cmluZ2lmeShmaWVsZF9kZWYpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBhdCBsZWFzdCBpdCBoYXMgdGhvc2UgZmllbGRzLi4uIEkgYW0gbm90IHN1cmUgaXQgbmVlZHMgdG8gZG8gYW55dGhpbmcgdW50aWwgJ2dldCcsIG1heWJlIGV2ZW4gaWYgdGhlcmUgYXJlIGRlZmF1bHQgdmFsdWVzLlxyXG5cclxuXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICovXHJcblxyXG5cclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygndG9mKHNwZWMpICcgKyBzcGVjKTtcclxuICAgICAgICAgICAgdmFyIGNoYWluZWRfZmllbGRfbmFtZTtcclxuXHJcbiAgICAgICAgICAgIC8vIElmIHRoZSBzcGVjIGlzIGFuIG9iamVjdC5cclxuXHJcbiAgICAgICAgICAgIGlmICh0X3NwZWMgPT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgICAgIGVhY2goc3BlYywgZnVuY3Rpb24oaSwgdikge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBKdXN0IGNvcHkgdGhlIGZ1bmN0aW9ucyBmb3IgdGhlIG1vbWVudD9cclxuICAgICAgICAgICAgICAgICAgICAvLyB3aGF0IGFib3V0IGNvcHlpbmcgZXZlcnl0aGluZyBlbHNlP1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIG5lZWQgdG8gbWF5IG1vcmUgYXR0ZW50aW9uIHRvIGFkZGluZyB0aGluZ3M/XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcHVzaCB0aGUgb3RoZXIsIG5vbi1mdW5jdGlvbiBpdGVtcyBvbmUgYnkgb25lP1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBPciBjb3B5IHRoZSBvdGhlciB0aGluZ3MgdG8gJ18nLlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyB2YXIgbXlfaSA9IHRoYXRbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gd2lsbCBzYXZlIGEgYml0IGluIHRoZSBDb3JlIHJld3JpdGUuIFdpbGwgZXZlbnR1YWxseVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHB1dCB0aGVzZSB0ZWNobmlxdWVzIGluIHRoZSBtYWluIGxpYi5cclxuICAgICAgICAgICAgICAgICAgICAvLyBjYWxsaW5nIHRoZSBmdW5jdGlvbnM/Pz9cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTWF5IGJlIHVzZWQgZm9yIGNvbnRyb2xzPz8/XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRnVuY3Rpb24gY2FsbHMgaW4gc3BlYy4uLlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIENhbGxpbmcgdGhpbmdzIGxpa2UgJ2JpbmQnIHRocm91Z2ggdGhlIHNwZWMuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2kgJyArIGkgKyAnID12PSAnICsgdiArICcgdGhhdFtpXSAnICsgdGhhdFtpXSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIE90aGVyIHRoaW5nIHRoYXQgd2UgbWF5IHdhbnQgdG8gZG8gaXMganVzdCBjb3B5XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpbmdzLlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlYWxseSBub3Qgc3VyZSBhYm91dCB0aGF0IGluIGdlbmVyYWwgdGhvdWdoLCB3aXRoXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRGF0YU9iamVjdCBiZWluZyBzbyBnZW5lcmFsbHkgdXNlZCBhcyBhIGJhc2lzIGZvclxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaW5ncyBsaWtlIGNvbnRyb2xzLlxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRoYXRbaV0gPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25uZWN0ZWQgYnkgbm93IVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3VjaCBhcyBzZXR0aW5nIHRoZSBmaWVsZHMuLi5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXRbaV0odik7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gX1tpXSA9IHY7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGV5IGNvdWxkIGJlIHZhbHVlcy4uLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgc2hvdWxkIHNldCB0aGUgdmFsdWVzXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwb3NzaWJseSBvbmx5IHNldCB0aGVtIGlmIHRoZXkgY29ycmVzcG9uZCB0byBmaWVsZHM/XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzZXQgdmFsdWVzIGZyb20gZmllbGRzIHNlZW1zIGxpa2UgYSBnb29kIGlkZWEgaGVyZS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gIHRoYXQgc2VlbXMgbGlrZSBhIGdvb2QgbGV2ZWwgb2YgY29ubmVjdGVkbmVzcy5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gIHdhbnQgYSBtYXAgb2YgdGhlIGZpZWxkcyB0byBxdWlja2x5IHRlc3QgdGhlbS5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNldHRpbmcgdmFsdWVzIGZyb20gY2hhaW5lZCBmaWVsZHM/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICBwcm9iYWJseSBiZXR0ZXIgdG8gc2V0IHRoZW0gZnJvbSB0aGUgbm9ybWFsIGZpZWxkcy5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJzIqIGNoYWluZWRfZmllbGRzICcgKyBzdHJpbmdpZnkoY2hhaW5lZF9maWVsZHMpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnMiogY2hhaW5lZF9maWVsZHNfbGlzdCAnICsgc3RyaW5naWZ5KGNoYWluZWRfZmllbGRzX2xpc3QpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGl0IHdpbGwgYmUgZG9tLm5vZGVUeXBlLlxyXG5cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGVuIGl0IHNob3VsZCBiZSBhYmxlIHRvIHNldCBzb21lIHZhbHVlcy5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnc3BlYyAnICsgc3RyaW5naWZ5KHNwZWMpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1heWJlIGEgbWFwIG9mIGNoYWluZWQgZmllbGRzIHdvdWxkIHdvcmsgYmV0dGVyLlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ291bGQgYmUgZG9uZSBhIGxvdCBtb3JlIGVmZmljaWVudGx5IHdpdGggYSBtYXAuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hhaW5lZF9maWVsZHNfbGlzdC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGNmLCBjaGFpbmVkX2ZpZWxkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgYyA9IDAsIGwgPSBjaGFpbmVkX2ZpZWxkc19saXN0Lmxlbmd0aDsgYyA8IGw7IGMrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYWluZWRfZmllbGQgPSBjaGFpbmVkX2ZpZWxkc19saXN0W2NdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRjZiA9IHRvZihjaGFpbmVkX2ZpZWxkKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRjZiA9PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFpbmVkX2ZpZWxkX25hbWUgPSBjaGFpbmVkX2ZpZWxkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGNmID09ICdhcnJheScpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhaW5lZF9maWVsZF9uYW1lID0gY2hhaW5lZF9maWVsZFswXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2NoYWluZWRfZmllbGRfbmFtZSAnICsgY2hhaW5lZF9maWVsZF9uYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb21pbmcgb3V0IGFzIHVuZGVmaW5lZC5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSSB0aGluayBJIG5lZWQgdG8gcmVkbyB0aGUgZmllbGQgY2hhaW5pbmcgc3lzdGVtIHNvbWV3aGF0LlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICBJdCdzIGFsZ29yaXRobXMgY2FuIGJlIG1hZGUgZmFzdGVyIGFuZCBuZWF0ZXIuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQmFzaWNhbGx5LCBhdCBhbnkgbGV2ZWwgd2UgZGVmaW5lIGZpZWxkcy5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOZWVkIHRvIGJlIGFibGUgdG8gZ2V0IHRoZSBmaWVsZHMgZm9yIHRoaXMgbGV2ZWwuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gIFdvdWxkIGhlbHAgdG8gZ2V0IHRoZSBuYW1lcyBvZiB0aGUgcGFyZW50cy5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgIEZpZWxkIGRlZmluaXRpb25zIG9mIHRoZSBzdWJjbGFzc2VzIG92ZXJ3cml0ZSB0aG9zZSBvZiB0aGUgc3VwZXJjbGFzc2VzLlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXYW50IHRvIGJlIGFibGUgdG8gZ2V0IHRoZSBmaWVsZCBjaGFpbi4uLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICBUaGF0IGlzIGdvaW5nIGJhY2t3YXJkcyBnZXR0aW5nIGFsbCBvZiB0aGUgZmllbGRzLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgTm90IG92ZXJ3cml0aW5nIHRoZW0gYXMgb2xkZXIgb25lcyBhcmUgZm91bmQuXHJcblxyXG5cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlZG9pbmcgdGhlIGZpZWxkIGNoYWluaW5nIGlzIHByb2JhYmx5IG9uZSBvZiB0aGUgbGFyZ2VzdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICBjaGFuZ2VzIHRvIG1ha2UgaW4gb3JkZXIgdG8gZ2V0IGEgbmljZWx5IHdvcmtpbmcgc3lzdGVtLlxyXG5cclxuXHJcblxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnaSAnICsgaSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5lZWQgdG8gbWFrZSBzdXJlIHdlIGEgYXJlIHByb3Blcmx5IGhvbGRpbmcgdGhlIGZpZWxkIHR5cGVzLlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hhaW5lZF9maWVsZF9uYW1lID09IGkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnKioqIGNoYWluZWRfZmllbGRfbmFtZSAnICsgY2hhaW5lZF9maWVsZF9uYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnc2V0dGluZycpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3RoYXQuc2V0KFtpLCB2XSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOZWVkIHRvIGNoZWNrIHNldHRpbmcgYSBjb2xsZWN0aW9uIHdpdGggYW4gYXJyYXkuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuc2V0KGksIHYpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygndGhhdC5fW2ldICcgKyBzdHJpbmdpZnkodGhhdC5fW2ldKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWFjaChjaGFpbmVkX2ZpZWxkc19saXN0LCBmdW5jdGlvbihpMiwgY2hhaW5lZF9maWVsZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2NoYWluZWRfZmllbGQgJyArIHN0cmluZ2lmeSh0b2YoY2hhaW5lZF9maWVsZCkpKTtcclxuXHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodG9mKGNoYWluZWRfZmllbGQpID09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhaW5lZF9maWVsZF9uYW1lID0gY2hhaW5lZF9maWVsZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRvZihjaGFpbmVkX2ZpZWxkKSA9PSAnYXJyYXknKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhaW5lZF9maWVsZF9uYW1lID0gY2hhaW5lZF9maWVsZFswXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2NoYWluZWRfZmllbGRfbmFtZSAnICsgY2hhaW5lZF9maWVsZF9uYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdpICcgKyBpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoYWluZWRfZmllbGRfbmFtZSA9PSBpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnY2hhaW5lZF9maWVsZF9uYW1lICcgKyBjaGFpbmVkX2ZpZWxkX25hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3NldHRpbmcnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3RoYXQuc2V0KFtpLCB2XSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5lZWQgdG8gY2hlY2sgc2V0dGluZyBhIGNvbGxlY3Rpb24gd2l0aCBhbiBhcnJheS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0LnNldChpLCB2KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygndGhhdC5fW2ldICcgKyBzdHJpbmdpZnkodGhhdC5fW2ldKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3Rocm93KCdzdG9wJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAvL2NoYWluZWRfZmllbGRzX2xpc3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGNoYWluZWRfZmllbGRzX21hcCAmJiBpc19kZWZpbmVkKGNoYWluZWRfZmllbGRzX21hcFtpXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdjaGFpbmVkX2ZpZWxkcyBpICcgKyBpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdjaGFpbmVkX2ZpZWxkcyB2ICcgKyB2KTtcclxuXHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuc2V0KGksIHYpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBldmVudHMgYXMgYSBsaXN0P1xyXG4gICAgICAgICAgICAgICAgLy8gb3IgbmFtZWQgYW55d2F5P1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIHRoZW4gdGhlcmUgaXMgYSBsaXN0IGZvciB0aGUgZXZlbnRzIG9mIGVhY2ggbmFtZS5cclxuICAgICAgICAgICAgICAgIC8vIGFsc28sIHdpbGwgY3JlYXRlIHRoZSBfYm91bmRfZXZlbnRzIG9iamVjdCB3aGVuIG5lZWRlZC5cclxuICAgICAgICAgICAgICAgIC8vdGhpcy5fYm91bmRfZXZlbnRzID0ge307XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGlzX2RlZmluZWQoc3BlYy5ldmVudF9iaW5kaW5ncykpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyAnMTYpIHN0b3AnO1xyXG4gICAgICAgICAgICAgICAgICAgIGVhY2goc3BlYy5ldmVudF9iaW5kaW5ncywgZnVuY3Rpb24oZXZlbnRfbmFtZSwgdikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodG9mKHYpID09ICdhcnJheScpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVhY2godiwgZnVuY3Rpb24oZXZlbnRfbmFtZSwgZm5fZXZlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodG9mKGZuX2V2ZW50KSA9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkX2V2ZW50X2xpc3RlbmVyKGV2ZW50X25hbWUsIGZuX2V2ZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0b2YodikgPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRfZXZlbnRfbGlzdGVuZXIoZXZlbnRfbmFtZSwgdik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgc3BlY19yZXNlcnZlZCA9IFsncGFyZW50JywgJ2V2ZW50X2JpbmRpbmdzJywgJ2xvYWRfYXJyYXknXTtcclxuICAgICAgICAgICAgICAgIHZhciBtYXBfc3BlY19yZXNlcnZlZCA9IGdldF90cnV0aF9tYXBfZnJvbV9hcnIoc3BlY19yZXNlcnZlZCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRG9uJ3QgZ2l2ZSB0aGUgY29uc3RyYWludCBhcyBqdXN0IHRoZSBzcGVjIVxyXG4gICAgICAgICAgICAgICAgLy8gIEl0J3Mgbm90IGEgZ29vZCBpZGVhLiBTcGVjaWZ5IGl0IHNlcGFyYXRlbHkuXHJcbiAgICAgICAgICAgICAgICAvLyAgU3BlYyBjYW4ganVzdCBiZSB0aGUgZGF0YSwgaXQgbG9va3MgbGlrZT9cclxuXHJcbiAgICAgICAgICAgICAgICAvL3ZhciBvX2NvbnN0cmFpbnQgPSB7fTtcclxuICAgICAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgICAgICAgZWFjaChzcGVjLCBmdW5jdGlvbihpLCB2KSB7XHJcbiAgICAgICAgICAgICAgICAgaWYgKCFtYXBfc3BlY19yZXNlcnZlZFtpXSkge1xyXG4gICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICAgb19jb25zdHJhaW50W2ldID0gdjtcclxuICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgaWYgKHNwZWMuY29uc3RyYWludCkgdGhhdC5jb25zdHJhaW50KHNwZWMuY29uc3RyYWludCk7XHJcbiAgICAgICAgICAgICAgICAvLyB0aGVuIGdvIHRocm91Z2ggdGhlIHNwZWMsIGlnbm9yaW5nIHRoZSByZXNlcnZlZCBvbmVzLCBhbmQgdHJlYXQgdGhvc2UgaXRlbXMgYXMgZmllbGQgY29uc3RyYWl0cyAvIGZpZWxkIGNvbnN0cmFpbnQgZGVmaW5pdGlvbnMuXHJcbiAgICAgICAgICAgICAgICAvLyBhbmQgX3BhcmVudD9cclxuICAgICAgICAgICAgICAgIC8vIGJ1dCBnZXQocGFyZW50KSBjb3VsZCBiZSByZWFsbHkgdXNlZnVsLlxyXG4gICAgICAgICAgICAgICAgLy8gQ291bGQgYmUgdmVyeSB1c2VmdWwgd2l0aCBjb250cm9scywgaGF2aW5nIHRoaXMgcGFyZW50XHJcbiAgICAgICAgICAgICAgICAvLyBzdHJ1Y3R1cmUuXHJcbiAgICAgICAgICAgICAgICAvLyBDb3VsZCBiZSB1c2VmdWwgaW4gYnViYmxpbmcgZXZlbnRzIGluIGNvbnRyb2xzIHRvby5cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBCdXQgbm90IGp1c3Qgb25lIHBvdGVudGlhbCBwYXJlbnQuXHJcbiAgICAgICAgICAgICAgICAvLyBUaGUgZGF0YSBvYmplY3QgY2FuIGFwcGVhciBpbiBtb3JlIHRoYW4gb25lIGNvbGxlY3Rpb24uXHJcbiAgICAgICAgICAgICAgICAvLyAgV2lsbCB1c2UgJ3JlbGF0aW9uc2hpcHMnLCB3aGVyZSB0aGVyZSBjYW4gYmUgbW9yZSB0aGFuIG9uZSAncGFyZW50J1xyXG4gICAgICAgICAgICAgICAgLy8gIFdpbGwgaGF2ZSB0aGluZ3MgaW5kZXhlZCBmb3IgZmFzdGVyIGFjY2Vzcy5cclxuICAgICAgICAgICAgICAgIC8vIHdoYXQgaWYgdGhlIHNwZWMgaXMgYSBjb2xsZWN0aW9uIG9mIHN0cmluZyBrZXlzIChyZXByZXNlbnRpbmcgZmllbGRzKSBhbmQgc3RyaW5nIHZhbHVlcyByZXByZXNlbnRpbmcgdGhlIGNvbnN0cmFpbnRzP1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIHBhcmVudCBjb3VsZCBiZSByZXNlcnZlZCAvIGlnbm9yZWQgYXMgYSBmaWVsZC5cclxuICAgICAgICAgICAgICAgIC8vICBjb3VsZCBjaGVjayBhbiBvYmplY3QgdG8gc2VlIGlmIGl0J3MgYSBmaWVsZCBkZWZpbml0aW9uIHR5cGUuXHJcbiAgICAgICAgICAgICAgICAvLyAgY291bGQgYmUgYSBzdHJpbmcuIGNvdWxkIGJlIGFuIGFycmF5IG9mIHRoZSByaWdodCBmb3JtLlxyXG4gICAgICAgICAgICAgICAgLy8gIEZpZWxkIGRlZmluaXRpb25zIGNvdWxkIGJlIGEgYml0IHRyaWNreSAtIGl0IG1heSBhY3R1YWxseSBjcmVhdGUgc3VjaCBhIGZpZWxkIGRlZmluaXRpb24gb2JqZWN0IGlmIGl0IG5lZWRzIHRvIGRvIHNvLlxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChpc19kZWZpbmVkKHNwZWMucGFyZW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0KCdwYXJlbnQnLCBzcGVjLnBhcmVudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcblxyXG5cclxuICAgICAgICAgICAgLy92YXIgdGhhdCA9IHRoaXM7XHJcblxyXG4gICAgICAgICAgICAvLyBUaGVzZSBldmVudHMgc2VlbSB0byBnZXQgY2FsbGVkIGZhciB0b28gbXVjaC5cclxuICAgICAgICAgICAgLy8gIE5lZWQgdG8gbG9vayBpbnRvIHRoZSBhZGRfZXZlbnRfbGlzdGVuZXIgY29kZSBmb3IgZGVhbGluZyB3aXRoIHNlcnZpbmcgbXVsdGlwbGUgcGFnZXMuXHJcblxyXG5cclxuICAgICAgICAgICAgLy8gb25seSBhZGQgaXQgaWYgaXQgaGFzIGEgY29udGV4dD9cclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9jb250ZXh0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmluaXRfZGVmYXVsdF9ldmVudHMoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy9pZiAoc3BlYy5maWVsZHMpIHtcclxuICAgICAgICAgICAgLy9cdHRoaXMuZmllbGRzKHNwZWMuZmllbGRzKTtcclxuICAgICAgICAgICAgLy99XHJcblxyXG5cclxuXHJcblxyXG4gICAgICAgICAgICAvLyBXYW50IHRvIGRvIHRoaXMgYWZ0ZXIgYWxsIGluaXRpYWxpemF0aW9uLlxyXG4gICAgICAgICAgICAvLyAgQWZ0ZXIgdGhlIHdob2xlIGluaXQgc2VxdWVuY2UgaGFzIGZpbmlzaGVkLlxyXG5cclxuXHJcblxyXG5cclxuICAgICAgICAgICAgLy9kZWxldGUgdGhpcy5faW5pdGlhbGl6aW5nO1xyXG4gICAgICAgICAgICB0aGlzLl9pbml0aWFsaXppbmcgPSBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vY29uc29sZS5sb2coJ2VuZCBEYXRhX09iamVjdCBpbml0Jyk7XHJcbiAgICB9LFxyXG5cclxuICAgICdpbml0X2RlZmF1bHRfZXZlbnRzJzogZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuYWRkX2V2ZW50X2xpc3RlbmVyKCdhZGQnLCBmdW5jdGlvbihlKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAodG9mKGUpID09ICdjb2xsZWN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHN0YWNrID0gbmV3IEVycm9yKCkuc3RhY2s7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhzdGFjayk7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyAnVGhlIGV2ZW50IG9iamVjdCBzaG91bGQgbm90IGJlIGEgY29sbGVjdGlvbi4nO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgcGFyZW50ID0gdGhhdC5wYXJlbnQoKTtcclxuICAgICAgICAgICAgaWYgKHBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgcGFyZW50LnJhaXNlX2V2ZW50KCdhZGQnLCBlKTtcclxuICAgICAgICAgICAgICAgIC8vdGhyb3cgJ3N0b3AnO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB0aGlzLmFkZF9ldmVudF9saXN0ZW5lcigncmVtb3ZlJywgZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICB2YXIgY2hhbmdlX2UgPSB7fTtcclxuICAgICAgICAgICAgZWFjaChlLCBmdW5jdGlvbihpLCB2KSB7XHJcbiAgICAgICAgICAgICAgICBjaGFuZ2VfZVtpXSA9IHY7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBjaGFuZ2VfZS5ldmVudF9uYW1lID0gJ3JlbW92ZSc7XHJcbiAgICAgICAgICAgIHRoYXQucmFpc2VfZXZlbnQoJ2NoYW5nZScsIGNoYW5nZV9lKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSB0aGF0LnBhcmVudCgpO1xyXG4gICAgICAgICAgICBpZiAocGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICBwYXJlbnQucmFpc2VfZXZlbnQoJ3JlbW92ZScsIGUpO1xyXG4gICAgICAgICAgICAgICAgLy90aHJvdyAnc3RvcCc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG4gICAgICAgICovXHJcblxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgJ2RhdGFfZGVmJzogZnAoZnVuY3Rpb24oYSwgc2lnKSB7XHJcbiAgICAgICAgaWYgKHNpZyA9PSAnW29dJykge1xyXG4gICAgICAgICAgICAvLyBjcmVhdGUgdGhlIG5ldyBkYXRhX2RlZiBjb25zdHJhaW50LlxyXG5cclxuXHJcbiAgICAgICAgfVxyXG4gICAgfSksXHJcblxyXG4gICAgJ2tleXMnOiBmdW5jdGlvbigpIHtcclxuICAgICAgICBpZiAoT2JqZWN0LmtleXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuXyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIHJlcyA9IFtdO1xyXG4gICAgICAgICAgICBlYWNoKHRoaXMuXywgZnVuY3Rpb24oaSwgdikge1xyXG4gICAgICAgICAgICAgICAgcmVzLnB1c2goaSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgJ3N0cmluZ2lmeSc6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciByZXMgPSBbXTtcclxuICAgICAgICByZXMucHVzaCgnRGF0YV9PYmplY3QoJyArIHN0cmluZ2lmeSh0aGlzLl8pICsgJyknKTtcclxuICAgICAgICByZXR1cm4gcmVzLmpvaW4oJycpO1xyXG4gICAgfSxcclxuXHJcbiAgICAndG9PYmplY3QnOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAvLyBuZWVkIHRvIGdvIHRocm91Z2ggZWFjaCBvZiB0aGVtLi4uXHJcbiAgICAgICAgdmFyIHJlcyA9IHt9O1xyXG5cclxuICAgICAgICAvL2NvbnNvbGUubG9nKCd0aGlzLl8gJyArIHN0cmluZ2lmeSh0aGlzLl8pKTtcclxuXHJcbiAgICAgICAgZWFjaCh0aGlzLl8sIGZ1bmN0aW9uKGksIHYpIHtcclxuICAgICAgICAgICAgaWYgKHYudG9PYmplY3QpIHtcclxuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3RvZiB2ICcgKyB0b2YodikpO1xyXG4gICAgICAgICAgICAgICAgcmVzW2ldID0gdi50b09iamVjdCgpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmVzW2ldID0gdjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcblxyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICAgICAgLy9yZXR1cm4gdGhpcy5fO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyB1c2luZ19maWVsZHNfY29ubmVjdGlvbigpXHJcbiAgICAvLyAgd2lsbCBzZWFyY2ggdXAgdGhlIG9iamVjdCBoZWlyYWNoeSwgdG8gc2VlIGlmIHRoZSBEYXRhX09iamVjdHMgZmllbGRzIG5lZWQgdG8gYmUgY29ubmVjdGVkIHRocm91Z2ggdGhlIHVzZSBvZiBmdW5jdGlvbnMuXHJcbiAgICAvLyAgdGhhdCB3aWxsIG1ha2UgdGhlIGZpZWxkcyBlYXN5IHRvIGNoYW5nZSBieSBjYWxsaW5nIGEgZnVuY3Rpb24uIFNob3VsZCBtYWtlIHRoaW5ncyBtdWNoIGZhc3RlciB0byBhY2Nlc3MgdGhhbiB3aGVuIHByb2dyYW1taW5nIHdpdGggQmFja2JvbmUuXHJcbiAgICAvLyB0aGVuIHdpbGwgY29ubmVjdCB0aGUgZmllbGRzIHdpdGggY29ubmVjdF9maWVsZHMoKVxyXG5cclxuICAgICd1c2luZ19maWVsZHNfY29ubmVjdGlvbic6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciByZXMgPSBmYWxzZTtcclxuICAgICAgICBpdGVyYXRlX2FuY2VzdG9yX2NsYXNzZXModGhpcy5jb25zdHJ1Y3RvciwgZnVuY3Rpb24oYV9jbGFzcywgc3RvcCkge1xyXG4gICAgICAgICAgICBpZiAoaXNfZGVmaW5lZChhX2NsYXNzLl9jb25uZWN0X2ZpZWxkcykpIHtcclxuICAgICAgICAgICAgICAgIHJlcyA9IGFfY2xhc3MuX2Nvbm5lY3RfZmllbGRzO1xyXG4gICAgICAgICAgICAgICAgc3RvcCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgICAgICByZXR1cm4gcmVzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgJ2Nvbm5lY3RfZmllbGRzJzogZnAoZnVuY3Rpb24oYSwgc2lnKSB7XHJcbiAgICAgICAgLy9jb25zb2xlLmxvZygnJyk7XHJcbiAgICAgICAgLy9jb25zb2xlLmxvZygnY29ubmVjdF9maWVsZHMgc2lnJyArIHNpZyk7XHJcbiAgICAgICAgLy9jb25zb2xlLmxvZygnYSAnICsgc3RyaW5naWZ5KGEpKTtcclxuXHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgIC8vdGhyb3cgJzgpIHN0b3AnO1xyXG5cclxuICAgICAgICBpZiAoYS5sID09IDEgJiYgdG9mKGFbMF0pID09ICdhcnJheScpIHtcclxuICAgICAgICAgICAgdmFyIGFycl9maWVsZHMgPSBhWzBdO1xyXG4gICAgICAgICAgICBlYWNoKGFbMF0sIGZ1bmN0aW9uKGksIHYpIHtcclxuICAgICAgICAgICAgICAgIHRoYXQuY29ubmVjdF9maWVsZHModik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHNpZyA9PSAnW3NdJykge1xyXG4gICAgICAgICAgICAvLyBjb25uZWN0IHRoYXQgZmllbGQgYnkgbmFtZVxyXG4gICAgICAgICAgICAvLyBjcmVhdGUgdGhlIGZ1bmN0aW9uXHJcblxyXG4gICAgICAgICAgICAvLyBjb25uZWN0IGEgc2luZ3VsYXIgZmllbGQuXHJcblxyXG4gICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICB0aGlzW2FbMF1dID0gZnAoZnVuY3Rpb24oYTIsIHNpZykge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3NpZyAnICsgc2lnKTtcclxuICAgICAgICAgICAgICAgIGlmIChhMi5sID09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhhdC5zZXQoYVswXSwgYTJbMF0pO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChhMi5sID09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhhdC5nZXQoYVswXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAqL1xyXG5cclxuICAgICAgICAgICAgdGhpc1thWzBdXSA9IGZ1bmN0aW9uKGExKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBhMSA9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIDAgcGFyYW1zXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoYXQuZ2V0KGFbMF0pO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyAxIHBhcmFtXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGF0LnNldChhWzBdLCBhMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnc2lnICcgKyBzaWcpO1xyXG4gICAgICAgICAgICAgICAgLy9pZiAoYTIubCA9PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAvL1x0cmV0dXJuIHRoYXQuc2V0KGFbMF0sIGEyWzBdKTtcclxuICAgICAgICAgICAgICAgIC8vfSBlbHNlIGlmIChhMi5sID09IDApIHtcclxuICAgICAgICAgICAgICAgIC8vXHRyZXR1cm4gdGhhdC5nZXQoYVswXSk7XHJcbiAgICAgICAgICAgICAgICAvL31cclxuICAgICAgICAgICAgfTtcclxuXHJcblxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChzaWcgPT0gJ1tvXScpIHtcclxuXHJcbiAgICAgICAgICAgIHRocm93KCcxNikgc3RvcCcpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9KSxcclxuXHJcbiAgICAvLyBkb2VzIHRoaXMgZ2V0IG92ZXJ3cml0dGVuP1xyXG5cclxuICAgIC8vIFZhcmlvdXMgaXRlbXMgbmVlZCB0byBoYXZlIHRoZWlyIHBhcmVudHMgc2V0IHByb3Blcmx5IHdoZW4gc3RhcnRpbmcuXHJcblxyXG4gICAgLy8gZnAgd29ya2luZz9cclxuXHJcbiAgICAvLyBEdWNrIHR5cGUgY29sbGVjdGlvbiBkZXRlY3QgLS0gX190eXBlID09ICdjb2xsZWN0aW9uJ1xyXG5cclxuICAgIC8vIERvbid0IGhhdmUgdGhlIGFycmF5IG9mIHBhcmVudHMuXHJcblxyXG4gICAgLy8gT25lIHBhcmVudCBhbmQgb25lIGluZGV4IGZvciB0aGUgbW9tZW50LiBUaGF0J3Mgd2hhdCBET00gbm9kZXMgbmVlZC5cclxuXHJcbiAgICAvLydwYXJlbnQnOiBmcChmdW5jdGlvbihhLCBzaWcpIHtcclxuICAgICdwYXJlbnQnOiBmdW5jdGlvbigpIHtcclxuXHQgICAgICB2YXIgYSA9IGFyZ3VtZW50cztcclxuXHQgICAgICBhLmwgPSBhcmd1bWVudHMubGVuZ3RoO1xyXG5cdCAgICAgIHZhciBzaWcgPSBnZXRfYV9zaWcoYXJndW1lbnRzLCAxKTtcclxuICAgICAgICB2YXIgb2JqLCBpbmRleDtcclxuICAgICAgICAvL2NvbnNvbGUubG9nKCdwYXJlbnQgc2lnJywgc2lnKTtcclxuXHJcblx0XHRcdFx0Ly8gQW5kIF9wYXJlbnQgc2hvdWxkIGJlIHNldCBhdXRvbWF0aWNhbGx5IHdoZW4gdGhlIGNvbnRyb2xzIGFyZSBwdXQgaW4gcGxhY2UuXHJcblxyXG4gICAgICAgIGlmIChhLmwgPT0gMCkge1xyXG5cdFx0XHRcdFx0Ly9jb25zb2xlLmxvZygndGhpcy5fcGFyZW50JywgdGhpcy5fcGFyZW50KTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGEubCA9PSAxKSB7XHJcbiAgICAgICAgICAgIG9iaiA9IGFbMF07XHJcblxyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2NvbnRleHQgJiYgb2JqLl9jb250ZXh0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jb250ZXh0ID0gb2JqLl9jb250ZXh0O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBJRHMgd2lsbCBvbmx5IHdvcmsgd2l0aGluIHRoZSBjb250ZXh0LlxyXG5cclxuXHJcblxyXG4gICAgICAgICAgICAvLyBBbm90aGVyIHdheSBvZiBleHByZXNzaW5nIHRoaXM/XHJcblxyXG4gICAgICAgICAgICAvLyBDYW4gaGF2ZSBhIHNpbmdsZSBwYXJlbnQsIG9yIG11bHRpcGxlIHBhcmVudHMuXHJcbiAgICAgICAgICAgIC8vICBNYXkgd2FudCBzb21ldGhpbmcgdG8gYmUgdGhlIG9ubHkgcGFyZW50LiBDb3VsZCBoYXZlIGEgZGlmZmVyZW50IG1vZGUgZm9yIG11bHRpcGxlIHBhcmVudHMuXHJcblxyXG4gICAgICAgICAgICAvLyAgdGhpcy5fcGFyZW50ID0gb2JqP1xyXG5cclxuXHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3BhcmVudCBvYmpfaWQgJyArIG9ial9pZCk7XHJcbiAgICAgICAgICAgIC8vdGhyb3cgJ3N0b3AnXHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ29iaiAnICsgc3RyaW5naWZ5KG9iaikpO1xyXG4gICAgICAgICAgICAvLyBzaG91bGQgbWF5YmUgcmVuYW1lIG9yIHN1YmRpdmlkZSBfcmVsYXRpb25zaGlwcy5cclxuICAgICAgICAgICAgLy8gIGl0IHdpbGwgYWxzbyBiZSB1c2VmdWwgZm9yIGRhdGFiYXNlcy5cclxuICAgICAgICAgICAgLy8gIGhvd2V2ZXIsIHdvdWxkIG5lZWQgdG8gd29yayB3aXRoIHRoZSBjb25zdHJhaW50IHN5c3RlbS5cclxuICAgICAgICAgICAgLy8gICBsaWtlbHkgdGhhdCB0aGV5IHdvdWxkIGJlIHN5bmNyb25pc2VkIHRocm91Z2ggY29kZS5cclxuXHJcbiAgICAgICAgICAgIHZhciByZWxhdGVfYnlfaWQgPSBmdW5jdGlvbih0aGF0KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgb2JqX2lkID0gb2JqLl9pZCgpO1xyXG4gICAgICAgICAgICAgICAgdGhhdC5fcmVsYXRpb25zaGlwc1tvYmpfaWRdID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHJlbGF0ZV9ieV9yZWYgPSBmdW5jdGlvbih0aGF0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGF0Ll9wYXJlbnQgPSBvYmo7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVsYXRlX2J5X3JlZih0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGEubCA9PSAyKSB7XHJcbiAgICAgICAgICAgIG9iaiA9IGFbMF07XHJcbiAgICAgICAgICAgIGluZGV4ID0gYVsxXTtcclxuXHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fY29udGV4dCAmJiBvYmouX2NvbnRleHQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRleHQgPSBvYmouX2NvbnRleHQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMuX3BhcmVudCA9IG9iajtcclxuICAgICAgICAgICAgdGhpcy5faW5kZXggPSBpbmRleDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChpc19kZWZpbmVkKGluZGV4KSkge1xyXG4gICAgICAgICAgICAvLyBJIHRoaW5rIHdlIGp1c3Qgc2V0IHRoZSBfX2luZGV4IHByb3BlcnR5LlxyXG4gICAgICAgICAgICAvLyAgSSB0aGluayBhIF9fcGFyZW50IHByb3BlcnR5IGFuZCBhIF9faW5kZXggcHJvcGVydHkgd291bGQgZG8gdGhlIGpvYiBoZXJlLlxyXG4gICAgICAgICAgICAvLyAgU3VpdHMgRE9NIGhlaXJhY2h5LlxyXG4gICAgICAgICAgICAvLyBBIF9fcmVsYXRpb25zaGlwcyBwcm9wZXJ0eSBjb3VsZCBtYWtlIHNlbnNlIGZvciB3aWRlciB0aGluZ3MsIGhvd2V2ZXIsIGl0IHdvdWxkIGJlIGVhc3kgKGZvciB0aGUgbW9tZW50PylcclxuICAgICAgICAgICAgLy8gdG8ganVzdCBoYXZlIC5fX3BhcmVudCBhbmQgLl9faW5kZXhcclxuICAgICAgICAgICAgLy9cclxuXHJcblxyXG4gICAgICAgICAgICAvLyBOb3Qgc3VyZSBhbGwgRGF0YV9PYmplY3RzIHdpbGwgbmVlZCBjb250ZXh0cy5cclxuICAgICAgICAgICAgLy8gIEl0J3MgbWFpbmx5IHVzZWZ1bCBmb3IgQ29udHJvbHMgc28gZmFyXHJcblxyXG5cclxuXHJcblxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIGdldCB0aGUgb2JqZWN0J3MgaWQuLi5cclxuXHJcbiAgICAgICAgICAgIC8vIHNldHRpbmcgdGhlIHBhcmVudC4uLiB0aGUgcGFyZW50IG1heSBoYXZlIGEgY29udGV4dC5cclxuXHJcblxyXG5cclxuXHJcblxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLypcclxuICAgICdwYXJlbnQnOiBmdW5jdGlvbihhMSwgYTIpIHtcclxuICAgICAgICB2YXIgdGExID0gdHlwZW9mIGExLCB0YTIgPSB0eXBlb2YgYTIsIHRyaSwgaW5mbztcclxuICAgICAgICBpZiAodGExID09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIC8vIDAgcGFyYW1zXHJcblxyXG4gICAgICAgICAgICAvLyBjb3VsZCBjYWxsIHRoZSBzaW1wbGUgZ2V0IGZ1bmN0aW9uIGhlcmUsIGJ1dCBtYXliZSB3ZSBjYW4gaGF2ZSBpdCBpbmxpbmUgYW5kIGZhc3QuXHJcbiAgICAgICAgICAgIHZhciBhcnJfcGFyZW50cyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKGkgaW4gdGhpcy5fcmVsYXRpb25zaGlwcykge1xyXG4gICAgICAgICAgICAgICAgaW5mbyA9IHRoaXMuX3JlbGF0aW9uc2hpcHNbaV07XHJcbiAgICAgICAgICAgICAgICB0cmkgPSB0eXBlb2YgaW5mbztcclxuICAgICAgICAgICAgICAgIGlmICh0cmkgPT0gJ251bWJlcicpIHtcclxuXHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRyaS5fX3R5cGUgPT09ICdjb2xsZWN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGFycl9wYXJlbnRzLnB1c2goaW5mbyk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRyaS5fX3R5cGUgPT09ICdkYXRhX29iamVjdCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBhcnJfcGFyZW50cy5wdXNoKGluZm8pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChhcnJfcGFyZW50cy5sZW5ndGggPT0gMSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFycl9wYXJlbnRzWzBdO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGFycl9wYXJlbnRzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhcnJfcGFyZW50cztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9IGVsc2UgaWYgKHRhMiA9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAvLyAxIHBhcmFtXHJcbiAgICAgICAgICAgIGlmIChhMS5fX3R5cGUgPT0gJ2RhdGFfb2JqZWN0Jykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGExLl9jb250ZXh0KSB0aGlzLl9jb250ZXh0ID0gYTEuX2NvbnRleHQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gMiBwYXJhbXNcclxuICAgICAgICAgICAgaWYgKGExLl9fdHlwZSA9PSAnZGF0YV9vYmplY3QnICYmIHR5cGVvZiBhMiA9PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudCA9IGExO1xyXG4gICAgICAgICAgICAgICAgdmFyIHBfaWQgPSBwYXJlbnQuX2lkKCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgcG9zaXRpb25faW5fYXJyYXkgPSBhMjtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50Ll9jb250ZXh0KSB0aGlzLl9jb250ZXh0ID0gcGFyZW50Ll9jb250ZXh0O1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIGl0J3MgdGhlIGNoaWxkIHNheWluZyBpdCdzIGdvdCB0aGUgYXR0cmlidXRpb24gdG8gdGhlIHBhcmVudCBoZXJlXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gY2hpbGQga25vd3Mgd2hhdCBwb2lzaXRpb24gaXQgaXMgd2l0aGluIHBhcmVudC5cclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJlbnRzID0gdGhpcy5fcGFyZW50cyB8fCB7fTtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJlbnRzW3BfaWRdID0gW3BhcmVudCwgcG9zaXRpb25faW5fYXJyYXldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgICovXHJcblxyXG4gICAgJ19mcF9wYXJlbnQnOiBmcChmdW5jdGlvbihhLCBzaWcpIHtcclxuXHJcbiAgICAgICAgLy8gTWF5YmUgZGV0ZWN0IGlmIGl0J3MgYSBEYXRhX09iamVjdCBvciBDb250cm9sIHJlbGF0aXZlbHkgcXVpY2tseSBoZXJlLlxyXG4gICAgICAgIC8vICBUaGVuIHBlcmhhcHMgY2FsbCAuX3BhcmVudF9EYXRhX09iamVjdFxyXG4gICAgICAgIC8vICAgdGhlcmUgd291bGQgbGlrZWx5IGJlIHNvbWUgbW9yZSBvcHRpbWl6ZWQgZnVuY3Rpb25zLlxyXG5cclxuICAgICAgICAvLyAuX3BhcmVudF9nZXRcclxuXHJcblxyXG5cclxuICAgICAgICAvL2NvbnNvbGUubG9nKCdwYXJlbnQgc2lnICcgKyBzaWcpO1xyXG4gICAgICAgIC8vdGhyb3cgJ3N0b3AnO1xyXG4gICAgICAgIGlmIChhLmwgPT0gMCkge1xyXG4gICAgICAgICAgICAvLyB0aGVyZSBjb3VsZCBiZSBqdXN0IGEgc2luZ2xlIHBhcmVudC4uLlxyXG4gICAgICAgICAgICAvLyAgaWYgdGhlcmUgaXMgbW9yZSB0aGV5IHdpbGwgYmUgcmV0dXJuZWQgYXMgYW4gYXJyYXkuXHJcblxyXG4gICAgICAgICAgICB2YXIgYXJyX3BhcmVudHMgPSBbXTtcclxuXHJcbiAgICAgICAgICAgIC8vIGxvb2sgYXQgdGhlIF9yZWxhdGlvbnNoaXBzLlxyXG5cclxuICAgICAgICAgICAgLy8gX3JlbGF0aW9uc2hpcHMgd2lsbCBiZSB1c2VkIGluc3RlYWQgb2YgLnBhcmVudCBvciAuX3BhcmVudFxyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCd0aGlzLl9yZWxhdGlvbnNoaXBzICcgKyBzdHJpbmdpZnkodGhpcy5fcmVsYXRpb25zaGlwcykpO1xyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCd0aGlzLl9wYXJlbnRzICcgKyBzdHJpbmdpZnkodGhpcy5fcGFyZW50cykpO1xyXG5cclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygndGhpcyAnICsgc3RyaW5naWZ5KHRoaXMpKTtcclxuXHJcbiAgICAgICAgICAgIC8vdmFyIHN0YWNrID0gbmV3IEVycm9yKCkuc3RhY2tcclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhzdGFjayk7XHJcbiAgICAgICAgICAgIC8vdGhyb3cgJ3N0b3AnO1xyXG5cclxuICAgICAgICAgICAgLy8gYW5kIGVhY2ggcmVsYXRpb25zaGlwIHJlY29yZCBtYXkgaW5kaWNhdGUgYSBwYXJlbnRcclxuICAgICAgICAgICAgLy8gIGRvZXMgc28gd2l0aCBhbiBpbnRlZ2VyLCB3aGljaCBpcyB0aGUgaW5kZXggd2l0aGluIHRoYXQgcGFyZW50LlxyXG4gICAgICAgICAgICAvLyAgIHdpbGwgbWFrZSBmb3IgbW9yZSBlZmZpY2llbnQgYWxnb3JpdGhtcyB0aGFuIGpRdWVyeSdzIC5pbmRleCgpLlxyXG4gICAgICAgICAgICB2YXIgdHJpO1xyXG4gICAgICAgICAgICBlYWNoKHRoaXMuX3JlbGF0aW9uc2hpcHMsIGZ1bmN0aW9uKHJlbGF0aXZlX2lkLCByZWxhdGlvbnNoaXBfaW5mbykge1xyXG4gICAgICAgICAgICAgICAgdHJpID0gdG9mKHJlbGF0aW9uc2hpcF9pbmZvKTtcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygncmVsYXRpdmVfaWQgJyArIHJlbGF0aXZlX2lkKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAodHJpID09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVsYXRpb25zaGlwcyB3aWxsIGJlIGNoYW5nZWQgYW5kIHRlc3RlZC5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaXQgaW5kaWNhdGVzIGEgcGFyZW50LlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHBlcmhhcHMgd2Ugc2hvdWxkIGFsc28gcmV0dXJuIHRoZSBwb3NpdGlvbiB3aXRoaW4gdGhlIHBhcmVudD9cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBuZWVkcyBjaGFuZ2luZyAvIGZpeGluZy5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgJ1JlbGF0aW9uc2hpcHMgc3lzdGVtIG5lZWRzIG1vcmUgd29yayBoZXJlLiBIYWQgYmVlbiB1c2luZyB0aGUgbWFwIG9mIGFsbCBtYW55IG9iamVjdHMsIHdoaWNoIGhhcyBiZWVuIHJlbW92ZWQgZm9yIHdlYiBzZXJ2ZXIgcGVyZm9ybWFuY2UgcmVhc29ucy4nO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpZF9tYXAgPSBtYXBfanNndWlfaWRzO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fY29udGV4dCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZF9tYXAgPSB0aGlzLl9jb250ZXh0Lm1hcF9vYmplY3RzO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgYXJyX3BhcmVudHMucHVzaChpZF9tYXBbcmVsYXRpdmVfaWRdKTtcclxuICAgICAgICAgICAgICAgICAgICAqL1xyXG5cclxuXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3RyaSAnICsgdHJpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyaSA9PSAnZGF0YV9vYmplY3QnIHx8IHRyaSA9PSAnY29sbGVjdGlvbicpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXJyX3BhcmVudHMucHVzaChyZWxhdGlvbnNoaXBfaW5mbyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3JlbGF0aXZlX2lkICcgKyByZWxhdGl2ZV9pZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnbWFwX2pzZ3VpX2lkc1tyZWxhdGl2ZV9pZF0gJyArIG1hcF9qc2d1aV9pZHNbcmVsYXRpdmVfaWRdKTtcclxuICAgICAgICAgICAgICAgICAgICAvL3Rocm93ICdzdG9wJztcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgLypcclxuXHJcblxyXG4gICAgICAgICAgICBlYWNoKHRoaXMuX3BhcmVudHMsIGZ1bmN0aW9uKGksIHYpIHtcclxuICAgICAgICAgICAgICAgIGFycl9wYXJlbnRzLnB1c2godik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBpZiAoYXJyX3BhcmVudHMubGVuZ3RoID09IDEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhcnJfcGFyZW50c1swXTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChhcnJfcGFyZW50cy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJyX3BhcmVudHM7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy9pZiAoc2lnID09ICcnKVxyXG4gICAgICAgICAgICAvL3Rocm93ICcyKSBzdG9wJztcclxuICAgICAgICAgICAgLy8gb3RoZXJ3aXNlLCBtYXkgaGF2ZSBiZWVuIGdpdmVuIGEgcGFyZW50IGNvbnRyb2wuXHJcbiAgICAgICAgICAgIC8vICBNYXkgbWFrZSBhIHRlc3Qgc3VpdGUgdG8gdGVzdCB0eXBlcyBhbmQgc2lnbmF0dXJlcy5cclxuXHJcbiAgICAgICAgICAgIC8vIHRoZSBwYXJlbnQgc2hvdWxkIGJlIGEgRGF0YV9PYmplY3QgKHdoaWNoIGluY2x1ZGVzIENvbnRyb2wpLCBhcyB3ZWxsIGFzIG90aGVyIHRoaW5ncy5cclxuICAgICAgICAgICAgLy8gIEkgdGhpbmsgdGhhdCB0aGVyZSB3aWxsIGJlIGEgbG90IG9mIHBvd2VyIGFuZCBmbGV4aWJpbGl0eSBpbiBjb250cm9scyB3aGVuIHRoZXkgZ2V0IHVzZWQgYWdhaW4gdXNpbmcgdGhlIERhdGFfT2JqZWN0IHVuZGVycGlubmluZ3MuXHJcbiAgICAgICAgICAgIC8vIEl0IHdpbGwgYWxzbyBiZSBwb3NzaWJsZSB0byBtYWtlIG11Y2ggbW9yZSBjb25kZW5zZWQgdmVyc2lvbnMgb2YgdGhlIGZyYW1ld29yay5cclxuICAgICAgICAgICAgLy9cclxuXHJcbiAgICAgICAgICAgIC8vIFBhcmVudHMgbmVlZHMgYSBzaWduaWZpY2FudCBhbW91bnQgbW9yZSB3b3JrLi4uXHJcbiAgICAgICAgICAgIC8vICBCdXQgbmVlZHMgdG8gc3RvcmUgdGhlIHBvc2l0aW9ucyB3aXRoaW4gcGFyZW50cy5cclxuXHJcbiAgICAgICAgICAgIC8vIHNldCB0aGUgcGFyZW50IC0gYnV0IG1heSBhbHNvIG5lZWQgdG8ga25vdyB0aGUgcG9zaXRpb24gb2YgdGhlIGNoaWxkLlxyXG5cclxuICAgICAgICAgICAgaWYgKHNpZyA9PSAnW0RdJykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudCA9IGFbMF07XHJcblxyXG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnW0RdIHBhcmVudCBpbyBEYXRhX09iamVjdCAnICsgKHBhcmVudCBpbnN0YW5jZW9mIERhdGFfT2JqZWN0KSk7XHJcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdbRF0gcGFyZW50IGlvIENvbGxlY3Rpb24gJyArIChwYXJlbnQgaW5zdGFuY2VvZiBDb2xsZWN0aW9uKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudC5fY29udGV4dCkgdGhpcy5fY29udGV4dCA9IHBhcmVudC5fY29udGV4dDtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBtYXliZSBiZXR0ZXIgdG8ganVzdCB1c2UgLl9wYXJlbnQuXHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHVzZV9wYXJlbnRfaWQgPSBmdW5jdGlvbigpIHtcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwX2lkID0gcGFyZW50Ll9pZCgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGNvdWxkIHJldHVybiB0aGUgcG9zaXRpb24gd2l0aGluIHRoYXQgcGFyZW50P1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBJdCBtYXkgbm90IGhhdmUgaXRzIHBvc2l0aW9uIHNldCAtIGJlY2F1c2UgaWYgdGhlIHBhcmVudCBpcyBhIERhdGFfT2JqZWN0LCB0aGVuIGl0IGRvZXMgbm90IGhhdmUgcG9zaXRpb25zIGFzIHN1Y2guXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRwID0gdG9mKHBhcmVudCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0cCA9PSAnZGF0YV9vYmplY3QnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vdGhpcy5fcGFyZW50cyA9IHRoaXMuX3BhcmVudHMgfHwge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJ1dCBpdCdzIHBvc2l0aW9uIG1heSBlZmZlY3RpdmVseSBiZSB0aGUgZmllbGQgbmFtZS4uLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgbWF5IGJlIHdvcnRoIGhhdmluZyB0aGF0LlxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vdGhpcy5fcGFyZW50c1twX2lkXSA9IHBhcmVudDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlbGF0aW9uc2hpcHMgPSB0aGlzLl9yZWxhdGlvbnNoaXBzIHx8IHt9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVsYXRpb25zaGlwc1twX2lkXSA9IHBhcmVudDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAodHAgPT0gJ2NvbGxlY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93ICdSZXF1aXJlZDogcG9zaXRpb24gaW4gYXJyYXkgb2YgaXRlbSc7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBhbiBhcnJheSBvZiBwYXJlbnRzP1xyXG4gICAgICAgICAgICAgICAgLy8gIG9yIGp1c3Qgc2V0IHRoZSBwYXJlbnQ/IE11bHRpcGxlIHBhcmVudHMgd291bGQgaGVscCAoaW4gdGhlb3J5KS5cclxuICAgICAgICAgICAgICAgIHZhciB1c2VfcGFyZW50X3JlZiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHdpbGwgd29yayBvbiBwYXJlbnQgbGF0ZXIgb24uXHJcblxyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG5cclxuXHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBjb3VsZCBiZSBhIGNvbGxlY3Rpb24gYW5kIGEgbnVtYmVyLi4uXHJcblxyXG4gICAgICAgICAgICBpZiAoc2lnID09ICdbRCxuXScpIHtcclxuICAgICAgICAgICAgICAgIHZhciBwYXJlbnQgPSBhWzBdO1xyXG4gICAgICAgICAgICAgICAgdmFyIHBfaWQgPSBwYXJlbnQuX2lkKCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgcG9zaXRpb25faW5fYXJyYXkgPSBhWzFdO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChwYXJlbnQuX2NvbnRleHQpIHRoaXMuX2NvbnRleHQgPSBwYXJlbnQuX2NvbnRleHQ7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gaXQncyB0aGUgY2hpbGQgc2F5aW5nIGl0J3MgZ290IHRoZSBhdHRyaWJ1dGlvbiB0byB0aGUgcGFyZW50IGhlcmVcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBjaGlsZCBrbm93cyB3aGF0IHBvaXNpdGlvbiBpdCBpcyB3aXRoaW4gcGFyZW50LlxyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuX3BhcmVudHMgPSB0aGlzLl9wYXJlbnRzIHx8IHt9O1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuX3BhcmVudHNbcF9pZF0gPSBbcGFyZW50LCBwb3NpdGlvbl9pbl9hcnJheV07XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gcGFyZW50IGtlZXBzIGEgbGlzdCBvZiBhbGwgY2hpbGRyZW4/XHJcbiAgICAgICAgICAgICAgICAvLyBwYXJlbnQgY2FuIGhhdmUgY2hpbGRyZW4gaW4gZGlmZmVyZW50IHBsYWNlcywgaW4gZGlmZmVyZW50IG90aGVyIGNvbGxlY3Rpb25zLlxyXG5cclxuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3Bvc2l0aW9uX2luX2FycmF5ICcgKyBwb3NpdGlvbl9pbl9hcnJheSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9wYXJlbnQuY2hpbGRyZW4uXHJcblxyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLypcclxuXHJcbiAgICAgICAgICAgIGlmIChhLmwgPT0gMSkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3NpZyAnICsgc2lnKTtcclxuICAgICAgICAgICAgICAgIC8vdGhyb3cgJ3N0b3AnO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIHRoZSBzaWduYXR1cmUgY291bGQgYmUgRCwgYSBEYXRhX09iamVjdC5cclxuXHJcblxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygncF9pZCAnICsgcF9pZCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gcGFyZW50cyBkaWN0IG9mIG9iamVjdHMuLi4gbm90IHN1cmUgYWJvdXQgdXNpbmcgYW4gYWN0dWFsIGNvbGxlY3Rpb24gaGVyZS5cclxuICAgICAgICAgICAgICAgIC8vICBjb3VsZCBnZXQgdG9vIGNvbXBsaWNhdGVkIHVubmVjZXNzYXJpbHkuXHJcbiAgICAgICAgICAgICAgICAvLyBDb3VsZCB0cnkgaXQgbGF0ZXIgd2hlbiBkYXRhIHN0cnVjdHVyZXMgYXJlIG1vcmUgZmluaXNoZWQuXHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5fcGFyZW50cyA9IHRoaXMuX3BhcmVudHMgfHwge307XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5fcGFyZW50c1twX2lkXSA9IHBhcmVudDtcclxuXHJcblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICovXHJcblxyXG4gICAgICAgIH1cclxuICAgIH0pLFxyXG5cclxuICAgICdfaWQnOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAvLyBnZXRzIHRoZSBpZC5cclxuICAgICAgICAvL2NvbnNvbGUubG9nKCdEYXRhX09iamVjdCBfaWQgdGhpcy5fY29udGV4dCAnICsgdGhpcy5fY29udGV4dCk7XHJcblxyXG4gICAgICAgIC8vIFNob3VsZCBnZXQgdGhlIGNvbnRleHQgYXQgYW4gZWFybHkgc3RhZ2UgaWYgcG9zc2libGUuXHJcbiAgICAgICAgLy8gIE5lZWQgdG8gaGF2ZSBpdCBhcyB0aGUgaXRlbSBpcyBhZGRlZCwgSSB0aGluay5cclxuICAgICAgICBpZiAodGhpcy5fX2lkKSByZXR1cm4gdGhpcy5fX2lkO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5fY29udGV4dCkge1xyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCd0aGlzLl9fdHlwZSAnICsgdGhpcy5fX3R5cGUpO1xyXG5cclxuICAgICAgICAgICAgLy8gX190eXBlIHdpbGwgYmUgY29udHJvbD9cclxuICAgICAgICAgICAgLy8gX19kYXRhX3R5cGUgYXMgY29udHJvbC5cclxuICAgICAgICAgICAgLy8gIHRoYXQncyB0aGUgb3ZlcnJpZGluZyB0eXBlLCB0aGVyZSBhcmUgYSBmZXcgb2YgdGhlbVxyXG4gICAgICAgICAgICAvLyBfX3R5cGUgY291bGQgYmUgdGhlIG1vcmUgc3BlY2lmaWMgdHlwZSBzdWNoIGFzIHJhZGlvX2J1dHRvbi5cclxuXHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3RoaXMuX2NvbnRleHQubmV3X2lkICcgKyB0aGlzLl9jb250ZXh0Lm5ld19pZCk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLl9faWQgPSB0aGlzLl9jb250ZXh0Lm5ld19pZCh0aGlzLl9fdHlwZV9uYW1lIHx8IHRoaXMuX190eXBlKTtcclxuXHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ19faWQgJyArIHRoaXMuX19pZCk7XHJcbiAgICAgICAgICAgIC8vdGhyb3cgJyFzdG9wJztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fYWJzdHJhY3QpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIWlzX2RlZmluZWQodGhpcy5fX2lkKSkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFdoYXQgZG9lcyBub3QgaGF2ZSB0aGUgYWJzdHJhY3Q/XHJcblxyXG4gICAgICAgICAgICAgICAgLy92YXIgc3RhY2sgPSBuZXcgRXJyb3IoKS5zdGFjaztcclxuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coc3RhY2spO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIG5vIHN1Y2ggZnVuY3Rpb24uLi4gYnV0IHRoZXJlIHNob3VsZCBiZSBzb21ldGhpbmcgZGVjbGFyZWQgaW4gbWFueSBzaXR1YXRpb25zLlxyXG5cclxuICAgICAgICAgICAgICAgIHRocm93ICdzdG9wLCBjdXJyZW50bHkgdW5zdXBwb3J0ZWQuJztcclxuICAgICAgICAgICAgICAgIHRoaXMuX19pZCA9IG5ld19kYXRhX29iamVjdF9pZCgpO1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCchISEgbm8gY29udGV4dCBfX2lkICcgKyB0aGlzLl9faWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9faWQ7XHJcbiAgICB9LFxyXG5cclxuICAgICdmaWVsZHMnOiBmcChmdW5jdGlvbihhLCBzaWcpIHtcclxuXHJcbiAgICAgICAgLy8uZmllbGRzKCkgbWF5IGJlIGJldHRlciBzdWl0ZWQgdG8gZ2V0dGluZyBpbmZvIGFib3V0IHRoZSBmaWVsZHMsIHJhdGhlciB0aGFuIGFsbCBvZiB0aGUgZmllbGRzJyBpbmZvLlxyXG4gICAgICAgIC8vICBNYWtpbmcgdGhlIEFQSXMgcmV0dXJuIHJlbGF0aXZlbHkgc2ltcGxlIGRhdGEgaXMgYSBzdGVwIHRvIHRha2UuXHJcbiAgICAgICAgLy8gIEtlZXBpbmcgdGhlIGZ1bmN0aW9uYWxpdHkgYnV0IHNpbXBsaWZ5aW5nIHRoZSBBUElzLlxyXG4gICAgICAgIC8vICAgU29tZXRpbWVzIG1vcmUgY29tcGxpY2F0ZWQgQVBJIGNhbGxlcyB3aWxsIGJlIG1hZGUsIGJ1dCB0aGV5IHdpbGwgdGFrZSBtb3JlIHBhcmFtZXRlcnMgdGhhdCBzaG93cyB0aGUgY29kZXIgZXhwZWN0cyB0byBnZXRcclxuICAgICAgICAvLyAgIG1vcmUgY29tcGxpY2F0ZWQgcmVzdWx0cyBiYWNrLlxyXG5cclxuXHJcblxyXG5cclxuICAgICAgICAvLyBmaWVsZCBuYW1lc1xyXG4gICAgICAgIC8vIGZpZWxkIG5hbWVzIGFuZCB2YWx1ZXNcclxuICAgICAgICAvLyBmaWVsZCBuYW1lcyBhbmQgdHlwZXNcclxuICAgICAgICAvLyBmaWVsZCBuYW1lcywgdHlwZXMgYW5kIHZhbHVlc1xyXG5cclxuICAgICAgICAvLyBJIHRoaW5rIGZpZWxkIG5hbWVzIGFuZCB0eXBlcyBpcyBhIG5lYXQgYW1vdW50IG9mIGRhdGEgdGhhdCB3aWxsIGhlbHAgd2l0aCBkZWJ1Z2dpbmcuXHJcbiAgICAgICAgLy8gIENhbiBpdCByZXR1cm4gYW4gb2JqZWN0IHdoaWNoIGhhcyBhIC52YWx1ZXMoKSBmdW5jdGlvbj9cclxuXHJcbiAgICAgICAgLy8gIENoZWNrIGluIHRoZSBmaWVsZHMgY29sbGVjdGlvbiwgZm9yIHRoZSBmaWVsZHMnIG1ldGFkYXRhLCBvciBjb3VsZCBjaGVjayB0aGUgZmllbGRzIGRlZmluaXRpb24/XHJcbiAgICAgICAgLy8gIFdhbnQgdG8gYmUgYWJsZSB0byB0ZWxsIHdoYXQgQ29udHJvbCBGaWVsZHMgYSBDb250cm9sIGhhcywgZm9yIGV4YW1wbGUuXHJcbiAgICAgICAgLy8gSXQgd291bGQgYmUgZ29vZCB0byBoYXZlIHNpbXBseSBuYW1lZCBmdW5jdGlvbnMgcmV0dXJuIGRhdGEgdGhhdCdzIG5vdCBhbGwgdGhhdCBjb21wbGljYXRlZCBhbmQgY2FuIGJlIGRlYnVnZ2VkIGVhc2lseSwgd2hlcmUgcG9zc2libGUuXHJcblxyXG4gICAgICAgIC8vIENhbiBoYXZlIGEgZGlmZmVyZW50IG1lY2hhbmlzbSBmb3IgZ2V0dGluZyBhbGwgZmllbGRzJyB2YWx1ZXMuXHJcblxyXG4gICAgICAgIC8vIEFsc28sIGdldHRpbmcgdGhlIGZpZWxkIG9iamVjdHMgdGhlbXNlbHZlcywgdGhleSBoYXZlIGFzc29jaWF0ZWQgY29uc3RyYWludHMuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuICAgICAgICAvLyBhbiBlYXNpZXIgaW50ZXJmYWNlIHRvIHRoZSBmaWVsZHMgdGhhbiBmaWVsZHMgYW5kIGNvbnN0cmFpbnRzLlxyXG4gICAgICAgIC8vICB0aGlzIG1heSBiZSBpbW11dGFibGUgd2hlbiBpdCBpcyBoZWxkIGluIGEgY29sbGVjdGlvbiAtIG5vdCBzdXJlLlxyXG4gICAgICAgIC8vICBtYXkgbm90IHdhbnQgdG8ga2VlcCBjcmVhdGluZyBuZXcgY29waWVzIG9mIGZpZWxkIHNldHMgYW5kIGNvbnN0cmFpbnRzIGZvciB1c2UgaW4gaW5kaXZpZHVhbCBEYXRhX09iamVjdHMuXHJcblxyXG4gICAgICAgIC8vIFRoZSBpbmRpdmlkdWFsIERhdGFfT2JqZWN0cyB3aWxsIG5lZWQgdG8gaGF2ZSB0aGVpciBvd24gY29uc3RyYWludHMsIHRvIGJlZ2luIHdpdGguXHJcblxyXG4gICAgICAgIC8vIHdlIG1heSBoYXZlIGJlZW4gZ2l2ZW4gdGhlIGNoYWluZWQgZmllbGRzIGhlcmUuXHJcbiAgICAgICAgLy9cclxuXHJcblxyXG4gICAgICAgIC8vY29uc29sZS5sb2coJyoqKioqIGZpZWxkcyBzaWcgJyArIHNpZyk7XHJcblxyXG4gICAgICAgIC8vIFNob3VsZCBoYXZlIGhhZCBmaWVsZHMgc2V0IGFscmVhZHkuXHJcbiAgICAgICAgLy8gIFRoZSBEYXRhX09iamVjdCBjb25zdHJ1Y3RvciBzaG91bGQgZmluZCBvdXQgd2hhdCBmaWVsZHMgYXJlIHBhcnQgb2YgaXQuXHJcbiAgICAgICAgLy8gIE5vdCBzdXJlIGhvdyBlYXN5IHRoYXQgaXMgdG8gZG8gZnJvbSB0aGF0IGxldmVsLi4uIHRoZXJlIG5lZWRzIHRvIGJlIGEgd2F5LlxyXG5cclxuICAgICAgICAvL1xyXG5cclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcblxyXG4gICAgICAgIGlmIChhLmwgPT0gMCkge1xyXG5cclxuICAgICAgICAgICAgLy8gV2lsbCBiZSBrZWVwaW5nIHRyYWNrIG9mIHRoZSBmaWVsZHMgaW50ZXJuYWxseS5cclxuICAgICAgICAgICAgLy8gIFRoZXkgZ2V0IHN0b3JlZCBpbiBhbiBhcnJheSwgc28gdGhhdCB0aGUgb3JkZXIgZ2V0cyBtYWludGFpbmVkLlxyXG5cclxuICAgICAgICAgICAgLypcclxuXHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2ZpZWxkcyB0aGlzLl9tYXBfZmllbGRfY29uc3RyYWludHMgJyArIHN0cmluZ2lmeSh0aGlzLl9tYXBfZmllbGRfY29uc3RyYWludHMpKTtcclxuXHJcbiAgICAgICAgICAgIHZhciByZXMgPSBbXTtcclxuXHJcbiAgICAgICAgICAgIGVhY2godGhpcy5fbWFwX2ZpZWxkX2NvbnN0cmFpbnRzLCBmdW5jdGlvbihmaWVsZF9uYW1lLCB2KSB7XHJcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdmaWVsZF9uYW1lICcgKyBmaWVsZF9uYW1lKTtcclxuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3YgJyArIHN0cmluZ2lmeSh2KSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gdGhlbiBmb3IgZWFjaCBjb25zdHJhaW50LCBnZXQgYW4gaW5mbyBvYmplY3QgZnJvbSBpdC5cclxuICAgICAgICAgICAgICAgIC8vIHYudG9fb2JqX2luZm9cclxuICAgICAgICAgICAgICAgIC8vIHYudG9faW5mb19vYmpcclxuXHJcbiAgICAgICAgICAgICAgICBlYWNoKHYsIGZ1bmN0aW9uKGkyLCBjb25zdHJhaW50X2Zvcl9maWVsZCkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBNYXkgYWxzbyBiZSBzYXlpbmcgaXQncyBhIHByaW1hcnkga2V5IGZpZWxkXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gIE5lZWQgbW9yZSB3b3JrIG9uIHNldHRpbmcgZmllbGRzXHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoY29uc3RyYWludF9mb3JfZmllbGQgaW5zdGFuY2VvZiBDb25zdHJhaW50LkZpZWxkX0RhdGFfVHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmllbGRfY29uc3RyYWludF9pbmZvX29iaiA9IGNvbnN0cmFpbnRfZm9yX2ZpZWxkLnRvX2luZm9fb2JqKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2ZpZWxkX2NvbnN0cmFpbnRfaW5mb19vYmogJyArIHN0cmluZ2lmeShmaWVsZF9jb25zdHJhaW50X2luZm9fb2JqKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmaW5kIG91dCBpZiB0aGUgZmllbGQgaXMgcmVhZC1vbmx5LlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZsYWdzID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGF0Ll9tYXBfcmVhZF9vbmx5ICYmIHRoYXQuX21hcF9yZWFkX29ubHlbZmllbGRfbmFtZV0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsYWdzLnB1c2goJ3JlYWRfb25seScpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmbGFncy5sZW5ndGggPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2goW2ZpZWxkX25hbWUsIGZpZWxkX2NvbnN0cmFpbnRfaW5mb19vYmpdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcy5wdXNoKFtmaWVsZF9uYW1lLCBmaWVsZF9jb25zdHJhaW50X2luZm9fb2JqLCBmbGFnc10pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHJlcztcclxuICAgICAgICAgICAgKi9cclxuXHJcbiAgICAgICAgICAgIC8vIGFuIGluZGV4IG9mIHRoZSBwb3NpdGlvbiBvZiBhIGZpZWxkIHdpdGhpbiB0aGUgYXJyYXk/IFdvdWxkIHRoYXQgYmUgdXNlZnVsP1xyXG4gICAgICAgICAgICAvLyAgbWVhbnMgc29tZSBlbmNhcHN1bGF0aW9uIG1heSBiZSB3b3J0aHdoaWxlIGhlcmVcclxuXHJcbiAgICAgICAgICAgIC8vIGhhdmUgYSBsb29rIGF0IHRoZSBmYyAoZmllbGRzX2NvbGxlY3Rpb24pXHJcblxyXG4gICAgICAgICAgICB2YXIgZmllbGRzX2NvbGxlY3Rpb24gPSB0aGlzLmZjO1xyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdmaWVsZHNfY29sbGVjdGlvbiAnICsgZmllbGRzX2NvbGxlY3Rpb24pO1xyXG5cclxuICAgICAgICAgICAgLy8gbm90IGp1c3QgdGhlIGZpZWxkIHZhbHVlcy5cclxuICAgICAgICAgICAgdmFyIHJlcztcclxuXHJcblxyXG4gICAgICAgICAgICBpZiAoZmllbGRzX2NvbGxlY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgIHJlcyA9IGZpZWxkc19jb2xsZWN0aW9uLm9rdnMudmFsdWVzKCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXMgPSBbXTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHJlcztcclxuXHJcblxyXG4gICAgICAgICAgICAvL3JldHVybiB0aGlzLl9hcnJfZmllbGRzIHx8IFtdO1xyXG4gICAgICAgICAgICAvLyBjYW4gZ2V0IGEgcG9zaXRpb24gbWFwIHJlbGF0aXZlbHkgcXVpY2tseSBmcm9tIHRoZSBhcnJheSBvZiBmaWVsZHMuXHJcbiAgICAgICAgICAgIC8vICBjYW4gYmUgZG9uZSBhZnRlciBhbnkgYWRqdXN0bWVudCBvbiB0aGUgZmllbGRzIGlzIGRvbmUuXHJcbiAgICAgICAgICAgIC8vIHRoaXMuX2ZpZWxkX3Bvc2l0aW9uc19ieV9uYW1lXHJcbiAgICAgICAgICAgIC8vICBvciBhIGxpbmtlZCBsaXN0IG9mIGZpZWxkcz8gVGhhdCBjb3VsZCB3b3JrIGZvciBwcmVzZXJ2aW5nIG9yZGVyLCBpdGVyYXRpbmcsIGluc2VydGlvbiwgZGVsZXRpb24sXHJcblxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChzaWcgPT0gJ1tzXScpIHtcclxuICAgICAgICAgICAgLy8gZ2V0IGEgc2luZ2xlIGZpZWxkLlxyXG5cclxuICAgICAgICAgICAgLy8gZ2V0IHRoZSBmaWVsZCBmcm9tIHRoZSBmaWVsZF9jb2xsZWN0aW9uLlxyXG5cclxuICAgICAgICAgICAgdmFyIGZjID0gdGhpcy5mYztcclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnKiogZmMgJyArIGZjKTtcclxuICAgICAgICAgICAgdmFyIHJlcyA9IGZjLmdldChhWzBdKTtcclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygncmVzICcgKyBzdHJpbmdpZnkocmVzKSk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXM7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy92YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgaWYgKHNpZyA9PSAnW29dJykge1xyXG4gICAgICAgICAgICAvLyB3aGVuIGdpdmluZyBpdCB0aGUgY2hhaW5lZCBmaWVsZHMsIG5lZWQgdG8gcHJvY2VzcyB0aGVtIHJpZ2h0LlxyXG4gICAgICAgICAgICAvLyAgbWF5IGJlIGJlc3QgdG8gY2xvbmUgdGhlbS5cclxuXHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2FbMF0gJyArIHN0cmluZ2lmeShhWzBdKSk7XHJcblxyXG4gICAgICAgICAgICAvLyBiZXR0ZXIgdG8gZW5zdXJlIHRoZSBmaWVsZHMgaW4gb3JkZXIuLi5cclxuXHJcbiAgICAgICAgICAgIC8vICBjYW4gc2V0IGVhY2ggZmllbGQgaW5kaXZpZHVhbGx5LlxyXG5cclxuICAgICAgICAgICAgLy8gU2V0dGluZyBhIGZpZWxkIHdpdGggYSB2YWx1ZS4uLlxyXG4gICAgICAgICAgICAvLyAgVGhlIGZpZWxkIHR5cGUgY291bGQgYmUgYSBiaXQgbW9yZSBjb21wbGV4LlxyXG4gICAgICAgICAgICAvLyAgTmVlZCB0byBiZSBjYXJlZnVsIGFib3V0IHVzaW5nIEpTT04gb3IgSlMgb2JqZWN0IGlucHV0IHRvIHNldCBhIGZpZWxkIC0gaXQgbWF5IG5lZWQgdG8gYmUgaW5zdGFudGlhdGVkIGZyb20gdGhhdCBpbnB1dC5cclxuXHJcblxyXG5cclxuXHJcblxyXG4gICAgICAgICAgICBlYWNoKGFbMF0sIGZ1bmN0aW9uKGksIHYpIHtcclxuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2kgJyArIHN0cmluZ2lmeShpKSk7XHJcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCd2ICcgKyBzdHJpbmdpZnkodikpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIGl0J3MgdXNpbmcgdGhlIG5ldyBzZXRfZmllbGQgaW4gQ29sbGVjdGlvbi5cclxuICAgICAgICAgICAgICAgIHRoYXQuc2V0X2ZpZWxkKGksIHYpO1xyXG4gICAgICAgICAgICAgICAgLy8gZm9yIHNldHRpbmcgYW4gZXhpc3RpbmcgZmllbGQuLi5cclxuICAgICAgICAgICAgICAgIC8vICBzZWUgaWYgdGhlIGZpZWxkIGV4aXN0cyAoc2VhcmNoIHRoZSBmaWVsZHMgb2JqZWN0IG9yIG90aGVyIGxvb2t1cClcclxuICAgICAgICAgICAgICAgIC8vICAgaWYgaXQgZXhpc3RzLCBtb2RpZnkgdGhlIGV4aXN0aW5nIG9uZSAtIGNvbXBsaWNhdGVkIHdoZW4gb3RoZXIgdGhpbmdzIGRlcGVuZCBvbiB0aGlzLlxyXG4gICAgICAgICAgICAgICAgLy8gICAgdGhlIGNvbnN0cmFpbnRzIGFuZCBpbmRleGVzIHdpbGwgYWxzbyBkZXBlbmQgb24gdGhlIGZpZWxkcywgc28gYSBtb2RpZmljYXRpb24gaW4gYSBmaWVsZCBjYW4gcmVzdWx0IGluIHRoZSByZW1vdmFsIG9mIGEgY29uc3RyYWludCBvciBpbmRleC5cclxuICAgICAgICAgICAgICAgIC8vICAgICByZW1vdmFsIG9mIGEgZmllbGQgY291bGQgbmVjZXNzaXRhdGUgdGhlIHJlbW92YWwgb2YgYSBjb25zdHJhaW50IG9yIGluZGV4LlxyXG4gICAgICAgICAgICAgICAgLy8gICAgICByZW1vdmVfY29uc3RyYWludHNfZm9yX2ZpZWxkXHJcbiAgICAgICAgICAgICAgICAvLyAgICAgIHJlbW92ZV9pbmRleGVzX2Zvcl9maWVsZFxyXG5cclxuICAgICAgICAgICAgICAgIC8vIERvbid0IHdhbnQgdG8gcmVtb3ZlIG11bHRpLWZpZWxkIGNvbnN0cmFpbnRzIHdoZW4gcmVwbGFjaW5nIG9uZSBmaWVsZCAtIGJ1dCBkbyB3YW50IHRoYXQgd2hlbiBwcm9wZXJseSByZW1vdmluZyBhIGZpZWxkLlxyXG4gICAgICAgICAgICAgICAgLy8gIEkgZ3Vlc3MgdGhpcyB3aWxsIGp1c3QgdGFrZSBhIGJpdCBtb3JlIGNvZGluZyBhbmQgdGVzdGluZyB0byBnZXQgdGhlIGRlc2lyZWQgYmVoYXZpb3JzLlxyXG4gICAgICAgICAgICAgICAgLy8gUmVhbGx5IHdhbnQgdG8gYmUgdXNpbmcgZmllbGRzIGFzIGEgY29udmVuaXRlbnQgaW50ZXJmYWNlIGZvciBjb25zdHJhaW50cy5cclxuICAgICAgICAgICAgICAgIC8vICBUaGV5IHdpbGwgZW5jb21wYXNzIGEgZmV3IHRoaW5ncyBpbnZvbHZpbmcgdGhlbS5cclxuICAgICAgICAgICAgfSwgdGhhdCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0pLFxyXG5cclxuICAgICdjb25zdHJhaW50cyc6IGZwKGZ1bmN0aW9uKGEsIHNpZykge1xyXG4gICAgICAgIC8vIG9yIGNvbnN0cmFpbnRzLi4uIGlmIGdpdmVuIG11bHRpcGxlIG9uZXMuXHJcbiAgICAgICAgLy8gICBJIHRoaW5rIGNvbnN0cmFpbnRzIG1heSBiZSB0aGUgYmV0dGVyIG5hbWUgaGVyZS5cclxuICAgICAgICAvLyAgIFdpbGwgYWNjZXB0IHRoZSBzaW5ndWxhciBhcyB3ZWxsLlxyXG5cclxuXHJcblxyXG5cclxuXHJcbiAgICAgICAgLy9jb25zb2xlLmxvZygnRGF0YV9PYmplY3QgY29uc3RyYWludCBzaWcgJyArIHNpZyk7XHJcblxyXG4gICAgICAgIC8vIHdhcyAnZmllbGRzJ1xyXG5cclxuICAgICAgICAvLyBhcyBjb25zdHJhaW50cywgYSBEYXRhX09iamVjdCBjYW4gYWxzbyBiZSBhIENvbGxlY3Rpb24sIHNvIHRoZXNlIHdpbGwgbmVlZCB0byBhcHBseSB0byBjb2xsZWN0aW9ucyBhcyB3ZWxsLlxyXG5cclxuICAgICAgICAvLyBjb2xsZWN0aW9ucyB3b24ndCBoYXZlIGZpZWxkcyB0aG91Z2gsIHNvIEZpZWxkX0NvbnN0cmFpbnRzIHdvbid0IGFwcGx5IHRvIHRoZW0sIGFuZCBjb2xsZWN0aW9ucyB3b24ndCBhY2NlcHQgdGhlbSBhcyBjb25zdHJhaW50cy5cclxuXHJcblxyXG4gICAgICAgIC8vIGZpZWxkIGNvbnN0cmFpbnRzLi4uXHJcblxyXG4gICAgICAgIC8vIG1heSBiZSBnaXZlbiB0aGUgZmllbGQgY29uc3RyYWludHNcclxuXHJcbiAgICAgICAgaWYgKGEubCA9PSAwKSB7XHJcblxyXG4gICAgICAgICAgICAvLyB3YW50IHRvIGdldCBhbGwgdGhlIGNvbnN0cmFpbnRzLlxyXG5cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBGaWVsZCByYXRoZXIgdGhhbiBjb2x1bW4uXHJcblxyXG5cclxuICAgICAgICAvLyBDb2xsZWN0aW9ucyB3aWxsIGhhdmUgb3RoZXIgc29ydHMgb2YgY29uc3RyYWludHMsIHN1Y2ggYXMgdGFibGUgY29uc3RyYWludHMuXHJcbiAgICAgICAgLy8gIE5pY2UgdG8gYmUgYWJsZSB0byBoYXZlIGNvbGxlY3Rpb25zIGhhdmUgY29uc3RyYWludHMgZGVmaW5lZCBpbiB0ZXJtcyBvZiBvdGhlciBjb2xsZWN0aW9ucy5cclxuXHJcblxyXG4gICAgICAgIC8vIEZvcmVpZ25fS2V5X0NvbnN0cmFpbnQgaXMgYSB0YWJsZSBjb25zdHJhaW50XHJcbiAgICAgICAgLy8gVW5pcXVlIGlzIGFzIHdlbGwuLi4gaXQgZG9lcyBub3QgY2hlY2sgaW5kaXZpZHVhbCBmaWVsZHMsIGRlcGVuZHMgb24gdGhlIHdob2xlIHRhYmxlLlxyXG4gICAgICAgIC8vICBGaW5lIHRvIGluZ29yZSB0aGUgZmFjdCB0aGF0IFNRTCBjYW4gcmVjb2duaXNlIHRoZW0gYXMgY29sdW1uIGNvbnN0cmFpbnRzIGhlcmUsIHdlIGFyZSBub3QgZGVhbGluZyB3aXRoIGNvbHVtbnMsXHJcbiAgICAgICAgLy8gIGJ1dCBmaWVsZHMuIEZpZWxkcyB3b24ndCBzYXkgdGhleSBhcmUgY29uc3RyYWluZWQgdG8gdW5pcXVlIHZhbHVlcy4uLiBjb2xsZWN0aW9ucyB3aWxsIHNheSB0aGV5IGNvbnN0cmFpbiBmaWVsZHMgdG8gdW5pcXVlIHZhbHVlcy5cclxuICAgICAgICAvLyAgIFdvdWxkIGJlIG1vcmUgbWVtb3J5IGVmZmljaWVudC5cclxuXHJcblxyXG4gICAgICAgIC8vIHRoZSBzaWduYXR1cmUuLi4gY291bGQgYmUgYSBmaWVsZF9jb25zdHJhaW50P1xyXG4gICAgICAgIC8vIGNvdWxkIGJlIGEgY29sbGVjdGlvbl9jb25zdHJhaW50P1xyXG4gICAgICAgIC8vICB0aGF0IG1heSBiZSB3b3J0aCBwdXR0aW5nIGludG8gdGhlIHNpZ25hdHVyZXMsIHdpdGggZmMgYW5kIGNjXHJcbiAgICAgICAgLy8gICBvciBGQyBhbmQgQ0NcclxuICAgICAgICAvLyB0aGF0J3MgaG93IHRoZXkgZ2V0IGJyb3VnaHQgaW50byB0aGUgc3lzdGVtIGF0IHF1aXRlIGEgbG93IGxldmVsLCB3aXRoIHRoZSBmbGV4aWJpbGl0eSBtYWtpbmcgdGhlIGNvZGUgY2xlYXJlciBoZXJlLlxyXG5cclxuXHJcbiAgICAgICAgLy8gZnVuY3Rpb24gd2FudGVkIHRvIGdldCBhbmQgc2V0IHRoZSBmaWVsZHMgYXMgd2VsbC4uLlxyXG5cclxuICAgICAgICAvLy8gaXQgbG9va3MgbGlrZSB0aGVyZSBhcmUgZmllbGQgY29uc3RyYWludHMgaW4gdXNlIGhlcmUuXHJcbiAgICAgICAgLy8gIHRoZSBmaWVsZHMgd2lsbCBiZSBhbiBvYmplY3QgLyBhcnJheSB3aXRoIHRoZSBmaWVsZHMuXHJcblxyXG5cclxuXHJcbiAgICAgICAgaWYgKHNpZyA9PSAnW29dJykge1xyXG4gICAgICAgICAgICAvLyBzZXR0aW5nIHRoZSBmaWVsZCBjb25zdHJhaW50cy5cclxuXHJcbiAgICAgICAgICAgIC8vIE1heSBoYXZlIGEgY2xvc2VyIGxvb2sgYXQgdGhvc2Ugb2JqZWN0cy5cclxuXHJcbiAgICAgICAgICAgIC8vIG92ZXJ3cml0ZSBleGlzdGluZyBvbmVzLlxyXG4gICAgICAgICAgICB2YXIgZmllbGRfY29uc3RyYWludHMgPSBhWzBdO1xyXG4gICAgICAgICAgICB0aGlzLl9maWVsZF9jb25zdHJhaW50cyA9IGZpZWxkX2NvbnN0cmFpbnRzO1xyXG5cclxuXHJcbiAgICAgICAgICAgIC8vIGRvZXMgaXQgbWF0Y2ggdGhlIGN1cnJlbnQgZmllbGQgY29uc3RyYWludHM/XHJcbiAgICAgICAgICAgIC8vICBpZiBub3QsIHRocm93IGFuIGVycm9yLlxyXG5cclxuXHJcblxyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIC8vIHN0cmluZywgP1xyXG4gICAgICAgIC8vICBpdCB3b3VsZCB0cnkgdG8gcHJvY2VzcyB0aGUgPyBhcyBhIGZpZWxkX2NvbnN0cmFpbnQgZm9yIHRoYXQgZmllbGRcclxuICAgICAgICAvLyAgaWYgaXQgYWxyZWFkeSBpcyBhIGZpZWxkX2NvbnN0cmFpbnQsIHRoZW4gZ3JlYXRcclxuICAgICAgICAvLyAgaWYgaXQgaXMgYW4gYXJyYXkgb3IgYSBzdHJpbmcgKHBvc3NpYmx5IG90aGVyIG9iamVjdCkgaXQgd2lsbCBwYXJzZSAvIGludGVycHJldCB0aGF0IGFzIGEgZmllbGRfY29uc3RyYWludCBvYmplY3RcclxuXHJcbiAgICAgICAgLy8gTWFraW5nIHRoZSBzeXN0ZW0gb2Ygc3BlY2lmeWluZyBjb25zdHJhaW50cyBlYXN5LCB3aGlsZSBzdGlsbCBwcm92aWRpbmcgdGhlIGZ1bGwgZGF0YWJhc2UtbGlrZSBtb2RlbCxcclxuICAgICAgICAvLyAgaXMgYW4gaW50ZXJlc3RpbmcgY2hhbGxlbmdlLiBJdCBzaG91bGQgbWFrZSBmb3IgYSBuaWNlIHRvb2wgb24gdGhlIGZyb250LWVuZCB0aGF0IGNhbiBjcmVhdGUgY29kZSB0aGF0IGdldHMgdHJhbnNmb3JtZWRcclxuICAgICAgICAvLyAgaW50byB0aGUgREIgY29kZSBhbmQgYWxsb3dzIGFjY2VzcyB0byBpdCB3aXRob3V0IHRvbyBtdWNoIGRpZmZpY3VsdHkuXHJcblxyXG4gICAgICAgIC8vIFRoaXMgc3lzdGVtLCBpbiBKYXZhU2NyaXB0LCB3aWxsIGJlIGFibGUgdG8gYmluZCB0byBkYXRhYmFzZXMgcmVsYXRpdmVseSBlYXNpbHkuXHJcbiAgICAgICAgLy8gIFNob3VsZCBwcm92aWRlIHRoZSBjb2RlciB3aXRoIGVhc3kgYWNjZXNzIHRvIGRhdGEgaW4gdmFyaW91cyBkYXRhYmFzZXMuXHJcbiAgICAgICAgLy8gIFRoaXMgd2hvbGUgY29uc3RyYWludHMgYW5kIGRhdGEgdHlwZXMgc3lzdGVtIHdpbGwgaGF2ZSB3aWRlIGFwcGxpY2F0aW9uIHRvIGEgbG90IG9mIGRhdGEgYXZhaWxhYmxlIG9uIHRoZSBpbnRlcm5ldCxcclxuICAgICAgICAvLyAgIGFuZCB3aWxsIGJlIHVzZWZ1bCBmb3IgcHVibGlzaGluZyBkYXRhIHRvby5cclxuXHJcbiAgICAgICAgLy8gTG9va2luZyBmb3J3YXJkIHRvIG1ha2luZyBhIHJlc291cmNlcyBzeXN0ZW0gdGhhdCBtYWtlcyBpdCByZWxhdGl2ZWx5IGVhc3kgdG8gYWNjZXNzIGRhdGEgdGhhdCBpcyBzdG9yZWQgc29tZXdoZXJlIHdpdGggYW4gZWFzeSBBUEkuXHJcbiAgICAgICAgLy8gIE1heSBiZSBpbnRlcmVzdGluZyB0byBvcGVuLXNvdXJjZSBzb21lIG9mIHRoaXMgdGVjaG5vbG9neS4gTWF5IGJlIGJlc3QgdG8gb3Blbi1zb3VyY2UgYWxsIG9mIGl0P1xyXG4gICAgICAgIC8vICBJIHRoaW5rIG9wZW4gc291cmNpbmcgYSBwcmVjaXNlLCBmYWlybHkgY29tcGFjdCBidWlsZCBvZiBpdCB3b3VsZCBiZSBuaWNlLlxyXG4gICAgICAgIC8vICAgV29ydGggdGhpbmtpbmcgaW4gdGVybXMgb2YgcG9zc2libGUgZXh0ZW5zaW9ucy5cclxuXHJcbiAgICAgICAgLy8gVGhlIHN5c3RlbSB0byBkbyB3aXRoIGZpbmRpbmcgYW5kIGRlZmluaW5nIG1ldGFkYXRhLCBhbmQgbWF0Y2hpbmcgdGhhdCB3aXRoIGRhdGEgc2NyYXBlZCBmcm9tIHdlYnNpdGVzIG9yIGZyb20gd2ViIHJlc291cmNlcy4uLlxyXG4gICAgICAgIC8vICBOb3Qgc3VyZSBhYm91dCBvcGVuIHNvdXJjaW5nIHNvbWUgb2YgdGhlIGNvcmUgaW5kZXhpbmcgc3R1ZmYgcXVpdGUgeWV0LiBQb3NzaWJseSBpbiB0aGUgZnV0dXJlLlxyXG5cclxuICAgICAgICAvLyBCdXQgbXkgd2Vic2l0ZSBjb3VsZCBtYWtlIG1ldGFkYXRhIGF2YWlsYWJsZS5cclxuICAgICAgICAvLyAgVGhlcmUgY291bGQgYmUgc29tZSBvcGVuLXNvdXJjZWQgY29kZSB0byBkbyB3aXRoIHRoZSBjb3JlIHRoaW5ncywgSSdtIHN1cmUuXHJcblxyXG4gICAgICAgIC8vIFBlcmhhcHMgY29ubmVjdGluZyB0byB2YXJpb3VzIHJlc291cmNlcy5cclxuICAgICAgICAvLyAgSG9zdGluZyBkYXRhIHBlcmhhcHMsIGlkZW50aWZ5aW5nIGl0IHRvIHRoZSBpbmRleC5cclxuXHJcbiAgICAgICAgLy8gUGVyaGFwcyBwZW9wbGUgcnVubmluZyBob3N0aW5nIHNvZnR3YXJlIEkgaGF2ZSB3cml0dGVuIHdpbGwgY29ubmVjdCB0byB0aGUgY2VudHJhbCBzeXN0ZW0sIGFsc28gY291bGQgdXNlIHRoZSBSZXNvdXJjZXMgc3lzdGVtXHJcbiAgICAgICAgLy8gIHRvIG9idGFpbiBkYXRhIGZyb20gZWxzZXdoZXJlIGZvciB0aGVpciBvd24gdXNlLCB3aGlsZSBwdWJsaXNoaW5nIGl0IHdpdGggTWV0YUJlbmNoIGluZGV4aW5nIHN5c3RlbXMsIEFQSXMgYW5kIHNlbWFudGljcy5cclxuXHJcblxyXG4gICAgICAgIGlmIChhLmwgPT0gMiAmJiB0b2YoYVswXSkgPT0gJ3N0cmluZycpIHtcclxuXHJcblxyXG5cclxuXHJcbiAgICAgICAgfVxyXG5cclxuXHJcblxyXG4gICAgICAgIC8vIG1heSBiZSByZXR1cm5pbmcgdGhlIGZpZWxkIGNvbnN0cmFpbnRzXHJcblxyXG5cclxuXHJcbiAgICB9KSxcclxuXHJcbiAgICAnbWF0Y2hlc19maWVsZF9jb25zdHJhaW50JzogZnAoZnVuY3Rpb24oYSwgc2lnKSB7XHJcbiAgICAgICAgLy8gdGhlcmUgbWF5IGJlIG1vcmUgdGhhbiBvbmUgY29uc3RyYWludCBmb3IgdGhhdCBmaWVsZC5cclxuXHJcbiAgICAgICAgLy9jb25zb2xlLmxvZygnbWF0Y2hlc19maWVsZF9jb25zdHJhaW50IHNpZyAnICsgc2lnKTtcclxuICAgICAgICAvL2NvbnNvbGUubG9nKCdtYXRjaGVzX2ZpZWxkX2NvbnN0cmFpbnQgYSAnICsgc3RyaW5naWZ5KGEpKTtcclxuXHJcblxyXG4gICAgICAgIGlmIChzaWcgPT0gJ1tzLHNdJykge1xyXG4gICAgICAgICAgICB2YXIgZmllbGRfbmFtZSA9IGFbMF07XHJcblxyXG4gICAgICAgICAgICAvLyB0aGUgY29uc3RyYWludCBhcyBqdXN0IG9uZSBpdGVtLlxyXG4gICAgICAgICAgICAvLyAgdGhlcmUgY291bGQgYmUgbXVsdGlwbGUgZmllbGRzIGNvbnN0cmFpbnRzIGZvciB0aGF0IGl0ZW0uXHJcblxyXG4gICAgICAgICAgICBpZiAodG9mKGFbMV0pID09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3RyX2NvbnN0cmFpbnQgPSBhWzFdO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIHRoZW4gdXNlIHRoZSBjb25zdHJhaW50IG1vZHVsZSB0byB0ZXN0IHRoZXNlLlxyXG5cclxuICAgICAgICAgICAgICAgIHZhciBmaWVsZF92YWwgPSB0aGlzLmdldChmaWVsZF9uYW1lKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBvYmpfbWF0Y2hlc19jb25zdHJhaW50KGZpZWxkX3ZhbCwgc3RyX2NvbnN0cmFpbnQpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAodG9mKGFbMV0pID09ICdhcnJheScpIHtcclxuICAgICAgICAgICAgICAgIHRocm93ICdNdWx0aXBsZSBjb25zdHJhaW50cyBub3QgeWV0IGltcGxlbWVudGVkIGhlcmUnO1xyXG4gICAgICAgICAgICB9XHJcblxyXG5cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL3Rocm93KCdzdG9wJylcclxuXHJcbiAgICAgICAgLy8gZ2l2ZW4gYXMgc3RyaW5nXHJcblxyXG5cclxuICAgICAgICAvL1xyXG5cclxuXHJcbiAgICB9KSxcclxuXHJcbiAgICAnb2JqX21hdGNoZXNfZmllbGRfY29uc3RyYWludHMnOiBmdW5jdGlvbihvYmopIHtcclxuICAgICAgICAvL2NvbnNvbGUubG9nKCdtYXRjaGVzX2ZpZWxkX2NvbnN0cmFpbnRzICcpO1xyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICAvLyBpdGVyYXRlIHRocm91Z2ggdGhlIGZpZWxkIGNvbnN0cmFpbnRzXHJcbiAgICAgICAgdmFyIG1hdGNoZXMgPSB0cnVlO1xyXG5cclxuICAgICAgICAvLyBkb24ndCBjaGVjayBpdCBhZ2FpbnN0IHRoZSBfZmllbGRfY29uc3RyYWludHM/XHJcbiAgICAgICAgLy8gIGdldCB0aGVfZmllbGRfY29uc3RyYWludHM/XHJcbiAgICAgICAgLy8gIGhhdmUgdGhlIC5mYyAoZmllbGQgY29sbGVjdGlvbikgaW50ZXJhY3Rpbmcgd2l0aCB0aGUgZmllbGQgY29uc3RyYWludHM/XHJcbiAgICAgICAgLy8gICBoYXZlIHRoZSBmaWVsZHNfY29sbGVjdGlvbiBzeXN0ZW0gc3RvcmUgdGhlIGZpZWxkIGNvbnN0cmFpbnRzP1xyXG4gICAgICAgIC8vICBwb3NzaWJseSBub3QsIGJlY2F1c2Ugc29tZSBjb25zdHJhaW50cyB3aWxsIGJlIG91dHNpZGUgb2YgaW5kaXZpZHVhbCBmaWVsZHMuXHJcblxyXG4gICAgICAgIC8vIHBlcmhhcHMgaGF2ZSBfdW5pcXVlX2NvbnN0cmFpbnRzX2NvbGxlY3Rpb24gLyBpbmRleCB0aGF0IGtlZXBzIHRyYWNrIG9mIHRoZSB1bmlxdWUgY29uc3RyYWludHMuXHJcblxyXG4gICAgICAgIC8vIHRoZXkgYXJlIGRpZmZlcmVudCB0byB0aGUgZmllbGQgY29uc3RyYWludHMuIGZvciB0aGUgbW9tZW50IHRoZXkgY2FuIGp1c3QgYmUgYW4gaW5kZXguXHJcbiAgICAgICAgLy8gIGNvdWxkIG1heWJlIGhhdmUgdGhlbSBsaWtlIGZsYWdzLlxyXG5cclxuICAgICAgICAvLyAgdGhleSBjYW4gYmUgYWRkZWQsIHJlbW92ZWQsIHRoZXkgd2lsbCBiZSBpbmRleGVkIGZvciBzYXQgcmV0cmlldmFsIGFuZCBjaGVja2luZy5cclxuXHJcbiAgICAgICAgLy8gaW5kZXhlcy4uLiBhbm90aGVyIGluZGV4IGluZGV4PyB0aGVzZSBpbmRpY2F0ZSBob3cgdGhpbmdzIGdldCBpbmRleGVkIHdpdGhpbiB0aGUgY29sbGVjdGlvbiwgcmF0aGVyIHRoYW4gYmVpbmcgdGhlIGluZGV4ZXMgdGhlbXNlbHZlcy5cclxuXHJcbiAgICAgICAgLy8gZmllbGRfaW5kZXhfc2NoZW1hP1xyXG4gICAgICAgIC8vXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbiAgICAgICAgZWFjaCh0aGlzLl9maWVsZF9jb25zdHJhaW50cywgZnVuY3Rpb24oaSwgdikge1xyXG4gICAgICAgICAgICAvLyBkb2VzIGl0IG1hdGNoP1xyXG5cclxuICAgICAgICAgICAgbWF0Y2hlcyA9IG1hdGNoZXMgJiYgb2JqLm1hdGNoZXNfZmllbGRfY29uc3RyYWludChpLCB2KVxyXG5cclxuICAgICAgICB9KVxyXG4gICAgICAgIHJldHVybiBtYXRjaGVzO1xyXG4gICAgICAgIC8vdGhyb3coJ3N0b3AnKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8vIE1heWJlIGZpZWxkcyBhbmQgZmllbGQgY29uc3RyYWludCBoZWF2eSBsaWZ0aW5nIHNob3VsZCBiZSBkb25lIGVsc2V3aGVyZT9cclxuICAgIC8vICBCdXQgRGF0YV9PYmplY3Qgd2lsbCBiZSByaWdodCBpbiB0aGUgY29yZSByZWFsbHkuXHJcblxyXG4gICAgLy8gSSBkb3VidCB0aGUgY29yZSB3aWxsIGJlIGFsbCB0aGF0IGxhcmdlIGluIHRlcm1zIG9mIGZpbGUgc2l6ZS5cclxuICAgIC8vICBBIGxvdCBvZiBzaXplIHNhdmluZ3Mgd2lsbCBiZSBtYWRlLCBhbmQgaXQgd2lsbCBiZSB2ZXJ5IHNtYWxsIGFuZCBlZmZpY2llbnQgY29tcGFyZWQgdG8gbWFueSBvdGhlciBzeXN0ZW1zLlxyXG4gICAgLy8gIENvbWJpbmluZyBkaWZmZXJlbnQgdGhpbmdzIGludG8gb25lIGZpbGUgd291bGQgYmUgYW5vdGhlciBkYXlzIHdvcmsuXHJcblxyXG4gICAgLy8gSSBjb3VsZCBhbHNvIGRvIHNvbWUgbW9yZSB3b3JrIG9uIGJ1aWxkaW5nIHVwIHRoZSBKYXZhU2NyaXB0IGNvZGUgYW5kIGV2YWx1YXRpbmcgaXQuXHJcbiAgICAvLyAgVGhhdCBjb3VsZCBzYXZlIGEgbG90IG9mIHNwYWNlIHdpdGggYW4gZWZmaWNpZW50IGNvbXByZXNzaW9uIG1lY2hhbmlzbS5cclxuXHJcblxyXG4gICAgLy8gU2V0dGluZyBhIHdob2xlIGJ1bmNoIG9mIGZpZWxkcywgb3IgZXZlbiBhIGZpZWxkLCBtYXkgYmUgYmV0dGVyIGRvbmUgaW4gYSBjb2xsZWN0aW9uLCBiZWNhdXNlIHNvbWUgb2YgdGhlIGZpZWxkIGhhcyB0byBkbyB3aXRoIGhvdyBhIGNvbGxlY3Rpb24gaGFuZGxlcyBpdC4uLlxyXG4gICAgLy8gIGluZGV4aW5nIGl0LFxyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgJ2ZpZWxkcyc6IGZwKGZ1bmN0aW9uKGEsIHNpZykge1xyXG4gICAgICAgIGlmIChzaWcgPT0gJ1tvXScpIHtcclxuICAgICAgICAgICAgLy8gb3ZlcndyaXRlIGFsbCBmaWVsZHMuXHJcblxyXG4gICAgICAgICAgICAvLyB3aWxsIHVzZSB0aGUgc2V0X2ZpZWxkIHRvIHNldCB0aGUgaW5kaXZpZHVhbCBmaWVsZHM/XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9jb25zb2xlLmxvZygnQ29sbGVjdGlvbiBmaWVsZHMgc2lnICcgKyBzaWcpO1xyXG5cclxuXHJcbiAgICB9KSxcclxuICAgICovXHJcbiAgICAvLyBUaGUgZmllbGQgY29uc3RyYWludHMsIGFuZCBkYXRhX3R5cGUgc3lzdGVtIGlzIGdldHRpbmcgcXVpdGUgbGFyZ2UgYW5kIGEgYml0IGZyYWdtZW50ZWQuXHJcbiAgICAvLyAgSG9wZWZ1bGx5IGl0IHdpbGwgYmUgY2xvc2VyIGludGVncmF0ZWQgaW50byB0aGUgY29yZSwgYW5kIHRlc3RlZCB3aXRoIHNvbWUgcmVsYXRpdmVseSBzaW1wbGUgZXhhbXBsZXMgdG8gc2hvdyB0aGF0IGl0IHdvcmtzXHJcbiAgICAvLyAgYW5kIHdoYXQgcmVzdWx0cyB0byBleHBlY3QuXHJcblxyXG4gICAgLy8gVGhlIGNvbnN0cmFpbnRzIGFib3V0IHdoYXQgb2JqZWN0cyBjYW4gYmUgd2lsbCBnbyBhIGxvbmcgd2F5IHRvd2FyZHMgdGhlIGdvYWwgb2Ygc3BlY2lmaXlpbmcgdGhpbmdzIGluIEphdmFTY3JpcHQgdGhhdFxyXG4gICAgLy8gIHdpbGwgd29yayBvbiBtYW55IHN5c3RlbXMgZXZlbnR1YWxseS4gVGhlc2UgbWVjaGFuaXNtcyB3aWxsIGJlIHVzZWZ1bCBpbiBHVUlzLCBzbyBpdCB3aWxsIGhlbHAgdGhhdCB0aGV5IGFyZSBidWlsdCBpbnRvIHRoZSBjb3JlIG9mIHRoZSBmcmFtZXdvcmsuXHJcblxyXG4gICAgLy8gQXQgdGhlIG1vbWVudCBJIGFtIHB1dHRpbmcgcXVpdGUgYSBsb3QgaW4sIGhhdmluZyBzcGVudCBzb21lIHRpbWUgY29uc2lkZXJpbmcgd2hhdCB3aWxsIGJlIG5lZWRlZCBuZXh0LlxyXG4gICAgLy8gIEEgbGF0ZXIgc3RhZ2Ugd2lsbCBiZSByZWZhY3RvcmluZyB0aGluZ3MuIFRoYXQgbWF5IGNvbWUgd2hlbiBpdCBpcyBydW5uaW5nIGluIGEgYnJvd3NlciBhbmQgSSBzZWUgaG93IG11Y2ggaXQgaXMgdXNpbmcuXHJcbiAgICAvLyAgSXQgbWF5IGJlIGRvbmUgYWZ0ZXIgc29tZSBtb3JlIGNvZGUgYW5hbHlzeXMsIHBlcmhhcHMgZW5hYmxlZCBieSBKYXZhU2NyaXB0IHBhcnNpbmcgYW5kIHN0b3JpbmcgdGhlIGNvZGUgb24gdGhlIHN5c3RlbSByZWFkeSBmb3IgdXNlXHJcbiAgICAvLyAgIGFuZCBhbmFseXNpc1xyXG5cclxuICAgIC8vIHNldF9maWVsZCBmb3IgdGhlIERhdGFfT2JqZWN0Li4uIHRoZSBmaWVsZCBpcyBhIGNvbnN0cmFpbnQgdG8gZG8gd2l0aCB0aGUgdHlwZSwgaXQgY291bGQgYWxzbyBiZSB0aGF0IGFuIGluZGV4IGlzIHNldCB1cCBmb3IgdGhhdCBmaWVsZC5cclxuXHJcbiAgICAvLyAgd2FudCByZWFkLW9ubHkgZmllbGRzIHRvIG9wZXJhdGUgb24gdGhlIGNsYXNzIGxldmVsIGFzIHdlbGwuXHJcbiAgICAvLyAgSSB0aGluayB0aGUgbWFwIGlzIHVzZWZ1bCwgSSdtIG5vdCBzbyBzdXJlIHRoYXQgdGhleSBhcmUgY29uc3RyYWludHMgYW55d2F5LlxyXG4gICAgLy8gIEZpZWxkIHByb3BlcnRpZXMuLi4gdGhlbiBjYW4gaGF2ZSBhIGZpZWxkIHByb3BlcnR5IG1hcCBvciBmaWVsZCBwcm9wZXJ0eSBpbmRleC5cclxuXHJcblxyXG4gICAgJ3JlYWRfb25seSc6IGFycmF5aWZ5KGZwKGZ1bmN0aW9uKGEsIHNpZykge1xyXG4gICAgICAgIHZhciBtcm8gPSB0aGlzLl9tYXBfcmVhZF9vbmx5ID0gdGhpcy5fbWFwX3JlYWRfb25seSB8fCB7fTtcclxuXHJcbiAgICAgICAgdmFyIGZpZWxkX25hbWUgPSBhWzBdO1xyXG5cclxuICAgICAgICBpZiAoc2lnID09ICdbc10nKSB7XHJcbiAgICAgICAgICAgIC8vIGEgZmllbGQgbmFtZSB0byBtYWtlIHJlYWQtb25seVxyXG4gICAgICAgICAgICBtcm9bZmllbGRfbmFtZV0gPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc2lnID09ICdbcyxiXScpIHtcclxuICAgICAgICAgICAgLy8gYSBmaWVsZCBuYW1lIHRvIG1ha2UgcmVhZC1vbmx5LCBib29sZWFuIHZhbHVlIGNhbiBiZSBmYWxzZVxyXG5cclxuICAgICAgICAgICAgdmFyIGJvb2xfaXNfcmVhZF9vbmx5ID0gYVsxXTtcclxuICAgICAgICAgICAgaWYgKGJvb2xfaXNfcmVhZF9vbmx5KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZWFkX29ubHkoZmllbGRfbmFtZSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvL2RlbGV0ZSBtcm9bZmllbGRfbmFtZV07XHJcbiAgICAgICAgICAgICAgICBtcm9bZmllbGRfbmFtZV0gPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGFycmF5Li4uIHByb2Nlc3MgdGhlbT9cclxuICAgICAgICAvLyAgY291bGQgYXJyYXlpZnkgdGhlIHdob2xlIGZ1bmN0aW9uLlxyXG4gICAgfSkpLFxyXG5cclxuICAgICdzZXRfZmllbGQnOiBmcChmdW5jdGlvbihhLCBzaWcpIHtcclxuXHJcbiAgICAgICAgLy8gVGhpcyB3aWxsIGJlIG92ZXJoYXVsZWQuLi5cclxuICAgICAgICAvLyAgIEl0IHdpbGwgbmVlZCB0byBlZmZpY2llbnRseSBzZWUgaWYgYW4gZXhpc3RpbmcgZmllbGQgaXMgdGhlcmUuXHJcblxyXG4gICAgICAgIC8vIElmIGl0IGlzIHRoZXJlLCBpdCB3aWxsIHVwZGF0ZSB0aGUgZmllbGQuIFRoYXQgbWF5IHRoZW4gbWVhbiB0aGF0IGNvbnN0cmFpbnRzIG5lZWQgdG8gZ2V0IHVwZGF0ZWQgYXMgd2VsbC4uXHJcbiAgICAgICAgLy8gIHdvdWxkIG1lYW4gcmVtb3Zpbmcgc29tZSBleGlzdGluZyBvbmVzIHBlcmhhcHM/XHJcbiAgICAgICAgLy8gQnV0IGl0IHdvdWxkIGNoZWNrIHdoYXQgY29uc3RyYWludHMgYXJlIHRoZW4gbmVlZGVkIGZvciB0aGF0IGZpZWxkIGFuZCByZW1vdmUgdGhlIGV4dHJhbmVvdXMgb25lcy5cclxuICAgICAgICAvLyAgU2FtZSB3aXRoIHNpbmdsZS1maWVsZCBpbmRleGVzLlxyXG5cclxuICAgICAgICAvLyBXaGVuIGFkZGluZyB0aGUgZmllbGQsIHdvdWxkIGFsc28gbmVlZCB0byB1cGRhdGUgdGhlIGNvbnN0cmFpbnRzLlxyXG4gICAgICAgIC8vICBDb3VsZCBoYXZlIHRoZSBjb25zdHJhaW50IHN5c3RlbSByZXNwb25kIHRvIGZpZWxkIGNoYW5nZXMsIG1heWJlIGJlIHRoZSBmaXJzdCBsaXN0ZW5lci5cclxuICAgICAgICAvLyAgIHVzaW5nIHRoaXMuZW5zdXJlX2ZpZWxkX2NvbnN0cmFpbnQoZmllbGRfbmFtZSwgZmllbGRfaW5mbyk7P1xyXG5cclxuXHJcbiAgICAgICAgdGhpcy5mYyA9IHRoaXMuZmMgfHwgbmV3IEZpZWxkc19Db2xsZWN0aW9uKCk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLmZjLnNldC5hcHBseSh0aGlzLmZjLCBhKTtcclxuXHJcbiAgICAgICAgLy8gYWx0aG91Z2ggaXQgaGFzIGJlZW4gYWRkZWQsIHdlIG5lZWQgdG8gc2V0IHRoZSBwYXJlbnQuLi5cclxuICAgICAgICAvLyAgbWF5YmUgZmMgY2FuIGRvIHRoaXM/XHJcblxyXG4gICAgICAgIC8vY29uc29sZS5sb2coJ3NldF9maWVsZCBzaWcgJyArIHNpZyk7XHJcbiAgICAgICAgLy9jb25zb2xlLmxvZygnc2V0X2ZpZWxkIGEgJyArIHN0cmluZ2lmeShhKSk7XHJcblxyXG4gICAgICAgIC8vIFtzLFtmXV1cclxuICAgICAgICAvLyAgZGF0YSB0eXBlIGlzIGRlZmluZWQgYnkgYSBjb25zdHJ1Y3RvciB3aXRoaW4gYW4gYXJyYXlcclxuICAgICAgICAvLyAgIG1lYW5zIGEgY29sbGVjdGlvbiBvZiB0aGF0IHR5cGUuXHJcblxyXG4gICAgICAgIC8vIHNldHMgYSBkYXRhIHR5cGUgY29uc3RyYWludCBvbiB0aGF0IGZpZWxkXHJcbiAgICAgICAgLypcclxuICAgICAgICBpZiAoc2lnID09ICdbcyxbZl1dJykge1xyXG5cclxuICAgICAgICAgICAgdGhyb3cgJzEwKSBTdG9wJztcclxuICAgICAgICB9XHJcbiAgICAgICAgKi9cclxuICAgICAgICAvLyBDb2xsZWN0aW9uIGhhcyBzb21ldGhpbmcgdGhhdCBvdmVycmlkZXMgdGhpcy5cclxuICAgICAgICAvKlxyXG4gICAgICAgIGlmIChzaWcgPT0gJ1tzLHNdJykge1xyXG4gICAgICAgICAgICAvLyB3aWxsIG5lZWQgdG8gaW50ZXJwcmV0IHRoZSBzZWNvbmQgcGFydFxyXG4gICAgICAgICAgICB2YXIgZmllbGRfbmFtZSA9IGFbMF07XHJcbiAgICAgICAgICAgIHZhciBmaWVsZF90ZXh0ID0gYVsxXTtcclxuXHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2ZpZWxkX3RleHQgJyArIGZpZWxkX3RleHQpO1xyXG4gICAgICAgICAgICAvLyBwYXJzZSB0aGUgZmlleCB0ZXh0LiBpdCBtYXkgaGF2ZSBzb21lIHRoaW5ncyB0byBkbyB3aXRoIGNvbnN0cmFpbnRzIHRoYXQgYXBwbHkgdG8gdGhlIGNvbGxlY3Rpb24sIGlmIGl0IGlzIGluIGEgY29sbGVjdGlvbi5cclxuICAgICAgICAgICAgLy8gIG5vdCBzbyBzdXJlIGFib3V0IHNhdmluZyB0aGVzZSBoZXJlLiBUaGV5IGNvdWxkIGJlIHNhdmVkIHNvIHRoYXQgdGhleSBnZXQgcHV0IGludG8gYSBjb2xsZWN0aW9uIGZpbmUgd2l0aCBvdGhlciB1bmlxdWUgZmllbGRzLi4uXHJcbiAgICAgICAgICAgIC8vIGJ1dCB0aGVuIHdlJ2xsIGJlIHRha2luZyBtb3JlIGNhcmUgc3BlY2lmeWluZyB0aGluZ3MgaW4gdGhlIGNvbGxlY3Rpb24gaWYgbmVjZXNzYXJ5LlxyXG5cclxuICAgICAgICAgICAgdmFyIGZpZWxkX2luZm8gPSBpbnB1dF9wcm9jZXNzb3JzWydmaWVsZF90ZXh0J10oZmllbGRfdGV4dCk7XHJcblxyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdmaWVsZF9pbmZvICcgKyBzdHJpbmdpZnkoZmllbGRfaW5mbykpO1xyXG5cclxuICAgICAgICAgICAgLy8gdGhlbiBlbnN1cmUgdGhlIGNvbnN0cmFpbnQocykgY29ycmVzcG9uZGluZyB0byB0aGUgZmllbGQsIHdoZXJlIHBvc3NpYmxlLlxyXG4gICAgICAgICAgICAvLyAgbm90IGFibGUgdG8gcHV0IHVuaXF1ZW5lc3MgY29uc3RyYWludCBpbiBwbGFjZSBoZXJlLCB5ZXQuIEl0J3MgcmVhbGx5IGRlYWx0IHdpdGggYW5kIGVuZm9yY2VkIGJ5IHRoZSBDb2xsZWN0aW9uIGNsYXNzLlxyXG5cclxuICAgICAgICAgICAgLy8gSSB0aGluayB0aGUgbGlicmFyeSBjb3JlIGlzIGdldHRpbmcgcHJldHR5IGJpZyBub3csIGl0IGNvdWxkIHN0aWxsIGRvIHdpdGggbW9yZSBmb3IgSFRNTCwgQ1NTIHByb2Nlc3NpbmcuXHJcbiAgICAgICAgICAgIC8vICBUaGUgZGF0YWJhc2Ugc2lkZSBvZiB0aGluZ3Mgd2lsbCBiZSBleHBhbmRlZCwgaXQgd2lsbCBiZSBnb29kIHRvIGhhdmUgY29kZSB1c2luZyB2ZXJ5IG5pY2Ugc3ludGF4IHByb3ZpZGVkIGJ5IHRoZSBsaWJyYXJ5LlxyXG5cclxuICAgICAgICAgICAgdGhpcy5lbnN1cmVfZmllbGRfY29uc3RyYWludChmaWVsZF9uYW1lLCBmaWVsZF9pbmZvKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChmaWVsZF9pbmZvLnJlYWRfb25seSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZWFkX29ubHkoZmllbGRfbmFtZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEp1c3QgbmVlZCB0byBkbyBxdWl0ZSBhIGxvdCBtb3JlLi4uXHJcbiAgICAgICAgICAgIC8vICBRdWl0ZSBhIGJpdCBtb3JlIG5lZWRlZCBmb3IgdGhlIG9iamVjdHMgdG8gd29yayBsaWtlIHRoZXkgc2hvdWxkLCB0aGVuIEknbGwgYmUgdXNpbmcgdGhvc2Ugb2JqZWN0cyBmb3IgdGhlIEhUTUwgY29tcG9uZW50cywgYW5kIGFsc28gZm9yIHRoZVxyXG4gICAgICAgICAgICAvLyAgZGF0YWJhc2UgbGF5ZXIuXHJcblxyXG4gICAgICAgICAgICAvLyBQZXJzaXN0aW5nIHRvIHRoYXQgREIgbGF5ZXIgc2VlbXMgbGlrZSBhIHJlYWxseSB1c2VmdWwgc3RhZ2UsIG5vdCBzdXJlIGFib3V0IG9wZW4tc291cmNpbmcgdGhhdCBjb2RlLlxyXG4gICAgICAgICAgICAvLyAgTWF5IGJlIGJlc3QgdG8uLi4gbWF5IGJlIGJldHRlciB0aGF0IG15IE9STSBpcyB1c2VkLiBJJ2Qgc3RpbGwgaGF2ZSB0aGUgcG93ZXJmdWwgd2ViIGFwcCB0b28/XHJcbiAgICAgICAgICAgIC8vICAgQ291bGQgaGF2ZSBkaWZmZXJlbnQgbGljZW5zaW5nIGZvciB0aGF0IGNvbXBvbmVudC4uLiBjb21tZXJjaWFsIGRlcGxveW1lbnRzIGNvc3QgbW9uZXk/XHJcbiAgICAgICAgICAgIC8vICAgIEJ1dCB0aGVuIHdhbnQgdG8gaGF2ZSB0aGluZ3MgZGlzdHJpYnV0ZWQgbmljZSBhbmQgZWFzaWx5LiBQZXJoYXBzIGNvdWxkIGhhdmUgZGlmZmVyZW50IG9wdGlvbnMgZm9yIHRoaXMuIFdpdGggdGhlIHdlYnNpdGUgcnVubmluZyBvdXQtb2YtdGhlLWJveCxcclxuICAgICAgICAgICAgLy8gICAgIGNvdWxkIGRpcmVjdGx5IGdvIHRvIHRoZSBNb25nbyBsYXllci5cclxuICAgICAgICAgICAgLy8gV291bGQgYmUgdmVyeSBuaWNlIHRvIGhhdmUgb3Blbi1zb3VyY2UgY29kZSBwcm9kdWNpbmcgZXZlcnl0aGluZyB0aGF0J3MgbmVlZGVkLiBDb3VsZCBnZXQgcXVpdGUgYSBsb3Qgb2YgaW50ZXJlc3QuXHJcbiAgICAgICAgICAgIC8vICBNYXliZSB3aWxsIGtlZXAgdGhhdCBvbiBteSBzZXJ2ZXIgZm9yIHRoZSBtb21lbnQsIG9yIGluIHRoZSBjbGllbnQtc2lkZSBhcHBsaWNhdGlvbnMgcGVvcGxlIHVzZS5cclxuICAgICAgICAgICAgLy8gV2lsbCBiZSBmaW5lIHdpdGhvdXQgT1NpbmcgYWxsIHRoZSBPUk0sIGJ1dCBhIHJlbGF0aXZlbHkgc2ltcGxlIE1vbmdvIGxheWVyIHdvdWxkIHdvcmsgZmluZS5cclxuICAgICAgICAgICAgLy8gIEl0IG1heSBiZSBtb3JlIHdoYXQgcGVvcGxlIHdhbnQsIGFuZCB3b3VsZCBnZXQgZGV2ZWxvcGVyIGludGVyZXN0LiBUaGUgT1JNIHdvdWxkIGJlIHVzZWZ1bCBmb3IgYWNjZXNzaW5nIGxlZ2FjeSBzeXN0ZW1zPyBTUUwgY2FuIGJlIHZlcnkgdXNlZnVsIGluIGl0c1xyXG4gICAgICAgICAgICAvLyAgIG93biByaWdodCwgYnV0IGNvdWxkIGJlIGhhcmRlciB0byB1c2UgZWZmZWN0aXZlbHkgaW4gdGhpcyBjYXNlLlxyXG5cclxuXHJcbiAgICAgICAgICAgIC8vIGRvZXMgaXQgaGF2ZSB0aGUgbm90X251bGwgY29uc3RyYWludD9cclxuICAgICAgICAgICAgLy8gIGVhY2ggZmllbGQgY2FuIGhhdmUgbW9yZSB0aGFuIG9uZSBjb25zdHJhaW50LlxyXG4gICAgICAgICAgICAvLyAgbm90IHN1cmUgYWJvdXQgYSBjb2xsZWN0aW9uIG9mIGNvbnN0cmFpbnRzIHRob3VnaC5cclxuICAgICAgICAgICAgLy8gICBwZXJoYXBzIGEgc2ltcGxlciBjb2xsZWN0aW9uIHdvdWxkIGJlIHZlcnkgdXNlZnVsIGluIGltcGxlbWVudGluZyBzb21lIG9mIHRoZSBtb3JlIGFkdmFuY2VkIHRoaW5ncy5cclxuICAgICAgICAgICAgLy8gIGFycmF5IG9mIGNvbnN0cmFpbnRzIGZvciBlYWNoIGZpZWxkIHdpbGwgZG8gZm9yIHRoZSBtb21lbnQuXHJcblxyXG4gICAgICAgICAgICAvLyBjYW4gYmUgYm90aCBhIE5vdF9OdWxsIGNvbnN0cmFpbnQgYW5kIGEgZGF0YSB0eXBlIGNvbnN0cmludC5cclxuICAgICAgICAgICAgLy8gZWFzeSB0aGVuIHRvIGNyZWF0ZSB0aGUgZmllbGQgd2l0aCB0aGlzIGluZm9ybWF0aW9uLlxyXG5cclxuICAgICAgICAgICAgLy8gIGZpbmQgb3V0IGlmIHRoZXJlIGlzIGFuIGV4aXN0aW5nIGZpZWxkIChjb25zdHJhaW50KS5cclxuICAgICAgICAgICAgLy8gIGZpbmQgb3V0IGFib3V0IGV4aXN0aW5nIGluZGV4ZXMgZm9yIHRoYXQgZmllbGQsIGNyZWF0ZSBvbmUgaWYgbmVlZGVkXHJcbiAgICAgICAgICAgIC8vICBmaW5kIG91dCBhYm91dCBleGlzdGluZyBjb25zdHJhaW50cywgc3VjaCBhcyBub3RfbnVsbFxyXG4gICAgICAgICAgICAvLyAgIHBlcmhhcHMgbm90X251bGwgY2FuIGJlIGEgdmFsdWUgY29uc3RyYWludCAtIGJ1dCBpdCdzIHNvbWV0aGluZyB0aGF0IHRyYW5zbGF0ZXMgcmVhZGlseSBpbnRvIHRoZSBkYXRhYmFzZSBzeXN0ZW0uXHJcblxyXG4gICAgICAgICAgICAvLyB0aGlzIHdpbGwgYmUgZm9yIHNldHRpbmcgc2luZ2xlIGZpZWxkIGluZGV4ZXMuXHJcblxyXG4gICAgICAgICAgICAvLyBPdGhlciBpbmRleGVzIGNvdWxkIGJlIGRlZmluZWQgd2l0aCBtdWx0aXBsZSBmaWVsZHMuXHJcblxyXG4gICAgICAgICAgICAvLyBXaWxsIGJlIHVzZWZ1bCBmb3IgaXRlcmF0aW5nIHRocm91Z2ggYSBjb2xsZWN0aW9uLCBnZXR0aW5nIHRoZSB2YWx1ZXMgdGhhdCBtYXRjaCB0d28gZ2l2ZW4gdmFsdWVzLlxyXG5cclxuICAgICAgICB9XHJcbiAgICAgICAgKi9cclxuXHJcbiAgICB9KSxcclxuXHJcblxyXG4gICAgLy8gdW5pcXVlLCBub3RfbnVsbCBiZWluZyB0aGUgZmllbGQgY29uc3RyYWludHMgaW4gYWN0aW9uLlxyXG5cclxuICAgIC8vICB1bmlxdWUgY291bGQgYXBwbHkgdG8gbXVsdGlwbGUgZmllbGRzIGF0IG9uY2UuIFdvdWxkIG5lZWQgdGhlIGluZGV4IHdpdGggdGhvc2UgdHdvIGZpZWxkcyBsb29raW5nIGZvciBjb2xsaXNpb25zLlxyXG5cclxuICAgIC8vIGNvbnN0cmFpbnRzOiB7XHJcbiAgICAvL1x0J3VuaXF1ZSc6IFsnc2Nob29sX2Rpc3RyaWN0JywgJ2Rpc3RyaWN0X3NjaG9vbF9pZCddXHJcbiAgICAvL31cclxuXHJcbiAgICAvLyB3aWxsIGFsc28gdHJ5IHRvIGdldCBhIGZpZWxkIGNvbnN0cmFpbnQsIGJhc2VkIG9uIHRoZSBmaWVsZC5cclxuICAgIC8vICBidXQgbWF5IGFsc28gZG8gaXQgYmFzZWQgb24gdHlwZSwgbWF5YmUgZ2V0X2ZpZWxkX2RhdGFfdHlwZV9jb25zdHJhaW50XHJcblxyXG4gICAgJ3NldF9maWVsZF9kYXRhX3R5cGVfY29uc3RyYWludCc6IGZ1bmN0aW9uKGZpZWxkX25hbWUsIGRhdGFfdHlwZV9jb25zdHJ1Y3Rvcikge1xyXG4gICAgICAgIC8vIHRoZXNlIGR0Y3MgYXJlIHNlcGFyYXRlIHRvIHRoZSBmaWVsZHMgdGhlbXNlbHZlcy5cclxuXHJcbiAgICAgICAgLy8gTWF5IGJlIGJldHRlciB1c2luZyB0aGUgRmllbGRfQ29sbGVjdGlvbiBoZXJlLlxyXG5cclxuICAgICAgICB2YXIgZm1jID0gdGhpcy5fbWFwX2ZpZWxkX2NvbnN0cmFpbnRzID0gdGhpcy5fbWFwX2ZpZWxkX2NvbnN0cmFpbnRzIHx8IHt9O1xyXG4gICAgICAgIHZhciBmbWZjID0gZm1jW2ZpZWxkX25hbWVdO1xyXG4gICAgICAgIGlmIChmbWZjKSB7XHJcbiAgICAgICAgICAgIHZhciBkZWxldGlvbl9pbmRleDtcclxuICAgICAgICAgICAgZWFjaChmbWZjLCBmdW5jdGlvbihpLCB2KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBpZiBpdCBpcyBhIEZpZWxkX0RhdGFfVHlwZV9Db25zdHJhaW50XHJcbiAgICAgICAgICAgICAgICBpZiAodiBpbnN0YW5jZW9mIENvbnN0cmFpbnQuRmllbGRfRGF0YV9UeXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9yZXR1cm4gdjtcclxuICAgICAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh2LmRhdGFfdHlwZV9jb25zdHJ1Y3RvciA9PT0gZGF0YV90eXBlX2NvbnN0cnVjdG9yKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlcGxhY2UgdGhhdCBvbmUuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0aW9uX2luZGV4ID0gaTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcblxyXG4gICAgICAgICAgICBpZiAoaXNfZGVmaW5lZChkZWxldGlvbl9pbmRleCkpIHtcclxuICAgICAgICAgICAgICAgIGZtZmMuc3BsaWNlKGRlbGV0aW9uX2luZGV4LCAxKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBjcmVhdGUgdGhlIG5ldyBjb25zdHJhaW50IG9iamVjdC5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgJ2dldF9maWVsZF9kYXRhX3R5cGVfY29uc3RyYWludCc6IGZ1bmN0aW9uKGZpZWxkX25hbWUpIHtcclxuICAgICAgICB2YXIgZm1jID0gdGhpcy5fbWFwX2ZpZWxkX2NvbnN0cmFpbnRzO1xyXG4gICAgICAgIC8vIGZpZWxkX2NvbnN0cmFpbnRzIC0gdGhleSBhcmUgY29uc3RyYWludHMgdGhhdCBhcHBseSB0byB0aGUgZmllbGRzLiBUaGV5IGFyZSBub3QgdGhlIGxpc3Qgb2YgZmllbGRzLlxyXG4gICAgICAgIHZhciByZXN1bHQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgLy9cclxuICAgICAgICBpZiAoZm1jKSB7XHJcbiAgICAgICAgICAgIHZhciBmbWZjID0gZm1jW2ZpZWxkX25hbWVdO1xyXG4gICAgICAgICAgICBpZiAoZm1mYykge1xyXG4gICAgICAgICAgICAgICAgZWFjaChmbWZjLCBmdW5jdGlvbiAoaSwgdikge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIGl0IGlzIGEgRmllbGRfRGF0YV9UeXBlX0NvbnN0cmFpbnRcclxuICAgICAgICAgICAgICAgICAgICBpZiAodiBpbnN0YW5jZW9mIENvbnN0cmFpbnQuRmllbGRfRGF0YV9UeXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHY7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9LFxyXG5cclxuXHJcbiAgICAvL1xyXG5cclxuICAgIC8vIGVuc3VyZV9jb25zdHJhaW50X2Zyb21fZmllbGRcclxuICAgIC8vIGVuc3VyZV9jb25zdHJhaW50c19mcm9tX2ZpZWxkXHJcbiAgICAvLyAgY2FuIGhhdmUgYSBub3QgbnVsbCBjb25zdHJhaW50LCBjYW4gaGF2ZSBhIGRhdGEgdHlwZSBjb25zdHJhaW50LlxyXG4gICAgLy8gIGNhbiBiZSBnaXZlbiB0aGUgd2hvbGUgW2ZpZWxkX25hbWUsIFtzdHJfZmllbGQsIG9ial9maWVsZF9pbmZvXV1cclxuICAgIC8vIHBvc3NpYmx5IG5vdF9udWxsIGNvbnN0cmFpbnQgd291bGQgYmUgcGFydCBvZiBkYXRhIHR5cGUgY29uc3RyYWludD9cclxuICAgIC8vICBlYXNpZXIgdG8gaGF2ZSBzZXBhcmF0ZSBub3QgbnVsbCBjb25zdHJhaW50LlxyXG5cclxuICAgIC8vIG9uY2Ugd2UgaGF2ZSB0aGUgZmllbGQsIHRoZXJlIGFyZSBzb21lIHBvc3NpYmxlIGNvbnN0cmFpbnRzLlxyXG4gICAgLy8gIGNvdWxkIGhhdmUgdGhlbSBpbmRleGVkLi4uIGFuIG9iaiBzYXlpbmcgbm90X251bGwsIHdpdGggbGluayB0byBjb25zdHJhaW50IGlmIGl0IGlzIHRoZXJlLlxyXG4gICAgLy8gIF9tYXBfZmllbGRfY29uc3RyYWludHMuLi5cclxuICAgIC8vICBfbWFwX2ZpZWxkX2NvbnN0cmFpbnRzW2ZpZWxkX25hbWVdW2NvbnN0cmFpbnRfdHlwZV9uYW1lXVxyXG4gICAgLy8gIF9tYXBfZmllbGRfY29uc3RyYWludHNbZmllbGRfbmFtZV1bJ211bHRpX2ZpZWxkJ11cclxuICAgIC8vICAgYW5kIHRoZW4gdGhlcmUgaXMgYSBsaXN0IG9mIGFsbCB0aGUgY29uc3RyYWludHMgdGhhdCBoYXZlIGdvdCB0aGUgZmllbGQgbWVudGlvbmVkLi4uXHJcblxyXG4gICAgLy8gc29tZSBvZiB0aGVzZSB0aGluZ3MgY291bGQgYmUgZG9uZSB3aXRoIGEgcXVpY2sgc2VhcmNoLlxyXG5cclxuXHJcbiAgICAvLyAgIHdoZW4gd2UgaGF2ZSB0aGUgZmllbGQgbmFtZSwgd2UgY2FuIHJlZmVyIHRvIGFsbCBpdHMgY29uc3RyYWludHMgZnJvbSB0aGlzLlxyXG5cclxuICAgIC8vIGFuZCB0aGVuIHRoZXJlIHNob3VsZCBiZSB0aGUgKEtWUykgbWFwIG9mIHVuaXF1ZSBjb25zdHJhaW50cyBvcmRlcmVkIGJ5IGFscGhhYmV0aWMgZmllbGRzLi4uXHJcbiAgICAvLyAgYWxzbyBzdG9yaW5nIHdoZW4gYSBmaWVsZCBpcyBtZW50aW9uZWQgaW4gYSBjb25zdHJhaW50LCBidXQgaXQncyBub3QgdGhlIG9ubHkgZmllbGQ/XHJcbiAgICAvLyAgIHdoZW4gZGVsZXRpbmcgYSBmaWVsZCB3ZSdsbCBuZWVkIHRvIGdldCBhbGwgY29uc3RyYWludHMgdGhhdCBhIGZpZWxkIGlzIGludm9sdmVkIGluLlxyXG5cclxuICAgIC8vXHJcblxyXG5cclxuXHJcbiAgICAvLyAgY2FuIGFsc28gYmUgZ2l2ZW4gW2ZpZWxkX25hbWUsIHN0cl9maWVsZF0sIGNhbiBjYWxjdWxhdGUgdGhlIGNvbnN0cmFpbnQgb2JqZWN0LlxyXG4gICAgLy8gICBtYXkgYXQgdGltZXMgYmUgZ2l2ZW4gdGhlIG9ial9maWVsZF9pbmZvIGFuZCBuZWVkIHRvIG1ha2UgdGhlIHRleHQgcmVwcmVzZW50YXRpb25cclxuXHJcblxyXG5cclxuICAgICdlbnN1cmVfZmllbGRfY29uc3RyYWludCc6IGZwKGZ1bmN0aW9uKGEsIHNpZykge1xyXG5cclxuICAgICAgICAvLyB0aGlzIHdvdWxkIGFsc28gaGF2ZSB0byBpbnRlcmFjdCB3aXRoIHRoZSBmaWVsZCBvYmplY3QgaWYgbmVjZXNzYXJ5LCBrZWVwaW5nIHRoaW5ncyBpbiBzeW5jLlxyXG5cclxuICAgICAgICAvLyB3aWxsIGhhdmUgZGlmZmVyZW50IGZpZWxkX2NvbnN0cmFpbnQgbWFwcy5cclxuICAgICAgICAvLyBvciBhIG1hcCBvZiB0aGUgZmllbGRzIHRvIHRoZSBjb25zdHJpYWludCB0eXBlcy5cclxuICAgICAgICAvL1xyXG5cclxuXHJcbiAgICAgICAgLy8gKGZjX21hcFtmaWVsZF9uYW1lXVsndW5pcXVlJ10pXHJcbiAgICAgICAgLy8gZmNfbWFwW2ZpZWxkX25hbWVdWydkYXRhX3R5cGUnXVxyXG4gICAgICAgIC8vIGZjX21hcFtmaWVsZF9uYW1lXVsnbm90X251bGwnXVxyXG5cclxuXHJcblxyXG4gICAgICAgIC8vICBlbnN1cmVzIGEgc2luZ2xlIGNvbnN0cmFpbnQ/XHJcbiAgICAgICAgLy8gW3Msc10gY2FuIHBhcnNlIHRoZSBmaWVsZCB0ZXh0XHJcblxyXG4gICAgICAgIGlmIChzaWcgPT0gJ1tzLG9dJykge1xyXG4gICAgICAgICAgICB2YXIgZmllbGRfbmFtZSA9IGFbMF07XHJcbiAgICAgICAgICAgIHZhciBmaWVsZF9pbmZvID0gYVsxXTtcclxuXHJcbiAgICAgICAgICAgIC8vIERpZmZlcmVudCBjb25zdHJhaW50cyB0aGF0IGNhbiBhcHBseSB0byB0aGUgZmllbGQuLi4gYnV0IGxpa2VseSB0byBiZSBhIGRhdGFfdHlwZSBjb25zdHJhaW50IHJlYWxseS5cclxuXHJcblxyXG5cclxuICAgICAgICAgICAgLy8gY2FuIGVuc3VyZSBub3QgbnVsbCBhbmQgZGF0YSB0eXBlXHJcblxyXG4gICAgICAgICAgICAvLyBPSy4uLiBsb29rcyBsaWtlIHRoZSBmaWVsZF9jb25zdHJhaW50cyB3aWxsIG5lZWQgdG8gYmUgb3JnYW5pemVkIHNvbWVob3cuXHJcbiAgICAgICAgICAgIC8vICBUaGV5IGFyZSBhbm90aGVyIHRoaW5nIHRoYXQgcGVyaGFwcyBhIHNpbXBsZSBpbmRleGluZyBzeXN0ZW0gd291bGQgaGVscCB3aXRoLlxyXG4gICAgICAgICAgICAvLyBXaWxsIGJlIG9yZ2FuaXppbmcgdGhlbSB1c2luZyB0aGUgbmF0aXZlIEphdmFTY3JpcHQgb2JqZWN0cy5cclxuXHJcbiAgICAgICAgICAgIC8vIEhhdmluZyBhbiBhcnJheSBvZiBmaWVsZF9jb25zdHJhaW50cyBtYWtlcyBzZW5zZSwgc28gdGhhdCB0aGUgb3JkZXIgaXMgbWFpbnRhaW5lZC5cclxuXHJcbiAgICAgICAgICAgIC8vIGFycmF5IG9mIGZpZWxkIGNvbnN0cmFpbnRzLlxyXG4gICAgICAgICAgICAvLyBtYXAgb2YgZmllbGQgY29uc3RyYWludHMuXHJcblxyXG4gICAgICAgICAgICAvL3RoaXMuX2Fycl9maWVsZF9jb25zdHJhaW50cyA9IHRoaXMuX2Fycl9maWVsZF9jb25zdHJhaW50cyB8fCBbXTtcclxuXHJcbiAgICAgICAgICAgIC8vICBub3Qgc28gc3VyZSBhYm91dCB0aGlzIGFycmF5IG9mIGNvbnN0cmFpbnRzIGFnYWluLlxyXG4gICAgICAgICAgICAvLyAgcGVyaGFwcyBvbmx5IGtlZXBpbmcgdGhlbSBpbiB0aGUgbWFwIGlzIGVub3VnaC5cclxuXHJcbiAgICAgICAgICAgIC8vIGZpZWxkIGNvbnN0cmFpbnRzX2J5X2ZpZWxkXHJcbiAgICAgICAgICAgIC8vIF9tYXBfZmllbGRfY29uc3RyYWludHMuLi4gdGhpcyB3aWxsIGhvbGQgdGhlIGNvbnN0cmFpbnRzIGJ5IGZpZWxkLlxyXG4gICAgICAgICAgICAvLyAgdGhlcmUgbWF5IG5vdCBiZSBtb3JlIHRoYW4gb25lIGNvbnN0cmFpbnQgZm9yIGEgcGFydGljdWxhciBmaWVsZCwgdGhlcmUgbWF5IGJlIGEgbWFwIG9mIHN1Y2ggY29uc3RyYWludHMuXHJcblxyXG4gICAgICAgICAgICAvLyBzbyBpdCdzIG9yZ2FuaXplZCBieSBmaWVsZCBoZXJlLi4uIGVhc2llciB0byBnZXQgdGhlIGV4aXN0aW5nIGZpZWxkIGNvbnN0cmFpbnRzLCBvdmVyd3JpdGUgdGhlbSwgb3IgY3JlYXRlIGEgbmV3IG9uZSxcclxuICAgICAgICAgICAgLy8gIG9yIHRvIGxvb2sgaXQgdXAuXHJcblxyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdmaWVsZF9pbmZvICcgKyBzdHJpbmdpZnkoZmllbGRfaW5mbykpO1xyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdhICcgKyBzdHJpbmdpZnkoYSkpO1xyXG5cclxuICAgICAgICAgICAgLy8gV2lsbCBfbWFwX2ZpZWxkX2NvbnN0cmFpbnRzIGJlIGluIHRoZSBGaWVsZF9Db2xsZWN0aW9uP1xyXG5cclxuICAgICAgICAgICAgdGhpcy5fbWFwX2ZpZWxkX2NvbnN0cmFpbnRzID0gdGhpcy5fbWFwX2ZpZWxkX2NvbnN0cmFpbnRzIHx8IHt9O1xyXG4gICAgICAgICAgICB0aGlzLl9tYXBfZmllbGRfY29uc3RyYWludHNbZmllbGRfbmFtZV0gPSB0aGlzLl9tYXBfZmllbGRfY29uc3RyYWludHNbZmllbGRfbmFtZV0gfHwgW107XHJcbiAgICAgICAgICAgIC8vIGRvbid0IHdhbnQgYW4gYXJyYXkgb2YgY29uc3RyYWludHMgdGhlcmUuLi5cclxuICAgICAgICAgICAgLy8gIHRoZXJlIGFyZSBub3QgbWFueSBjb25zdHJhaW50cyB0aGF0IGNhbiBiZSB0aGVyZSwgc3VjaCBhcyBkYXRhX3R5cGUsIG5vdF9udWxsXHJcblxyXG4gICAgICAgICAgICAvLyBUaGUgY29uc3RyYWludHMgb25seSBhcHBseSB0byBmaWVsZHMgaW5kaXZpZHVhbGx5XHJcbiAgICAgICAgICAgIC8vICBUaGVyZSBjYW4gYmUgY29sbGVjdGlvbiBjb25zdHJhaW50cyB0aGF0IGFwcGx5LCB0aGV5IGNhbiBiZSBzcGVjaWZpZWQsIGFuZCB0aGV5IGdldCBhcHBsaWVkIHRvIHRoZSByZWxldmFudCBjb2xsZWN0aW9uLlxyXG5cclxuXHJcblxyXG5cclxuICAgICAgICAgICAgdmFyIGZjX2l0ZW1fYXJyID0gdGhpcy5fbWFwX2ZpZWxkX2NvbnN0cmFpbnRzW2ZpZWxkX25hbWVdO1xyXG4gICAgICAgICAgICAvLyBIYXZlIHRoZSBmaWVsZHMgcmVmZXJlbmNpbmcgdGhlaXIgY29uc3RyYWludHMuXHJcbiAgICAgICAgICAgIC8vICBBbHNvIGhhdmUgYSBtYXAgLyBzb3J0ZWQgS1ZTIG9mIGNvbnN0cmFpbnRzIGJ5IHRoZSBmaWVsZHMgdGhleSBhcmUgZm9yLCBkaWZmZXJlbnQgd2F5cyB0aGV5IG5lZWQgdG8gYmUgbG9va2VkIHVwXHJcbiAgICAgICAgICAgIC8vICAgYWxoYWJldGljYWxseSBzb3J0ZWQgbGlzdCBvZiB1bmlxdWUgZmllbGRzIGtlcHQgaW4gYSBLVlNcclxuICAgICAgICAgICAgLy8gICAgbm8gc3VjaCB0aGluZyBhcyBhIHVuaXF1ZSBpbmRleCAtIG9ubHkgdW5pcXVlIGNvbnN0cmFpbnQuXHJcbiAgICAgICAgICAgIC8vICAgYSBzaW5nbGUgZmllbGQgY2FuIGJlIHVuaXF1ZSAoaGF2ZSBhIHVuaXF1ZSBjb25zdHJhaW50KVxyXG4gICAgICAgICAgICAvLyAgIGEgdW5pcXVlIGNvbnN0cmFpbnQgY2FuIGFwcGx5IHRvIG11bHRpcGxlIGZpZWxkcy5cclxuXHJcbiAgICAgICAgICAgIC8vIG1hcCBvZiBmaWVsZHMgb2JqZWN0cyBieSBuYW1lXHJcbiAgICAgICAgICAgIC8vICBhcyB3ZWxsIGFzIGFycmF5IG9mIGZpZWxkc1xyXG4gICAgICAgICAgICAvLyAgIHRoZSBGaWVsZHMgb2JqZWN0IC0gcGVyaGFwcyBpdCBzaG91bGQgYmUgZGVmaW5lZCBhcyBpdHMgb3duIGNsYXNzLlxyXG4gICAgICAgICAgICAvLyAgICBJdCB3b3VsZCBtYWtlIHNlbnNlLlxyXG4gICAgICAgICAgICAvLyBBIHVuaXF1ZSBjb25zdHJhaW50IGRvZXMgbm90IHJlYWxseSBhcHBseSB0byB0aGUgZmllbGQsIGJ1dCBtb3JlIHRvIHRoZSBjb2xsZWN0aW9uLCB3aXRoIHJlZmVyZW5jZSB0byB0aGUgZmllbGQuXHJcbiAgICAgICAgICAgIC8vICBJdCdzIHN0aWxsIGluZm9ybWF0aW9uIHRoYXQgc2hvdWxkIGdldCBzdG9yZWQgYWxvbmdzaWRlIHRoZSBmaWVsZC5cclxuXHJcblxyXG4gICAgICAgICAgICAvLyBsb29raW5nIGZvciBhbiBleGlzdGluZyBjb25zdHJhaW50IGFscmVhZHkuXHJcbiAgICAgICAgICAgIC8vICB0aGUgd2hvbGUgc3l0ZW0gY2FuIGJlIGltcHJvdmVkLlxyXG4gICAgICAgICAgICAvLyBJIHRoaW5rIGhhdmluZyBhbiBhY3R1YWwgLl9maWVsZHMgb2JqZWN0IHdvdWxkIGhlbHAuXHJcbiAgICAgICAgICAgIC8vICBJdCB3b3VsZCBiZSBhbiBhcnJheSAob3Igc2ltcGxlciBjb2xsZWN0aW9uPylcclxuICAgICAgICAgICAgLy8gICBBIHNpbXBsZSBjb2xsZWN0aW9uIGNvdWxkIGJlIHF1aXRlIG5pY2UgaWYgaXQgaGFzIEIrIGluZGV4aW5nIGNhcGFiaWxpdHkuXHJcbiAgICAgICAgICAgIC8vICAgIEJ1dCB0aGUgd2hvbGUgdGhpbmcgaGFzIGdvdCBhIGJpdCBjb21wbGljYXRlZCBhbnl3YXkgd2l0aCBEYXRhX09iamVjdC5cclxuICAgICAgICAgICAgLy8gSnVzdCBhbiBhcnJheSB3b3VsZCBkbyBmaW5lIGZvciB0aGUgbW9tZW50LlxyXG4gICAgICAgICAgICAvLyAgV2FudCB0byBiZSBzdXJlIG9mIG1haW50YWluaW5nIHRoZSBvcmRlci5cclxuICAgICAgICAgICAgLy8gICBfbWFwX2ZpZWxkcyBnb2VzIHRvIHRoZSBmaWVsZCBieSBuYW1lLlxyXG5cclxuICAgICAgICAgICAgLy8gVGhlIGZpZWxkIHdpbGwgcmVmZXJlbmNlIGJvdGggaW5kZXhlcyBhbmQgY29uc3RyYWludHMuXHJcbiAgICAgICAgICAgIC8vICBJbmRleGVzIGFuZCBjb25zdHJhaW50cyB3aWxsIHJlZmVyIHRvIHBhcnRpY3VsYXIgZmllbGRzLCBvZnRlbiBieSBuYW1lLlxyXG5cclxuICAgICAgICAgICAgLy8gRG9uJ3Qgd2FudCBjb21wbGljYXRlZCBkYXRhIHR5cGVzIHRvIGRvIHdpdGggZmllbGRzLlxyXG4gICAgICAgICAgICAvLyAgVGhlcmUgaXMgYSBfZmllbGRzIG9iamVjdC5cclxuICAgICAgICAgICAgLy8gIF9hcnJfZmllbGRzXHJcbiAgICAgICAgICAgIC8vICBrdnNfZmllbGRzPyBpdCBzdG9yZXMgdGhlIGZpZWxkcyBieSBuYW1lIGluIGEga3ZzLiBhbHNvIGZvciBtdWx0aS1maWVsZCBjb25zdHJhaW50cyBhbmQgaW5kZXhlcz9cclxuXHJcbiAgICAgICAgICAgIC8vIERvaW5nIHRoZSBpbmRpdmlkdWFsIGZpZWxkcywgYW5kIGFsc28gdGhlIG11bHRpcGxlIGZpZWxkcyB3aGVuIHRoZXkgYXJlIGFwcGxpZWQgdG9nZXRoZXIuXHJcblxyXG5cclxuXHJcblxyXG5cclxuICAgICAgICAgICAgLy8gVGhhdCBpcyBhIGZhaXJseSBtYWpvciBjaGFuZ2UgZm9yIHRoZSBkYXRhX29iamVjdC5cclxuICAgICAgICAgICAgLy8gIFdpbGwgbm90IGhhdmUgdGhlIGNvbnN0cmFpbnQgbWFwIGp1c3QgYXMgaXQgaXMuXHJcbiAgICAgICAgICAgIC8vICBUaGVyZSB3aWxsIGJlIHRoZSBpbmRleCBmb3IgbXVsdGktZmllbGQgY29uc3RyYWludHMsIGJ1dCBqdXN0IGEgc2ltcGxlIGFycmF5IGZvciB0aGUgZmllbGRzLlxyXG4gICAgICAgICAgICAvLyAgX21hcF9maWVsZF9jb25zdHJhaW50c1tmaWVsZDFfbmFtZV1bZmllbGQyX25hbWVdW2FycmF5IG9mIGNvbnN0cmFpbnRzIGFwcGx5aW5nIHRvIHRoYXQgZmllbGQgY29tYmluYXRpb25dXHJcblxyXG4gICAgICAgICAgICAvLyBJIHRoaW5rIHRoZSBCKyBLVlMgd2lsbCBiZSBiZXR0ZXIgZm9yIHN0b3JpbmcgdGhlIGNvbnN0cmFpbnRzIGJ5IHRoZWlyIGZpZWxkcy5cclxuICAgICAgICAgICAgLy9cclxuXHJcblxyXG5cclxuICAgICAgICAgICAgdmFyIGR0X2luZm8gPSBmaWVsZF9pbmZvLmRhdGFfdHlwZTtcclxuXHJcbiAgICAgICAgICAgIHZhciBuZXdfZHRfY29uc3RyYWludCA9IENvbnN0cmFpbnQuZnJvbV9vYmooZHRfaW5mbyk7XHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ25ld19kdF9jb25zdHJhaW50ICcgKyBzdHJpbmdpZnkobmV3X2R0X2NvbnN0cmFpbnQpKTtcclxuXHJcbiAgICAgICAgICAgIGlmICghaXNfZGVmaW5lZChuZXdfZHRfY29uc3RyYWludCkpIHtcclxuICAgICAgICAgICAgICAgIC8vdGhyb3cgJzkpIE5ldyBjb25zdHJhaW50IGZyb21fb2JqIG5vdCBwcm9mdWNpbmcgY29uc3RyYWludCc7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgZHRfY29uc3RyYWludDtcclxuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2ZjX2l0ZW1fYXJyICcgKyBzdHJpbmdpZnkoZmNfaXRlbV9hcnIpKTtcclxuICAgICAgICAgICAgICAgIGlmIChmY19pdGVtX2Fyci5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgdXBkYXRpbmcgcmVsZXZhbnQgY29uc3RyYWludHMuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVhbGx5IGxvb2tpbmcgZm9yIHRoZSBkYXRhX3R5cGUgY29uc3RyYWludC5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGR0X2NvbnN0cmFpbnRzID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnZmNfaXRlbV9hcnIgJyArIHN0cmluZ2lmeShmY19pdGVtX2FycikpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHNob3VsZCBvbmx5IGJlIG9uZSBpbiB0aGVyZSBhdCBtYXhpbXVtXHJcbiAgICAgICAgICAgICAgICAgICAgZWFjaChmY19pdGVtX2FyciwgZnVuY3Rpb24oaSwgY29uc3RyYWludF9pdGVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2NvbnN0cmFpbnRfaXRlbSAnICsgc3RyaW5naWZ5KGNvbnN0cmFpbnRfaXRlbSkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnN0cmFpbnRfaXRlbSBpbnN0YW5jZW9mIENvbnN0cmFpbnQuRmllbGRfRGF0YV9UeXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdjb25zdHJhaW50X2l0ZW0gJyArIHN0cmluZ2lmeShjb25zdHJhaW50X2l0ZW0pKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29uc3RyYWludF9pbmZvID0gY29uc3RyYWludF9pdGVtLnRvX2luZm9fb2JqKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdjb25zdHJhaW50X2luZm8gJyArIHN0cmluZ2lmeShjb25zdHJhaW50X2luZm8pKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2ZpZWxkX2luZm8gJyArIHN0cmluZ2lmeShmaWVsZF9pbmZvKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0YWNrID0gbmV3IEVycm9yKCkuc3RhY2tcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coIHN0YWNrIClcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyAoJzYpIGl0IGlzISBzdG9wLCBjaGVjayB0byBzZWUgaWYgaXQgaXMgYSBGaWVsZF9EYXRhX1R5cGVfQ29uc3RyYWludCwgdXNlIGluc3RhbmNlT2YnKVxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSSB0aGluayBkZWxldGUgYW55IGV4aXN0aW5nIGR0IGNvbnN0cmFpbnRzP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgRG8gbm90aGluZyBpZiB0aGUgY29uc3RyYWludHMgbWF0Y2guLi5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gIFdpbGwgbGlrZWx5IGhhdmUgZXZlbnRzIHRvIGRvIHdpdGggYWRkaW5nIGFuZCByZW1vdmluZyBjb25zdHJhaW50cy5cclxuXHJcblxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgZXhpc3RpbmcgY29uc3RyYWludCBhZ2FpbnN0IHZhbHVlcyBnaXZlbi4gcG9zc2libHkgY2hhbmdlIGl0LCBwb3NzaWJseSByZXBsYWNlIGl0LlxyXG5cclxuXHJcblxyXG5cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZjX2l0ZW1fYXJyLnB1c2gobmV3X2R0X2NvbnN0cmFpbnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvL3Rocm93KCc3KSBzdG9wJyk7XHJcblxyXG5cclxuXHJcbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIG5vdGhpbmcgdGhlcmUsIGNyZWF0ZSBpdC5cclxuXHJcbiAgICAgICAgICAgIC8vIGlmIGl0J3MgdGhlcmUsIG92ZXJ3cml0ZSBhbnkgY29uc3RyYWludHMgd2l0aCB0aGUgcmVsZXZhbnQgb25lIGZyb20gdGhlIGZpZWxkIGluZm8gd2Ugd2VyZSBnaXZlbi5cclxuXHJcblxyXG5cclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygndGhpcy5fYXJyX2ZpZWxkX2NvbnN0cmFpbnRzICcgKyBzdHJpbmdpZnkodGhpcy5fYXJyX2ZpZWxkX2NvbnN0cmFpbnRzKSk7XHJcbiAgICAgICAgICAgIC8vdGhyb3coJzUgc3RvcCcpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9KSxcclxuXHJcbiAgICAnbWF0Y2hlc19maWVsZF9jb25zdHJhaW50cyc6IGZwKGZ1bmN0aW9uKGEsIHNpZykge1xyXG4gICAgICAgIGlmIChhLmwgPT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYXRjaGVzX2ZpZWxkX2NvbnN0cmFpbnRzKHRoaXMuX2ZpZWxkX2NvbnN0cmFpbnRzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGNvbXBhcmluZyBhbiBvYmplY3Qgd2l0aCBpdHMgZmllbGQgY29uc3RyYWludHMuLi4gdGhhdCBjb3VsZCBiZSBvdXRzaWRlIHRoaXMuXHJcblxyXG4gICAgICAgIC8vIGNoZWNrX2ZpZWxkX2NvbnN0cmFpbnRzXHJcbiAgICAgICAgLy8gIGRvZXMgdGhlIGNoZWNrIGFuZCBzYXlzIHdoZXJlIGl0IGZhaWxzXHJcblxyXG4gICAgICAgIC8vIG1hdGNoZXNfZmllbGRfY29uc3RyYWludHNcclxuICAgICAgICAvLyAgc3RvcHMgd2hlbiBpdCBmYWlscywgcmV0dXJucyBmYWxzZVxyXG5cclxuICAgICAgICAvLyBkb2VzIGEgRGF0YV9PYmplY3QgbWF0Y2ggY29uc3RyYWludHM/XHJcblxyXG4gICAgICAgIC8vIG1heSB3YW50IHRvIGNoZWNrIGlmIGEgRGF0YV9PYmplY3QgdGhhdCBnZXRzIHByb3ZpZGVkIG1hdGNoZXMgdGhlIGZpZWxkIGNvbnN0cmFpbnRzIHN0b3JlZCBpbiB0aGlzIERhdGFfT2JqZWN0LlxyXG4gICAgICAgIC8vICBPbmUgRGF0YV9PYmplY3QgY2FuIGJlIHVzZWQgYXMgcmVmZXJlbmNlIGZvciBkb2luZyBjaGVja3MuXHJcbiAgICAgICAgLy8gICBUaGUgRGF0YV9PYmplY3RzIHRoYXQgZ2V0IHB1dCBpbiBkb24ndCBoYXZlIHRoZSBjaGVja3MgYXMgcGFydCBvZiB0aGVtLCBidXQgdGhleSBtYXkgaGF2ZSBjaGVja3MgZG9uZSBvbiB0aGVtIGJlZm9yZSB0aGV5IGhhdmVcclxuICAgICAgICAvLyAgIGNvbXBsZXRlZCB1cGRhdGluZy4gVGhpcyBjb3VsZCBiZSB1c2VkIHRvIGluZGljYXRlIGFuIGVycm9yIHRvIHRoZSB1c2VyIGluIHRoZSBHVUkuXHJcblxyXG4gICAgICAgIC8vIFRoaXMgcmVhbGx5IHdvbid0IGJlIHNvIGhhcmQgdG8gZG8sIGFuZCB0byBnZXQgcmlnaHQuXHJcbiAgICAgICAgLy8gIEhvcGVmdWxseSBhbGwgdGhlc2UgdGhpbmdzIHdvdWxkIGJlIGFibGUgdG8gYmUgdXNlZCBmb3IgdmFyaW91cyBwYWNrYWdlcy5cclxuICAgICAgICAvLyBJIHRoaW5rIGRlY2xhcmF0aXZlIHdyaXRpbmcgb2YgbXVjaCBvZiBpdCwgc28gdGhhdCBhIExNUyBjb3VsZCBiZSBzZXQgdXAsIG9yIHNvbWV0aGluZyBmb3Igc29jaWFsIHNlcnZpY2VzIHRoYXRcclxuICAgICAgICAvLyAgZGVhbCB3aXRoIGluZm9ybWF0aW9uIGFib3V0IGluZGl2aWR1YWxzLCB3b3JrZmxvd3MsIGFuZCByZXBvcnRpbmcgKGhlbHBpbmcgcHJvZHVjZSB0aGUgcmVxdWlyZWQgZG9jdW1lbnRzIGFuZCBrZWVwXHJcbiAgICAgICAgLy8gIHVzZXJzIG9mIHRoZSBzeXN0ZW0gaW5mb3JtZWQpXHJcblxyXG4gICAgICAgIC8vY29uc29sZS5sb2coJ21hdGNoZXNfZmllbGRfY29uc3RyYWludHMgc2lnICcgKyBzaWcpO1xyXG5cclxuICAgICAgICBpZiAoc2lnID09ICdbRF0nKSB7XHJcbiAgICAgICAgICAgIC8vIERvZXMgdGhhdCBEYXRhX09iamVjdCBtYXRjaCB0aGUgY29uc3RyYWludHMgb2YgdGhpcyBvbmU/XHJcblxyXG4gICAgICAgICAgICB2YXIgZmNzID0gdGhpcy5fZmllbGRfY29uc3RyYWludHM7XHJcblxyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdmY3MgJyArIHN0cmluZ2lmeShmY3MpKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBvYmogPSBhWzBdO1xyXG5cclxuICAgICAgICAgICAgdmFyIGFsbF9tYXRjaCA9IHRydWUsIG9ial9maWVsZF92YWx1ZSwgbWF0Y2hlcztcclxuXHJcbiAgICAgICAgICAgIGVhY2goZmNzLCBmdW5jdGlvbihmaWVsZF9uYW1lLCBjb25zdHJhaW50KSB7XHJcbiAgICAgICAgICAgICAgICAvLyB0aGVzZSBjb25zdHJhaW50cyBjb3VsZCBwb3RlbnRpYWxseSBiZSBzb21ldGhpbmcgcXVpdGUgY29tcGxpY2F0ZWQgYW5kIG5lc3RlZC5cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBXZSB3b3VsZCBuZWVkIHRvIGJlIGNhcmVmdWwgYWJvdXQgdGhhdC5cclxuICAgICAgICAgICAgICAgIC8vIFdpbGwgdXNlIHRoaXMgZm9yIHNwZWNpZnlpbmcgSFRNTCBjb250cm9scywgYmVpbmcgc3VyZSB0aGV5IGFyZSBvdXRwdXQgaW4gYSBzdGFuZGFyZCBmb3JtYXQuXHJcblxyXG4gICAgICAgICAgICAgICAgb2JqX2ZpZWxkX3ZhbHVlID0gb2JqLmdldChmaWVsZF9uYW1lKTtcclxuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ29ial9maWVsZF92YWx1ZSAnICsgb2JqX2ZpZWxkX3ZhbHVlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdjb25zdHJhaW50ICcgKyBjb25zdHJhaW50KTtcclxuXHJcbiAgICAgICAgICAgICAgICBtYXRjaGVzID0gb2JqX21hdGNoZXNfY29uc3RyYWludChvYmpfZmllbGRfdmFsdWUsIGNvbnN0cmFpbnQpO1xyXG5cclxuICAgICAgICAgICAgICAgIGFsbF9tYXRjaCA9IGFsbF9tYXRjaCAmJiBtYXRjaGVzO1xyXG4gICAgICAgICAgICAgICAgLy9pZiAoIW1hdGNoZXMpIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIC8vIHJldHVybmluZyBmYWxzZSBmcm9tIHRoZSBtYWluIGxvb3A/XHJcbiAgICAgICAgICAgICAgICAvLyAgYnJlYWtpbmcgb3V0IG9mIG15IGVhY2ggbG9vcC4uLiBib3RoIHRoZXNlIHRoaW5ncyB3aWxsIG5lZWQgdG8gYmUgbG9va2VkIGludG8uXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gZWFjaCBjb3VsZCBiZSB1c2VkIHRvIGJ1aWxkIGEgcmVzdWx0Li4uIGJ1dCBkbyB3YW50IGJyZWFrIGNvbmRpdGlvbnMuXHJcblxyXG4gICAgICAgICAgICAgICAgLy9jaGVja192YWx1ZV9hZ2FpbnN0X2NvbnN0cmFpbnRcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBhIGZ1bmN0aW9uIHRvIGNoZWNrIGFnYWluc3QgdGhlIGNvbnN0cmFpbnRzLlxyXG4gICAgICAgICAgICAgICAgLy8gIHRoaXMgaXMgdG8gZG8gd2l0aCB0aGluZ3Mgbm8gbG9uZ2VyIHRvIGRvIHdpdGggRGF0YV9PYmplY3QsIHNob3VsZCBiZSBpbiBsYW5nLWVzc2VudGlhbHNcclxuICAgICAgICAgICAgICAgIC8vICBwb3NzaWJseSB3b3J0aCBtYWtpbmcgYW4gaW50ZXJtZWRpYXRlIGxldmVsLlxyXG4gICAgICAgICAgICAgICAgLy8gSXQncyBnb2luZyBvdXRzaWRlIG9mIHRoZSBlc3NlbnRpYWxzLCBidXQgaXQgc3RpbGwgaXMgcHJldHR5IGltcG9ydGFudFxyXG4gICAgICAgICAgICAgICAgLy8gTWF5YmUgaGF2ZSBjb3JlLCB3aGljaCBpbmNsdWRlcyBlc3NlbnRpYWxzIGFuZCB2YWxpZGF0aW9uLCBvciB2YWxpZF9kYXRhXHJcbiAgICAgICAgICAgICAgICAvLyAgQ291bGQgaGF2ZSBhIGNvbnN0cmFpbnRzIG1vZHVsZS5cclxuICAgICAgICAgICAgICAgIC8vICAgVGhpcyB3b3VsZCBiZSB3b3JraW5nIGluIGEgbmVzdGVkIHdheSwgdGhlIGNvbnN0cmFpbnRzIGNvdWxkIGJlIG5lc3RlZC5cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDb25zdHJhaW50cyB3b3VsZCBiZSBkZWZpbmVkIGFzIG9iamVjdHMuXHJcbiAgICAgICAgICAgICAgICAvLyAgVGhleSB3b3VsZCBvZnRlbiBiZSBzcGVjaWZpZWQgYXMgdGV4dCwgc3VjaCBhcyAnaW50Jy5cclxuICAgICAgICAgICAgICAgIC8vICBUaGV5IGNvdWxkIGJlIHNwZWNpZmllZCB0byBiZSBhbiBhcnJheSwgbGlrZSBbWydyZWQnLCAnaW50J10sIFsnZ3JlZW4nLCAnaW50J10sIFsnYmx1ZScsICdpbnQnXV1cclxuICAgICAgICAgICAgICAgIC8vICBIYXZpbmcgYSBjb25zdHJhaW50IG9iamVjdCB3b3VsZCBoZWxwIHRvIHN0b3JlIG1hcHMgdGhhdCBhcmUgZ2VuZXJhdGVkIHRvIGhlbHAgd2l0aCB0aGF0IGNvbnN0cmFpbnQuXHJcbiAgICAgICAgICAgICAgICAvLyAgVGhleSB3b3VsZCBhbHNvIGFjdCBhcyBpbmRleGVzIGZvciBzb21lIGFycmF5cywgaGVscGluZyB3aXRoIHRoZSBKYXZhU2NyaXB0IGltcGxlbWVudGF0aW9uLlxyXG5cclxuICAgICAgICAgICAgICAgIC8vICB2YWxpZF9kYXRhIG1heSBiZSBhIGdvb2QgbmFtZSBiZWNhdXNlIGl0IHdpbGwgcG90ZW50aWFsbHkgaGF2ZSBzb21lIG1vcmUgZGF0YSBoYW5kbGluZyBmYWNpbGl0aWVzLCBzdWNoIGFzIGRlYWxpbmcgd2l0aFxyXG4gICAgICAgICAgICAgICAgLy8gIG5lc3RlZCBkYXRhLiBJIG1heSBiZSBtb3ZpbmcgZnVuY3Rpb25hbGl0eSBvdXQgb2YgTmVzdGVkIGFuZCBwdXR0aW5nIGl0IHNvbWV3aGVyZSBzaW1wbGVyLCBtYXliZSBJJ2xsIGJlIGJldHRlciBhYmxlIHRvIGV4cHJlc3MgaXRcclxuICAgICAgICAgICAgICAgIC8vICB3aXRoIHJlY3Vyc2l2ZSBmdW5jdGlvbnMuXHJcbiAgICAgICAgICAgICAgICAvLyBXaWxsIGJlIGRlYWxpbmcgd2l0aCBkYXRhIHR5cGVzIGF0IGRpZmZlcmVudCBsZXZlbHMuXHJcbiAgICAgICAgICAgICAgICAvLyAgQ291bGQgYmUgbW9yZSBzeXN0ZW1hdGljIGFib3V0IG1hcHMgdGhhdCBleHByZXNzIHBvc2l0aW9ucyBvZiBpdGVtcyBpbiBhcnJheXMuXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSSB0aGluayB0aGF0IHNpZGUgb2YgdGhpbmdzLCB0aWR5aW5nIGl0IHVwIGEgbG90LCB3aWxsIGhlbHAgd2l0aCBnZXR0aW5nIHRoZXNlIHRoaW5ncyBydW5uaW5nIGNvcnJlY3RseSBpbiBhIHdlYiBzZXJ2ZXIuXHJcblxyXG5cclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAvLyBXaWxsIGJlIGZhc3RlciB0byBicmVhayBvdXQgb2YgZWFjaCBsb29wLlxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGFsbF9tYXRjaDtcclxuICAgICAgICB9XHJcblxyXG5cclxuXHJcbiAgICAgICAgaWYgKHNpZyA9PSAnW29dJykge1xyXG5cclxuICAgICAgICAgICAgLy8gbWF5IHdhbnQgdG8gdGVzdCBpZiBhbiBvYmplY3QgbWF0Y2hlcyB0aGUgZmllbGQgY29uc3RyYWludHMuXHJcblxyXG4gICAgICAgICAgICAvLyBvYmVqY3QgcmVwcmVzZW50aW5nIHRoZSBjb25zdHJhaW50cy4uLlxyXG4gICAgICAgICAgICAvLyAgc2VlaW5nIGlmIHRoaXMgRGF0YV9PYmplY3QgbWVldHMgdGhvc2UgY29uc3RyYWludHMuXHJcblxyXG4gICAgICAgICAgICAvLyB0aGVzZSBjb25zdHJhaW50cyBhcmUgZ2l2ZW4gYXMgYSBmaWVsZC5cclxuXHJcblxyXG5cclxuXHJcblxyXG4gICAgICAgICAgICAvLyBhbiBvYmplY3QgcmVwcmVzZW50aW5nIHRob3NlIGNvbnN0cmFpbnRzLlxyXG4gICAgICAgICAgICAvLyAgbm90IHVzaW5nIGEgRGF0YV9PYmplY3QgZm9yIHRoaXMgeWV0LlxyXG5cclxuICAgICAgICAgICAgLy8gZmluZCBvdXQgd2hpY2ggYXJlIHRoZSBjdXJyZW50IGtleXMgKGdldCBhIHRydXRoIG1hcCBvZiB0aGVtKVxyXG5cclxuICAgICAgICAgICAgLy8gc2VlIGlmIGFsbCBvZiB0aGUgY3VycmVudCBvbmVzIGFkaGVyZSB0byB0aGUgZ2l2ZW4gY29uc3RyYWludHNcclxuXHJcbiAgICAgICAgICAgIC8vIHNlZSBpZiBhbGwgb2YgdGhlIGdpdmVuIGNvbnN0cmFpbnRzIGhhdmUgYmVlbiBtZXRcclxuICAgICAgICAgICAgLy8gIGNvdWxkIGhhdmUgYSBtYXAgb2YgdGhlIGdpdmVuIGNvbnN0cmFpbnRzLCBhbmQgZGVsZXRlIHRoZW0gZnJvbSB0aGF0IG1hcCBhcyB0aGV5IGhhdmUgYmVlbiBtZXRcclxuICAgICAgICAgICAgLy8gIHRoZW4gZ28gdGhyb3VnaCB0aGUgbWFwIHVzaW5nIGVhY2ggdG8gc2VlIHdoaWNoIG9uZXMgaGF2ZSBub3QgYmVlbiBtZXQuXHJcblxyXG4gICAgICAgICAgICAvLyBNYXkgdXNlIHNvbWUgY29kZSB0byBkbyB3aXRoIGRhdGEgdHlwZXMuXHJcbiAgICAgICAgICAgIC8vICBXaXRoIHRoZSBIVE1MIHByb2Nlc3NpbmcsIHdpbGwgYmUgdGFraW5nIGluIGRhdGEgd2l0aCBmZXdlciBjb25zdHJhaW50cywgYW5kIHRyYW5zZm9ybWluZyBpdCBzbyBpdCBtYXRjaGVzIHdoYXQgaXMgcmVxdWlyZWQuXHJcblxyXG4gICAgICAgICAgICAvLyBJIHRoaW5rIHRoZXJlIHdpbGwgYmUgYSBmYWlyIGJpdCBtb3JlIGNvZGluZyB0byBnZXQgdGhlIEhUTUwgc3lzdGVtIGZ1bGx5IHJ1bm5pbmcgd2l0aCB0aGUgbmV3ZXIgRGF0YV9PYmplY3QgYWJzdHJhY3Rpb24sXHJcbiAgICAgICAgICAgIC8vICBhbmQgZGF0YSB0eXBlcyBhbmQgdHJhbnNmb3JtYXRpb25zIHNwZWNpZmllZCBpbiB0ZXJtcyBvZiB0aGUgZGF0YSB0eXBlLCBtZWFuaW5nIHRoYXQgdGhlIGNvZGUgd2lsbCBiZSBtb3JlIGNvbmNpc2UgYW5kIGRlY2xhcmF0aXZlXHJcbiAgICAgICAgICAgIC8vIFNvbWUgcXVpdGUgY29tcGxleCB0aGluZ3MgdG8gZG8gd2l0aCBpbmRleGluZyBhbmQgZGF0YSB0cmFuc2Zvcm1hdGlvbiBnZXQgZG9uZSBlbHNld2hlcmUsIGZvciBleGFtcGxlLlxyXG5cclxuICAgICAgICAgICAgLy8gSSBhbSBleHBlY3RpbmcgdG8gZ2V0IHRoaXMgdG8gd29yayBmYWlybHkgc29vbiwgSSBoYXZlIG1hZGUgYSBsb3Qgb2YgcHJvZ3Jlc3MgcmVjZW50bHkuXHJcbiAgICAgICAgICAgIC8vIEhhdmluZyB0aGUgY29kZSBleGVjdXRpbmcgYW5kIHByb2R1Y2luZyBhIHdlYnNpdGUgd2lsbCBiZSB2ZXJ5IG5pY2UuXHJcbiAgICAgICAgICAgIC8vICBXb3VsZCBiZSBnb29kIHRvIGdldCBhIHBvcnRmb2xpbyBvbmxpbmUsIGJ1dCB2ZXJ5IGdvb2QgaW5kZWVkIGlmIGl0IGxvYWRzIHF1aWNrbHksIGhhcyBhIG5pY2UgbWVudSwgYW5kIGp1c3QgZ2VuZXJhbGx5IGlzIG15XHJcbiAgICAgICAgICAgIC8vICBwcm9mZXNzaW9uYWwgLyBidXNpbmVzcyB3ZWJzaXRlLlxyXG5cclxuICAgICAgICAgICAgLy8gSXQgZG9lcyBzZWVtIGxpa2UgYSByZWFsIGJ1c2luZXNzIHByaW9yaXR5IHRvIGdldCB0aGlzIHNpdGUgdXAgb25saW5lLlxyXG4gICAgICAgICAgICAvLyAgSXQgY291bGQgYmUgdmVyeSB1c2VmdWwgZm9yIGN1c3RvbWVycywgbWF5YmUgaWYgSSBhbSBkb2luZyBmcm9udC1lbmQgZGV2ZWxvcG1lbnQgd29yaywgY2FuIHNob3cgc29tZXRoaW5nIGFuZCBnZXQgY29tbWVudHMgcmFwaWRseVxyXG4gICAgICAgICAgICAvLyAgIHdpdGhpbiBteSBzeXN0ZW0uXHJcblxyXG4gICAgICAgICAgICAvLyBBbnl3YXksIG5lZWQgdG8gZ2V0IHRoaXMgbWF0Y2hpbmcgdGhlIGZpZWxkIGNvbnN0cmFpbnRzIGhlcmUuXHJcblxyXG4gICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICB2YXIgZmllbGRfY29uc3RyYWludHMgPSBhWzBdO1xyXG5cclxuXHJcbiAgICAgICAgICAgIC8vIGNoZWNrIGZvciBtYXRjaGluZyBhIHNpbmdsZSBjb25zdHJhaW50XHJcblxyXG5cclxuXHJcbiAgICAgICAgICAgIGVhY2goZmllbGRfY29uc3RyYWludHMsIGZ1bmN0aW9uKGksIHYpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdmaWVsZF9jb25zdHJhaW50cyBpICcgKyBpKTtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdmaWVsZF9jb25zdHJhaW50cyB2ICcgKyBzdHJpbmdpZnkodikpO1xyXG5cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICovXHJcblxyXG4gICAgICAgICAgICByZXR1cm4gZGF0YV9vYmplY3RfbWF0Y2hlc19maWVsZF9jb25zdHJhaW50cyh0aGlzLCBhWzBdKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICB9KSxcclxuXHJcblxyXG4gICAgLy8gcmVxdWlyZXMgaXMgZGlmZmVyZW50IHRvIGFjY2VwdHMuXHJcblxyXG4gICAgLy8gcmVxdWlyZW1lbnRzIG1heSBiZSBuZWVkZWQgdG8gZG8gc29tZXRoaW5nLlxyXG4gICAgLy8gYWNjZXB0cyBpcyBhYm91dCBzZXR0aW5nIGRhdGEgb24gaXQuXHJcbiAgICAvLyAgY291bGQgc2F5IChvciBhc3N1bWUpIHRoYXQgdGhlIGZpZWxkcyBhcmUgcmVxdWlyZWQuIFRoZXkgY291bGQgYmUgcmVxdWlyZWQgaW4gb3JkZXIgdG8gcGVyc2lzdCBpdCB0byBzb21lIGxvY2F0aW9uLlxyXG4gICAgLy8gUGVyaGFwcyBvbmx5IHNvbWUgZmllbGRzIGFyZSByZXF1aXJlZCwgb3IgdGhlaXIgcmV1cWlyZW1lbnQgaXMgbWV0IHdoZW4gdGhleSBhcmUgbnVsbCBvciB1bmRlZmluZWQuXHJcblxyXG4gICAgLy8gIFNheWluZyBhIGZpZWxkIGlzIHJlcXVpcmVkIGlzIGVxdWl2YWxlbnQgdG8gc2F5aW5nIGl0IGlzICdub3QgbnVsbCcuXHJcbiAgICAvLyAgIEZpZWxkcyB3aWxsIHBvc3NpYmx5IG5vdCBtZWV0IHRoaXMgY29uc3RyYWludCBqdXN0IGFzIHRoZSBvYmplY3QgaGFzIGJlZW4gY3JlYXRlZC4uLiBidXQgaXQgbWF5IGJlIHRoYXQgdGhlIG9iamVjdCBtdXN0IGdldCBjcmVhdGVkIHdpdGggdGhlIG5lY2Vzc2FyeVxyXG4gICAgLy8gICBkYXRhLiBJdCB3aWxsIGJlIHBvc3NpYmxlLCB0aG91Z2gsIHRvIGhhdmUgdGhlIERhdGFfT2JqZWN0LCBub3QgY29udGFpbmluZyBhbnkgZGF0YS4gTWF5YmUgaXQgd2lsbCBiZSBjb25zaWRlcmVkIGVtcHR5LCBvciBkYXRhbGVzc1xyXG4gICAgLy8gICBkYXRhbGVzcyBtYXkgYmUgYmV0dGVyIGFzIGl0IGRvZXMgbm90IGltcGx5IHRoZSBvcHBvc2l0ZSBvZiAnZnVsbCcuXHJcblxyXG5cclxuXHJcblxyXG4gICAgJ19fX19yZXF1aXJlcyc6IGZwKGZ1bmN0aW9uKGEsIHNwZWMpIHtcclxuXHJcbiAgICAgICAgLy8gTGVhdmluZyB0aGlzIGZvciB0aGUgbW9tZW50LCBkZXZlbG9waW5nIGZpZWxkIGNvbnN0cmFpbnRzLlxyXG5cclxuXHJcbiAgICAgICAgLy8gc2V0cyBpdGVtcyBpbiB0aGlzIG9iamVjdCdzIHNjaGVtYVxyXG4gICAgICAgIC8vICB0aGlzIGNvdWxkIHNldCBpdGVtcyBpbiBhbiBpdGVtLWxldmVsIHJhdGhlciB0aGFuIGNsYXNzLWxldmVsIHNjaGVtYS5cclxuICAgICAgICAvLyAgIHRoZXJlIGNvdWxkIGJlIHR3byBzY2hlbWFzIC0gdGhlIG9uZSBpdCBzdGFydHMgd2l0aCwgYW5kIHRob3NlIHRoYXQgb3ZlcnJpZGUgdGhlIGRlZmF1bHQgc2NoZW1hLlxyXG4gICAgICAgIC8vICAgVGhhdCBhdm9pZHMgY29weWluZyBsb3RzIG9mIHRoZSBkZWZhdWx0IHNjaGVtYSBpdGVtcywgbWFraW5nIGNvbnRyb2xzIHN0YXJ0IG1vcmUgcXVpY2tseSBhbmQgd2lsbCB1c2UgbGVzcyBtZW1vcnkuXHJcbiAgICAgICAgLy8gICAgTGVzcyByZWR1bnRhbnQgaW5mb3JtYXRpb24gYmVpbmcgc3RvcmVkLlxyXG5cclxuICAgICAgICAvLyBiYXNlX3NjaGVtYSAodGhpcyBjb3VsZCBiZSBzZXQgYnkgYSBzdHJpbmcgbmFtZSwgcmVmZXJyaW5nIHRvIGpzZ3VpLnNjaGVtYXMpLlxyXG4gICAgICAgIC8vIG92ZXJyaWRlc19zY2hlbWEgKG9iamVjdF9zY2hlbWEgbWF5IGJlIGEgYmV0dGVyIG5hbWUpLlxyXG5cclxuICAgICAgICAvLyAncmVxdWlyZXMnIHdvdWxkIGJlIHNldHRpbmcgc29tZXRoaW5nIG9uIHRoZSBvdmVycmlkZXNfc2NoZW1hIChvciBvYmplY3Rfc2NoZW1hKVxyXG5cclxuICAgICAgICAvLyBvYmplY3Rfc2NoZW1hXHJcbiAgICAgICAgLy8gb2JqZWN0X3R5cGVfc2NoZW1hXHJcbiAgICAgICAgLy8gb2JqZWN0X2Jhc2Vfc2NoZW1hXHJcbiAgICAgICAgLy8gb2JqZWN0X3NjaGVtYV9hZGRpdGlvbnNcclxuXHJcbiAgICAgICAgLy8gYmFzZV9zY2hlbWFcclxuICAgICAgICAvLyBzY2hlbWFfYWRkaXRpb25zXHJcbiAgICAgICAgLy8gYWRkaXRpb25hbF9zY2hlbWFcclxuICAgICAgICAvLyBvYmplY3Rfc2NoZW1hXHJcblxyXG4gICAgICAgIC8vIGJhc2Vfc2NoZW1hXHJcbiAgICAgICAgLy8gb2JqZWN0X3NjaGVtYVxyXG5cclxuICAgICAgICAvLyB0eXBlcyB3aWxsIGJlIG5hbWVzcGFjZWQgbW9yZVxyXG4gICAgICAgIC8vICB0aGVyZSBpcyB0aGUgdHlwZSBzeXN0ZW0gb2YgdGhlIEphdmFTY3JpcHQgY29kZSBoZXJlXHJcbiAgICAgICAgLy8gIHRoZXJlIGlzIGFuIGludGVybmFsIHR5cGUgc3lzdGVtIGZvciBhcmJpdHJhcnkgbmFtZXNwYWNlZCBvYmplY3RzLi4uIHRoZXkgd2lsbCBmb2xsb3cgdGhlIG5hbWVzIG9mIG9iamVjdHMgaGVyZS5cclxuXHJcbiAgICAgICAgLy9cclxuXHJcblxyXG5cclxuICAgICAgICAvLyBzY2hlbWFzIGFwcGxpZWQgdG8gcHJvcGVydGllc1xyXG4gICAgICAgIC8vICBkb25lIHNvIHRoYXQgdGhlIGNoZWNraW5nIHN0YWdlIGNhbiBzZWUgdGhhdCByZXF1aXJtZW50cyBhcmUgbWV0LlxyXG5cclxuICAgICAgICAvLyBJdCBtYXkgYmUgd29ydGggcHV0dGluZyB0aGlzIGluIGEgJ3NjaGVtYScgZm9yIHRoZSBvYmplY3QsIHJhdGhlciB0aGFuIGF0IHRoaXMgc3RhZ2UuXHJcblxyXG4gICAgICAgIC8vIFNldHRpbmcgc2NoZW1hcyBmb3Igc3ViLW9iamVjdHMsIGFuZCBzZXR0aW5nIHNjaGVtYXMgZm9yIHRoZSBvYmplY3RzIHRoZW1zZWx2ZXMgbWFrZXMgYSBsb3Qgb2Ygc2Vuc2UuXHJcbiAgICAgICAgLy8gIFBlcmhhcHMgdGhlIHNjaGVtYXMgZm9yIHRoZSBzdWItb2JqZWN0cyBzaG91bGQgYmUgc2V0IHRocm91Z2ggdGhlIHNjaGVtYSBmb3IgdGhlIG9iamVjdCBpdHNlbGYuXHJcblxyXG4gICAgICAgIC8vIHRoaXMsIEkgdGhpbmssIHdpbGwgYmUgc2V0dGluZyBhIHBhcnRpY3VsYXIgaXRlbSBvbiB0aGUgb2JqZWN0X3NjaGVtYS5cclxuICAgICAgICAvLyB0aGUgb2JqZWN0X3NjaGVtYSBjb3VsZCBzaW1wbGUgYmUgYSBkYXRhX3R5cGVfbmFtZS5cclxuICAgICAgICAvLyAgdGhpcyB3aWxsIHRpZSBpbnRvIGpzZ3VpLmRhdGFfdHlwZV9uYW1lXHJcbiAgICAgICAgLy8gTGlrZWx5IHRvIG1ha2UgdGhlIG5lc3RlZCBzeXN0ZW0gY2xlYXJlciBhbmQgbW9yZSBjb21wYWN0LCBhbmQgaW5jb3Jwb3JhdGUgaXQgaW50byB0aGUgbWFpbiBwYXJ0LlxyXG4gICAgICAgIC8vICBJIHRoaW5rIEknbGwgZ2V0IHRoaW5ncyBydW5uaW5nIGluIGEgZmFpcmx5IGNvbXBhY3Qgd2F5IHRoYXQgd291bGQgZW5hYmxlIHRoaW5ncyB0byBydW4gcmVhbGx5IHdlbGwgb24gYSBtb2JpbGUgZGV2aWNlLlxyXG4gICAgICAgIC8vICAgQ291bGQgaGF2ZSBzaWduaWZpY2FudGx5IGFkdmFuY2VkIHByb2dyYW1taW5nIGFyb3VuZCB0aGUgMTJLQiBtYXJrLCB3b3VsZCBoYXZlIHRoaW5ncyByZWFsbHkgb3B0aW1pemVkLCBidXQgaXQgbmVlZHMgdG8gZ2V0IGEgYml0IGNvbXBsaWNhdGVkIGluXHJcbiAgICAgICAgLy8gICBvcmRlciB0byBpbXBsZW1lbnQgc3VjaCBmdW5jdGlvbmFsaXR5LiBBIGxvdCBjYW4gYmUgZG9uZSBpbiB0aGF0IHJlbGF0aXZlbHkgc21hbGwgc2l6ZSwgYW5kIG1vcmUgc3RpbGwgY2FuIGJlIGRvbmUgdXNpbmcgdGhhdCBjb2RlIGZvciB0aGUgbW9iaWxlIGFwcGxpY2F0aW9uLlxyXG5cclxuICAgICAgICAvLyBQdXR0aW5nIHRoZSByZXF1aXJlbWVudCBpbmZvcm1hdGlvbiBpbnRvIHRoZSBvYmplY3Rfc2NoZW1hIG1ha2VzIHNlbnNlXHJcbiAgICAgICAgLy8gIE1heSBiZSBzaW1pbGFyIHRvIHVzaW5nIGEgZGF0YV90eXBlX25hbWU/XHJcbiAgICAgICAgLy8gICBvciBzY2hlbWFfbmFtZT9cclxuXHJcbiAgICAgICAgLy8gc2NoZW1hX25hbWUgbWF5IG1ha2UgbW9yZSBzZW5zZS5cclxuICAgICAgICAvLyBwb3NzaWJseSBhbHNvIGhhdmUgYSBncm91cCAvIGNvbGxlY3Rpb24gb2Ygc2NoZW1hcy5cclxuICAgICAgICAvLyAgbm90IHN1cmUgYWJvdXQgY29sbGVjdGlvbiBiZWNhdXNlIHRoZXNlIHNjaGVtYXMgd2lsbCBiZSB1c2VkIGZvciBpbXBsZW1lbnRpbmcgdGhpbmdzIHRvIGRvIHdpdGggdGhlIGNvbGxlY3Rpb24uXHJcbiAgICAgICAgLy8gIGNvdWxkIGhhdmUgYW4gYXBwbGljYXRpb24td2lkZSBkaWN0aW9uYXJ5IG9mIHNjaGVtYXMuXHJcbiAgICAgICAgLy8gIHNvbWUgb2YgdGhlc2Ugd2lsbCBoYXZlIHRvIGRvIHdpdGggSFRNTCwgZm9yIGV4YW1wbGUuXHJcblxyXG4gICAgICAgIC8vIEl0IG1ha2VzIHNlbnNlIHRvIHVzZSBhIHNjaGVtYSBzeXN0ZW0gaW4gdmFyaW91cyBwbGFjZXMgd2hlcmUgaXQgaXMgYXBwcm9wcmlhdGUsIGFuZCBjYWxsIGl0IGEgc2NoZW1hLlxyXG4gICAgICAgIC8vICBTaG91bGQgYmUgY29tcGF0YWJsZSB3aGVyZSBwb3NzaWJsZSB3aXRoIHRoZSBvYmplY3QgZGVmaW5pdGlvbnMgYW5kIGFjY2Vzcywgc3VjaCBhcyBpbmRleGVkX2FycmF5XHJcbiAgICAgICAgLy8gIENhbGxlZCB0aGUganNndWktc2NoZW1hIHN0YW5kYXJkIEkgdGhpbmsuXHJcbiAgICAgICAgLy8gSSBtYXkgbWFrZSBzb21lIHNlcGFyYXRlIGNvbXBvbmVudHMgdGhhdCB3b3JrIHVzaW5nIHRoaXMgc3RhbmRhcmQuIFRoZXkgY291bGQgYmUgcmVmZXJlbmNlIGltcGxlbWVudGF0aW9ucyBvZiBzb21lIHRoaW5ncy5cclxuICAgICAgICAvLyAgQ2hlY2tpbmcgdGhhdCBhbiBvYmplY3QncyBwcm9wZXJ0aWVzIGNvbmZvcm0gdG8gdGhlIHNjaGVtYVxyXG4gICAgICAgIC8vICAgU2hvdWxkIG1ha2UgaXQgcG9zc2libGUgdG8gZWFzaWx5IGdldCB0aGUgc2NoZW1hIHRlc3RlciB0byBrbm93IGhvdyB0aGUgb2JqZWN0J3MgcHJvcGVydGllcyBhcmUgZG9uZSwgc3VjaCBhcyBvbiBEYXRhX09iamVjdCB1c2luZyBnZXQgYW5kIHNldFxyXG4gICAgICAgIC8vICAgZnVuY3Rpb25zLlxyXG5cclxuICAgICAgICAvLyBXaWxsIGFsc28gYmUgYWJsZSB0byBzYXkgc29tZXRoaW5nIHJlcXVpcmVzIGFuIG9iamVjdCB3aXRoIGEgcGFydGljdWxhciBpbnRlcmZhY2UuXHJcbiAgICAgICAgLy8gIERhdGFfT2JqZWN0cyB3aWxsIGhhdmUgYW4gJ2ludGVyZmFjZXMnIHByb3BlcnR5IChwcml2YXRlIHByb3BlcnR5KVxyXG4gICAgICAgIC8vICAgdGhpcyB3aWxsIGhlbHAgdGhlbSB0ZWxsIHdoZXRoZXIgdGhlIG9iamVjdCB0aGF0IGlzIGNvbm5lY3RlZCBoYXMgdGhlIHJpZ2h0IGludGVyZmFjZShzKVxyXG5cclxuICAgICAgICAvLyBPYmplY3RzIGNhbiBoYXZlIG1vcmUgdGhhbiBvbmUgaW50ZXJmYWNlLlxyXG4gICAgICAgIC8vICBUaGlzIGlzIGFraW4gdG8gYyMuIEluIHRoaXMgY2FzZSwgd2UgZG9uJ3QgY2FyZSBhYm91dCBob3cgaW5oZXJpdGFuY2UgaXMgZG9uZSBvbiB0aGUgb2JqZWN0IChpdCBjYW4gYmUgZG9uZSBpbiBkaWZmZXJlbnQgd2F5cyB0byBjIyksIGJ1dCB3ZSBhcmUgc2F5aW5nIHRoYXQgdGhlIG9iamVjdFxyXG4gICAgICAgIC8vICBjb25mb3JtcyB0byBhIHBhcnRpY3VsYXQgaW50ZXJmYWNlLCBpZSBoYXMgdmFyaW91cyBwcm9wZXJpdGllcy5cclxuICAgICAgICAvLyAgIEluIHNvbWUgY2FzZXMgdGhvc2UgcHJvcGVydGllcyBtdXN0IGJlIHNldC5cclxuXHJcbiAgICAgICAgLy8gV2lsbCBhbHNvIGJlIGFibGUgdG8gc3BlY2lmeSBmdW5jdGlvbnMgaW4gaW50ZXJmYWNlcyAoYW5kIG9iamVjdF9zY2hlbWFzIEkgdGhpbmspLCBzbyB0aGF0IGl0IGNhbiBiZSBydW4gdGhyb3VnaCB0ZXN0cy5cclxuXHJcbiAgICAgICAgLy8gSW50ZXJmYWNlczogYW4gaW50ZXJmYWNlIGlzIGEgbmFtZWQgY29uZm9ybWFuY2UgdG8gZWl0aGVyIGEgc3BlY2lmaWVkIG9yIG5hbWVkIHNjaGVtYS5cclxuXHJcbiAgICAgICAgLy8ganNndWkuZGF0YV90eXBlcyAtPiBqc2d1aS5zY2hlbWFzXHJcblxyXG4gICAgICAgIC8vIFRoZXNlIHNjaGVtYXMgd2lsbCBiZSB1c2FibGUgaW4gZm9ybSB2YWxpZGF0aW9uLCBjcmVhdGluZyBIVE1MIGZvcm1zLCBwcm9jZXNzaW5nIHRoZW0sIGFuZCBkZWFsaW5nIHdpdGggb2JqZWN0cyBpbiBkYXRhYmFzZXMsIHBlcmhhcHMgd2l0aCBnZW5lcmF0ZWQgQ1JVRC5cclxuICAgICAgICAvLyAgVGhleSB3aWxsIGJlIHNpbXBsZSB0byBzcGVjaWZ5LlxyXG4gICAgICAgIC8vICBUaGVyZSB3aWxsIHNvbWV0aW1lIGJlIGEgR1VJIHRvb2wgZm9yIHNwZWNpZnlpbmcgc2NoZW1hcy5cclxuICAgICAgICAvLyAgIFRoZXkgd29uJ3QgYmUgdG9vIGNvbXBsaWNhdGVkIC0gYnV0IHRoZXkgY291bGQgYmUgdXNlZCBmb3IgZGVzY3JpYmluZyBzb21lIHJlYWwtd29yayBvYmplY3RzLlxyXG5cclxuXHJcblxyXG4gICAgICAgIC8vIHRlbGwgaXQgd2hhdCB0byBsb29rIGZvciB3aXRoIHRoYXQgcHJvcGVydHkuXHJcblxyXG4gICAgICAgIC8vIFRoZXJlIG1heSBiZSBzb21lIG1vcmUgY29tcGxpY2F0ZWQgY2FzZXMuXHJcbiAgICAgICAgLy8gIENvdWxkIGJlIHJlZmVycmluZyB0byBtdWx0aXBsZSByZXF1aXJlZCBvYmplY3RzIGZvciBvbmUgcHJvcGVydHkgbmFtZS5cclxuICAgICAgICAvLyAgVGhleSBjb3VsZCBiZSBpbiBhIGNvbGxlY3Rpb24sIG9yIGFuIGFycmF5LlxyXG5cclxuICAgICAgICAvLyBjYW4gYWRkIGFuIG9iamVjdCB0byB0aGUgcmVxdWlyZW1lbnRzLlxyXG4gICAgICAgIC8vICBjaGVja3MgdGhhdCB0aGUgaXRlbSBpcyB0aGVyZT9cclxuXHJcbiAgICAgICAgLy8gY2hlY2tzIHRoYXQgdGhlIGl0ZW0gY29uZm9ybXMuXHJcbiAgICAgICAgLy8gIHBvc3NpYmx5IHRvIGFuIG9iamVjdF9zY2hlbWEuXHJcbiAgICAgICAgLy8gdGhlIG9iamVjdF9zY2hlbWEgc3lzdGVtIGNvdWxkIGJlIHVzZWQgZm9yIGRhdGEgdHlwZXMgZWxzZXdoZXJlIC0gbm90IHN1cmUgYWJvdXQgdGhpcy4gSXQgc291bmRzIE9LIHRob3VnaC5cclxuXHJcbiAgICAgICAgLy8gZWxzZXdoZXJlLCB3aGUgY2hlY2sgaWYgYW4gb2JqZWN0IGNvbmZvcm1zIHRvIGEgc2V0IHR5cGUuXHJcblxyXG4gICAgICAgIC8vIG1heWJlIG9iamVjdF9zY2hlbWEgc2hvdWxkIGJlIHRoZSBzYW1lIHN5c3RlbSwgb3IgdGhlIG90aGVyIHN5c3RlbSBjb3VsZCBjaGFuZ2Ugb3ZlciB0byB1c2luZyBhbiBvYmplY3Rfc2NoZW1hLCB0byBtYWtlIHRoaW5ncyBjbGVhcmVyLlxyXG4gICAgICAgIC8vICBJIHRoaW5rIHRoZSBvYmplY3Rfc2NoZW1hIGFic3RyYWN0aW9uIHdvdWxkIGhlbHAgYSBiaXQuXHJcblxyXG4gICAgICAgIC8vIHdpbGwgYmUgbWFraW5nIHVzZSBvZiBqc2d1aS5kYXRhX3R5cGVzX2luZm9cclxuXHJcbiAgICAgICAgLy8gc3RyaW5nIGFuZCBhbiBvYmplY3RcclxuICAgICAgICAvLyAgdGhlIHN0cmluZyBpcyB0aGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgd2l0aGluIHRoaXMgb2JqZWN0XHJcbiAgICAgICAgLy8gIHRoZSBvYmplY3QgaXMgdGhlIHNjaGVtYSBmb3IgdGhhdCBwcm9wZXJ0eS5cclxuXHJcblxyXG5cclxuICAgICAgICAvLyBSZXF1aXJlbWVudHMgd2lsbCBiZSBzZWFsdCB3aXRoIHRocm91Z2ggdGhlIGNvbnN0cmFpbnRzIHN5c3RlbS5cclxuICAgICAgICAvLyAgUGVyaGFwcyBpdCBpcyBhbiBhc3N1bXB0aW9uIHRoYXQgaXQgaXMgcmVxdWlyZWQgdGhlIGNvbnN0cmFpbnRzIGFyZSBzYXRpc2ZpZWQuXHJcblxyXG4gICAgICAgIC8vICBBIHJlcXVpcmVtZW50cyBzeXN0ZW0gbWF5IG9wZXJhdGUgZm9yIHJlc291cmNlcy4uLiBub3Qgc28gc3VyZSBhYm91dCBoYXZpbmcgcmVxdWlyZW1lbnRzIGluIHRoZSBEYXRhX09iamVjdCBhcyB0aGF0IHNlZW1zIGxpa2UgaXQgY2FuIGJlXHJcbiAgICAgICAgLy8gICBoYW5kbGVkIGJ5IGZpZWxkcyBhbmQgY29uc3RyYWludHMuXHJcblxyXG5cclxuICAgICAgICBpZiAoYS5sID09IDApIHtcclxuICAgICAgICAgICAgLy8gcmV0dXJuIHRoZSByZXF1aXJlbWVudHMuXHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVxdWlyZW1lbnRzO1xyXG5cclxuICAgICAgICB9XHJcblxyXG5cclxuXHJcbiAgICB9KSxcclxuXHJcblxyXG4gICAgLy8gbWVldHNfcmVxdWl0ZW1lbnRzLCB3YXMgY2hlY2tfcmVxdWlyZW1lbnRzP1xyXG5cclxuICAgIC8vIG1lZXRzIHJldHVybnMgYSBib29sZWFuLCBjaGVjayByZXR1cm5zIGEgcmVwb3J0IHNheWluZyB3aGVyZSBpdCBmYWlsZWQuXHJcblxyXG4gICAgLy8gQSByZXNvdXJjZSBtYXkgcmVxdWlyZSBhbm90aGVyIHJlc291cmNlIHRvIGhhdmUgc3RhcnRlZCBpbiBvcmRlciB0byBzdGFydC5cclxuICAgIC8vICBOb3cgd29ya2luZyBvbiB0aGUgY29kZSBleGVjdXRpb24gcGF0aCBmb3IgdGhlIE1ldGFCZW5jaCBob3N0aW5nIChleHBhbmRhYmxlKSBzZXJ2ZXIgdG8gYmUgcnVuLlxyXG4gICAgLy8gIFdpbGwgaG9zdCB0aGUgd2Vic2l0ZSBhcyBhIFJlc291cmNlIGJlZm9yZSBsb25nLlxyXG4gICAgLy8gIFdpbGwgYWxzbyBiZSBpbnRlcmFjdGluZyB3aXRoIERCcyB1c2luZyBhIHJlc291cmNlIEFQSS5cclxuXHJcbiAgICAvLyBUaGVyZSBpcyBxdWl0ZSBhIGJpdCBvZiBnZW5lcmFsIHN0cnVjdHVyZSwgYW5kIGxvdHMgb2Ygc2NvcGUgZm9yIHNwZWNpZmljcyB0byBiZSBidWlsdC5cclxuICAgIC8vICBEbyB3YW50IHRvIGdldCBteSB3ZWJzaXRlIGhvc3RlZC5cclxuICAgIC8vICBBIGZldyBjb21wb25lbnRzIGNvdWxkIGRpc3BsYXkgdGhpbmdzIHF1aXRlIG5pY2VseS5cclxuXHJcbiAgICAvLyBXaWxsIGhhdmUgYSBkZW1vIHNlY3Rpb24gc2hvd2luZyBmcm9udC1lbmQgY29tcG9uZW50cy5cclxuICAgIC8vICBNYXkgaGF2ZSBhbiBlLWxlYXJuaW5nIHNlY3Rpb25cclxuXHJcbiAgICAvLyBNb2JpbGUgZGV2ZWxvcG1lbnRcclxuICAgIC8vXHJcblxyXG5cclxuICAgIC8vIFdpbGwgdXNlIGZpZWxkIGNvbnN0cmFpbnRzIGZvciB0aGUgbW9tZW50XHJcbiAgICAvLyAgUmVxdWlyZW1lbnRzIG1heSBtYWtlIGFuIGFwcGVhcmFuY2UgaW4gcmVzb3VyY2VzLCBpZSBzYXlpbmcgdGhhdCBhIHJlc291cmNlIHJlcXVpcmVzIGFub3RoZXIgcmVzb3VyY2UgKHRvIGhhdmUgc3RhcnRlZCkgYmVmb3JlIGl0IGNhbiBzdGFydC5cclxuICAgICdfX19fX21lZXRzX3JlcXVpcmVtZW50cyc6IGZwKGZ1bmN0aW9uKGEsIHNpZykge1xyXG5cclxuICAgICAgICAvLyBQb3NzaWJseSBjaGVjayBmaWVsZCBjb25zdHJhaW50cywgYnV0IHRoZXNlIHdvdWxkIGhhdmUgcHJvYmFibHkgYmVlbiBjaGVja2VkIG9uIGlucHV0IG9yIG9uIHNldHRpbmcgdGhlIGNvbnN0cmFpbnRzLlxyXG5cclxuICAgICAgICB2YXIgcmVxdWlyZW1lbnRzID0gdGhpcy5fcmVxdWlyZW1lbnRzO1xyXG4gICAgICAgIGlmICghcmVxdWlyZW1lbnRzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChzaWcgPT0gJ1tzXScpIHtcclxuICAgICAgICAgICAgICAgIHZhciBwcm9wZXJ0eV9uYW1lID0gYVswXTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBkb2VzIGl0IG1lZXQgdGhhdCBvbmUgcmVxdWlyZW1lbnQ/XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gbm90IHN1cmUgZXhhY3RseSBob3cgcmVxdWlyZW1lbnRzIGFyZSBleHByZXNzZWQgcmlnaHQgbm93LlxyXG4gICAgICAgICAgICAgICAgLy8gIEkgdGhpbmsgbWFueSBvZiB0aG9zZSB0aGluZ3Mgc2hvdWxkIGJlIHdyaXR0ZW4gdXAgaW4gZG9jdW1lbnRhdGlvbiBvbiB0aGUgc3lzdGVtIGFuZCBwdWJsaXNoZWQuXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gJ25hbWUnOiBbJ3JlZ2V4JywgcnhdXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gY291bGQgY2hlY2sgZm9yIGRpZmZlcmVudCBkYXRhIHR5cGVzIGFzIHdlbGxcclxuICAgICAgICAgICAgICAgIC8vICBjb3VsZCBjaGVjayB0aGF0IHNvbWV0aGluZyBoYXMgYSBwYXJ0aWN1bGFyIHN0YXR1cywgZWl0aGVyIGZ1bmN0aW9uIHJlc3VsdCBvciBpdHMgb3duIG9iamVjdC5cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSG93IG11Y2ggb2YgdGhpcyBpcyBpbiAnbmVzdGVkJz9cclxuICAgICAgICAgICAgICAgIC8vICBIb3cgbXVjaCBvZiBuZXN0ZWQgc2hvdWxkIGJlIGJyb3VnaHQgdG8gdGhlIGNvcmU/XHJcblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0pLFxyXG5cclxuXHJcbiAgICAvLyBhbHRob3VnaCB0aGlzIGlzIG5vdCBhIGNvbGxlY3Rpb24sIGl0IGlzIHNpbWlsYXIgdG8gYSBub3JtYWwgSlMgZGljdCAvIG9iamVjdC5cclxuICAgIC8vICB3b3VsZCBiZSBnb29kIHRvIGl0ZXJhdGUgb3ZlciBhbGwgdGhlIGl0ZW1zIG9mIGRhdGEgaW4gdGhpcy5cclxuXHJcbiAgICAnZWFjaCc6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgLy8gY291bGQgdXNlIGZvciBpIGluLi4uXHJcblxyXG5cclxuICAgICAgICAvKlxyXG4gICAgICAgIGVhY2godGhpcy5fLCBmdW5jdGlvbihpLCB2KSB7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrKGksIHYpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgICovXHJcblxyXG4gICAgICAgIC8vIENvdWxkIGhhdmUgaW5saW5lIGNvZGUgaGVyZSBmb3Igc3BlZWQ/XHJcbiAgICAgICAgZWFjaCh0aGlzLl8sIGNhbGxiYWNrKTtcclxuXHJcblxyXG4gICAgfSxcclxuXHJcblxyXG4gICAgLy8gY291bGQgbWFrZSB0aGlzIHBvbHltb3JwaGljIHNvIHRoYXQgaXRcclxuICAgICdwb3NpdGlvbl93aXRoaW4nOiBmdW5jdGlvbihwYXJlbnQpIHtcclxuICAgICAgICB2YXIgcF9pZCA9IHBhcmVudC5faWQoKTtcclxuICAgICAgICAvL2NvbnNvbGUubG9nKCdwX2lkICcgKyBwX2lkKTtcclxuICAgICAgICAvL2NvbnNvbGUubG9nKCd0aGlzLl9wYXJlbnRzICcgKyBzdHJpbmdpZnkodGhpcy5fcGFyZW50cykpO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5fcGFyZW50cyAmJiBpc19kZWZpbmVkKHRoaXMuX3BhcmVudHNbcF9pZF0pKSB7XHJcbiAgICAgICAgICAgIHZhciBwYXJlbnRfcmVsX2luZm8gPSB0aGlzLl9wYXJlbnRzW3BfaWRdO1xyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdwYXJlbnRfcmVsX2luZm8gJyArIHN0cmluZ2lmeShwYXJlbnRfcmVsX2luZm8pKTtcclxuXHJcbiAgICAgICAgICAgIC8vdmFyIHBhcmVudHMgPSB0aGlzLl9wYXJlbnRzO1xyXG4gICAgICAgICAgICAvL2lmIChwYXJlbnRzKSB7XHJcbiAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgIC8vfVxyXG4gICAgICAgICAgICB2YXIgcG9zX3dpdGhpbiA9IHBhcmVudF9yZWxfaW5mb1sxXTtcclxuXHJcbiAgICAgICAgICAgIC8vIEl0IGlzIGluZGV4ZWQgYnkgcG9zaXRpb24gaW4gcGFyZW50IHRocm91Z2ggdGhlIHBhcmVudC5cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBwb3Nfd2l0aGluO1xyXG5cclxuICAgICAgICB9XHJcblxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLy8gTWF5YmUganVzdCAncmVtb3ZlJyBmdW5jdGlvbi5cclxuICAgIC8vICBUaGlzIG1heSBiZSBuZWVkZWQgd2l0aCBtdWx0aXBsZSBwYXJlbnRzLCB3aGljaCBhcmUgbm90IGJlaW5nIHVzZWQgYXQgdGhlIG1vbWVudC5cclxuXHJcbiAgICAncmVtb3ZlX2Zyb20nOiBmdW5jdGlvbihwYXJlbnQpIHtcclxuICAgICAgICB2YXIgcF9pZCA9IHBhcmVudC5faWQoKTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuX3BhcmVudHMgJiYgaXNfZGVmaW5lZCh0aGlzLl9wYXJlbnRzW3BfaWRdKSkge1xyXG5cclxuICAgICAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMuX3BhcmVudHNbcF9pZF1bMF07XHJcbiAgICAgICAgICAgIHZhciBwb3Nfd2l0aGluID0gdGhpcy5fcGFyZW50c1twX2lkXVsxXTtcclxuXHJcbiAgICAgICAgICAgIC8vIGlzIHRoZSBwb3NpdGlvbiB3aXRoaW4gYWNjdXJhdGU/XHJcbiAgICAgICAgICAgIHZhciBpdGVtID0gcGFyZW50Ll9hcnJbcG9zX3dpdGhpbl07XHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2l0ZW0gJyArIHN0cmluZ2lmeShpdGVtKSk7XHJcblxyXG5cclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnJyk7XHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3Bvc193aXRoaW4gJyArIHBvc193aXRoaW4pO1xyXG4gICAgICAgICAgICAvLyBUaGVuIHJlbW92ZSB0aGUgaXRlbSBpbiB0aGUgY29sbGVjdGlvbiAob3IgRGF0YV9PYmplY3Q/KSAuLi4uXHJcbiAgICAgICAgICAgIC8vIGFuZCB0aGUgYWN0dWFsIHBhcmVudD9cclxuXHJcbiAgICAgICAgICAgIC8vIGNhbiBnZXQgY29udHJvbCAvIGRhdGFvYmplY3QgLyBjb2xsZWN0aW9uIGJ5IGl0cyBJRCBvZiBjb3Vyc2UuXHJcblxyXG4gICAgICAgICAgICBwYXJlbnQucmVtb3ZlKHBvc193aXRoaW4pO1xyXG5cclxuICAgICAgICAgICAgLy8gUmVtb3ZlIGl0IGJ5IGluZGV4LlxyXG5cclxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3BhcmVudHNbcF9pZF07XHJcblxyXG5cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLy8gV2lsbCBqdXN0IGRlYWwgd2l0aCBjb25zdHJhaW50cyBmb3IgdGhlIG1vbWVudC5cclxuICAgIC8vICBJJ2xsIHByb2JhYmx5IG1ha2UgaXQgc28gdGhhdCByZXNvdXJjZXMgaGF2ZSByZXF1aXJlbWVudHMuXHJcblxyXG5cclxuXHJcbiAgICAvLyBSZXF1aXJlbWVudHMgbWF5IGJlIG1vcmUgZ2VuZXJhbCBhbmQgZmxleGlibGUgdGhhbiBmaWVsZCBjb25zdHJhaW50cy5cclxuICAgIC8vICBSZXF1aXJlbWVudHMgY291bGQgYmUgdGhhdCBhbm90aGVyIGNvbXBvbmVudCBoYXMgaW5pdGlhbGl6ZWQuXHJcblxyXG5cclxuICAgICdfX19fX2NoZWNrX3JlcXVpcmVtZW50cyc6IGZwKGZ1bmN0aW9uKGEsIHNpZykge1xyXG4gICAgICAgIC8vIHRlbGwgaXQgd2hhdCB0byBsb29rIGZvciB3aXRoIHRoYXQgcHJvcGVydHkuXHJcblxyXG4gICAgICAgIGlmIChhLmwgPT0gMCkge1xyXG4gICAgICAgICAgICAvLyB0aGVuIGNoZWNrIGFsbCBvZiB0aGUgcmVxdWlyZW1lbnRzXHJcbiAgICAgICAgICAgIC8vIHJldHVybnMgdHJ1ZSBpZiBzdWNjZXNzZnVsLCBvdGhlcndpc2UgZGV0YWlscyBvZiB3aGVyZSBpdCBmYWlscy5cclxuXHJcbiAgICAgICAgICAgIC8vIGNvdWxkIG1heWJlIGxlYWQgdG8gYSB0cnV0aCh4KSBmdW5jdGlvbiB0aGF0IGNoZWNrcyBpZiB4ID09PSB0cnVlLCByYXRoZXIgdGhhbiBpcyBhbiBvYmplY3QgdGhhdCBjb3VsZCBiZSBnaXZpbmcgZGV0YWlscyBvZiBzb21ldGhpbmcgYmVpbmcgZmFsc2UuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoc2lnID09ICdbc10nKSB7XHJcbiAgICAgICAgICAgIC8vIHRoZW4gY2hlY2sgdGhhdCBvbmUgcHJvcGVydHlcclxuICAgICAgICAgICAgdmFyIHByb3BlcnR5X25hbWUgPSBhWzBdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGEubCA9PSAxICYmIGFbMF0gPT09IHRydWUpIHtcclxuICAgICAgICAgICAgLy8gdGhhdCBtZWFucyBpdCdzIHJlY3Vyc2l2ZS5cclxuICAgICAgICAgICAgLy8gIHdlJ2xsIGJlIGNoZWNraW5nIHRoZSByZXF1aXJlbWVudHMgb2YgdGhpcywgYW5kIG9mIGFueSByZXF1aXJlZCBvYmplY3RzLlxyXG5cclxuXHJcblxyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgfSksXHJcblxyXG4gICAgLy8gd2lsbCBiZSBhYmxlIHRvIHVzZSB0aGUgRGF0YU9iamVjdCdzIGNsYXNzX25hbWUgZm9yIGdldCBhbmRcclxuICAgIC8vIHNldC5cclxuICAgIC8vIG1heWJlIGp1c3QgdHlwZV9uYW1lP1xyXG4gICAgLy8gQ291bGQgaGF2ZSBhIHR5cGUgbmFtZSBoZWlyYWNoeS4gU28gdGhhdCBpZiBpdCBkb2VzIG5vdCBmaW5kXHJcbiAgICAvLyBnZXQvc2V0IG1ldGhvZHMgZm9yIGRpdiwgaXQgdXNlcyB0aGUgb25lcyBmb3IgY29udHJvbC5cclxuXHJcbiAgICAvKlxyXG4gICAgICogJ3Byb3BlcnR5X2Vuc3VyZSc6IGZ1bmN0aW9uKHByb3BlcnR5X25hbWUsIHZhbHVlKSB7IC8vIGxpa2VcclxuICAgICAqIHNldCwgYnV0IGRvZXMgbm90IG92ZXJ3cml0ZSBpdC5cclxuICAgICAqXHJcbiAgICAgKlxyXG4gICAgICogdmFyIGFsID0gdGhpcy5fYWxpYXNbcHJvcGVydHlfbmFtZV07IC8vY29uc29sZS5sb2coJ2FsICcgK1xyXG4gICAgICogYWwpOyBpZiAoYWwpIHsgcHJvcGVydHlfbmFtZSA9IGFsOyB9XHJcbiAgICAgKlxyXG4gICAgICogLy92YXIgczNfbmFtZSA9IHByb3BlcnR5X25hbWUuc3BsaXQoJy4nKTsgdmFyIHBvczEgPVxyXG4gICAgICogcHJvcGVydHlfbmFtZS5pbmRleE9mKCcuJyk7IC8vIG9yIGNhbGwgc2V0XHJcbiAgICAgKlxyXG4gICAgICogaWYgKHBvczEgPT0gLTEpIHsgLy8gaWYgKHRvZih0aGlzLl9bcHJvcGVydHlfbmFtZV0pID09XHJcbiAgICAgKiAndW5kZWZpbmVkJykgeyB0aGlzLl9bcHJvcGVydHlfbmFtZV0gPSB2YWx1ZTsgfVxyXG4gICAgICogIH0gZWxzZSB7IC8vIGl0IHNlcGFyYXRlcyB0aGVtIGludG8gc3ViLXByb3BlcnRpZXMuIC8vIHNob3VsZFxyXG4gICAgICogdXNlIHRoZSBzZXQgcHJvY2VkdXJlIGZvciB0aGUgc3VicHJvcGVydGllcy5cclxuICAgICAqICAvLyBhbmQgdGhlIGV2ZW50IHdpbGwgc2F5IHdoaWNoIHN1YnByb3BlcnR5IGhhcyBjaGFuZ2VkLlxyXG4gICAgICogc2V0KHRoaXMsIHByb3BlcnR5X25hbWUsIHZhbHVlKTtcclxuICAgICAqXHJcbiAgICAgKiAgfVxyXG4gICAgICogIH1cclxuICAgICAqL1xyXG5cclxuICAgIC8vIFJlbW92aW5nIGV2ZW50cyB3b24ndCB3b3JrIHdlbGwgd2hlbiB0aGVyZSBhcmUgdmFyeSBtYW55LlxyXG4gICAgLy8gUGVyaGFwcyBtdWx0aXBsZSBsaXN0ZW5lcnMgY291bGQgYmUgcmVtb3ZlZCByZWxhdGl2ZWx5XHJcbiAgICAvLyBxdWlja2x5LlxyXG4gICAgLy8gQWxzbywgd2hhdCBhYm91dCBldmVudCBkZWxlZ2F0aW9uIHRvIGFub3RoZXIgb2JqZWN0P1xyXG4gICAgLy8gU29tZXRoaW5nIGNvdWxkIGhhdmUgYW4gZXZlbnRfcGFyZW50LlxyXG4gICAgLy8gR2V0cyB0b2xkIGFib3V0IGV2ZW50cy5cclxuICAgIC8vIEFuZCB0aGF0IHdpbGwgaGF2ZSB0aGUgZXZlbnQgaGFuZGxlclxyXG4gICAgLy8gU2F2ZXMgYXR0YWNoaW5nIHNvIG1hbnkgZXZlbnQgaGFuZGxlcnMuXHJcbiAgICAvLyBFdmVudCBwcm9wYWdhdGVzIC8gYnViYmxlcy5cclxuICAgIC8vIENvdWxkIGV2ZW4gaGF2ZSBqdXN0IGEgJ3BhcmVudCcgZGF0YSBvYmplY3QgdGhhdCByZWNlaXZlc1xyXG4gICAgLy8gdGhpcyBpbmZvcm1hdGlvbiBhYm91dCBldmVudHM/XHJcbiAgICAvLyBNYXkgZG8gb3RoZXIgdGhpbmdzIHRob3VnaC5cclxuICAgIC8vIENvdWxkIGV2ZW4gaGF2ZSB0aGUgcGFyZW50IGV2ZW50bCBsaXN0ZW5lcnMgbGlzdGVuIGZvciB0aGVcclxuICAgIC8vIGFjdHVhbCBldmVudHM/XHJcbiAgICAvLyBOb3QgdGhlbiB0aHJvdyB0aGVtIGluIHRoZSBzYW1lIHdheS5cclxuICAgIC8vIEhUTUwgc3VyZmFjZXMgd2lsbCBiZSBsaXN0ZW5pbmcgZm9yIHRoZSBldmVudHMgb2YgZGVsZWdhdGVkXHJcbiAgICAvLyBvYmplY3RzIHRocm91Z2ggdGhlIEhUTUwgZXZlbnQgZGVsZWdhdGlvbiBtZWNoYW5pYy5cclxuICAgIC8vIFNvIGV2ZW4gd2l0aCBubyBsaXN0ZW5lcnMgc2V0IHVwLCBpdCB3aWxsIHRlbGwgYSBkZWxlZ2F0aW9uXHJcbiAgICAvLyBwYXJlbnQuXHJcbiAgICAvLyBPciBldmVudCBwYXJlbnQuXHJcbiAgICAvLyBXaWxsIGxlYXZlIGRlZmluaW5nIHRoZSBldmVudCBidWJibGluZyBoZXJlLlxyXG5cclxuICAgIC8vIEJhY2tib25lIGRvZXMgbm90IHNlZW0gdG8gaGF2ZSB0aGlzIGV2ZW50IGJ1YmJsaW5nIG1lY2hhbmlzbS5cclxuICAgIC8vIFNlZW1zIHRvIGJlIGFib3V0IHJlY2VpdmluZyBhbGwgZXZlbnRzIGZvciBhIHBhZ2UuXHJcbiAgICAvLyBRdWl0ZSBwb3NzaWJseSBzaG91bGQgaGF2ZSBhIERhdGFfT2JqZWN0IEV2ZW50IGNsYXNzLlxyXG4gICAgLy8gVGhpcyB3aWxsIGtub3cgdGhlIHRhcmdldCwgbWF5YmUgb3RoZXIgdGhpbmdzLlxyXG4gICAgLy8gRE8gTkVFRCBUTyBrZWVwIHRyYWNrIG9mIHRoZSB0YXJnZXQgd2hlbiBzZW5kaW5nIHRoZXNlIGV2ZW50c1xyXG4gICAgLy8gdGhyb3VnaCBhIGNoYWluLlxyXG4gICAgLy8gVGFyZ2V0IGlzIGFzc3VtZWQgdG8gYmUgdGhpcyB3aGVuIGNhbGxpbmcgaXQgd2l0aCAyXHJcbiAgICAvLyBwYXJhbWV0ZXJzXHJcblxyXG4gICAgLy8gRXZlbnRzIGdldHRpbmcgcmFpc2VkIG9uIHRvbyBtYW55IGl0ZW1zIHdoZW4gdGhlcmUgYXJlIG9iamVjdHMgd2l0aGluIGRpZmZlcmVudCBwYWdlIGNvbnRleHRzLlxyXG5cclxuICAgIC8vIFdhbnQgb2JqZWN0cyBpbiBtb3JlIGluZGVwZW5kZW50IGNvbnRleHRzLlxyXG5cclxuXHJcblxyXG4gICAgJ2xvYWRfZnJvbV9zcGVjJzogZnVuY3Rpb24oc3BlYywgYXJyX2l0ZW1fbmFtZXMpIHtcclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgZWFjaChhcnJfaXRlbV9uYW1lcywgZnVuY3Rpb24oaSwgdikge1xyXG4gICAgICAgICAgICB2YXIgc3BlY19pdGVtID0gc3BlY1t2XTtcclxuICAgICAgICAgICAgaWYgKGlzX2RlZmluZWQoc3BlY19pdGVtKSkge1xyXG4gICAgICAgICAgICAgICAgdGhhdFsnc2V0J10odiwgc3BlY19pdGVtKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSxcclxuXHJcbiAgICAnbW9kX2xpbmsnOiBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4ganNndWk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vIENvdWxkIHVzZSBsZXNzIHBvbHltb3JwaGlzbSBhbmQgcmVjdXJzaW9uIGhlcmUuXHJcbiAgICAvLyAgQ291bGQgbWF5YmUgaXRlcmF0ZSBzdHJ1Y3R1cmUgd2l0aCBhIHdoaWxlIGxvb3AuXHJcblxyXG4gICAgJ3ZhbHVlJzogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHJlcyA9IHt9O1xyXG4gICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbihpLCB2KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygdi52YWx1ZSA9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICByZXNbaV0gPSB2LnZhbHVlKCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXNbaV0gPSB2O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vIE11Y2ggb2YgdGhlIHRpbWUgZW5oYW5jZWRfZGF0YV9vYmplY3Qgd2lsbCBiZSB1c2VkLlxyXG4gICAgLy8gZ2V0KCkgcmV0dXJucyB0aGUgb2JqZWN0IC0gd2lsbCBtYWtlIHRoZSBvYmplY3Qgb3V0IG9mIGZpZWxkIHZhbHVlcyAvIGp1c3QgcmV0dXJuIF8uXHJcblxyXG4gICAgLy8gQXN5bmNyb25vdXMgbmVzdGVkIGdldCBnZXRzIHRyaWNreSAtIGVzcGVjaWFsbHkgd2hlbiBzb21lIG9mIHRoZSBjYWxscyB0byBnZXQgb2JqZWN0c1xyXG4gICAgLy8gIGFyZSBhc3luY3Jvbm91cyBhbmQgc29tZSBhcmUgbm90LiBIb3dldmVyLCBuZWVkIHRvIHByb2Nlc3MgdGhlIGxpc3Qgb2YgcHJvcGVydHkgbmFtZXNcclxuICAgIC8vICBhc3luY3Jvbm91c2x5IHdoZXJlIG5lY2Vzc2FyeS5cclxuXHJcbiAgICAvLyBNYXliZSB3aWxsIGRvIHRoYXQgb3V0c2lkZSBvZiBkYXRhLW9iamVjdCB0aG91Z2guXHJcbiAgICAvLyAgVGhlIG5vbi1hc3luYyBnZXQgaXMgZmFpcmx5IGNvbXBsaWNhdGVkIGFscmVhZHkuXHJcbiAgICAvLyAgSXQgbWF5IGJlIHBvc3NpYmxlIHRvIG1ha2UgYSBuZXcgZ2V0IGZ1bmN0aW9uIGZvciBSZXNvdXJjZSB0aGF0IG1ha2VzIHVzZSBvZiB0aGUgZ2V0IGZ1bmN0aW9uXHJcbiAgICAvLyAgIG9mIGRhdGEtb2JqZWN0LlxyXG4gICAgLy8gIEhvd2V2ZXIsIGEgZGF0YS1vYmplY3Qgd291bGQgbmVlZCB0byBiZSBhYmxlIHRvIGludGVyYWN0IHdpdGggdGhpcy4uLlxyXG4gICAgLy8gICBTbyBJIHRoaW5rIHRoYXQgZGF0YS1vYmplY3QgbmVlZHMgdGhpcyBjYXBhYmlsaXR5IHRvby5cclxuICAgIC8vICAgSSB0aGluayB0aGF0IGFzeW5jcm9ub3VzIG5lc3RlZCBnZXQgd2lsbCBiZSBhIHJlYWxseSB1c2VmdWwgY2FwYWJpbGl0eSB0byBoYXZlLFxyXG4gICAgLy8gICBidXQgaXQgd29uJ3QgYmUgc28gZWFzeSB0byBpbXBsZW1lbnQuXHJcbiAgICAvLyAgICBOZWVkIHRvIGJlIG1ldGhvZGljYWwgYWJvdXQgaXQuXHJcbiAgICAvLyAgUnVubmluZyB0aHJvdWdoIG5lc3RlZCBnZXQgZXhhbXBsZXMgYW5kIHRlc3RzIHdvdWxkIG1ha2UgYSBsb3Qgb2Ygc2Vuc2UuXHJcbiAgICAvLyAgSSB0aGluayBtYWtpbmcgc29tZSBzbWFsbGVyIGpzZ3VpIHRlc3QgY2FzZXMgd291bGQgYWxzbyBiZSB2ZXJ5IHVzZWZ1bC5cclxuXHJcbiAgICAvLyBXb3VsZCBpdCBiZSBwb3NzaWJsZSB0byBtYWtlIHNvbWUgc2ltcGxlIHJlc291cmNlcyB0aGF0IHRha2UgYSB3aGlsZSB0byByZXR1cm4gYSBzaW1wbGUgcmVzdWx0LCAoMXMgbWF5YmUpP1xyXG4gICAgLy8gIFRoZW4gdGhleSBjb3VsZCBiZSBpbiBhIGNoYWluIC8gc2VxdWVuY2Ugc28gdGhhdCB0aGUgYXN5bmMgZ2V0IGNhbiBiZSB0ZXN0ZWQgdG8gd29yay5cclxuXHJcbiAgICAvLyBQZXJoYXBzIG9ubHkgUmVzb3VyY2VzIGhhdmUgYW4gYXN5bmMgZ2V0KCkgYXQgdGhlaXIgb3duIGxldmVsLCBnZXR0aW5nIHRoZWlyIG93biBpbmZvcm1hdGlvbi5cclxuXHJcbiAgICAvLyBnZXQgLSBhIHdvcmQgdXNlZCBiZWNhdXNlIEpTIGRpZCBub3QgaGF2ZSBnZXR0ZXJzIGFuZCBzZXR0ZXJzLCBnZXR0aW5nIGZyb20gYSBsb2NhbCB2YXJpYWJsZVxyXG4gICAgLy8gICAgICAgYSB3b3JkIHVzZWQgdG8gc2lnbmlmeSBnZXR0aW5nIGZyb20gYSBtb3JlIHJlbW90ZSBsb2NhdGlvbiwgbGlrZSBmcm9tIGRpc2sgb3Igb3ZlciBhIG5ldHdvcmtcclxuICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsY3VsYXRpb25cclxuXHJcbiAgICAvLyBNYWtpbmcgYSB2ZXJ5IGZsZXhpYmxlIGdldCBmdW5jdGlvbiB3b3VsZCBiZSBhIHZlcnkgdXNlZnVsIHRoaW5nIHRvIGRvLiBJdCB3aWxsIGNvdmVyIHRoZSB2YXJpb3VzIG1lYW5pbmdzLFxyXG4gICAgLy8gIGRlYWxpbmcgd2l0aCBsb2NhbGx5IHN0b3JlZCBkYXRhIGFzIHdlbGwgYXMgcmVtb3RlLlxyXG5cclxuICAgIC8vIFdpdGhpbiBhIERhdGFfT2JqZWN0LCBpdCB3aWxsIGJlIGdldHRpbmcgRGF0YV9PYmplY3QgcHJvcGVydGllcyBzeW5jcm9ub3VzbHksIGJ1dCB3aGVuIGl0IGVuY291bnRlcnMgYSBSZXNvdXJjZSxcclxuICAgIC8vICBpdCBtYXkgbmVlZCB0byBnZXQgdGhhdCBhc3luY3Jvbm91c2x5LlxyXG5cclxuICAgIC8vIEhvdyBhYm91dDpcclxuICAgIC8vICBJZiBEYXRhX09iamVjdCBnZXQgd2FzIGNhbGxlZCBhc3luY2hyb25vdXNseSwgaXQgY2FuIGNhbGwgYXN5bmMgZ2V0IGZ1bmN0aW9ucyBmcm9tIHJlc291cmNlcywgYW5kIGNvbnRpbnVlc1xyXG4gICAgLy8gICB0aHJvdWdoIHRoZSBjaGFpbiBjYWxsaW5nIGFzeW5jaHJvbm91c2x5LlxyXG4gICAgLy8gIEl0IGZhaWxzIGlmIGl0IHRyaWVzIHRvIG1ha2UgYSBzeW5jcm9ub3VzIGNhbGwgb24gYSBSZXNvdXJjZS5cclxuICAgIC8vICAgSW50ZWdyYXRpbmcgcHJvbWlzZXMgd291bGQgYmUgbmljZSwgYnV0IGl0J3MgYSBuZXcgc3R5bGUgb2YgcHJvZ3JhbW1pbmcgdGhhdCBtYWtlcyB0aGF0IHBhcnRcclxuICAgIC8vICAgIG1vcmUgY29tcGxpY2F0ZWQgd2hlbiB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggb3RoZXIgcGllY2VzIG9mIGNvZGluZyB0aGF0IEknbSBhbHNvIHdvcmtpbmcgb24uXHJcblxyXG5cclxuICAgIC8vIEkgdGhpbmsgdGhlIG5vbiBhc3luY3Jvbm91cyBnZXQgY2FuIGJlIHNpbXBsaWZpZWQuXHJcbiAgICAvLyAgSXQgc2VlbXMgbGlrZSBpdCBpcyBkZWZpbml0ZWx5IHdvcnRoIGdldHRpbmcgdW5pdCB0ZXN0aW5nIGRvbmUuXHJcblxyXG5cclxuXHJcbiAgICAnZ2V0JzogZnAoZnVuY3Rpb24oYSwgc2lnKSB7XHJcblxyXG4gICAgICAgIC8vIDE3LzA2LzIwMTQgLSBOZXN0ZWQgaW50cmluc2ljIHByb3BlcnRpZXMuXHJcbiAgICAgICAgLy8gIE5lZWQgdG8gYWNjZXNzIG9iamVjdFtwcm9wZXJ0eU5hbWVdLCBub3QganVzdCBvYmplY3QuX1twcm9wZXJ0eU5hbWVdXHJcbiAgICAgICAgLy8gICBIb3dldmVyLCBtYXkgd2FudCB0byBzYXkgc29tZSBuYW1lcyBvZiBwcm9wZXJ0aWVzIGFyZSBuZXZlciBpbnRyaW5zaWMuXHJcblxyXG5cclxuICAgICAgICAvLyBDb3VsZCBoYXZlIG1vcmUgbWFuYWdhYmxlIChmb3IgdGhlIGNvbXBpbGVyKSBmdW5jdGlvbnMuXHJcblxyXG4gICAgICAgIC8vIGJ1dCB3aGVuIG5lc3RlZCBpcyBpbiBwbGFjZSwgaXMgaXQgc3RpbGwgd29ya2luZyByaWdodD9cclxuICAgICAgICAvLyBhbHNvIHdpbGwgaGF2ZSB0byBkZWFsIHdpdGggcGFydGljdWxhciBvdXRwdXQgZm9ybWF0cy5cclxuICAgICAgICAvLyAgbWFueSBjb250cm9scyAvIGRhdGEgdHlwZXMgZm9yIHRoZSBtb21lbnQgd2lsbCBoYXZlIGRlZmF1bHQgb3V0cHV0IGFzIEhUTUwgZm9ybWF0dGVkLlxyXG4gICAgICAgIC8vY29uc29sZS5sb2coJ0RhdGFfT2JqZWN0IGdldCB0aGlzLl9fdHlwZV9uYW1lICcgKyB0aGlzLl9fdHlwZV9uYW1lKTtcclxuICAgICAgICAvL2NvbnNvbGUubG9nKCdEYXRhX09iamVjdCBnZXQgc2lnICcgKyBzaWcpO1xyXG4gICAgICAgIC8vY29uc29sZS5sb2coJyogZ2V0IGEgJyArIHN0cmluZ2lmeShhKSk7XHJcbiAgICAgICAgLy8gd2lsbCBhbHNvIGJlIGxvb2tpbmcgYXQgdGhlIG91dHB1dCBwcm9jZXNzb3JzLlxyXG4gICAgICAgIGlmIChpc19kZWZpbmVkKHRoaXMuX190eXBlX25hbWUpKSB7XHJcbiAgICAgICAgICAgIC8vIHNob3VsZCBwb3NzaWJseSBoYXZlIHRoaXMgYXNzaWduZWQgZm9yIGNvbnRyb2xzLi4uXHJcbiAgICAgICAgICAgIC8vdmFyIHJhd19pbnB1dCA9IGE7XHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3RoaXMuX190eXBlX25hbWUgaXMgZGVmaW5lZDogJyArIHRoaXMuX190eXBlX25hbWUpO1xyXG5cclxuICAgICAgICAgICAgLy92YXIgcGFyc2VkX2lucHV0X29iaiA9IGpzZ3VpLmlucHV0X3Byb2Nlc3NvcnNbdGhpcy5fX3R5cGVfbmFtZV0ocmF3X2lucHV0KTtcclxuICAgICAgICAgICAgaWYgKGEubCA9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgb3V0cHV0X29iaiA9IGpzZ3VpLm91dHB1dF9wcm9jZXNzb3JzW3RoaXMuX190eXBlX25hbWVdKHRoaXMuXyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb3V0cHV0X29iajtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRocm93ICdub3QgeWV0IGltcGxlbWVudGVkJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoc2lnID09ICdbcyxmXScpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBob3dldmVyLCBpdCBpcyBtb3JlIGNvbXBsaWNhdGVkIHRoYW4gdGhhdC5cclxuICAgICAgICAgICAgICAgIC8vICBtYXliZSBwdXQgdGhpcyBpbiByZXNvdXJjZSBsZXZlbD9cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBUaG91Z2gsIGNvbGxlY3Rpb25zIGFuZCBkYXRhLW9iamVjdHMgaGFuZGxpbmcgYXN5bmMgb3BlcmF0aW9ucyB3ZWxsIHdvdWxkIGJlIGFuIGFkdmFudGFnZS5cclxuICAgICAgICAgICAgICAgIC8vICBUaGlzIG1heSBpbnRlcnNwZXJzZSB3aXRoIHRoZSByZXNvdXJjZXMsIGNvdWxkIHBlcmhhcHMgaGF2ZSB0aGUgcmVzb3VyY2UgcmV0dXJuIGEgcHJvbWlzZVxyXG4gICAgICAgICAgICAgICAgLy8gIChmdW5jdGlvbj8pIGlmIGl0IGhhZCB0byBvcGVyYXRlIGFzeW5jcm9ub3VzbHkuXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gR28gdGhyb3VnaCB0aGUgc3lzdGVtIHdpdGggYXN5bmMgY2FsbHM/XHJcbiAgICAgICAgICAgICAgICAvLyAgTWF5IG5vdCBiZSBhbGwgdGhhdCBoYXJkIHRvIGRvLi4uXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSSB0aGluayB0aGlzIG1heSBuZWVkIG1vcmUgd29yay4uLlxyXG4gICAgICAgICAgICAgICAgLy8gIEtlZXAgY29udGludWluZyB0aHJvdWdoIHRoZSBjaGFpbiwgdXNpbmcgYXN5bmMgY2hhaW5pbmcuXHJcbiAgICAgICAgICAgICAgICB0aHJvdyAnQXN5bmNyb25vdXMgYWNjZXNzIG5vdCBhbGxvd2VkIG9uIERhdGFfT2JqZWN0IGdldC4nXHJcblxyXG5cclxuICAgICAgICAgICAgICAgIHZhciByZXMgPSB0aGlzLmdldChhWzBdKTtcclxuICAgICAgICAgICAgICAgIHZhciBjYWxsYmFjayA9IGFbMV07XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZXMgPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlcyhjYWxsYmFjayk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXM7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBjb3VsZCBjaGVjayBpZiB3ZSBoYWQgYSBmdW5jdGlvbiByZXR1cm5lZC5cclxuICAgICAgICAgICAgICAgIC8vICB0aGVuIHdlIGV4ZWN1dGUgdGhhdCBmdW5jdGlvblxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAvL2NhbGxiYWNrKG51bGwsIHJlcyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIGNoZWNrIHRvIHNlZSBpZiB0aGVyZSBpcyBhIGZpZWxkIGRlZmluZWQuXHJcbiAgICAgICAgICAgIGlmIChzaWcgPT0gJ1tzXScpIHtcclxuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2dldCBwYXJhbTogJyArIGFbMF0pO1xyXG4gICAgICAgICAgICAgICAgdmFyIGZjID0gdGhpcy5mYztcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBsZXQncyBoYXZlIGEgbG9vayBhdCB0aGUgZmllbGRzXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRG9uJ3QgdHJ5IHRvIHN0cmluZ2lmeSBmaWVsZCBjb2xsZWN0aW9ucyAoeWV0KS5cclxuXHJcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdmYy5nZXQoKSAnICsgc3RyaW5naWZ5KGZjLmdldCgpKSk7XHJcblxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgZmllbGRfbmFtZSA9IGFbMF07XHJcbiAgICAgICAgICAgICAgICAvLyBjb3VsZCBoYXZlIC5zIGluIGl0LCBtYWtpbmcgaXQgbmVzdGVkLCBhbmQgaGF2ZSByZW1vdmVkIG5lc3RlZCBmcm9tIGhlcmUuXHJcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdwcmUgZmMgZ2V0Jyk7XHJcbiAgICAgICAgICAgICAgICB2YXIgZmllbGQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoZmMpIHtcclxuICAgICAgICAgICAgICAgICAgICBmaWVsZCA9IGZjLmdldChhWzBdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgLy90aHJvdyAnc3RvcCc7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gYmVpbmcgdG9sZCB0byBnZXQgJ2RvbS5hdHRyaWJ1dGVzLmNsYXNzJy5cclxuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2ZpZWxkICcgKyBmaWVsZCk7XHJcbiAgICAgICAgICAgICAgICAvLyBzaG91bGQgYmUgYWJsZSB0byBnZXQgJ2RvbScgZmllbGQgZmlyc3QuXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gc28gaWYgaXQgaXMgbXVsdGktbGV2ZWwsIHdlIGNhbiBoYXZlIGEgZnVuY3Rpb24gdGhhdCBwcm9jZXNzZXMgdGhpcyBtdWx0aS1sZXZlbCByZXF1ZXN0LlxyXG5cclxuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2ZpZWxkX25hbWUgJyArIGZpZWxkX25hbWUpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChmaWVsZF9uYW1lLmluZGV4T2YoJy4nKSA+IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlbiB3ZSBhcmUgZGVhbGluZyB3aXRoIGEgcmVxdWVzdCBmb3IgYSBuZXN0ZWQgb2JqZWN0LlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFNwbGl0IHVwIHRoZSBmaWVsZF9uYW1lIGludG8gdGhlIHZhcmlvdXMgZmllbGQgbmFtZXMgZm9yIHRoZSBsZXZlbHMsIHRoZW4gaGF2ZSBhIHJlY3Vyc2l2ZSBmdW5jdGlvbiBoZXJlXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gIHByb2Nlc3MgdGhyb3VnaCB0aGUgbGV2ZWxzLiBXaWxsIGtlZXAgdGhlIHJlY3Vyc2l2ZSBwYXJ0IHNtYWxsIGluIHNpemUgYW5kIGxvY2F0ZWQgaGVyZS5cclxuICAgICAgICAgICAgICAgICAgICAvLyBNYXkgbm90IG5lZWQgdG8gZXZlbiBiZSByZWN1cnNpdmUuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhcnJfZmllbGRfbmFtZXMgPSBmaWVsZF9uYW1lLnNwbGl0KCcuJyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBsZXZlbCA9IDAsIGwgPSBhcnJfZmllbGRfbmFtZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjdXJyZW50X29iaiA9IHRoaXMsIG5ld19vYmosIGZuYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlKGxldmVsIDwgbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmbmFtZSA9IGFycl9maWVsZF9uYW1lc1tsZXZlbF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY3VycmVudF9vYmopIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9LLCBidXQgd2UgbWF5IGJlIGRlYWxpbmcgYXN5bmNyb25vdXNseSBub3cuIElmIHRoZSBjdXJyZW50IG9iamVjdCBpcyBhIGZ1bmN0aW9uLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpdCBnZXRzIGNhbGxlZCBhbmQgd2UgdXNlIHRoZSBjYWxsYmFjayB0byBkbyBpdHMgc3R1ZmYuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJIHRoaW5rIHRoaXMgYnJhbmNoIHNob3VsZCBvbmx5IGhhbmRsZSBzeW5jaHJvbm91cyBjaGFpbmluZy5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjdXJyZW50X29iaiA9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgZ290dGVuIGluZm8gaXMgdGhlcmUgSSBob3BlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIHRvdGFsbHkgd291bGQgbm90IHdvcmsgaW4gYSB3aGlsZSBsb29wIEkgdGhpbmsuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgTWF5YmUgd291bGQgbmVlZCB0byBzcGxpdCB1cCB0aGUgZ2V0dGluZywgYW5kIGVuZGluZyB0aGUgd2hpbGUgbG9vcC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1heSBiZSB3b3J0aCBzZWVpbmcgd2hhdCBpcyBuZXh0Li4uXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhpcyB3YXMgY2FsbGVkIHdpdGhvdXQgYSBjYWxsYmFjaywgYW5kIG5lZWRzIHRvIGJlIGFzeW5jLCBjYW4gcmV0dXJuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgYSBmdW5jdGlvbiB0byBjYWxsLlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxldCdzIGhhdmUgYSBsb29rIGF0IHRoZSBuZXh0IGxldmVscyBmaWVsZCBuYW1lcy4uLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ2xldmVsJywgbGV2ZWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ2Fycl9maWVsZF9uYW1lcycsIGFycl9maWVsZF9uYW1lcyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2FudCB0byBnZXQgdGhlIHNsaWNlIG9mIGFycl9maWVsZF9uYW1lcyB1bnRpbCB0aGUgbmV4dFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gIG1heWJlIHJldHVybiBhIHByb21pc2UgdG8gZ2V0IGl0IGhlcmU/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgIGFuZCBzZXQgaXQgdXAgc28gdGhhdCBpdCBwcm9jZWVkcyB0byBnZXQgaXQuLi5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dCA9IGFycl9maWVsZF9uYW1lcy5zbGljZShsZXZlbCkuam9pbignLicpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihjYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vcmV0dXJuIGN1cnJlbnRfb2JqLmdldChuZXh0LCBjYWxsYmFjayk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRfb2JqKGZ1bmN0aW9uKGVyciwgcmVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdnb3QgcmVzJywgcmVzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ2dvdCByZXMnLCBzdHJpbmdpZnkocmVzKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGF0J3MgYXNzdW1pbmcgcmVzIGlzIGEgcmVzb3VyY2Ugb3IgZGF0YV9vYmplY3Q/XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXMuZ2V0KG5leHQsIGNhbGxiYWNrKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9yZXMobmV4dCwgY2FsbGJhY2spO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2NhbGxiYWNrKG51bGwsIHJlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2FudCB0byBjYWxsIGdldCBvbiB0aGUgaXRlbSByZXR1cm5lZC5cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy90aHJvdyAnc3RvcCc7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jdXJyZW50X29iaihmdW5jdGlvbihlcnIsIGdvdHRlbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9cdC8vbmV3X29iaiA9IGN1cnJlbnRfb2JqLmdldChmbmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1x0bGV2ZWwrKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vXHQvLyB0b28gbGF0ZSBieSBub3cuIHdvdWxkIG5lZWQgdG8gYnJlYWsgb3V0IG9mIHRoZSB3aGlsZS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vXHQvLyAgbm90IHJlYWxseSBwb3NzaWJseSAocmlnaHQgbm93KT9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vXHQvL1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vXHRjdXJyZW50X29iaiA9IG5ld19vYmo7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL30pXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdfb2JqID0gY3VycmVudF9vYmouZ2V0KGZuYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnZm5hbWUgJyArIGZuYW1lKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNvLCB3aGVuIHRoZSBkb20gb2JqZWN0IGlzIG9idGFpbmVkLCBpdCBzaG91bGQgaGF2ZSBpdHMgb3duIGZpZWxkcy5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gIFRoZSAnZ2V0JyBmdW5jdGlvbiB3aWxsIG5lZWQgdG8gYmUgbW9kaWZpZWQgdG8gcmV0dXJuIG9iamVjdHMgb2YgdGhlIHJpZ2h0IHR5cGUgLyBjbGFzcy5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ25ld19vYmogJyArIHN0cmluZ2lmeShuZXdfb2JqKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2N1cnJlbnRfb2JqICcgKyBzdHJpbmdpZnkoY3VycmVudF9vYmopKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldmVsKys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRfb2JqID0gbmV3X29iajtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYnV0IGNvdWxkIHRoaXMgcmV0dXJuIGEgZnVuY3Rpb24/XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gIGNvdWxkIHRoYXQgYmUgaGFuZGxlZD9cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRfb2JqO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2ZpZWxkX25hbWUgJyArIGZpZWxkX25hbWUpO1xyXG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnZmllbGQgJyArIHN0cmluZ2lmeShmaWVsZCkpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIGZpZWxkcyBzZWVtIHRvIHN0b3AgaGF2aW5nIGJlZW4gc2V0IHVwIHByb3Blcmx5LlxyXG5cclxuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2dldDogZmllbGQgJyArIChmaWVsZCkpO1xyXG4gICAgICAgICAgICAgICAgLy90aHJvdyAnc3RvcCc7XHJcbiAgICAgICAgICAgICAgICBpZiAoZmllbGQpIHtcclxuICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCd0b2YoZmllbGQpICcgKyB0b2YoZmllbGQpKTtcclxuICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdmaWVsZCAnICsgc3RyaW5naWZ5KGZpZWxkKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vdGhyb3cgJ3N0b3AnO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCd0aGlzLl9bZmllbGRfbmFtZV0gJyArIHRoaXMuX1tmaWVsZF9uYW1lXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZGVwZW5kaW5nIG9uIHRoZSB0eXBlLCBzdWNoIGFzIGlmIGl0IGlzIGEgY29sbGVjdGlvbiBvciBzb21lIG90aGVyIGtpbmQgb2YgRGF0YV9PYmplY3QsIGRlZmluZSBpdC5cclxuICAgICAgICAgICAgICAgICAgICAvL2lmICghaXNfZGVmaW5lZCgpKVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBkbyB3ZSBrbm93IHRoZSBmaWVsZCBuYW1lIHlldD9cclxuICAgICAgICAgICAgICAgICAgICAvLyB5ZXNcclxuICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdmaWVsZF9uYW1lICcgKyBmaWVsZF9uYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCd0aGlzLl9bZmllbGRfbmFtZV0gJyArIHRoaXMuX1tmaWVsZF9uYW1lXSk7XHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX1tmaWVsZF9uYW1lXSkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnZGlkIG5vdCBmaW5kIG9iamVjdCBmb3IgZmllbGQuIHdpbGwgbWFrZSBvbmUgaWYgYXBwcm9wcmlhdGUuIGZpZWxkX25hbWUgPSAnICsgZmllbGRfbmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3RoaXMuX1tmaWVsZF9uYW1lXSAnICsgdGhpcy5fW2ZpZWxkX25hbWVdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY3JlYXRlIHRoZSBuZXcgaXRlbSBvZiB0aGF0IHR5cGUuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICBqdXN0IGNvbGxlY3Rpb25zIGZvciB0aGUgbW9tZW50LlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNpZ19maWVsZCA9IGdldF9pdGVtX3NpZyhmaWVsZCwgMjApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCcxKSBzaWdfZmllbGQgJyArIHN0cmluZ2lmeShzaWdfZmllbGQpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnZmllbGQgJyArIHN0cmluZ2lmeShmaWVsZCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBbmQgYSBmdW5jdGlvbiBoZXJlPyBUaGUgZGVmaW5pdGlvbiBvZiBhIGZpZWxkPyBTdHJpbmcgY29uc3J1Y3RvciBldGMuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICBIYXJkZXIgdG8gZGlmZmVyZW50aWF0ZSBiZXR3ZWVuIHRoYXQgYW5kIGNhbGxiYWNrcyBub3cuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIG9yIGEgY2FsbGJhY2s/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICBUaGVyZSB3b3VsZCBuZWVkIHRvIGJlIGEgd2F5IHRvIHRlbGwgdGhlIGRpZmZlcmVuY2UsIGV2ZW4gaWYgd2UgYXNzaWduIGFcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gIF9pc19jb25zdHJ1Y3RvciBwcm9wZXJ0eSB0byB0aGUgY29uc3RydWN0b3JzLlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUGVyaGFwcyBzdG9wIHVzaW5nIHRoaXM/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICBXZSBjYW4gZ2V0IGZpZWxkcyBhbnl3YXksIHdpdGhvdXQgc3BlY2lmeWluZyB0aGUgdHlwZXMuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICBBbHNvIHRoZSBjb25zdHJ1Y3RvciBmdW5jdGlvbiB0aGVyZSBnZXRzIGNvbmZ1c2VkIHdpdGggY2FsbGJhY2tzIHBvdGVudGlhbGx5LlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNpZ19maWVsZCA9PSAnW3MscyxmXScpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmaWVsZF9uYW1lID0gZmllbGRbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmllbGRTdHJUeXBlID0gZmllbGRbMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmllbGREZWYgPSBmaWVsZFsyXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNYXliZSBsb29rIG91dCBmb3IgU3RyaW5nP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gIERlYWxpbmcgd2l0aCBTdHJpbmcgZmllbGRzLCBnaXZlbiBhcyBhIFN0cmluZyBjbGFzcz9cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQnV0IGlmIGl0IGlzIGEgU3RyaW5nLCBtYXliZSB3ZSB1c2UgYSBEYXRhX1ZhbHVlXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpZWxkRGVmID09IFN0cmluZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2lzIGEgU3RyaW5nJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy90aHJvdyAnc3RvcCc7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkdmFsID0gbmV3IERhdGFfVmFsdWUoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnY29udGV4dCc6IHRoaXMuX2NvbnRleHRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX1tmaWVsZF9uYW1lXSA9IGR2YWw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX1tmaWVsZF9uYW1lXTtcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChmaWVsZERlZiA9PSBOdW1iZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdpcyBhIFN0cmluZycpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdGhyb3cgJ3N0b3AnO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZHZhbCA9IG5ldyBEYXRhX1ZhbHVlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2NvbnRleHQnOiB0aGlzLl9jb250ZXh0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9bZmllbGRfbmFtZV0gPSBkdmFsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9bZmllbGRfbmFtZV07XHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZmllbGRTdHJUeXBlID09ICdDbGFzcycpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDYW4ndCBjcmVhdGUgYSBuZXcgc3RyaW5nIGxpa2UgdGhpcy4uLlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgRmllbGRDb25zdHJ1Y3RvciA9IGZpZWxkRGVmO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuT2JqID0gbmV3IEZpZWxkQ29uc3RydWN0b3Ioe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnY29udGV4dCc6IHRoaXMuX2NvbnRleHRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX1tmaWVsZF9uYW1lXSA9IG5PYmo7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX1tmaWVsZF9uYW1lXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaWdfZmllbGQgPT0gJ1tzLFtzLHVdXScpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGl0IGxvb2tzIGxpa2UgaXQgaGFzIGdvbmUgd3JvbmcuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RhY2sgPSBuZXcgRXJyb3IoKS5zdGFjaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHN0YWNrKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNpZ19maWVsZCA9PSAnW3MscyxvXScpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmaWVsZF9uYW1lID0gZmllbGRbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmllbGRfdHlwZV9uYW1lID0gZmllbGRbMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmllbGRfaW5mbyA9IGZpZWxkWzJdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vZmllbGRfbmFtZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnKiBmaWVsZF9uYW1lICcgKyBmaWVsZF9uYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJyogZmllbGRfdHlwZV9uYW1lICcgKyBmaWVsZF90eXBlX25hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnKiBmaWVsZF9pbmZvICcgKyBzdHJpbmdpZnkoZmllbGRfaW5mbykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbmVlZCB0byBjb3ZlciBjYXNlcyB3aGVyZSB3ZSBoYXZlIHRoZSBmaWVsZCBpbmZvLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gIGl0IG1heSBuZWVkIHRvIGNyZWF0ZSBhIG5ldyBvYmplY3QgbWF0Y2hpbmcgdGhhdCBmaWVsZCwgd2l0aCB0aGUgY2hlY2tcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgdGhhdCB0aGUgZGF0YSBmaXRzIGludG8gdGhhdCBmaWVsZC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERhdGFfVmFsdWUgd291bGQgbGlrZWx5IGJlIGEgZ29vZCB0eXBlIGZvciBhIHZhcmlldHkgb2YgZmllbGRzLlxyXG5cclxuXHJcblxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmllbGRfdHlwZV9uYW1lID09ICdjb2xsZWN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2xhenkgbG9hZGluZyAtIGNyZWF0aW5nIG5ldyBjb2xsZWN0aW9uJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fW2ZpZWxkX25hbWVdID0gbmV3IGpzZ3VpLkNvbGxlY3Rpb24oe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnY29udGV4dCc6IHRoaXMuX2NvbnRleHRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fW2ZpZWxkX25hbWVdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBpdCdzIGp1c3QgYSBzdHJpbmc/XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICdkYXRhX29iamVjdCdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgbWF5IGdldCB0aGUgZGF0YV90eXBlX29iamVjdF9jb25zdHJ1Y3RvciBoZXJlLlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmllbGRfdHlwZV9uYW1lID09ICdkYXRhX29iamVjdCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRvYmogPSBuZXcgRGF0YV9PYmplY3Qoeydjb250ZXh0JzogdGhpcy5fY29udGV4dH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9bZmllbGRfbmFtZV0gPSBkb2JqO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb2JqLnBhcmVudCh0aGlzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX1tmaWVsZF9uYW1lXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmllbGRfdHlwZV9uYW1lID09ICdvcmRlcmVkX3N0cmluZ19saXN0Jykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3NsID0gbmV3IE9yZGVyZWRfU3RyaW5nX0xpc3QoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fW2ZpZWxkX25hbWVdID0gb3NsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fW2ZpZWxkX25hbWVdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZmllbGRfdHlwZV9uYW1lID09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVzZSBhIERhdGFfVmFsdWU/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdGhyb3cgJ3N0b3AnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZHYgPSBuZXcgRGF0YV9WYWx1ZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnY29udGV4dCc6IHRoaXMuX2NvbnRleHRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vZHYuc2V0KClcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2R2Ll9faWQgJyArIGR2Ll9faWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdkdi5faWQoKSAnICsgZHYuX2lkKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3Rocm93ICdzdG9wJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fW2ZpZWxkX25hbWVdID0gZHY7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBub3QgcHJvdmlkaW5nIGFuIGluZGV4XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR2LnBhcmVudCh0aGlzKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2R2ICcgKyBzdHJpbmdpZnkoZHYpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9bZmllbGRfbmFtZV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5lZWQgdG8gbG9vayBpbnRvIG1vcmUgaW5mbyBhYm91dCB0aGUgZmllbGQuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2ZpZWxkX2luZm8gJyArIHN0cmluZ2lmeShmaWVsZF9pbmZvKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlnbm9yZSBpbmRleGVkIGhlcmUgSSB0aGluay5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhbiBnZXQgZGF0YSB0eXBlIG9iamVjdCBjb25zdHJ1Y3RvcnMgZm9yIHZhcmlvdXMgdHlwZXMgb2YgZmllbGQsIHN1Y2ggYXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gIHtcImRhdGFfdHlwZVwiOiBbXCJ0ZXh0XCIsIDMyXSwgXCJpbmRleGVkXCI6IHRydWV9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICBpbmRleGVkIHRleHQoMzIpXHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9pZiAoZmllbGRfaW5mby5kYXRhX3R5cGUgPT0gKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBuZWVkIHRvIHNlZSBpZiBpdCdzIGEgdGV4dCBmaWVsZC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gIGRhdGFfdHlwZSA9IFtuYW1lLCBsZW5ndGhdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICBhbmQgbG9vayBhdCB0aGUgaXRlbV9zaWcgZm9yIHRoZSBkYXRhX3R5cGUuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkdCA9IGZpZWxkX2luZm8uZGF0YV90eXBlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZHRfc2lnID0gZ2V0X2l0ZW1fc2lnKGR0LCA0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnZHRfc2lnICcgKyBkdF9zaWcpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGR0X3NpZyA9PSAnW3Msbl0nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YV90eXBlX25hbWUgPSBkdFswXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkYXRhX3R5cGVfbGVuZ3RoID0gZHRbMV07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlbiBmb3IgdGV4dCwganVzdCBtYWtlIGEgRGF0YV9WYWx1ZVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhX3R5cGVfbmFtZSA9PSAndGV4dCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZFZhbCA9IG5ldyBEYXRhX1ZhbHVlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2NvbnRleHQnOiB0aGlzLl9jb250ZXh0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9kVmFsLnBhcmVudCh0aGlzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3ZhbHVlLnNldChmaWVsZF92YWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX1tmaWVsZF9uYW1lXSA9IGRWYWw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX1tmaWVsZF9uYW1lXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgZGF0YSB0eXBlIGlzIGp1c3QgYSBzdHJpbmcsIG5lZWQgdG8gcHJvY2VzcyBzb21lIHNwZWNpZmljXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgZGF0YSB0eXBlcy5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgbWF5IGJlIHBvc3NpYmxlIHVzaW5nIGlucHV0IHByb2Nlc3NvcnM/XHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkdF9zaWcgPT0gJ3MnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YV90eXBlX25hbWUgPSBkdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJyoqKiBkYXRhX3R5cGVfbmFtZSAnICsgZGF0YV90eXBlX25hbWUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhX3R5cGVfbmFtZSA9PSAnaW50Jykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkVmFsID0gbmV3IERhdGFfVmFsdWUoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnY29udGV4dCc6IHRoaXMuX2NvbnRleHRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2RWYWwucGFyZW50KHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdmFsdWUuc2V0KGZpZWxkX3ZhbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fW2ZpZWxkX25hbWVdID0gZFZhbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fW2ZpZWxkX25hbWVdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9pZiAoZGF0YV90eXBlX25hbWUgPT0gJycpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZHRvYyA9IHRoaXMubW9kX2xpbmsoKS5lbnN1cmVfZGF0YV90eXBlX2RhdGFfb2JqZWN0X2NvbnN0cnVjdG9yKGZpZWxkX3R5cGVfbmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdkdG9jICcgKyBkdG9jKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZW4gdXNlIHRoaXMgdG8gY29uc3RydWN0IHRoZSBlbXB0eSBmaWVsZC5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3Rocm93ICchIXN0b3AnO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmaWVsZF92YWwgPSBuZXcgZHRvYyh7J2NvbnRleHQnOiB0aGlzLl9jb250ZXh0fSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWVsZF92YWwucGFyZW50KHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fW2ZpZWxkX25hbWVdID0gZmllbGRfdmFsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX1tmaWVsZF9uYW1lXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aHJvdyAnc3RvcCc7XHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIGl0IGlzIGEgZGVmaW5lZCBkYXRhIHR5cGUuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gIGlmIHNvLCB3ZSBjYW4gZG8gc29tZXRoaW5nIHdpdGggaXQuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICBpbnB1dCB3aXRoIHRoYXQgZGF0YSB0eXBlLCBhbmQgb3V0cHV0IGZyb20gaXQuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgY29kZSBpcyBnZXR0aW5nIHF1aXRlIGJpZy4gSSB0aGluayBpdCB3b24ndCBiZSBhbGwgdGhhdCBiaWcgd2hlbiBjb21wcmVzc2VkLCByZWZhY3RvcmVkIGEgYml0LlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICBPbmNlIGl0IGhhcyBiZWVuIHRlc3RlZCBpdCBjYW4gYmUgcmVmYWN0b3JlZCBkb3duIHF1aXRlIGEgbG90LCBkb24ndCB3YW50IHRvIGRvIHRoYXQgd2hpbGUgaXQgaXMgc3RpbGwgYmVpbmcgYnVpbHQuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIGFuIGlucHV0IHByb2Nlc3Nvciwgd2Uga25vdyBob3cgdG8gZGVhbCB3aXRoIGl0IGZvciB0aGUgbW9tZW50LlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICBzYW1lIHdpdGggb3V0cHV0IHByb2Nlc3Nvcj9cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc28geW91IGdldCB0aGUgZG9tIGRhdGFfb2JqZWN0P1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICBJIHRoaW5rIGF1dG9tYXRpY2FsbHkgY3JlYXRlZCBhbmQgbmVzdGVkIERhdGFfT2JqZWN0cyBhcmUgdGhlIHdheS5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYSBEYXRhX09iamVjdCBvZiB0aGF0IHR5cGU/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gIGF1dG9tYXRpYyBEYXRhX09iamVjdCBleHRlbnNpb25zP1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3Rocm93KCc1KSBzdG9wJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNpZ19maWVsZCA9PSAnW3Msc10nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmllbGRfbmFtZSA9IGZpZWxkWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZpZWxkX3R5cGVfbmFtZSA9IGZpZWxkWzFdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2ZpZWxkX25hbWUgJyArIGZpZWxkX25hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnZmllbGRfdHlwZV9uYW1lICcgKyBmaWVsZF90eXBlX25hbWUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBlcmhhcHMgZ2V0dGluZyBjb2xsZWN0aW9uIGZpZWxkcyBzaG91bGQgYmUgbW92ZWQgdG8gZW5oYW5jZWRfZGF0YV9vYmplY3Q/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgbm90IGtlZW4gb24gaW50ZXJkZXBlbmRlbmNpZXMgaGVyZS5cclxuXHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaWVsZF90eXBlX25hbWUgPT0gJ2NvbGxlY3Rpb24nKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxhenkgY3JlYXRpb24gb2YgZmllbGRzLlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyAnbm90IHN1cHBvcnRlZCBoZXJlLiBzaG91bGQgdXNlIGNvZGUgaW4gZW5oYW5jZWQtZGF0YS1vYmplY3QuJztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU28sIENvbGxlY3Rpb24gaGFzIGJlZW4gYWRkZWQgdG8ganNndWkgYnkgbm93LlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdwcmUgbWFrZSBjb2xsJyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1heWJlIENvbGxlY3Rpb24gaGFzIG5vdCBiZWVuIGFkZGVkIHRvIGpzZ3VpLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICBOZWVkIHRvIGVuc3VyZSBpdCBkb2VzIGdldCBhZGRlZCB3aGVuIGl0J3MgZ2V0dGluZyB1c2VkLlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzZWVtcyBsaWtlIHRoZSBDb2xsZWN0aW9uIG9iamVjdCBkb2VzIG5vdCBnZXQgcHV0IGJhY2sgb24gdGhpcy4uLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICBvciBhdCBsZWFzdCBub3QgYWx3YXlzLlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBsb29rcyBsaWtlIHdlIHVzZSB0aGUgbW9kdWxlIGFzIGl0IGlzLlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29sbCA9IG5ldyBqc2d1aS5Db2xsZWN0aW9uKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2NvbnRleHQnOiB0aGlzLl9jb250ZXh0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdwcmUgc2V0IGNvbGwgcGFyZW50Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sbC5wYXJlbnQodGhpcyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX1tmaWVsZF9uYW1lXSA9IGNvbGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX1tmaWVsZF9uYW1lXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGZpZWxkX3R5cGVfbmFtZSA9PSAnZGF0YV9vYmplY3QnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRvYmogPSBuZXcganNndWkuRGF0YV9PYmplY3Qoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnY29udGV4dCc6IHRoaXMuX2NvbnRleHRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvYmoucGFyZW50KHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX1tmaWVsZF9uYW1lXSA9IGRvYmo7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX1tmaWVsZF9uYW1lXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkdG9jID0ganNndWkuZW5zdXJlX2RhdGFfdHlwZV9kYXRhX29iamVjdF9jb25zdHJ1Y3RvcihmaWVsZF90eXBlX25hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2R0b2MgJyArIGR0b2MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdGhyb3cgJyFzdG9wJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGVuIHVzZSB0aGlzIHRvIGNvbnN0cnVjdCB0aGUgZW1wdHkgZmllbGQuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gIHdpdGhvdXQgdGhlIG5ldyBjb25zdHJ1Y3RvciBpdCB3YXMgdHJ5aW5nIHRvIG1ha2UgYW4gYWJzdHJhY3QgdmVyc2lvbiEhIVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvYmogPSBuZXcgZHRvYyh7J2NvbnRleHQnOiB0aGlzLl9jb250ZXh0fSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9pZiAodGhpcy5fY29udGV4dCkgb2JqLl9jb250ZXh0ID0gdGhpcy5fY29udGV4dDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmoucGFyZW50KHRoaXMpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9bZmllbGRfbmFtZV0gPSBvYmo7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygndGhpcy5fICcgKyBzdHJpbmdpZnkodGhpcy5fKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9bZmllbGRfbmFtZV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc2lnX2ZpZWxkID09ICdbcyxbcyxzXV0nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmllbGRfbmFtZSA9IGZpZWxkWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZpZWxkX2luZm8gPSBmaWVsZFsxXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdmaWVsZF9pbmZvICcgKyBzdHJpbmdpZnkoZmllbGRfaW5mbykpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaWVsZF9pbmZvWzBdID09ICdjb2xsZWN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb2xsZWN0aW9uX3R5cGVfbmFtZSA9IGZpZWxkX2luZm9bMV07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5ldyBDb2xsZWN0aW9uKCdzdHJpbmcnKSBzaG91bGQgd29yay5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29udGV4dCBuZWVkcyB0byBiZSBzZXQgYXQgdGhlIGJlZ2lubmluZyB0aG91Z2guXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gIENhbid0IG1ha2UgYSBjb2xsZWN0aW9uIGZyb20gdGhpcyBtb2R1bGUuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5lZWQgYSB3YXkgdG8gYmUgYWJsZSB0byFcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy92YXIgbmNvbGwgPSBuZXcganNndWkuQ29sbGVjdGlvbih7J2NvbnRleHQnOiB0aGlzLl9jb250ZXh0fSlcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy92YXIgbmNvbGwgPSBuZXcganNndWkuQ29sbGVjdGlvbihjb2xsZWN0aW9uX3R5cGVfbmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9pZiAodGhpcy5fY29udGV4dCkgbmNvbGwuX2NvbnRleHQgPSB0aGlzLl9jb250ZXh0O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL25jb2xsLnBhcmVudCh0aGlzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3RoaXMuX1tmaWVsZF9uYW1lXSA9IG5jb2xsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vcmV0dXJuIHRoaXMuX1tmaWVsZF9uYW1lXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzaWdfZmllbGQgPT0gJ1tzLFtzLG9dXScpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFtmaWVsZE5hbWUsWydjb2xsZWN0aW9uJywgb2JqRGVmXV1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlZyBmaWVsZCBbXCJlbnRyaWVzXCIsIFtcImNvbGxlY3Rpb25cIiwge1wiYWRkcmVzc1wiOiBcInN0cmluZ1wiLCBcImZhbWlseVwiOiBcInN0cmluZ1wiLCBcImludGVybmFsXCI6IFwiYm9vbGVhblwifV1dXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpdCdzIGEgY29sbGVjdGlvbj8/IChjaGVjaywgd2l0aCB0aGUgcGFydGljdWxhciBkYXRhIHR5cGUpXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZpZWxkX25hbWUgPSBmaWVsZFswXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmaWVsZF9pbmZvID0gZmllbGRbMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YV90eXBlX25hbWUgPSBmaWVsZF9pbmZvWzBdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhX3R5cGVfbmFtZSA9PSAnY29sbGVjdGlvbicpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2JqRGVmID0gZmllbGRfaW5mb1sxXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyAnbm90IHN1cHBvcnRlZCBoZXJlLiBzaG91bGQgdXNlIGNvZGUgaW4gZW5oYW5jZWQtZGF0YS1vYmplY3QuJztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTmVlZCB0byBkbyBtb3JlIHRoYW4gdGhpcy5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3ZhciBuY29sbCA9IG5ldyBqc2d1aS5Db2xsZWN0aW9uKHsnY29udGV4dCc6IHRoaXMuX2NvbnRleHR9KVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3ZhciBuY29sbCA9IG5ldyBqc2d1aS5Db2xsZWN0aW9uKGNvbGxlY3Rpb25fdHlwZV9uYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2lmICh0aGlzLl9jb250ZXh0KSBuY29sbC5fY29udGV4dCA9IHRoaXMuX2NvbnRleHQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vbmNvbGwucGFyZW50KHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdGhpcy5fW2ZpZWxkX25hbWVdID0gbmNvbGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9yZXR1cm4gdGhpcy5fW2ZpZWxkX25hbWVdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnZGlkIGZpbmQgZmllbGQgb2JqICcgKyBmaWVsZF9uYW1lKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9bZmllbGRfbmFtZV07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL3ZhciB0ZiA9IHRvZih0aGlzLl9bZmllbGRfbmFtZV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3RmICcgKyB0Zik7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9pZiAoKVxyXG5cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gV2l0aG91dCBhIGZpZWxkLi4uIHRcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlcyA9IGxsX2dldCh0aGlzLl8sIGFbMF0pO1xyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpZWxkX25hbWUuaW5kZXhPZignLicpID4gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93ICdub3QgeWV0IGhhbmRsZWQnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzID0gdGhpc1thWzBdXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyBJbnN0cmluc2ljIGdldC4uLlxyXG5cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3Byb3BlcnR5X25hbWUgJyArIHByb3BlcnR5X25hbWUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBCcmVha3MgaXQgd2l0aCBzdHJpbmdpZnksIGlzIGhhcmQgdG8gdHJhY2sgZG93bi5cclxuICAgICAgICAgICAgICAgICAgICAvLyAgTWF5YmUgd29ydGgga2VlcGluZyBhcyBhbiBleGFtcGxlIGdvdGNoYS5cclxuICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdyZXMgJyArIHJlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG5cclxuICAgICAgICAgICAgfSBlbHNlIGlmIChhLmwgPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgLy8gbmVlZCB0byBnZXQgdGhlIHZhbHVlcyBvZiBhbGwgZmllbGRzLlxyXG4gICAgICAgICAgICAgICAgLy8gIFRoaW5rIHRoZXkgYXJlIG5vdyBiZWluZyBoZWxkIGluIHRoZSBmaWVsZCBjb2xsZWN0aW9uLCBmYy5cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICB9KSxcclxuXHJcbiAgICAvLyB0cnlpbmcgYSBkaWZmZXJlbnQgd2F5IG9mIGRvaW5nIHRoaW5ncy5cclxuXHJcbiAgICAnX19fZ2V0X2ZpZWxkc19jaGFpbic6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIC8vIGlzIHRoaXMgdGhlIHByb3RvdHlwZSAvIGNvbnN0cnVjdG9yLlxyXG5cclxuICAgICAgICB2YXIgbXlfZmllbGRzID0gdGhpcy5fZmllbGRzO1xyXG5cclxuICAgICAgICAvLyBhIGJpdCBkaWZmaWN1bHQuLi5cclxuXHJcblxyXG4gICAgICAgIGNvbnNvbGUubG9nKCdteV9maWVsZHMgJyArIHN0cmluZ2lmeShteV9maWVsZHMpKTtcclxuXHJcbiAgICAgICAgdmFyIGNvbiA9IHRoaXMuY29uc3RydWN0b3I7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ2NvbiAnICsgc3RyaW5naWZ5KGNvbikpO1xyXG5cclxuICAgICAgICAvL3RoaXMuX3N1cGVyKCk7XHJcblxyXG4gICAgICAgIC8qXHJcblxyXG4gICAgICAgIHZhciBzYyA9IHRoaXMuX3N1cGVyY2xhc3M7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ3NjICcgKyBzYyk7XHJcblxyXG5cclxuXHJcbiAgICAgICAgY29uc29sZS5sb2coJ3RoaXMuX2ZpZWxkcyAnICsgc3RyaW5naWZ5KHRoaXMuX2ZpZWxkcykpO1xyXG5cclxuICAgICAgICBpZiAoY29uKSB7XHJcbiAgICAgICAgICAgIHZhciBjb25fZmllbGRzID0gY29uLl9maWVsZHM7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdjb25fZmllbGRzICcgKyBzdHJpbmdpZnkoY29uX2ZpZWxkcykpO1xyXG5cclxuICAgICAgICAgICAgdmFyIGNvbl9zdXBlciA9IGNvbi5fc3VwZXJjbGFzcztcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ2Nvbl9zdXBlciAnICsgc3RyaW5naWZ5KGNvbl9zdXBlcikpO1xyXG5cclxuICAgICAgICAgICAgdmFyIGNvbl9wcm8gPSBjb24ucHJvdG90eXBlO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnY29uX3BybyAnICsgc3RyaW5naWZ5KGNvbl9wcm8pKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBjb25fcHJvX3N1cGVyID0gY29uLnByb3RvdHlwZS5fc3VwZXJjbGFzcztcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ2Nvbl9wcm9fc3VwZXIgJyArIHN0cmluZ2lmeShjb25fcHJvX3N1cGVyKSk7XHJcblxyXG4gICAgICAgICAgICB2YXIgY29uX3Byb19maWVsZHMgPSBjb25fcHJvLl9maWVsZHM7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdjb25fcHJvX2ZpZWxkcyAnICsgc3RyaW5naWZ5KGNvbl9wcm9fZmllbGRzKSk7XHJcblxyXG5cclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICB2YXIgcHJvID0gdGhpcy5wcm90b3R5cGU7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ3BybyAnICsgcHJvKTtcclxuXHJcbiAgICAgICAgaWYgKHBybykge1xyXG4gICAgICAgICAgICB2YXIgcHJvX2ZpZWxkcyA9IHByby5fZmllbGRzO1xyXG4gICAgICAgICAgICAvL3ZhciBjb25fcHJvID0gY29uLnByb3RvdHlwZTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ3Byb19maWVsZHMgJyArIHN0cmluZ2lmeShwcm9fZmllbGRzKSk7XHJcblxyXG5cclxuICAgICAgICAgICAgdmFyIHByb19zdXBlciA9IHByby5fc3VwZXI7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdwcm9fc3VwZXIgJyArIHN0cmluZ2lmeShwcm9fc3VwZXIpKTtcclxuXHJcblxyXG4gICAgICAgIH1cclxuICAgICAgICAqL1xyXG4gICAgfSxcclxuXHJcbiAgICAnX2dldF9pbnB1dF9wcm9jZXNzb3JzJzogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgLy90aHJvdyAnc3RvcCc7XHJcbiAgICAgICAgcmV0dXJuIGpzZ3VpLmlucHV0X3Byb2Nlc3NvcnM7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vXHJcblxyXG5cclxuICAgIC8vJ3NldCc6IGZwKGZ1bmN0aW9uKGEsIHNpZykge1xyXG4gICAgJ3NldCc6IChmdW5jdGlvbigpIHtcclxuICAgICAgdmFyIGEgPSBhcmd1bWVudHM7XHJcbiAgICAgIGEubCA9IGFyZ3VtZW50cy5sZW5ndGg7XHJcbiAgICAgIHZhciBzaWcgPSBnZXRfYV9zaWcoYXJndW1lbnRzLCAxKTtcclxuICAgICAgLy9jb25zb2xlLmxvZygnc2lnJywgc2lnKTtcclxuICAgICAgICAvLyBwcm9wZXJ0eV9uYW1lLCB2YWx1ZVxyXG5cclxuICAgICAgICAvLyBNYXkgb3ZlcnJpZGUgdGhpcyB3aXRoIGNvbGxlY3Rpb25zLi4uXHJcbiAgICAgICAgLy8gIENsZWFyLCB0aGVuIHB1c2ggZmlyc3QgaXRlbSwgd2hlbiBnaXZlbiBhIERhdGFfT2JqZWN0LlxyXG5cclxuICAgICAgICAvL2NvbnNvbGUubG9nKCdEYXRhX09iamVjdCBzZXQgc2lnICcgKyBzdHJpbmdpZnkoc2lnKSk7XHJcbiAgICAgICAgLy9jb25zb2xlLmxvZygndGhpcy5fYWJzdHJhY3QnLCB0aGlzLl9hYnN0cmFjdCk7XHJcbiAgICAgICAgaWYgKHRoaXMuX2Fic3RyYWN0KSByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcywgcmVzO1xyXG5cclxuICAgICAgICAvL2NvbnNvbGUubG9nKCcnKTtcclxuXHJcblxyXG4gICAgICAgIC8vIE1heSB3YW50IHRvIGFkZCBpdCB0byBhIGNvbGxlY3Rpb24gaW4gc29tZSBjYXNlcy5cclxuICAgICAgICAvLyAgT3IgbWFrZSBpdCB0aGUgb25seSBpdGVtIGluIHRoZSBjb2xsZWN0aW9uLlxyXG5cclxuICAgICAgICAvLyBUaGUgc2lnbmF0dXJlIGZvciBzZXQgYXMgd2VsbD9cclxuXHJcbiAgICAgICAgLy9jb25zb2xlLmxvZygnJyk7XHJcbiAgICAgICAgLy9jb25zb2xlLmxvZygnc2V0Jyk7XHJcblxyXG4gICAgICAgIC8vY29uc29sZS5sb2coJ3RoaXMuX190eXBlX25hbWUgJyArIHRoaXMuX190eXBlX25hbWUpO1xyXG4gICAgICAgIC8vY29uc29sZS5sb2coJ3RoaXMuX2RhdGFfdHlwZV9uYW1lICcgKyB0aGlzLl9kYXRhX3R5cGVfbmFtZSk7XHJcblxyXG5cclxuXHJcbiAgICAgICAgdmFyIGlucHV0X3Byb2Nlc3NvcnM7XHJcbiAgICAgICAgaWYgKHRoaXMuX21vZHVsZV9qc2d1aSkge1xyXG4gICAgICAgICAgICBpbnB1dF9wcm9jZXNzb3JzID0gdGhpcy5fbW9kdWxlX2pzZ3VpLmlucHV0X3Byb2Nlc3NvcnM7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaW5wdXRfcHJvY2Vzc29ycyA9IHRoaXMuX2dldF9pbnB1dF9wcm9jZXNzb3JzKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL2NvbnNvbGUubG9nKCcqKiogaW5wdXRfcHJvY2Vzc29ycyAnICsgc3RyaW5naWZ5KE9iamVjdC5rZXlzKGlucHV0X3Byb2Nlc3NvcnMpKSk7XHJcblxyXG4gICAgICAgIC8vIG9yIHNvbWUgb3RoZXIgdmFsdWUgd2lsbCBiZSBzZXQ/XHJcbiAgICAgICAgLy9jb25zb2xlLmxvZygnanNndWkuaW5wdXRfcHJvY2Vzc29ycyAnICsgc3RyaW5naWZ5KGpzZ3VpLmlucHV0X3Byb2Nlc3NvcnMpKTtcclxuICAgICAgICAvLyBUaGVzZSBpbnB1dCBwcm9jZXNzb3JzIG5lZWQgdG8gYmUgYXZhaWxhYmxlIHRocm91Z2hvdXQuXHJcbiAgICAgICAgLy8gIE5vdCBzdXJlIGFib3V0IHdoZXJlIHRvIHJldHJpZXZlIHRoZW0gZnJvbSB3aGVuIHVzaW5nIEFNRC5cclxuICAgICAgICAvLyAgIENvdWxkIHBhc3MgZm9yd2FyZCBhIHJlcXVlc3QgZm90IGlucHV0IHByb2Nlc3NvcnMuXHJcbiAgICAgICAgLy8gc28gd291bGQgaGF2ZSBfZ2V0X2lucHV0X3Byb2Nlc3NvcnMgZnVuY3Rpb24uXHJcbiAgICAgICAgLy8gIHRoYXQgd291bGQgcmV0cmlldmUgaXQgZnJvbSB3aGljaGV2ZXIgbW9kdWxlIGl0IGlzIGZyb20uXHJcblxyXG4gICAgICAgIC8vIHNvIHRoZXJlIG1heSBub3QgYmUgYW4gaW5wdXQgcHJvY2Vzc29yIHNldCB1cCBhbHJlYWR5IGZvciBpdC5cclxuICAgICAgICAvLyAgc29tZSBjbGFzc2VzIHdvbid0IG5lZWQgaXQuXHJcblxyXG4gICAgICAgIC8vIE5lZWQgdG8gcmVmYWN0b3IgdGhpcy5cclxuXHJcblxyXG4gICAgICAgIC8vIHNldFVzaW5nSW5wdXRQcm9jZXNzb3JcclxuXHJcbiAgICAgICAgLy8gc2V0VXNpbmdUaGlzXHJcblxyXG5cclxuXHJcblxyXG4gICAgICAgIC8vIExlc3MgaW1wb3J0YW50IGEgZGlzdGluY3Rpb24gbm93LlxyXG4gICAgICAgIC8vICBUaGUgZGF0YSB0eXBlcyBtYXkgaGF2ZSBiZWVuIHNldCB1cCBzbyB0aGF0IHRoZXkganVzdCBhcHBseSBmaWVsZHMsIG5vdCB0aGF0IHRoZXkgaGF2ZSBnb3RcclxuICAgICAgICAvLyAgIGlucHV0IGFuZCBvdXRwdXQgcHJvY2Vzc29ycy5cclxuXHJcbiAgICAgICAgaWYgKGlzX2RlZmluZWQodGhpcy5fZGF0YV90eXBlX25hbWUpICYmIGlucHV0X3Byb2Nlc3NvcnNbdGhpcy5fZGF0YV90eXBlX25hbWVdKSB7XHJcbiAgICAgICAgICAgIC8vIHVzZSB0aGUgaW5wdXQgcHJvY2Vzc29yIG9mIHRoZSBkYXRhX3R5cGUuXHJcblxyXG4gICAgICAgICAgICB0aHJvdyAnc3RvcCc7XHJcblxyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnaXNfZGVmaW5lZCBfZGF0YV90eXBlX25hbWUgYW5kIGlucHV0X3Byb2Nlc3NvcnNbdGhpcy5fZGF0YV90eXBlX25hbWVdJyk7XHJcblxyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCd0aGlzLl9fdHlwZV9uYW1lICcgKyB0aGlzLl9fdHlwZV9uYW1lKTtcclxuICAgICAgICAgICAgLy90aHJvdyAnc3RvcCc7XHJcbiAgICAgICAgICAgIHZhciByYXdfaW5wdXQgPSBhO1xyXG5cclxuICAgICAgICAgICAgLy8gd2UgbWF5IG5vdCBoYXZlIHRoZSBtZWFucyB0byBwYXJzZSB0aGF0IHJhdyBpbnB1dC4uLlxyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdpbnB1dF9wcm9jZXNzb3JzKVxyXG5cclxuICAgICAgICAgICAgLy8gT0ssIHNvIHdoZW4gc2V0dGluZyB1c2luZyB0aGUgdHlwZSB0aGF0IGhhcyBjb21lIGFib3V0IHRocm91Z2ggdGhlIHR5cGUgc3lzdGVtLi4uXHJcblxyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdyYXdfaW5wdXQgJyArIHN0cmluZ2lmeShyYXdfaW5wdXQpKTtcclxuXHJcblxyXG4gICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBubyBpbnB1dCBwcm9jZXNzb3IsIHRvIHNldCBfLCB3ZSBwcm9jZXNzIGl0IGRpcmVjdGx5LlxyXG5cclxuICAgICAgICAgICAgLy8gWyduYW1lLCB2YWx1ZSddO1xyXG4gICAgICAgICAgICAvLyAgc2V0IG91ciBvd24gZmllbGRzLlxyXG4gICAgICAgICAgICAvL2lmIChpbnB1dF9wcm9jZXNzb3JzW3RoaXMuX2RhdGFfdHlwZV9uYW1lXSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBhcnNlZF9pbnB1dF9vYmogPSBpbnB1dF9wcm9jZXNzb3JzW3RoaXMuX2RhdGFfdHlwZV9uYW1lXShyYXdfaW5wdXQpO1xyXG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygncGFyc2VkX2lucHV0X29iaiAnICsgc3RyaW5naWZ5KHBhcnNlZF9pbnB1dF9vYmopKTtcclxuICAgICAgICAgICAgICAgIC8vdGhyb3coJzIpIHN0b3AnKTtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLl8gPSBwYXJzZWRfaW5wdXRfb2JqO1xyXG5cclxuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdjaGFuZ2UnKTtcclxuICAgICAgICAgICAgLy99IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgLy99XHJcblxyXG5cclxuXHJcblxyXG5cclxuICAgICAgICAgICAgLy8gc2V0LCBqdXN0IHdpdGggYSB2YWx1ZS4uLiBqdXN0IHdpdGggdGhlIF9fdHlwZV9uYW1lLlxyXG4gICAgICAgICAgICAvLyAgVXNlcyB0aGUgZGF0YSB0eXBlIHBhcnNpbmcgdG8gZG8gdGhpcy5cclxuICAgICAgICAgICAgLy8gIFNob3VsZCB3b3JrIGZvciBmaWVsZHMuXHJcblxyXG5cclxuXHJcblxyXG5cclxuICAgICAgICAgICAgLy8gYnV0IHRoZW4gd2l0aCBnZXQoKSAtIGdldCBhY2NvcmRpbmcgdG8gYW4gb3V0cHV0IGZvcm1hdCBsaWtlIEhUTUwgLyBDU1MsIG9yIHRoZSBpbnRlcm5hbCBKU0dVSSByZXByZXNlbnRhdGlvbi5cclxuICAgICAgICAgICAgLy8gIGNvdWxkIHN0aWxsIG1ha2UgdXNlIG9mIF8gZm9yIHRoZSBpbnRlcm5hbCByZXByZXNlbnRhdGlvbi5cclxuXHJcblxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ25vIGR0biBkZWZpbmVkJyk7XHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2EubCAnICsgYS5sKTtcclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnJyk7XHJcblxyXG5cclxuICAgICAgICAgICAgaWYgKGEubCA9PSAyIHx8IGEubCA9PSAzKSB7XHJcblxyXG5cclxuICAgICAgICAgICAgICAgIHZhciBwcm9wZXJ0eV9uYW1lID0gYVswXSwgdmFsdWUgPSBhWzFdO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciB0YTIgPSB0b2YoYVsyXSk7XHJcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCd0YTInLCB0YTIpO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBzaWxlbnQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHZhciBzb3VyY2U7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHRhMiA9PSAnc3RyaW5nJyB8fCB0YTIgPT0gJ2Jvb2xlYW4nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2lsZW50ID0gYVsyXVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmICh0YTIgPT0gJ2NvbnRyb2wnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc291cmNlID0gYVsyXTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvL3NpbGVudCA9IGZhbHNlIHx8IGFbMl07XHJcblxyXG5cclxuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3NldCBwcm9wZXJ0eV9uYW1lICcgKyBwcm9wZXJ0eV9uYW1lICsgJywgdmFsdWUgJyArIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3NldCB2YWx1ZSAnICsgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnc2V0IHZhbHVlICcgKyBzdHJpbmdpZnkodmFsdWUpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBpcyB0aGUgcHJvcGVydHkgcmVhZF9vbmx5P1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5faW5pdGlhbGl6aW5nICYmIHRoaXMuX21hcF9yZWFkX29ubHkgJiYgdGhpcy5fbWFwX3JlYWRfb25seVtwcm9wZXJ0eV9uYW1lXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93ICdQcm9wZXJ0eSBcIicgKyBwcm9wZXJ0eV9uYW1lICsgJ1wiIGlzIHJlYWQtb25seS4nO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnKioqJyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIG5vdCB1c2luZyBsbF9zZXQgYW55IGxvbmdlci5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbmVlZCB0byB1c2UgYSByb3V0aW5lIHRoYXQgZGVhbHMgd2l0aCB0aGUgZGF0YV90eXBlcy5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpbmsgd2UgbmVlZCBzb21lIGtpbmQgb2YgcmVjdXJzaXZlIGdldC1zZXQgdHlwZSBvZiByb3V0aW5lLlxyXG4gICAgICAgICAgICAgICAgICAgIC8vICBHZXQgd2lsbCBnZXQgaXQgdG8gZ3JlYXRlIG9iamVjdHMgdGhhdCBhcmUgZmllbGRzIGFueXdheS5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygncHJvcGVydHlfbmFtZScsIHByb3BlcnR5X25hbWUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3BsaXRfcG4gPSBwcm9wZXJ0eV9uYW1lLnNwbGl0KCcuJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnc3BsaXRfcG4ubGVuZ3RoICcgKyBzcGxpdF9wbi5sZW5ndGgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIHNldHRpbmcgc29tZSB0eXBlcyBvZiBEYXRhX09iamVjdCBjbGFzc1xyXG4gICAgICAgICAgICAgICAgICAgIC8vICAobGlrZSBTZXJ2ZXIsIGEgc3ViY2xhc3Mgb2YgRGF0YV9PYmplY3QsIGFuZCBhIFJlc291cmNlKVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIG5lZWQgdG8gbWFrZSBzdXJlIGl0IHNldHMgaXQgd2l0aCB0aGUgaXRlbSBnaXZlbi5cclxuXHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoc3BsaXRfcG4ubGVuZ3RoID4gMSAmJiBwcm9wZXJ0eV9uYW1lICE9ICcuJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdzcGxpdF9wbiAnICsgc3RyaW5naWZ5KHNwbGl0X3BuKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3BuX2ZpcnN0ID0gc3BsaXRfcG5bMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzcG5fYXJyX25leHQgPSBzcGxpdF9wbi5zbGljZSgxKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZvciBkZWFsaW5nIHdpdGggYSByb290IGl0ZW0/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICBTbyBjYW4gc2V0IGl0cyAuIHByb3BlcnR5P1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSSB0aGluayB3ZSBoYXZlIGEgc3BlY2lhbCAnLicgZmllbGQuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICBUcmVhdCBpdCBhcyBhbiBvYmplY3QuXHJcblxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3Nwbl9maXJzdCAnICsgc3RyaW5naWZ5KHNwbl9maXJzdCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdzcG5fYXJyX25leHQgJyArIHN0cmluZ2lmeShzcG5fYXJyX25leHQpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkYXRhX29iamVjdF9uZXh0ID0gdGhpcy5nZXQoc3BuX2ZpcnN0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnZGF0YV9vYmplY3RfbmV4dCcsIGRhdGFfb2JqZWN0X25leHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YV9vYmplY3RfbmV4dCkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXMgPSBkYXRhX29iamVjdF9uZXh0LnNldChzcG5fYXJyX25leHQuam9pbignLicpLCB2YWx1ZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzaWxlbnQpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVfY2hhbmdlID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbmFtZSc6IHByb3BlcnR5X25hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICd2YWx1ZSc6IHZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnYnViYmxlZCc6IHRydWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc291cmNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVfY2hhbmdlLnNvdXJjZSA9IHNvdXJjZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEkgdGhpbmsgdGhpcyBpcyBidWJibGluZy5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgTWF5YmUgbWFyayBpdCBhcyBidWJibGVkLlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJhaXNlX2V2ZW50KCdjaGFuZ2UnLCBlX2NoYW5nZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXM7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvdWxkIGNyZWF0ZSBhIG5ldyBEYXRhX09iamVjdC5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3ZhciBuZG8gPSBuZXcgRGF0YV9PYmplY3Qoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9cdC8vIHdpdGggYSBjb250ZXh0P1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9cdCdjb250ZXh0JzogdGhpcy5fY29udGV4dFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy99KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBidXQgZm9yIHRoZSAnLicgcHJvcGVydHkuLi5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElzIHRoaXMgcmVjdXJzaXZlP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gIE5lZWQgdG8gZml4IHRoaXMuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWF5IG5lZWQgdG8gc3BlY2lmeSBhIGRhdGEgbW9kZWw/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgQnV0IHdlIHdhbnQgdGhpcyB0byBiZSBmbGV4aWJsZT9cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNYXliZSB3ZSBuZWVkIHRvIGRlY2xhcmUgdGhhdCBTY3JpcHQgaGFzIGdvdCBzb21lIGRlZXBlciBhdHRyaWJ1dGVzLlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdmFyIGRhdGFfb2JqZWN0X25leHQgPSBuZXdcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3Qgc3VyZSBob3cgdGhpcyBpcyByZWN1cnNpbmcgcHJvcGVybHkuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgTWF5YmUgd29yayBvbiB0aGlzIGF0IHNvbWUgb3RoZXIgdGltZSwgdXNpbmcgYW4gZXhhbXBsZSB0aGF0J3MgbW9yZSBzYW5kYm94ZWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgIHN1Y2ggYXMgdGhlIFVTIHByZXNpZGVudHMgZXhhbXBsZS5cclxuXHJcblxyXG5cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy92YXIgc3RhY2sgPSBuZXcgRXJyb3IoKS5zdGFja1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhzdGFjayk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdygnTm8gZGF0YSBvYmplY3QgYXQgdGhpcyBsZXZlbC4nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdygnMTApc3RvcCcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYWxsIGEgbXVsdGktbGV2ZWwtc2V0IGZ1bmN0aW9uP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgY291bGQgZG8gaXQgcmVjdXJzaXZlbHkgaGVyZSBmb3IgdGhlIG1vbWVudCBJIHRoaW5rLCB3aXRob3V0IG11Y2ggY29kZS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICBsaWtlIGl0IGlzIG5vdyA6KVxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJzIpIG5vIHNwbGl0Jyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBub3QgbmVjZXNzYXJpbHksIGl0IHN0aWxsIG1heSBhcHBseSB0byBhIGRhdGFfb2JqZWN0LlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygncHJlIGdldCAnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gIGlmIHRoZXJlIGlzIG5vdGhpbmcsIGdldCBzaG91bGQgcmV0dXJuIHVuZGVmaW5lZCAvIG51bGwuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgcGVyaGFwcyBtYWtlIGl0IGlmIGl0IGlzIGFuIGV4cGVjdGVkIG9iamVjdCB0aG91Z2guXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgIGl0IGxvb2tzIGxpa2UgaXQgaXMgZXhwZWN0ZWQ/IG9yIHdlIGhhdmUgaXQgZnJvbSB0aGUgdmFsdWUgYW55d2F5LlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICBtYXliZSBpdCdzIG9ubHkgZmluZSB0byBzZXQgaXQgdG8gYSBkYXRhX29iamVjdCAvIGRhdGFfdmFsdWUuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBpdCBpcyBqdXN0IGEgc3RyaW5nIHdlIGNhbiBtYWtlIGEgRGF0YV9WYWx1ZSB0byBob2xkIGl0IGFuZCB0aGVuIHB1dCBpdCBpbiBwbGFjZS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FuIHVzZSB0aGUgZG9iaiBmdW5jdGlvbj8/P1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FuIGp1c3Qgc2V0IHRoZSB2YWx1ZS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gIGNvdWxkIGp1c3QgcmVjb3JkIHRoZSBzdHJpbmcgaW4gaGVyZS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gIHB1dHRpbmcgaXQgaW4gYSBEYXRhX1ZhbHVlIHdvdWxkIGV2ZW50dWFsbHkgaGVscCB3aXRoIGF1dG9tYXRpYyBzdHJpbmcgaW5kZXhpbmcuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgQW5kIGl0IHdvdWxkIHBvdGVudGlhbGx5IGJlIGFuIGluZGV4ZWQgZmllbGQgYW55d2F5LlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUG90ZW50aWFsbHkgcGFyc2luZyBvYmplY3QgaW5wdXQ/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICBXaWxsIGhhdmUgbW9yZSBvZiB0aGF0IHdvcmtpbmcgdG8gZG8gd2l0aCBzb21lIEhUTUwgcHJvcGVydGllcyB0byBzdGFydCB3aXRoLlxyXG5cclxuXHJcblxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGdldCBpdD8/P1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgdGhhdCBjb3VsZCB3b3JrLi4uIGNvdWxkIGNyZWF0ZSB0aGUgcmlnaHQgY29uc3RydWN0b3IuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgVGhlcmUgbWF5YmUgd2lsbCBvbmx5IGJlIGFcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1heWJlIGRvbid0IG5lZWQgdG8gZ2V0IHRoaXMuLi5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnLS0tJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIG1heSBiZSBhYmxlIHRvIGdldCBpdCwgdXNpbmcgbGF6eSBsb2FkaW5nIGluIHNvbWUgY2FzZXMuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICBUaGlzIG1heSBsb29rIGF0IHRoZSBmaWVsZHMgYW5kIGNyZWF0ZSBhIG5ldyBvYmplY3QuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCcxKSBwcm9wZXJ0eV9uYW1lICcgKyBwcm9wZXJ0eV9uYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQnV0IHdlIGFyZSBzZXR0aW5nIGl0ISEhXHJcblxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1heSBkbyBhd2F5IHdpdGggZGF0YV9vYmplY3RfbmV4dC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkYXRhX29iamVjdF9uZXh0ID0gdGhpcy5nZXQocHJvcGVydHlfbmFtZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBMb29raW5nIGZvciB0aGVzZSBpbiByZXNvdXJjZXMsIGFuZCBkb2luZyBtb3JlIHRoYW4gbmVlZHMgdG8gYmUgZG9uZSBvbiBpbml0P1xyXG5cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTbywgdGhlIHByb3BlcnR5IGhhcyBub3QgYmVlbiBkZWZpbmVkIGNvcnJlY3RseS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gIE5lZWQgdG8gbWFrZSBpdCBzbyB0aGF0IGRhdGFfZGVmIHNldHMgdXAgdGhlIGZpZWxkcyBzbyB0aGF0IHRoZXkgd29yay5cclxuXHJcblxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJy0tLScpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgZ2V0cyBpdCBhcyBhIHN0cmluZz9cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTdHJpbmdpZnlpbmcgdGhpcyBjYXVzZXMgYW4gZW5kbGVzcyBsb29wIChzb21ldGltZXMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2RhdGFfb2JqZWN0X25leHQgJyArIHN0cmluZ2lmeShkYXRhX29iamVjdF9uZXh0KSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmYWlsaW5nIHRvIGdldCB0YWdOYW1lIHByb3BlcnR5IC0gaXQncyBhIHN0cmluZyBwcm9wZXJcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuZCB3aGVuIHNldHRpbmcgdGhlIHRhZ19uYW1lIG9iamVjdD9cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3Byb3BlcnR5X25hbWUgJyArIHByb3BlcnR5X25hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCd2YWx1ZSAnLCAodmFsdWUpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnKioqKiogZGF0YV9vYmplY3RfbmV4dCAnICsgZGF0YV9vYmplY3RfbmV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNfZGVmaW5lZChkYXRhX29iamVjdF9uZXh0KSkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFkZCBpdCB0byB0aGUgZmllbGRzIGNvbGxlY3Rpb24/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3RoaXMuX1twcm9wZXJ0eV9uYW1lXSA9IG5ldyBEYXRhX09iamVjdCh7fSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3JldHVybiB0aGlzLnNldChwcm9wZXJ0eV9uYW1lLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCd0b2YodmFsdWUpICcgKyB0b2YodmFsdWUpKTtcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy92YXIgdHYgPSB0b2YodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHR2ID0gdHlwZW9mIHZhbHVlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHYgPT0gJ2RhdGFfb2JqZWN0Jykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvcHkgZGlyZWN0bHkgaW4gbW9yZSBjYXNlcyB0aGFuIHRoaXMuLi4gbWF5YmUganVzdCBmb3IgcHJpbWl0aXZlIHR5cGVzIGRvIHdlIHVzZSB0aGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgZGF0YV92YWx1ZS5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZHY7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCd0diAnICsgdHYpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR2ID09ICdzdHJpbmcnIHx8IHR2ID09ICdudW1iZXInIHx8IHR2ID09ICdib29sZWFuJyB8fCB0diA9PSAnZGF0ZScpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkdiA9IG5ldyBEYXRhX1ZhbHVlKHsndmFsdWUnOiB2YWx1ZX0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkdiA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdkdiAnICsgc3RyaW5naWZ5KGR2KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3RoaXMuX1twcm9wZXJ0eV9uYW1lXSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy90aHJvdyAnU2hvdWxkIG1ha2UgYSBuZXcgRGF0YV9WYWx1ZSc7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fW3Byb3BlcnR5X25hbWVdID0gZHY7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3QgbWFraW5nIGEgbmV3IERhdGFfVmFsdWU/XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygndGhpcy5fW3Byb3BlcnR5X25hbWVdICcgKyB0aGlzLl9bcHJvcGVydHlfbmFtZV0pXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy90aGlzLnJhaXNlX2V2ZW50KCdjaGFuZ2UnLCBbcHJvcGVydHlfbmFtZSwgZHZdKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNpbGVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlX2NoYW5nZSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ25hbWUnOiBwcm9wZXJ0eV9uYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAndmFsdWUnOiBkdlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlX2NoYW5nZS5zb3VyY2UgPSBzb3VyY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJhaXNlX2V2ZW50KCdjaGFuZ2UnLCBlX2NoYW5nZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy90aHJvdyAnc3RvcCEhISc7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUGVyaGFwcyBzaG91bGQgcmV0dXJuIHRoZSBEYXRhX1ZhbHVlP1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCd0aGlzICcgKyBzdHJpbmdpZnkodGhpcykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnMikgcHJvcGVydHlfbmFtZSAnICsgcHJvcGVydHlfbmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdkYXRhX29iamVjdF9uZXh0ICcgKyBzdHJpbmdpZnkoZGF0YV9vYmplY3RfbmV4dCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygndG9mIGRhdGFfb2JqZWN0X25leHQgJyArIHRvZihkYXRhX29iamVjdF9uZXh0KSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSnVzdCBiZWNhdXNlIHdlIGNhbiBnZXQgdGhlIHNlcnZlciBhcyBhIG5leHQgZGF0YSBvYmplY3QsIGRvZXMgbm90IG1lYW4gd2UgbmVlZCB0by5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgSWYgd2UgaGF2ZSBiZWVuIGdpdmVuIGEgdmFsdWUsIHVzZSBpdC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICBIb3dldmVyLCBuZWVkIHRvIGNsYXJpZnkgdGhpcyBjb2RlIGhlcmUuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgIEF0IHNvbWUgdGltZXMgd2Ugd2lsbCB3YW50IGl0IHRvIHByb2R1Y2UgdGhlIG5leHQgbGV2ZWwgb2YgZGF0YSBvYmplY3QsIGJ1dCBub3QgYXQgb3RoZXJzLlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNldHRpbmcgYSBmaWVsZCBzaG91bGQgYmUgYSBmYWlybHkgc2ltcGxlIHByb2NlZHVyZSBpZiBwb3NzaWJsZSwgbWF5YmUgdGhpcyBjb2RlIGNvdWxkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgYmUgcmVmYWN0b3JlZC5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTbyB3aGVuIHdlIGhhdmUgYmVlbiBnaXZlbiBhIHNlcnZlciBwcm9wZXJ0eSwgd2Ugd2FudCB0byBzZXQgLl8uc2VydmVyIHRvIGl0XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUkVGQUNUT1I/XHJcblxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBpdCBpcyBhIGRhdGEgb2JqZWN0P1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gIGlmIGl0IGlzIGEgbmF0aXZlIHR5cGU/XHJcblxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNfanNfbmF0aXZlKGRhdGFfb2JqZWN0X25leHQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnaXNfanNfbmF0aXZlJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy90aGlzLnNldFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJ1dCBtYXliZSB0aGF0IG9iamVjdCBzaG91bGQgYmUgd3JhcHBlZCBpbiBEYXRhX09iamVjdD9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9bcHJvcGVydHlfbmFtZV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXMgPSB2YWx1ZTtcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdub3QgaXNfanNfbmF0aXZlJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy92YXIgcmVzID0gZGF0YV9vYmplY3RfbmV4dC5zZXQodmFsdWUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9bcHJvcGVydHlfbmFtZV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXMgPSB2YWx1ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnc2V0IGRhdGEgb2JqZWN0IG5leHQgdXNpbmcgdmFsdWUnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3ZhciByZXMgPSBsbF9zZXQodGhpcy5fLCBwcm9wZXJ0eV9uYW1lLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzaG91bGQgcmFpc2UgYW4gZXZlbnQgaGVyZS5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzLnJhaXNlX2V2ZW50KCdzZXQnLCBbcHJvcGVydHlfbmFtZSwgdmFsdWVdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZW4gdGhlIGV2ZW50IHRlbGxzIGV2ZXJ5dGhpbmcgdGhhdCBpcyBsaXN0ZW5pbmcgdG8gaXQuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCd0aGlzJywgdGhpcyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy90aGlzLnRyaWdnZXIoJ2NoYW5nZScsIFtwcm9wZXJ0eV9uYW1lLCB2YWx1ZV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygncHJvcGVydHlfbmFtZScsIHByb3BlcnR5X25hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygndmFsdWUnLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCd0aGlzJywgdGhpcyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzaWxlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZV9jaGFuZ2UgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICduYW1lJzogcHJvcGVydHlfbmFtZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3ZhbHVlJzogdmFsdWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZV9jaGFuZ2Uuc291cmNlID0gc291cmNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2NoYW5nZScsIGVfY2hhbmdlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2FudCB0byBsaXN0ZW4gdG8gdGhlIHNldCBldmVudCBmb3Igc29tZSB0aGluZ3Mgc3VjaCBhcyBHVUkgY29tcG9uZW50cyBpbiBwYXJ0aWN1bGFyLlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBCdXQgbWF5YmUgaXQgc2hvdWxkIGJlIGEgZGF0YV92YWx1ZSwgbm90IGEgZGF0YV9vYmplY3QuXHJcblxyXG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnMykgZWxzZSBzaWcgJyArIHNpZyk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQW5kIGZvciBhIERhdGFfT2JqZWN0P1xyXG4gICAgICAgICAgICAgICAgLy8gIEJhc2ljYWxseSBwdXQgaXQgaW50byBwbGFjZS5cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoc2lnID09ICdbRF0nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygncHJvcGVydHlfbmFtZSAnICsgcHJvcGVydHlfbmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fW3Byb3BlcnR5X25hbWVdID0gdmFsdWU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmFpc2VfZXZlbnQoJ2NoYW5nZScsIFtwcm9wZXJ0eV9uYW1lLCB2YWx1ZV0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBSYWlzZSBhIGNoYW5nZSBldmVudD9cclxuICAgICAgICAgICAgICAgICAgICAvLyAgT3IgaXMgc2V0IGV2ZW50IE9LP1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XHJcblxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHNpZyA9PSAnW29dJykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3NldHRpbmcgd2l0aCBhIHByb3ZpZGVkIG9iamVjdCcpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbWF5IG5lZWQgdG8gYmUgcmVjdXJzaXZlLlxyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXMgPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICBlYWNoKGFbMF0sIGZ1bmN0aW9uKGksIHYpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnaSAnICsgaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3YgJyArIHN0cmluZ2lmeSh2KSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNbaV0gPSB0aGF0LnNldChpLCB2KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy90aGF0LnJhaXNlX2V2ZW50KCdjaGFuZ2UnLCBbaSwgdl0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIEMgZm9yIGNvbGxlY3Rpb24/XHJcbiAgICAgICAgICAgICAgICBpZiAoc2lnID09ICdbY10nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy90aGlzLl9bXVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX1twcm9wZXJ0eV9uYW1lXSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmFpc2VfZXZlbnQoJ2NoYW5nZScsIFtwcm9wZXJ0eV9uYW1lLCB2YWx1ZV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vdGhyb3cgJ3Vuc3VwcG9ydGVkJztcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KSxcclxuICAgICdoYXMnIDogZnVuY3Rpb24ocHJvcGVydHlfbmFtZSkge1xyXG4gICAgICAgIHJldHVybiBpc19kZWZpbmVkKHRoaXMuZ2V0KHByb3BlcnR5X25hbWUpKTtcclxuICAgIH1cclxufSk7XHJcblxyXG52YXIgaW5pdGlhbGl6aW5nID0gZmFsc2UsIGZuVGVzdCA9IC94eXovLnRlc3QoZnVuY3Rpb24oKSB7XHJcbiAgICB4eXo7XHJcbn0pID8gL1xcYl9zdXBlclxcYi8gOiAvLiovO1xyXG5cclxuXHJcbnZhciBnZXRfZmllbGRzX2NoYWluID0gZnVuY3Rpb24oZGF0YV9vYmplY3RfY2xhc3MpIHtcclxuICAgIHZhciByZXMgPSBbXTtcclxuICAgIHZhciBpbm5lciA9IGZ1bmN0aW9uKGRhdGFfb2JqZWN0X2NsYXNzKSB7XHJcbiAgICAgICAgLy8gX2ZpZWxkcy4uLiBmaWVsZHMgd2lsbCBiZSBnaXZlbiBhcyBhbiBhcnJheSBieSBkZWZhdWx0LCB0byBwcmVzZXJ2ZSB0aGUgb3JkZXIuXHJcblxyXG4gICAgICAgIHZhciBmaWVsZHMgPSBkYXRhX29iamVjdF9jbGFzcy5fZmllbGRzO1xyXG5cclxuXHJcbiAgICAgICAgLy9jb25zb2xlLmxvZygnZ2V0X2ZpZWxkc19jaGFpbiBmaWVsZHMgJyArIHN0cmluZ2lmeShmaWVsZHMpKTtcclxuICAgICAgICBpZiAoZmllbGRzKSB7XHJcbiAgICAgICAgICAgIHJlcy5wdXNoKGZpZWxkcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIENvdWxkIGJlIHB1c2hpbmcgYW4gYXJyYXkgY29udGFpbmluZyBhbiBhcnJheSB0aGF0IHJlcHJlc2VudHMgb25lIGZpZWxkLlxyXG5cclxuICAgICAgICB2YXIgc2MgPSBkYXRhX29iamVjdF9jbGFzcy5fc3VwZXJjbGFzcztcclxuICAgICAgICAvL2NvbnNvbGUubG9nKCdzYyAnICsgc2MpO1xyXG4gICAgICAgIC8vaWYgKHNjKSBjb25zb2xlLmxvZygnc2MuY29uc3RydWN0b3IuX2ZpZWxkcyAnICsgc3RyaW5naWZ5KHNjLmNvbnN0cnVjdG9yLl9maWVsZHMpKTtcclxuICAgICAgICBpZiAoc2MpIHtcclxuICAgICAgICAgICAgaW5uZXIoc2MpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBpbm5lcihkYXRhX29iamVjdF9jbGFzcyk7XHJcbiAgICAvL2NvbnNvbGUubG9nKCdnZXRfZmllbGRzX2NoYWluIHJlcyAnICsgc3RyaW5naWZ5KHJlcykpO1xyXG4gICAgcmV0dXJuIHJlcztcclxufVxyXG5cclxuXHJcbi8vIEJ1dCB0aGUgZmllbGRzIG1heSBoYXZlIGFuIG9yZGVyLiBJdCBtYXkgYmUgbmVjZXNzYXJ5IHRvIHByZXNlcnZlIHRoYXQgb3JkZXIuXHJcbi8vICBUaGUgb3JkZXIgb2YgZmllbGRzIGlzIG5vdCBvZiBncmVhdCBpbXBvcmFuY2UgdXN1YWxseS4gTWF5IGJlIG5pY2UgdG8gaGF2ZSB0aGVpciBvcmRlciBndWFyYW50ZWVkIHRvIHN0YXkgdGhlIHNhbWUuLi5cclxuLy8gICBpdCBtYXkgYmUgdGhhdCBkaWZmZXJlbnQgSmF2YVNjcmlwdCBlbmdpbmVzIHdpbGwgZG8gdGhpcyBhbnl3YXkuXHJcblxyXG52YXIgZ2V0X2NoYWluZWRfZmllbGRzID0gZnVuY3Rpb24oZGF0YV9vYmplY3RfY2xhc3MpIHtcclxuICAgIC8vIHdvdWxkIGJlIG5pY2UgdG8gZG8gdGhpcyBpbiBhIHdheSB0aGF0IHByZXNlcnZlcyB0aGUgb3JkZXIuXHJcbiAgICAvLyAgYW4gYXJyYXkgb2YgZmllbGRzIG1heSBiZSBiZXR0ZXIuXHJcblxyXG4gICAgLy8gVGhlIGZpZWxkcyBjaGFpbi4uLiBuZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGlzIGdldHRpbmcgdGhlIHNlcGFyYXRlIGZpZWxkcy5cclxuICAgIHZhciBmYyA9IGdldF9maWVsZHNfY2hhaW4oZGF0YV9vYmplY3RfY2xhc3MpO1xyXG5cclxuXHJcblxyXG4gICAgdmFyIGkgPSBmYy5sZW5ndGg7IC8vb3IgMTBcclxuXHJcbiAgICAvL3ZhciByZXMgPSB7fTtcclxuICAgIHZhciByZXMgPSBbXTtcclxuXHJcbiAgICAvLyBOb3Qgc28gc3VyZSBhYm91dCBkb2luZyB0aGlzLi4uIGlzIGl0IGJyZWFraW5nIHVwIGEgZmllbGQgaW50byBtb3JlIHRoYW4gb25lIGZpZWxkIHdoZW4gaXQgc2hvdWxkIG5vdCBiZT9cclxuXHJcblxyXG4gICAgd2hpbGUoaS0tKVxyXG4gICAge1xyXG4gICAgICAvLy4uLlxyXG4gICAgICAgIHZhciBpdGVtID0gZmNbaV07XHJcblxyXG4gICAgICAgIC8vIHRoZSBpdGVtIGNhbiBiZSBhbiBvYmplY3QuLi4gb3IgYW4gYXJyYXkuIEFycmF5IGlzIGJldHRlci5cclxuXHJcbiAgICAgICAgLy9lYWNoKGl0ZW0sIGZ1bmN0aW9uKGkyLCB2KSB7XHJcbiAgICAgICAgLy9cdHJlc1tpMl0gPSB2O1xyXG4gICAgICAgIC8vfSk7XHJcblxyXG4gICAgICAgIC8vIFtmaWVsZF9uYW1lLCBmaWVsZF9pbmZvXVxyXG5cclxuICAgICAgICAvLyBOb3Qgc28gc3VyZSBhYm91dCBpbmNsdWRpbmcgdGhlIG51bWJlcj9cclxuICAgICAgICAvLyAgSXMgaXQgbmVjZXNzYXJ5P1xyXG4gICAgICAgIC8vIE1heWJlIGl0IGNhbiBiZSBpZ25vcmVkIGF0IGEgbGF0ZXIgc3RhZ2UuXHJcbiAgICAgICAgLy8gIEhvd2V2ZXIsIGRvIHdhbnQgaXQgdG8gcHJvcGVybHkgaW50ZXJwcmV0IHRoZSBmaWVsZHMgYXQgYSBsYXRlciBzdGFnZS5cclxuXHJcbiAgICAgICAgdmFyIGMgPSAwO1xyXG5cclxuICAgICAgICAvL2NvbnNvbGUubG9nKCdpdGVtJywgaXRlbSk7XHJcbiAgICAgICAgLy8gaXRlbSBpcyBlaXRoZXIgYW4gb2JqZWN0IG9yIGFuIGFycmF5LlxyXG5cclxuICAgICAgICBlYWNoKGl0ZW0sIGZ1bmN0aW9uKGkyLCBmaWVsZF9pbmZvKSB7XHJcblxyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCcnKTtcclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnaTIgJyArIGkyKTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0b2YoaTIpID09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICBjID0gYyArIDE7XHJcbiAgICAgICAgICAgICAgICByZXMucHVzaChbYywgW2kyLCBmaWVsZF9pbmZvXV0pO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmVzLnB1c2goW2kyLCBmaWVsZF9pbmZvXSk7XHJcbiAgICAgICAgICAgICAgICBjID0gaTI7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2ZpZWxkX2luZm8gJyArIHN0cmluZ2lmeShmaWVsZF9pbmZvKSk7XHJcblxyXG4gICAgICAgICAgICAvL3Jlc1tpMl0gPSB2O1xyXG4gICAgICAgICAgICAvLyBmaWVsZF9pbmZvIGNvdWxkIGp1c3QgYmUgdGhlIGZpZWxkX25hbWUgYW5kIHNvbWUgdGV4dC4gdGhhdCBzaG91bGQgYmUgZmluZS5cclxuXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgfVxyXG4gICAgLy8gbm90IHN1cmUgdGhhdCBhbGwgZmllbGRzIHdpbGwgaGF2ZSBzaW1wbGUgdHlwZXMuXHJcbiAgICAvLyAgc29tZSB3aWxsIGJlIGNvbnN0cnVjdG9ycyBldmVuLlxyXG4gICAgLy8gRmllbGRzIHNob3VsZCBoYXZlIGJlZW4gc2V0IGNvcnJlY3RseSwgbm90IGxpa2UgZ2V0X2NoYWluZWRfZmllbGRzIHJlcyBbWzAsIFwiaW5kZXhlZF9hcnJheVwiXSwgWzEsIFtbXCJyZWRcIiwgXCJudW1iZXJcIl0sIFtcImdyZWVuXCIsIFwibnVtYmVyXCJdLCBbXCJibHVlXCIsIFwibnVtYmVyXCJdXV1dXHJcbiAgICAvL2NvbnNvbGUubG9nKCdnZXRfY2hhaW5lZF9maWVsZHMgcmVzICcgKyBzdHJpbmdpZnkocmVzKSk7XHJcbiAgICByZXR1cm4gcmVzO1xyXG59XHJcblxyXG52YXIgY2hhaW5lZF9maWVsZHNfdG9fZmllbGRzX2xpc3QgPSBmdW5jdGlvbihjaGFpbmVkX2ZpZWxkcykge1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgdmFyIHJlcyA9IFtdO1xyXG4gICAgZWFjaChjaGFpbmVkX2ZpZWxkcywgZnVuY3Rpb24oaSwgdikge1xyXG4gICAgICAgIHZhciBmaWVsZF9udW1iZXIgPSB2WzBdO1xyXG4gICAgICAgIHZhciBmaWVsZCA9IHZbMV07XHJcbiAgICAgICAgcmVzLnB1c2goZmllbGQpO1xyXG4gICAgfSk7XHJcbiAgICAqL1xyXG5cclxuICAgIC8vY29uc29sZS5sb2coJ2NoYWluZWRfZmllbGRzICcgKyBzdHJpbmdpZnkoY2hhaW5lZF9maWVsZHMpKTtcclxuXHJcbiAgICB2YXIgbCA9IGNoYWluZWRfZmllbGRzLmxlbmd0aDtcclxuICAgIC8vY29uc29sZS5sb2coJ2wgJyArIGwpO1xyXG4gICAgdmFyIHJlcyA9IG5ldyBBcnJheShsKTtcclxuICAgIC8vdmFyIHJlc19wdXNoID0gcmVzLnB1c2g7XHJcbiAgICBmb3IgKHZhciBjID0gMDsgYyA8IGw7IGMrKykge1xyXG4gICAgICAgIC8vcmVzX3B1c2guY2FsbChyZXMsIGNoYWluZWRfZmllbGRzW2NdWzFdKTtcclxuICAgICAgICAvL3Jlcy5wdXNoKGNoYWluZWRfZmllbGRzW2NdWzFdKTtcclxuICAgICAgICByZXNbY10gPSBjaGFpbmVkX2ZpZWxkc1tjXVsxXTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIHJldHVybiByZXM7XHJcbn07XHJcblxyXG5qc2d1aS5tYXBfY2xhc3NlcyA9IHt9O1xyXG5cclxuLypcclxuT2JqZWN0LnByb3RvdHlwZS5iZWdldE9iamVjdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEYoKSB7fVxyXG4gICAgRi5wcm90b3R5cGUgPSB0aGlzO1xyXG4gICAgcmV0dXJuIG5ldyBGKCk7XHJcbn07XHJcblxyXG5uZXdPYmplY3QgPSBvbGRPYmplY3QuYmVnZXRPYmplY3QoKTtcclxuKi9cclxuXHJcbi8vIEFsc28gd2FudCB0byBzcGVjaWZ5IGZ1bmN0aW9ucyB0aGF0IGV4ZWN1dGUgdXBvbiBpbml0aWFsaXphdGlvbiB0aGF0IGNhbGxcclxuLy8gIGEgZnVuY3Rpb24sIHVzaW5nIGEgcGFyYW1ldGVyIHRoYXQgZ2V0cyBzZXQgaW4gdGhlIGRlZmluaXRpb24uXHJcbi8vIFRoaXMgd2lsbCBiZSB1c2VkIHRvIGVuYWJsZSBhIENvbGxlY3Rpb24gc3ViY2xhc3MgdG8gYmUgZGVmaW5lZCBhc1xyXG4vLyAgQ29sbGVjdGlvbi5leHRlbmQoeydkYXRhX29iamVjdCc6IERhdGFfT2JqZWN0X1N1YmNsYXNzfSk7XHJcbi8vICAgTGlrZSBhIGNvbGxlY3Rpb24gb2YgcHJvZHVjdHMgaG9sZGluZyB0aGUgUHJvZHVjdCBEYXRhX09iamVjdCB0eXBlIGFuZCBoYXZpbmcgdGhhdFxyXG4vLyAgIGVhc2lseSBhbmQgY2xlYXJseSBkZWNsYXJlZCB3aXRoaW4gdGhlIG1vZGVsIGNvZGUuXHJcbi8vIENvdWxkIHRoaXMgYmUgZG9uZSBpbiB0aGUgbm9ybWFsIGluaXQ/XHJcbi8vICBvciB1c2UgcHJvcHNUb01lcmdlP1xyXG5cclxuRGF0YV9PYmplY3QuZXh0ZW5kID0gZnVuY3Rpb24ocHJvcCwgcG9zdF9pbml0KSB7XHJcbiAgICB2YXIgX3N1cGVyID0gdGhpcy5wcm90b3R5cGU7XHJcbiAgICBpbml0aWFsaXppbmcgPSB0cnVlO1xyXG4gICAgdmFyIHByb3RvdHlwZSA9IG5ldyB0aGlzKCk7XHJcblxyXG4gICAgLy8gY29weWluZyBhY2Nyb3NzIHNvbWUgb2xkIHRoaW5ncz9cclxuICAgIC8vICBrZWVwaW5nIHNvbWUgdGhpbmdzIGluIHRoZSBwcm90b3R5cGUgY2hhaW4/XHJcbiAgICB2YXIgZm9yX2NsYXNzID0ge307XHJcblxyXG4gICAgaW5pdGlhbGl6aW5nID0gZmFsc2U7XHJcblxyXG4gICAgLy9pZiAodG9mKHByb3ApID09PSAnc3RyaW5nJykge1xyXG4gICAgaWYgKHR5cGVvZiBwcm9wID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIC8vIGdpdmluZyBpdCBhIGRhdGFfdHlwZSBmcm9tIHRoZSBqc2d1aS5kYXRhX3R5cGVzX2luZm9cclxuICAgICAgICB2YXIgZGF0YV90eXBlX25hbWUgPSBwcm9wO1xyXG4gICAgICAgIHZhciBkdGlzID0ganNndWkuZGF0YV90eXBlc19pbmZvO1xyXG4gICAgICAgIC8vY29uc29sZS5sb2coJ2R0aXMgJyArIHN0cmluZ2lmeShkdGlzKSk7XHJcbiAgICAgICAgLy9yZXR1cm4gZHRpcztcclxuICAgICAgICB2YXIgZGF0YV90eXBlX2luZm8gPSBkdGlzW2RhdGFfdHlwZV9uYW1lXTtcclxuICAgICAgICAvL2NvbnNvbGUubG9nKCdkYXRhX3R5cGVfbmFtZSAnICsgc3RyaW5naWZ5KGRhdGFfdHlwZV9uYW1lKSk7XHJcbiAgICAgICAgLy9jb25zb2xlLmxvZygnZGF0YV90eXBlX2luZm8gJyArIHN0cmluZ2lmeShkYXRhX3R5cGVfaW5mbykpO1xyXG4gICAgICAgIGZvcl9jbGFzc1tkYXRhX3R5cGVfbmFtZV0gPSBkYXRhX3R5cGVfbmFtZTtcclxuICAgICAgICBmb3JfY2xhc3NbZGF0YV90eXBlX2luZm9dID0gZGF0YV90eXBlX2luZm87XHJcbiAgICAgICAgLy8gdGhlbiBpdCB3aWxsIGJlIHJlYWQgZnJvbSB0aGUgY2xhc3Mgb2JqZWN0IGl0c2VsZi5cclxuICAgICAgICAvLyAgd2lsbCBiZSBhYmxlIHRvIGdldCB0aGUgY29uc3RydWN0b3Igb2JqZWN0LCBJIHRoaW5rLlxyXG4gICAgICAgIC8vIG1heWJlIG5vdCBiZXN0IHRvIGRvIHRoaXMgdGhyb3VnaCB0aGUgcHJvdG90eXBlP1xyXG4gICAgICAgIC8vICBoYXZpbmcgZGlmZmljdWx0eSBnZXR0aW5nIHRoZSBjb25zdHJ1Y3Rvciwgd2l0aGluIHRoZSBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cclxuICAgICAgICBwcm90b3R5cGVbJ19fdHlwZV9uYW1lJ10gPSBkYXRhX3R5cGVfbmFtZTtcclxuICAgICAgICBwcm90b3R5cGVbJ19fZGF0YV90eXBlX2luZm8nXSA9IGRhdGFfdHlwZV9pbmZvO1xyXG5cclxuICAgICAgICBwcm9wID0ge307XHJcblxyXG4gICAgICAgIC8vIHRoZW4gdGhpcyBlZmZlY3RpdmVseSBzZXRzIGl0cyBmaWVsZHMuXHJcbiAgICAgICAgLy8gIGNyZWF0ZSB0aGUgZmllbGRzLCBpbiBvcmRlciwgYW5kIGhhdmUgYSBudW1lcmljIGluZGV4IHNheWluZyB3aGljaCBmaWVsZCBpcyB3aGljaC5cclxuICAgICAgICAvLyAgd2lsbCBoYXZlIGFuIF9vcGVyYXRpbmdfbW9kZS5cclxuICAgICAgICAvLyAgdGhlIGRhdGFfb2JqZWN0IHdpbGwgYmUgYWJsZSB0byBvcGVyYXRlIGFzIGFuIGluZGV4ZWRfYXJyYXkuLi4gYnV0IG5vdCBzdXJlIGFib3V0IG1ha2luZyBhIGNvbGxlY3Rpb24gYW5kIGdpdmluZyBpdCBuYW1lZCBpdGVtcz9cclxuICAgICAgICAvLyAgIGNvbGxlY3Rpb24gYWxyZWFkeSB0YWtlcyBuYW1lZCBpdGVtcy5cclxuXHJcbiAgICAgICAgLy8gV2lsbCBhbHNvIG5lZWQgdG8gZGVhbCB3aXRoIGNvbGxlY3Rpb25zIG9mIG9iamVjdHMgaGVyZS5cclxuICAgICAgICAvLyAgV2lsbCBiZSB2ZXJ5IG5pY2Ugd2hlbiB0aGUgSFRNTCBjb2RlIGlzIHZlcnkgZGVjbGFyYXRpdmUuXHJcblxyXG4gICAgICAgIC8vIERhdGFfVHlwZV9JbnN0YW5jZT8gT3IgdGhlIGNvbnN0cnVjdG9yIHRvIHRoZSByZWxldmFudCBEYXRhX09iamVjdCBmdW5jdGlvbnMgYXMgaXRzIGluc3RhbmNlP1xyXG4gICAgICAgIC8vICBJdCdzIG5vdCBleGFjdGx5IGFuIGluc3RhbmNlLCBpdCdzIGEgY29uc3RydWN0b3IsIGJ1dCBjb25zdHJ1Y3RvcnMgY2FuIGhhdmUgdGhlaXIgb3duIG1ldGhvZHMgdG9vLlxyXG5cclxuICAgICAgICAvLyBUaGVuIHRoaXMgaXMgdGhlIGRhdGFfdHlwZV9pbnN0YW5jZSwgZWZmZWN0aXZlbHkuXHJcblxyXG4gICAgICAgIC8vIHNvIGl0IHdpbGwgaG9sZCB0aGUgZGF0YSB0eXBlIGluZm8gd2l0aGluIHRoZSBjb25zdHJ1Y3Rvcj9cclxuICAgICAgICAvLyAgb3IgbmFtZWQgcmVmZXJlbmNlIHRvIGl0IGlzIGZpbmUuXHJcblxyXG4gICAgICAgIC8vdGhyb3coJyoxIHN0b3AnKTtcclxuICAgIH1cclxuICAgIHZhciBwcm9wX2l0ZW0sIHRfcHJvcF9pdGVtLCB0bXAsIG5hbWUsIHJlcztcclxuXHJcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3ApO1xyXG4gICAgLy92YXIga2V5O1xyXG4gICAgZm9yICh2YXIgYyA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgYyA8IGw7IGMrKykge1xyXG4gICAgICBuYW1lID0ga2V5c1tjXTtcclxuICAgICAgcHJvcF9pdGVtID0gcHJvcFtuYW1lXTtcclxuXHJcbiAgICAgIGlmIChuYW1lLmNoYXJBdCgwKSA9PT0gJyMnKSB7XHJcblxyXG4gICAgICAgICAgLy8gZGlyZWN0IGNvcHkgd2l0aCAnIycuLi4gbm90IGJlZW4gdXNpbmcgdGhhdC5cclxuXHJcbiAgICAgICAgICBwcm90b3R5cGVbbmFtZS5zdWJzdHJpbmcoMSldID0gcHJvdG90eXBlW3Byb3BfaXRlbV07XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAvLyBpZiBpdCdzIGEgZnVuY3Rpb24sIHRoZW4gZG8gdGhlIGZvbGxvd2luZy5cclxuXHJcbiAgICAgICAgICAvLyBpZiBpdCdzIGFuIG9iamVjdCwgdGhlbiBpdCBtYXkgYmUgc29tZXRoaW5nIHNwZWNpZmljIHRvIHRoZSBEYXRhT2JqZWN0IHR5cGUuXHJcbiAgICAgICAgICAvLyAgc3VjaCBhcyBzZXR0aW5nIC8gZXh0ZW5kaW5nIGZpZWxkcyBvZiBhbiBvYmplY3QuXHJcblxyXG4gICAgICAgICAgLy8gc29tZSBzcGVjaWZpYyBub24tb2JqZWN0IHRoaW5ncyB3aWxsIGJlIHNldCB0byB0aGUgcHJvdG90eXBlLlxyXG4gICAgICAgICAgLy8gIGl0IHdpbGwgYmUgcG9zc2libGUgdG8gbG9vayBhdCB0aGlzIGluZm8sIHRoZSBmaWVsZHMgY2hhaW4gaW4gdGhlIG9iamVjdCwgd2lsbCB0YWtlIGEgYml0IG9mIHRyaWFsLCBlcnJvciBhbmQgZGVzaWduLlxyXG5cclxuICAgICAgICAgIHRfcHJvcF9pdGVtID0gdHlwZW9mIHByb3BfaXRlbTtcclxuICAgICAgICAgIC8vY29uc29sZS5sb2coJ3Byb3BfaXRlbScgKyBwcm9wX2l0ZW0pO1xyXG4gICAgICAgICAgaWYgKHRfcHJvcF9pdGVtID09PSAnZnVuY3Rpb24nKSB7XHJcblxyXG4gICAgICAgICAgICAgIHByb3RvdHlwZVtuYW1lXSA9IHR5cGVvZiBfc3VwZXJbbmFtZV0gPT09ICdmdW5jdGlvbicgJiYgZm5UZXN0LnRlc3QocHJvcF9pdGVtKSA/XHJcbiAgICAgICAgICAgICAgLy8gaGFkIHNvbWUgZGlmZmljdWx0eSB1c2luZyBmcCgpIHdpdGggJ2luaXQnIGZ1bmN0aW9ucy4gY291bGRcclxuICAgICAgICAgICAgICAvLyBpdCBoYXZlIHRvIGRvIHdpdGggZnVuY3Rpb24gbmFtZXM/XHJcblxyXG4gICAgICAgICAgICAgIChmdW5jdGlvbihuYW1lLCBmbikge1xyXG4gICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICB0bXAgPSB0aGlzLl9zdXBlcjtcclxuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N1cGVyID0gX3N1cGVyW25hbWVdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgcmVzID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N1cGVyID0gdG1wO1xyXG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcclxuICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICB9KShuYW1lLCBwcm9wW25hbWVdKSA6IHByb3BbbmFtZV07XHJcblxyXG4gICAgICAgICAgfSBlbHNlIGlmICh0X3Byb3BfaXRlbSA9PT0gJ29iamVjdCcgfHwgdF9wcm9wX2l0ZW0gPT09ICdib29sZWFuJykge1xyXG5cclxuICAgICAgICAgICAgICAvLyBkb24ndCBwdXQgdGhlc2UgaW4gdGhlIHByb3RvdHlwZS5cclxuICAgICAgICAgICAgICAvLyAgdGhleSBhcmUgbm90IGZvciB0aGUgb2JqZWN0IGl0c2VsZi5cclxuICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdwcm9wZXJ0eSBuYW1lJywgbmFtZSk7XHJcbiAgICAgICAgICAgICAgaWYgKG5hbWUgPT0gJ2NsYXNzX25hbWUnKSB7XHJcbiAgICAgICAgICAgICAgICAgIGZvcl9jbGFzc1snX2NsYXNzX25hbWUnXSA9IHByb3BfaXRlbTtcclxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5hbWUgPT0gJ2ZpZWxkcycpIHtcclxuICAgICAgICAgICAgICAgICAgLy8gbWF5YmUgY2FsbCBpdCBzb21ldGhpbmcgZWxzZSwgZmllbGRzIGlzIGEgZnVuY3Rpb24uXHJcbiAgICAgICAgICAgICAgICAgIC8vIGZpZWxkcyBjb3VsZCBiZSBhIGZ1bmN0aW9uLCBzbyBjYWxsIGl0IF9maWVsZHNcclxuICAgICAgICAgICAgICAgICAgLy8gaXQgc2V0cyB0aGUgYXJyYXkgb2YgZmllbGRzLi4uIGNvdWxkIGJlIGFuIG9iamVjdCByZXByZXNlbnRpbmcgZmllbGRzIGJ1dCBhbiBhcnJheSBpcyBiZXR0ZXIgYmVjYXVzZSB0aGUgb3JkZXIgZ2V0cyBwcmVzZXJ2ZWQuXHJcbiAgICAgICAgICAgICAgICAgIC8vZm9yX2NsYXNzWydfZmllbGRzJ10gPSBwcm9wX2l0ZW07XHJcbiAgICAgICAgICAgICAgICAgIGZvcl9jbGFzcy5fZmllbGRzID0gcHJvcF9pdGVtO1xyXG4gICAgICAgICAgICAgICAgICAvL3RoaXNbJ19maWVsZHMnXSA9IHByb3BfaXRlbTtcclxuICAgICAgICAgICAgICAgICAgLy8gdGhlbiB0aGUgZmllbGRzIHdpbGwgYmUgcmVhZCB1cG9uIGluaXRpYWxpemF0aW9uP1xyXG4gICAgICAgICAgICAgICAgICAvLyAgZ2V0dGluZyBhbGwgdGhlIGZpZWxkcyB1cCB0aGUgY2hhaW4uLi5cclxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5hbWUgPT0gJ2Nvbm5lY3RfZmllbGRzJykge1xyXG4gICAgICAgICAgICAgICAgICAvLyBtYXliZSBjYWxsIGl0IHNvbWV0aGluZyBlbHNlLCBmaWVsZHMgaXMgYSBmdW5jdGlvbi5cclxuICAgICAgICAgICAgICAgICAgLy8gZmllbGRzIGNvdWxkIGJlIGEgZnVuY3Rpb24sIHNvIGNhbGwgaXQgX2ZpZWxkc1xyXG5cclxuICAgICAgICAgICAgICAgICAgLy9mb3JfY2xhc3NbJ19jb25uZWN0X2ZpZWxkcyddID0gcHJvcF9pdGVtO1xyXG4gICAgICAgICAgICAgICAgICBmb3JfY2xhc3MuX2Nvbm5lY3RfZmllbGRzID0gcHJvcF9pdGVtO1xyXG5cclxuICAgICAgICAgICAgICAgICAgLy8gdGhlbiB0aGUgZmllbGRzIHdpbGwgYmUgcmVhZCB1cG9uIGluaXRpYWxpemF0aW9uP1xyXG4gICAgICAgICAgICAgICAgICAvLyAgZ2V0dGluZyBhbGwgdGhlIGZpZWxkcyB1cCB0aGUgY2hhaW4uLi5cclxuXHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgcHJvdG90eXBlW25hbWVdID0gcHJvcFtuYW1lXTtcclxuICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgfSAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgcHJvdG90eXBlW25hbWVdID0gcHJvcFtuYW1lXTtcclxuICAgICAgICAgIH1cclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICAvL2ZvciAobmFtZSBpbiBwcm9wKSB7XHJcblxyXG5cclxuICAgIC8vfTtcclxuXHJcbiAgICAvLyBMb29rcyBsaWtlIHRoaXMgbmVlZHMgdG8gYmUgY2hhbmdlZCBqdXN0IHRvIGJlIGxvY2FsLi4uXHJcblxyXG4gICAgdmFyIENsYXNzID0gZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICAgIC8vY29uc29sZS5sb2coJ0RhdGFfT2JqZWN0IGluaXRpYWxpemluZyAnICsgaW5pdGlhbGl6aW5nKTtcclxuICAgICAgICAvL2NvbnNvbGUubG9nKCdEYXRhX09iamVjdCAhIXRoaXMuaW5pdCAnICsgISF0aGlzLmluaXQpO1xyXG5cclxuICAgICAgICBpZiAoIWluaXRpYWxpemluZykge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5pbml0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmluaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBvc3RfaW5pdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vdGhpcy5wb3N0X2luaXQoKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBvc3RfaW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vaWYgKHBvc3RfaW5pdCkge1xyXG4gICAgICAgICAgICAgICAgLy8gICAgcG9zdF9pbml0LmNhbGwodGhpcyk7XHJcbiAgICAgICAgICAgICAgICAvL31cclxuICAgICAgICAgICAgICAgIC8vIENoZWNrIHRvIHNlZSBpZiB0aGVyZSBhcmUgZnVydGhlciBmdW5jdGlvbnMgdG8gY2FsbC4uLlxyXG4gICAgICAgICAgICAgICAgLy8gIHRoaW5ncyB0aGF0IGhhdmUgZ290IHB1dCBpbnRvIHRoZSBleHRlbmQgZnVuY3Rpb24/XHJcblxyXG5cclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3BlYyA9IGFyZ3VtZW50c1swXSB8fCB7fTtcclxuICAgICAgICAgICAgICAgIHNwZWMuYWJzdHJhY3QgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgLy92YXIgbmV3Q2xhc3MgPSBuZXcgQ2xhc3Moc3BlYyk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9yZXR1cm4gbmV3Q2xhc3M7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENsYXNzKHNwZWMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH07XHJcbiAgICBDbGFzcy5wcm90b3R5cGUgPSBwcm90b3R5cGU7XHJcbiAgICAvL0NsYXNzLmNvbnN0cnVjdG9yID0gQ2xhc3M7XHJcbiAgICBDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDbGFzcztcclxuICAgIC8vIGJ1dCBjb25zdHJ1Y3RvciBsb3NlcyBpbmZvLiBub3Qgc3VyZSBob3cgdG8gZ2V0IGJhY2sgYXQgdGhlIGNvbnN0cnVjdG9yIGZyb20gYW4gb2JqZWN0P1xyXG4gICAgLy8gIHdoYXQgaXMgdGhlIG9yaWdpbmFsIGNvbnN0cnVjdG9yIGV2ZW4/XHJcblxyXG4gICAgQ2xhc3MuZXh0ZW5kID0gYXJndW1lbnRzLmNhbGxlZTtcclxuXHJcbiAgICAvKlxyXG4gICAgaWYgKGZvcl9jbGFzcykge1xyXG4gICAgICAgIGZvciAodmFyIGMgPSAwLCBsID0gZm9yX2NsYXNzLmxlbmd0aDsgYyA8IGw7IGMrKykge1xyXG4gICAgICAgICAgICBDbGFzc1tpXSA9IGZvcl9jbGFzc1t2XTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAqL1xyXG4gICAgLy9jb25zb2xlLmxvZygnZm9yX2NsYXNzJywgZm9yX2NsYXNzKTtcclxuICAgIGZvciAoaSBpbiBmb3JfY2xhc3MpIHtcclxuICAgICAgICBDbGFzc1tpXSA9IGZvcl9jbGFzc1tpXTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLy9lYWNoKGZvcl9jbGFzcywgZnVuY3Rpb24oaSwgdikge1xyXG4gICAgLy9cdENsYXNzW2ldID0gdjtcclxuICAgIC8vfSk7XHJcblxyXG4gICAgLy8ganNndWkubWFwX2NsYXNzZXNbXVxyXG5cclxuICAgIGlmIChDbGFzc1snY2xhc3NfbmFtZSddKSB7XHJcbiAgICAgICAganNndWkubWFwX2NsYXNzZXNbQ2xhc3NbJ2NsYXNzX25hbWUnXV0gPSBDbGFzcztcclxuICAgIH1cclxuXHJcbiAgICAvL2NvbnNvbGUubG9nKCdfc3VwZXJwcm90b3R5cGUgJyArIF9zdXBlci5wcm90b3R5cGUpO1xyXG5cclxuICAgIC8vQ2xhc3MucHJvdG90eXBlLl9zdXBlcmNsYXNzID0gX3N1cGVyO1xyXG5cclxuICAgIENsYXNzLl9zdXBlcmNsYXNzID0gdGhpcztcclxuXHJcbiAgICAvL0NsYXNzLl9zdXBlcnByb3RvdHlwZSA9IF9zdXBlcjtcclxuXHJcblxyXG4gICAgLy8gKiBpZiAobmFtZXNwY0V4dGVuc2lvbikgeyBlYWNoKG5hbWVzcGNFeHRlbnNpb24sIGZ1bmN0aW9uKGksIG4pIHtcclxuICAgIC8vICogQ2xhc3NbaV0gPSBuOyB9KTsgfTsgaWYgKHByb3BzVG9NZXJnZSkgeyBlYWNoKHByb3BzVG9NZXJnZSxcclxuICAgIC8vICogZnVuY3Rpb24oaSwgbikgeyBpZiAodHlwZW9mIENsYXNzLnByb3RvdHlwZVtpXSA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgIC8vICogQ2xhc3MucHJvdG90eXBlW2ldID0gbjsgfSBlbHNlIHsgJC5leHRlbmQodHJ1ZSwgQ2xhc3MucHJvdG90eXBlW2ldLFxyXG4gICAgLy8vICogbik7IH07IH0pOyB9XHJcblxyXG5cclxuICAgIHJldHVybiBDbGFzcztcclxufTtcclxuXHJcblxyXG4vLyBXaWxsIGhhdmUgYWN0dWFsIENvbnN0cmFpbnQgcHJvZ3JhbW1pbmcgb2JqZWN0cy5cclxuLy8gIFRoZXkgbWF5IHRyYW5zbGF0ZSB0byB0aGUgZGF0YWJhc2UgbGV2ZWwgYXMgd2VsbC5cclxuLy8gIEluIG1hbnkgY2FzZXMgdGhlIGNvbnN0cmFpbnRzIHdpbGwgYmUgZXhwcmVzc2VkIGFzIHN0cmluZ3Mgc3VjaCBhcyAndGV4dCgzMiknLlxyXG4vLyAgIFdvdWxkIHRoZW4gYmUgdHJhbnNsYXRlZCB0byB2YXJjaGFyKDMyKSBvbiBhIGRpZmZlcmVudCBsZXZlbC5cclxuXHJcblxyXG5cclxudmFyIGRhdGFfb2JqZWN0X21hdGNoZXNfZmllbGRfY29uc3RyYWludHMgPSBmdW5jdGlvbihkYXRhX29iamVjdCwgZmllbGRfY29uc3RyYWludHMpIHtcclxuICAgIC8vIEZpZWxkIGNvbnN0cmFpbnRzIGdpdmVuIGFzIGEgbm9ybWFsIG9iamVjdC5cclxuXHJcbiAgICAvLyByZXR1cm5zIHRydWUgb3IgZmFsc2VcclxuICAgIC8vICB0aG91Z2ggY291bGQgcmV0dXJuIGZhaWx1cmUgaW5mb3JtYXRpb24gYXMgd2VsbCBpZiBhc2tlZCBmb3IgaXQuXHJcbiAgICAvLyAgbWFraW5nIGl0IGludG8gYW5vdGhlciBwb2x5bW9ycGhpYyBmdW5jdGlvbi5cclxuXHJcbiAgICBlYWNoKGZpZWxkX2NvbnN0cmFpbnRzLCBmdW5jdGlvbihmY19uYW1lLCBmY192YWx1ZSkge1xyXG4gICAgICAgIC8vY29uc29sZS5sb2coJ2ZjX25hbWUgJyArIGZjX25hbWUpO1xyXG4gICAgICAgIC8vY29uc29sZS5sb2coJ2ZjX3ZhbHVlICcgKyBmY192YWx1ZSk7XHJcblxyXG4gICAgfSk7XHJcbn07XHJcbi8vIFRoYXQgZGF0YSBvYmplY3Qgd2lsbCBiZSBpbmRleGFibGUuXHJcblxyXG52YXIgRW5oYW5jZWRfRGF0YV9PYmplY3QgPSBudWxsO1xyXG5cclxudmFyIHNldF9FbmhhbmNlZF9EYXRhX09iamVjdCA9IGZ1bmN0aW9uIChFRE8pIHtcclxuICAgIEVuaGFuY2VkX0RhdGFfT2JqZWN0ID0gRURPO1xyXG59O1xyXG5cclxudmFyIGdldF9FbmhhbmNlZF9EYXRhX09iamVjdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBFbmhhbmNlZF9EYXRhX09iamVjdDtcclxufTtcclxuXHJcblxyXG4vLyBzZWVtcyBsaWtlIGFuIG92ZXJsYXAgd2l0aCB0aGUgbmV3IGpzZ3VpLmZyb21PYmplY3QgZnVuY3Rpb24uXHJcbi8vICBUaGF0IHdpbGwgaW5pdGlhbGx5IGdvIGluIHRoZSBFbmhhbmNlZF9EYXRhX09iamVjdCBtb2R1bGUsIG9yIGpzZ3VpLWVuaFxyXG5cclxudmFyIGRvYmogPSBmdW5jdGlvbihvYmosIGRhdGFfZGVmKSB7XHJcbiAgICAvLyBjb3VsZCB0YWtlIGEgZGF0YV9kZWY/XHJcbiAgICAvLyBDb3VsZCB1c2UgdGhlIGVuaGFuY2VkIGRhdGEgb2JqZWN0IGlmIHdlIHBhdGNoIGJhY2t3YXJkcz9cclxuICAgIC8vICBTbyBFbmhhbmNlZF9EYXRhX09iamVjdCBjb3VsZCBob3BlZnVsbHkgcGF0Y2ggYmFja3dhcmRzIGluIHRoZSBjb2RlP1xyXG5cclxuICAgIC8vdmFyIHRkZCA9IHRvZihkYXRhX2RlZik7XHJcblxyXG4gICAgdmFyIGNzdHIgPSBEYXRhX09iamVjdDtcclxuICAgIGlmIChFbmhhbmNlZF9EYXRhX09iamVjdCkgY3N0ciA9IEVuaGFuY2VkX0RhdGFfT2JqZWN0O1xyXG4gICAgLy9jb25zb2xlLmxvZygnRW5oYW5jZWRfRGF0YV9PYmplY3QgJyArIEVuaGFuY2VkX0RhdGFfT2JqZWN0KTtcclxuXHJcbiAgICB2YXIgcmVzO1xyXG4gICAgaWYgKGRhdGFfZGVmKSB7XHJcbiAgICAgICAgcmVzID0gbmV3IGNzdHIoeydkYXRhX2RlZic6IGRhdGFfZGVmfSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJlcyA9IG5ldyBjc3RyKHt9KTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgdG9iaiA9IHRvZihvYmopO1xyXG5cclxuICAgIC8vY29uc29sZS5sb2coJ29iaiAnICsgc3RyaW5naWZ5KG9iaikpO1xyXG4gICAgaWYgKHRvYmogPT0gJ29iamVjdCcpIHtcclxuICAgICAgICB2YXIgcmVzX3NldCA9IHJlcy5zZXQ7XHJcbiAgICAgICAgZWFjaChvYmosIGZ1bmN0aW9uKGksIHYpIHtcclxuICAgICAgICAgICAgLy9yZXMuc2V0KGksIHYpO1xyXG4gICAgICAgICAgICByZXNfc2V0LmNhbGwocmVzLCBpLCB2KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcmVzO1xyXG59O1xyXG5cclxuXHJcbi8vIFRoaXMgY29kZSBjb3VsZCBiZSBkb25lIHVzaW5nIG90aGVyIG1lYW5zIGluIG90aGVyIHBhcnRzIG9mIHRoZSBzeXN0ZW0uXHJcbi8vICBUaGUgZnJhbWV3b3JrIGNvZGUgd2lsbCBwcm92aWRlIG1vcmUgdG8gZG8gd2l0aCBkYXRhIHR5cGUgZGVmaW5pdGlvbnMgYW5kIGludGVycHJldGluZyBpbnB1dCBkYXRhLlxyXG5cclxuLy8gdGhpcyBzZWVtcyBsaWtlIHBhcnQgb2YgYW4gaW5wdXQgcHJvY2Vzc29yLlxyXG4vLyAgY2hhbmdlcyBmcm9tIHRleHQgdG8gdGhlIEphdmFTY3JpcHQgb2JqZWN0cyB0aGF0IGdldCB1bmRlcnN0b29kLlxyXG5cclxuXHJcbi8vIHBhcnNpbmcgYSBkYXRhIHR5cGVcclxuLy8gc2ltaWxhciB0byBwYXJzaW5nIGEgSmF2YVNjcmlwdCBmdW5jdGlvbiBjYWxsLCBidXQgb25seSBvbmUgdGluZyBpbiB0aGUgYnJhY2tldHMsIGFuZCB0aGVyZSBtYXkgbm90IGJlIGJyYWNrZXRzIGFueXdheVxyXG5cclxuXHJcbnZhciBwYXJzZV9maWVsZF90ZXh0ID0gRmllbGRzX0NvbGxlY3Rpb24ucGFyc2VfZmllbGRfdGV4dDtcclxudmFyIHBhcnNlX2RhdGFfdHlwZSA9IEZpZWxkc19Db2xsZWN0aW9uLnBhcnNlX2RhdGFfdHlwZTtcclxuLy8gV2UgY2FuJ3QgZXh0ZW5kIHRoaXMgZnVydGhlciBkb3duIHdoaWxlIHVzaW5nIHJlcXVpcmVqc1xyXG4vLyAgTm90IHN1cmUgaG93IHRvIGFjaGlldmUgdGhpcyBub3csIHJlcXVpcmVqcyB3YXMgbWVhbnQgdG8gYmUgZm9yIGNvbnZlbmllbmNlLlxyXG5cclxuLy8gQ2FuIGhhdmUgc29tZSBzb3J0IG9mIGZ1bmN0aW9uIGNoYWluaW5nLlxyXG4vLyAgQW5kIGhhdmluZyBhIGZ1bmN0aW9uIHdpdGhpbiB0aGUgcmlnaHQgbW9kdWxlIGNhbGxlZC4uLlxyXG4vLyAgVGhhdCBjb3VsZCBiZSBhICdsaW5raW5nIGZ1bmN0aW9uLidcclxuLy8gbW9kX2xpbmsuXHJcblxyXG4vLyBBIG5ldyBjb25zdHJ1Y3RvciBmb3IgdGhlc2U/XHJcbi8vICBDdXJyaWVkIGZ1bmN0aW9ucz9cclxuLy8gIE9yIEJvb2xlYW5fRFYuLi4gV291bGQgaGF2ZSB0ZXN0cyBwb3NzaWJseS5cclxuXHJcbmpzZ3VpLm1hcF9kYXRhX3R5cGVfZGF0YV9vYmplY3RfY29uc3RydWN0b3JzID0ganNndWkubWFwX2RhdGFfdHlwZV9kYXRhX29iamVjdF9jb25zdHJ1Y3RvcnMgfHwge307XHJcbmpzZ3VpLm1hcF9kYXRhX3R5cGVfZGF0YV9vYmplY3RfY29uc3RydWN0b3JzWydib29sZWFuJ10gPSBEYXRhX1ZhbHVlO1xyXG4vL2Jvb2xlYW4nOiBEYXRhX1ZhbHVlXHJcblxyXG5cclxuXHJcbi8vIENvdWxkIGRvIHNvbWV0aGluZyBsaWtlIHBhc3MgdGhlIGVuc3VyZV9kYXRhX3R5cGVfZGF0YV9vYmplY3RfY29uc3RydWN0b3IgZnVuY3Rpb24gYXJvdW5kP1xyXG4vLyAgT3IgdGhlIEhUTUwgbW9kdWxlIHdpbGwgaGF2ZSBpdHMgb3duIHdheSBvZiBtYWtpbmcgb2JqZWN0IGNvbnN0cnVjdG9ycy5cclxuXHJcbi8vIEkgdGhpbmsgb25seSBoYXZpbmcgb2JqZWN0IGNvbnN0cnVjdG9yIGZ1bmN0aW9ucyBnb2luZyBkb3duIHRoZSBtb2R1bGUgbG9hZGluZyBoZWlyYWNoeSB3aWxsIHdvcmsuXHJcbi8vICBNYXkgaGF2ZSBhIG1hcCBvZiB2YXJpb3VzIGxvYWRpbmcgZnVuY3Rpb25zIHRoYXQgZ2V0IG1hZGUgaW4gZWFjaCBtb2R1bGUuXHJcblxyXG4vLyBUaGV5IGFyZSBiYXNpY2FsbHkgY29uc3RydWN0b3IgZnVuY3Rpb25zLlxyXG5cclxuLy8gQnV0IHRoaXMgY291bGQgaGF2ZSBhY2Nlc3Mgb3IgbmVlZCBhY2Nlc3MgdG8gbW9yZSBpbmZvcm1hdGlvbiBhYm91dCBob3cgdG8gY29uc3RydWN0IG9iamVjdHMuXHJcbi8vICBXYW50IHRvIGdldCB0aGlzIHdvcmtpbmcgZm9yICdjb2xvcicuXHJcbnZhciBlbnN1cmVfZGF0YV90eXBlX2RhdGFfb2JqZWN0X2NvbnN0cnVjdG9yID0gZnVuY3Rpb24oZGF0YV90eXBlX25hbWUpIHtcclxuXHJcbiAgICAvL2NvbnNvbGUubG9nKCcnKTtcclxuICAgIC8vY29uc29sZS5sb2coJycpO1xyXG4gICAgLy9jb25zb2xlLmxvZygnanNndWkubWFwX2RhdGFfdHlwZV9kYXRhX29iamVjdF9jb25zdHJ1Y3RvcnNbZGF0YV90eXBlX25hbWVdICcgKyBzdHJpbmdpZnkoanNndWkubWFwX2RhdGFfdHlwZV9kYXRhX29iamVjdF9jb25zdHJ1Y3RvcnNbZGF0YV90eXBlX25hbWVdKSk7XHJcbiAgICAvL2NvbnNvbGUubG9nKCcnKTtcclxuICAgIC8vY29uc29sZS5sb2coJycpO1xyXG5cclxuICAgIC8vIEhhcmRldCB0byBicmluZyB0aGF0IG1hcCB0aHJvdWdoIGFsbCBkZXBlbmRlbmNpZXMgYW5kIGJhY2suXHJcbiAgICAvLyAgSG93ZXZlciwgbmVlZCB0byBoYXZlIGFjY2VzcyB0byB0aGF0IG1hcCB2YXJpYWJsZS5cclxuXHJcbiAgICAvL2NvbnNvbGUubG9nKCdqc2d1aS5tYXBfZGF0YV90eXBlX2RhdGFfb2JqZWN0X2NvbnN0cnVjdG9ycyAnICsganNndWkubWFwX2RhdGFfdHlwZV9kYXRhX29iamVjdF9jb25zdHJ1Y3RvcnMpO1xyXG5cclxuICAgIGlmICghanNndWkubWFwX2RhdGFfdHlwZV9kYXRhX29iamVjdF9jb25zdHJ1Y3RvcnNbZGF0YV90eXBlX25hbWVdKSB7XHJcbiAgICAgICAgLy9jb25zb2xlLmxvZygnY3JlYXRpbmcgbmV3IERhdGFfT2JqZWN0IGNvbnN0cnVjdG9yIGZvciBkYXRhX3R5cGU6ICcgKyBkYXRhX3R5cGVfbmFtZSlcclxuXHJcbiAgICAgICAgLy8gTmVlZCB0byBnZXQgdGhlIHZhcmlhYmxlIGJhY2sgdGhyb3VnaCB0aGUgbW9kdWxlcy4uLlxyXG4gICAgICAgIC8vICBNaXNzaW5nIGdsb2JhbCB2YXJpYWJsZXM/XHJcbiAgICAgICAgLy8gIE1vdmUgdGhpcyBmdW5jdGlvbiBzb21ld2hlcmUgZWxzZT9cclxuICAgICAgICAvLyAgTWF5YmUgd2UgY291bGQgaGF2ZSBzb21lIHN0b3JhZ2UgYXZhaWxhYmxlIGluIGpzZ3VpLWxhbmctZXNzZW50aWFscyB0aHJvdWdoIGEgY2xvc3VyZS5cclxuICAgICAgICAvLyAgVGhhdCB3YXkgdGhlIGNvZGUgY291bGQgYmUgc2VudCBiYWNrLi4uIGJ1dCBkbyB3ZSBzdGlsbCBoYXZlIGRpZmZlcmVudCBpbnN0YW5jZXMgcnVubmluZz9cclxuXHJcbiAgICAgICAgLy8gQ291bGQganVzdCBiZSBkaWZmZXJlbnQgZXhlY3V0aW9uIGNvbnRleHRzLi4uIGNvIGNhbid0IGZlZWQgYmFjayB0aGlzIGluZm9ybWF0aW9uIGFib3V0IG90aGVyIG9iamVjdHMuXHJcbiAgICAgICAgLy8gIEJ1dCBjYW4gZmVlZCBmdW5jdGlvbmFsaXR5IGZvcmFyZHMuXHJcblxyXG4gICAgICAgIC8vIE1heSBuZWVkIHRvIGhhdmUgdGhpbmdzIG1vcmUgaW5kZXBlbmRhbnQuXHJcbiAgICAgICAgLy9cclxuXHJcbiAgICAgICAgLy92YXIgZHRpID0ganNndWkuZ2V0KCdkdGknKTtcclxuICAgICAgICAvL2NvbnNvbGUubG9nKCdkdGkgJyArIGR0aSk7XHJcbiAgICAgICAgLy90aHJvdyAnc3RvcCc7XHJcblxyXG4gICAgICAgIHZhciBkdG8gPSBqc2d1aS5kYXRhX3R5cGVzX2luZm9bZGF0YV90eXBlX25hbWVdO1xyXG5cclxuICAgICAgICAvL2NvbnNvbGUubG9nKCdkdG8gJyArIHN0cmluZ2lmeShkdG8pKTtcclxuXHJcbiAgICAgICAgdmFyIGR0YyA9IERhdGFfT2JqZWN0LmV4dGVuZCh7XHJcbiAgICAgICAgICAgICdmaWVsZHMnOiBkdG9cclxuICAgICAgICB9KVxyXG4gICAgICAgIGpzZ3VpLm1hcF9kYXRhX3R5cGVfZGF0YV9vYmplY3RfY29uc3RydWN0b3JzW2RhdGFfdHlwZV9uYW1lXSA9IGR0YztcclxuICAgIH1cclxuICAgIHJldHVybiBqc2d1aS5tYXBfZGF0YV90eXBlX2RhdGFfb2JqZWN0X2NvbnN0cnVjdG9yc1tkYXRhX3R5cGVfbmFtZV07XHJcbn1cclxuanNndWkuZW5zdXJlX2RhdGFfdHlwZV9kYXRhX29iamVjdF9jb25zdHJ1Y3RvciA9IGVuc3VyZV9kYXRhX3R5cGVfZGF0YV9vYmplY3RfY29uc3RydWN0b3I7XHJcblxyXG5pbnB1dF9wcm9jZXNzb3JzLmZpZWxkX3RleHQgPSBwYXJzZV9maWVsZF90ZXh0O1xyXG5pbnB1dF9wcm9jZXNzb3JzLmRhdGFfdHlwZSA9IHBhcnNlX2RhdGFfdHlwZTtcclxuXHJcbi8vIE1heWJlIGRvIHdpdGhvdXQgdGhlIGZvbGxvd2luZy5cclxuLy8gIEhhdmUgZGlmZmVyZW50LCBzaW1wbGVyLCBmbGF0dGVyIG5hbWVzcGFjaW5nLiBQdXQgbG90cyBvZiB0aGluZ3MgaW4ganNndWkuXHJcbi8vICBUaGVuIHdoZW4gdGhlIGZpbGVzIGdldCBidWlsdCB0b2dldGhlciB0aGV5IGdldCB0dXJuZWQgaW50byBsb2NhbCB2YXJpYWJsZXMuXHJcblxyXG4vL0RhdGFfT2JqZWN0LkRhdGFfVmFsdWUgPSBEYXRhX1ZhbHVlO1xyXG5cclxuXHJcblxyXG5EYXRhX09iamVjdC5GaWVsZHNfQ29sbGVjdGlvbiA9IEZpZWxkc19Db2xsZWN0aW9uO1xyXG5EYXRhX09iamVjdC5kb2JqID0gZG9iajtcclxuRGF0YV9PYmplY3QubWF0Y2hlc19maWVsZF9jb25zdHJhaW50cyA9IGRhdGFfb2JqZWN0X21hdGNoZXNfZmllbGRfY29uc3RyYWludHM7XHJcbkRhdGFfT2JqZWN0LnBhcnNlX2ZpZWxkX3RleHQgPSBwYXJzZV9maWVsZF90ZXh0O1xyXG5EYXRhX09iamVjdC5nZXRfY2hhaW5lZF9maWVsZHMgPSBnZXRfY2hhaW5lZF9maWVsZHM7XHJcbkRhdGFfT2JqZWN0LmNoYWluZWRfZmllbGRzX3RvX2ZpZWxkc19saXN0ID0gY2hhaW5lZF9maWVsZHNfdG9fZmllbGRzX2xpc3Q7XHJcbkRhdGFfT2JqZWN0Lm1hcF9kYXRhX3R5cGVfZGF0YV9vYmplY3RfY29uc3RydWN0b3JzID0ganNndWkubWFwX2RhdGFfdHlwZV9kYXRhX29iamVjdF9jb25zdHJ1Y3RvcnM7XHJcbkRhdGFfT2JqZWN0Lk1pbmlfQ29udGV4dCA9IE1pbmlfQ29udGV4dDtcclxuRGF0YV9PYmplY3Quc2V0X0VuaGFuY2VkX0RhdGFfT2JqZWN0ID0gc2V0X0VuaGFuY2VkX0RhdGFfT2JqZWN0O1xyXG5EYXRhX09iamVjdC5nZXRfRW5oYW5jZWRfRGF0YV9PYmplY3QgPSBnZXRfRW5oYW5jZWRfRGF0YV9PYmplY3Q7XHJcbkRhdGFfT2JqZWN0LmVuc3VyZV9kYXRhX3R5cGVfZGF0YV9vYmplY3RfY29uc3RydWN0b3IgPSBlbnN1cmVfZGF0YV90eXBlX2RhdGFfb2JqZWN0X2NvbnN0cnVjdG9yO1xyXG5cclxuLy9yZXR1cm4gRGF0YV9PYmplY3Q7XHJcbm1vZHVsZS5leHBvcnRzID0gRGF0YV9PYmplY3Q7XHJcbi8vfSlcclxuIiwidmFyIGpzZ3VpID0gcmVxdWlyZSgnLi9qc2d1aS1sYW5nLWVzc2VudGlhbHMnKTtcclxuXHJcbnZhciBqID0ganNndWk7XHJcbnZhciBDbGFzcyA9IGouQ2xhc3M7XHJcbnZhciBlYWNoID0gai5lYWNoO1xyXG52YXIgaXNfYXJyYXkgPSBqLmlzX2FycmF5O1xyXG52YXIgaXNfZG9tX25vZGUgPSBqLmlzX2RvbV9ub2RlO1xyXG52YXIgaXNfY3RybCA9IGouaXNfY3RybDtcclxudmFyIGV4dGVuZCA9IGouZXh0ZW5kO1xyXG52YXIgZ2V0X3RydXRoX21hcF9mcm9tX2FyciA9IGouZ2V0X3RydXRoX21hcF9mcm9tX2FycjtcclxudmFyIGdldF9tYXBfZnJvbV9hcnIgPSBqLmdldF9tYXBfZnJvbV9hcnI7XHJcbnZhciBhcnJfbGlrZV90b19hcnIgPSBqLmFycl9saWtlX3RvX2FycjtcclxudmFyIHRvZiA9IGoudG9mO1xyXG52YXIgaXNfZGVmaW5lZCA9IGouaXNfZGVmaW5lZDtcclxudmFyIHN0cmluZ2lmeSA9IGouc3RyaW5naWZ5O1xyXG52YXIgZnVuY3Rpb25hbF9wb2x5bW9ycGhpc20gPSBqLmZ1bmN0aW9uYWxfcG9seW1vcnBoaXNtO1xyXG52YXIgZnAgPSBqLmZwO1xyXG52YXIgYXJyYXlpZnkgPSBqLmFycmF5aWZ5O1xyXG52YXIgbWFwaWZ5ID0gai5tYXBpZnk7XHJcbnZhciBhcmVfZXF1YWwgPSBqLmFyZV9lcXVhbDtcclxudmFyIGdldF9pdGVtX3NpZyA9IGouZ2V0X2l0ZW1fc2lnO1xyXG52YXIgc2V0X3ZhbHMgPSBqLnNldF92YWxzO1xyXG52YXIgdHJ1dGggPSBqLnRydXRoO1xyXG52YXIgdHJpbV9zaWdfYnJhY2tldHMgPSBqLnRyaW1fc2lnX2JyYWNrZXRzO1xyXG52YXIgbGxfc2V0ID0gai5sbF9zZXQ7XHJcbnZhciBsbF9nZXQgPSBqLmxsX2dldDtcclxudmFyIGlucHV0X3Byb2Nlc3NvcnMgPSBqLmlucHV0X3Byb2Nlc3NvcnM7XHJcbnZhciBpdGVyYXRlX2FuY2VzdG9yX2NsYXNzZXMgPSBqLml0ZXJhdGVfYW5jZXN0b3JfY2xhc3NlcztcclxudmFyIGlzX2Fycl9vZl9hcnJzID0gai5pc19hcnJfb2ZfYXJycztcclxudmFyIGlzX2Fycl9vZl9zdHJzID0gai5pc19hcnJfb2Zfc3RycztcclxudmFyIGlzX2Fycl9vZl90ID0gai5pc19hcnJfb2ZfdDtcclxudmFyIGNsb25lID0ganNndWkuY2xvbmU7XHJcblxyXG52YXIgRXZlbnRlZF9DbGFzcyA9IHJlcXVpcmUoJy4vZXZlbnRlZC1jbGFzcycpO1xyXG5cclxuXHJcbnZhciBEYXRhX1ZhbHVlID0gRXZlbnRlZF9DbGFzcy5leHRlbmQoe1xyXG4gICAgJ2luaXQnOiBmdW5jdGlvbihzcGVjKSB7XHJcblxyXG4gICAgICAgIHRoaXMuX3N1cGVyKCk7XHJcbiAgICAgICAgLy8gdGhlIHNwZWMgd2lsbCBiZSB0aGUgdmFsdWUuXHJcbiAgICAgICAgLy8gIGNvdWxkIGJlIHRoZSB2YWx1ZSBhbmQgaXRzIHR5cGUuXHJcblxyXG4gICAgICAgIC8vY29uc29sZS5sb2coJ2pzZ3VpLl9fZGF0YV9pZF9tZXRob2QgJyArIGpzZ3VpLl9fZGF0YV9pZF9tZXRob2QpO1xyXG4gICAgICAgIC8vdGhyb3cgJ3N0b3AnO1xyXG5cclxuICAgICAgICAvLyBzbyBpZiB0aGUgZGF0YV9pZF9tZXRob2QgaXMgbGF6eSwgd2UgZ2V0IHRoZSBpZCB0aHJvdWdoIGEgZnVuY3Rpb24uXHJcblxyXG4gICAgICAgIC8vIENvdWxkIHRha2UgdGhlIGNvbnRleHQgYXMgYW5vdGhlciBwYXJhbWV0ZXIuLi5cclxuICAgICAgICAvLyAgQ2FuIG1ha2UgaXQgbW9yZSBmbGV4aWJsZSBpbiB0ZXJtcyBvZiBob3cgaXQgZ2V0cyBpbml0aWFsaXNlZC5cclxuICAgICAgICAvLyAgRGF0YV9WYWx1ZSh2YWx1ZSkgbWFrZXMgdGhlIG1vc3Qgc2Vuc2UuXHJcblxyXG4gICAgICAgIGlmIChzcGVjICYmIHNwZWMuY29udGV4dCkge1xyXG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0ID0gc3BlYy5jb250ZXh0O1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChzcGVjKSB7XHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJyEqIHNwZWMudmFsdWUgJyArIHNwZWMudmFsdWUpO1xyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdzcGVjICcgKyBzdHJpbmdpZnkoc3BlYykpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHNwZWMgJiYgaXNfZGVmaW5lZChzcGVjLnZhbHVlKSkge1xyXG4gICAgICAgICAgICB0aGlzLl8gPSBzcGVjLnZhbHVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICBpZiAoanNndWkuX19kYXRhX2lkX21ldGhvZCA9PSAnaW5pdCcpIHtcclxuICAgICAgICAgICAgLy90aHJvdyAnc3RvcCc7XHJcbiAgICAgICAgICAgIC8vIGFuZCB0aGVyZSBtYXkgYmUgYSBtYXAgaW4gdGhlIGNvbnRleHQuXHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5fY29udGV4dCkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIHRoZSBjb250ZXh0IG5vIGxvbmdlciBrZWVwcyBhIG1hcCBvZiB0aGUgb2JqZWN0cy5cclxuICAgICAgICAgICAgICAgIC8vICBXaWxsIHdvcmsgbW9yZSBvbiB0aGUgcmVsYXRpb25zaGlwcyBpbiBhIGJpdC5cclxuXHJcblxyXG5cclxuICAgICAgICAgICAgICAgIC8vdGhpcy5fY29udGV4dC5tYXBfb2JqZWN0c1t0aGlzLl9faWRdID0gdGhpcztcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIGRvbid0IHdhbnQgdG8gYmUgdXNpbmcgSURzIG91dCBvZiBjb250ZXh0LlxyXG5cclxuICAgICAgICAgICAgICAgIC8vdGhyb3cgJ0RhdGFfVmFsdWUgbmVlZHMgY29udGV4dCc7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gYnV0IHdlJ2xsIHRyeSB0aGlzIC0gbm90IHNldHRpbmcgdGhlIElELlxyXG4gICAgICAgICAgICAgICAgLy8gIHJlYWxseSBpdCBuZWVkcyBhbiBJRCB3aGVuIGl0J3MgaW4gYSBwYWdlLlxyXG4gICAgICAgICAgICAgICAgLy8gIERhdGFfVmFsdWVzIHNob3VsZCBiZSBhYmxlIHRvIHdvcmsgYXQgb3RoZXIgdGltZXMsIHN1Y2ggYXMgcmVuZGVyaW5nIEhUTUwgZXhhbXBsZXMuXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQnV0IG1heWJlIGl0IHNob3VsZCBiZSBhYmxlIHRvIG9wZXJhdGUgd2l0aCBubyBjb250ZXh0IG9yIElELlxyXG4gICAgICAgICAgICAgICAgLy8gIEl0IG1heSBiZSBhIGRlbWFuZCBvZiB0aGUgY29udGV4dCB0aGF0IGl0IGhhcyBhbiBJRC5cclxuICAgICAgICAgICAgICAgIC8vICAgKG1heWJlIG5vdCBpcyBzb21lIGNvbnRleHRzIHRob3VnaCkuXHJcblxyXG4gICAgICAgICAgICAgICAgLy90aGlzLl9faWQgPSBuZXdfZGF0YV92YWx1ZV9pZCgpO1xyXG5cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgLy9tYXBfanNndWlfaWRzW3RoaXMuX19pZF0gPSB0aGlzO1xyXG5cclxuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgKi9cclxuXHJcbiAgICAgICAgLy90aGlzLl92YWwgPSBzcGVjO1xyXG5cclxuICAgICAgICB0aGlzLl9fdHlwZSA9ICdkYXRhX3ZhbHVlJztcclxuXHJcbiAgICAgICAgLy90aGlzLl9ib3VuZF9ldmVudHMgPSB7fTtcclxuXHJcblxyXG4gICAgICAgIHRoaXMuX3JlbGF0aW9uc2hpcHMgPSB7fTtcclxuICAgIH0sXHJcbiAgICAnZ2V0JzogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgLy9yZXR1cm4gdGhpcy5fdmFsO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl87XHJcbiAgICB9LFxyXG4gICAgJ3ZhbHVlJzogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KCk7XHJcbiAgICB9LFxyXG4gICAgJ3RvT2JqZWN0JzogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgLy9pZiAodGhpcy5fLnRvT2JqZWN0KSB7XHJcbiAgICAgICAgLy9cdHJldHVybiB0aGlzLl8udG9PYmplY3QoKTtcclxuICAgICAgICAvL30gZWxzZSB7XHJcbiAgICAgICAgLy9cdHJldHVybiB0aGlzLl87XHJcbiAgICAgICAgLy99XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuXztcclxuXHJcbiAgICB9LFxyXG4gICAgJ3NldCc6IGZ1bmN0aW9uKHZhbCkge1xyXG4gICAgICAgIC8vdGhpcy5fdmFsID0gdmFsO1xyXG4gICAgICAgIHZhciBvbGRfdmFsID0gdGhpcy5fO1xyXG5cclxuICAgICAgICB0aGlzLl8gPSB2YWw7XHJcbiAgICAgICAgdGhpcy5yYWlzZSgnY2hhbmdlJywge1xyXG4gICAgICAgICAgICAnb2xkJzogb2xkX3ZhbCxcclxuICAgICAgICAgICAgJ3ZhbHVlJzogdmFsXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiB2YWw7XHJcbiAgICB9LFxyXG4gICAgJ3RvU3RyaW5nJzogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgLy9yZXR1cm4gc3RyaW5naWZ5KHRoaXMuZ2V0KCkpO1xyXG4gICAgICAgIC8vIGNvblxyXG5cclxuICAgICAgICAvL2NvbnNvbGUubG9nKCd0aGlzLl92YWwgJyArIHN0cmluZ2lmeSh0aGlzLl92YWwpKTtcclxuICAgICAgICAvL3Rocm93ICdzdG9wJztcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KCk7XHJcbiAgICB9LFxyXG4gICAgLy8gTWF5YmUgYSBwYXJ0aWN1bGFyIHN0cmluZ2lmeSBmdW5jdGlvbj9cclxuICAgICdzdHJpbmdpZnknOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAvL3JldHVybiBzdHJpbmdpZnkodGhpcy5nZXQoKSk7XHJcbiAgICAgICAgLy8gY29uXHJcblxyXG4gICAgICAgIC8vY29uc29sZS5sb2coJ3RoaXMuX3ZhbCAnICsgc3RyaW5naWZ5KHRoaXMuX3ZhbCkpO1xyXG4gICAgICAgIC8vdGhyb3cgJ3N0b3AnO1xyXG5cclxuICAgICAgICB2YXIgdmFsID0gdGhpcy5nZXQoKTtcclxuXHJcbiAgICAgICAgLy92YXIgdHZhbCA9IHRvZih2YWwpO1xyXG4gICAgICAgIHZhciB0dmFsID0gdHlwZW9mIHZhbDtcclxuICAgICAgICBpZiAodHZhbCA9PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICByZXR1cm4gJ1wiJyArIHZhbCArICdcIic7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHZhbDtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgICdjbG9uZSc6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciB2YWwgPSB0aGlzLnZhbHVlKCk7XHJcblxyXG4gICAgICAgIHZhciByZXMgPSBuZXcgRGF0YV9WYWx1ZSh7XHJcbiAgICAgICAgICAgICd2YWx1ZSc6IHZhbFxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvL2NvbnNvbGUubG9nKCdyZXMnLCByZXMpO1xyXG4gICAgICAgIC8vdGhyb3cgJ3N0b3AnO1xyXG5cclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfSxcclxuXHJcblxyXG4gICAgJ19pZCc6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIC8vIGdldHMgdGhlIGlkLlxyXG4gICAgICAgIC8vY29uc29sZS5sb2coJ3RoaXMuX2NvbnRleHQgJyArIHRoaXMuX2NvbnRleHQpO1xyXG4gICAgICAgIC8vdGhyb3cgJ3N0b3AnO1xyXG4gICAgICAgIGlmICh0aGlzLl9faWQpIHJldHVybiB0aGlzLl9faWQ7XHJcbiAgICAgICAgaWYgKHRoaXMuX2NvbnRleHQpIHtcclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygndGhpcy5fX3R5cGUgJyArIHRoaXMuX190eXBlKTtcclxuICAgICAgICAgICAgLy90aHJvdyAnc3RvcCc7XHJcbiAgICAgICAgICAgIHRoaXMuX19pZCA9IHRoaXMuX2NvbnRleHQubmV3X2lkKHRoaXMuX190eXBlX25hbWUgfHwgdGhpcy5fX3R5cGUpO1xyXG5cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoIWlzX2RlZmluZWQodGhpcy5fX2lkKSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgJ0RhdGFWYWx1ZSBzaG91bGQgaGF2ZSBjb250ZXh0JztcclxuICAgICAgICAgICAgICAgIHRoaXMuX19pZCA9IG5ld19kYXRhX3ZhbHVlX2lkKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5fX2lkO1xyXG5cclxuICAgIH0sXHJcbiAgICAncGFyZW50JzogZnAoZnVuY3Rpb24oYSwgc2lnKSB7XHJcbiAgICAgICAgdmFyIG9iaiwgaW5kZXg7XHJcbiAgICAgICAgLy9jb25zb2xlLmxvZygncGFyZW50IHNpZycsIHNpZyk7XHJcblxyXG5cclxuICAgICAgICBpZiAoYS5sID09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGEubCA9PSAxKSB7XHJcbiAgICAgICAgICAgIG9iaiA9IGFbMF07XHJcblxyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2NvbnRleHQgJiYgb2JqLl9jb250ZXh0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jb250ZXh0ID0gb2JqLl9jb250ZXh0O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBJRHMgd2lsbCBvbmx5IHdvcmsgd2l0aGluIHRoZSBjb250ZXh0LlxyXG5cclxuXHJcblxyXG4gICAgICAgICAgICAvLyBBbm90aGVyIHdheSBvZiBleHByZXNzaW5nIHRoaXM/XHJcblxyXG4gICAgICAgICAgICAvLyBDYW4gaGF2ZSBhIHNpbmdsZSBwYXJlbnQsIG9yIG11bHRpcGxlIHBhcmVudHMuXHJcbiAgICAgICAgICAgIC8vICBNYXkgd2FudCBzb21ldGhpbmcgdG8gYmUgdGhlIG9ubHkgcGFyZW50LiBDb3VsZCBoYXZlIGEgZGlmZmVyZW50IG1vZGUgZm9yIG11bHRpcGxlIHBhcmVudHMuXHJcblxyXG4gICAgICAgICAgICAvLyAgdGhpcy5fcGFyZW50ID0gb2JqP1xyXG5cclxuXHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3BhcmVudCBvYmpfaWQgJyArIG9ial9pZCk7XHJcbiAgICAgICAgICAgIC8vdGhyb3cgJ3N0b3AnXHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ29iaiAnICsgc3RyaW5naWZ5KG9iaikpO1xyXG4gICAgICAgICAgICAvLyBzaG91bGQgbWF5YmUgcmVuYW1lIG9yIHN1YmRpdmlkZSBfcmVsYXRpb25zaGlwcy5cclxuICAgICAgICAgICAgLy8gIGl0IHdpbGwgYWxzbyBiZSB1c2VmdWwgZm9yIGRhdGFiYXNlcy5cclxuICAgICAgICAgICAgLy8gIGhvd2V2ZXIsIHdvdWxkIG5lZWQgdG8gd29yayB3aXRoIHRoZSBjb25zdHJhaW50IHN5c3RlbS5cclxuICAgICAgICAgICAgLy8gICBsaWtlbHkgdGhhdCB0aGV5IHdvdWxkIGJlIHN5bmNyb25pc2VkIHRocm91Z2ggY29kZS5cclxuXHJcbiAgICAgICAgICAgIC8vdmFyIHJlbGF0ZV9ieV9pZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgLy8gICAgdmFyIG9ial9pZCA9IG9iai5faWQoKTtcclxuICAgICAgICAgICAgLy8gICAgdGhpcy5fcmVsYXRpb25zaGlwc1tvYmpfaWRdID0gdHJ1ZTtcclxuICAgICAgICAgICAgLy99XHJcblxyXG4gICAgICAgICAgICAvL3ZhciByZWxhdGVfYnlfcmVmID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAvLyAgICB0aGlzLl9wYXJlbnQgPSBvYmo7XHJcbiAgICAgICAgICAgIC8vfVxyXG4gICAgICAgICAgICAvL3JlbGF0ZV9ieV9yZWYoKTtcclxuXHJcbiAgICAgICAgICAgIHZhciByZWxhdGVfYnlfaWQgPSBmdW5jdGlvbiAodGhhdCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG9ial9pZCA9IG9iai5faWQoKTtcclxuICAgICAgICAgICAgICAgIHRoYXQuX3JlbGF0aW9uc2hpcHNbb2JqX2lkXSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciByZWxhdGVfYnlfcmVmID0gZnVuY3Rpb24gKHRoYXQpIHtcclxuICAgICAgICAgICAgICAgIHRoYXQuX3BhcmVudCA9IG9iajtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZWxhdGVfYnlfcmVmKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYS5sID09IDIpIHtcclxuICAgICAgICAgICAgb2JqID0gYVswXTtcclxuICAgICAgICAgICAgaW5kZXggPSBhWzFdO1xyXG5cclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9jb250ZXh0ICYmIG9iai5fY29udGV4dCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY29udGV4dCA9IG9iai5fY29udGV4dDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5fcGFyZW50ID0gb2JqO1xyXG4gICAgICAgICAgICB0aGlzLl9pbmRleCA9IGluZGV4O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGlzX2RlZmluZWQoaW5kZXgpKSB7XHJcbiAgICAgICAgICAgIC8vIEkgdGhpbmsgd2UganVzdCBzZXQgdGhlIF9faW5kZXggcHJvcGVydHkuXHJcbiAgICAgICAgICAgIC8vICBJIHRoaW5rIGEgX19wYXJlbnQgcHJvcGVydHkgYW5kIGEgX19pbmRleCBwcm9wZXJ0eSB3b3VsZCBkbyB0aGUgam9iIGhlcmUuXHJcbiAgICAgICAgICAgIC8vICBTdWl0cyBET00gaGVpcmFjaHkuXHJcbiAgICAgICAgICAgIC8vIEEgX19yZWxhdGlvbnNoaXBzIHByb3BlcnR5IGNvdWxkIG1ha2Ugc2Vuc2UgZm9yIHdpZGVyIHRoaW5ncywgaG93ZXZlciwgaXQgd291bGQgYmUgZWFzeSAoZm9yIHRoZSBtb21lbnQ/KVxyXG4gICAgICAgICAgICAvLyB0byBqdXN0IGhhdmUgLl9fcGFyZW50IGFuZCAuX19pbmRleFxyXG4gICAgICAgICAgICAvL1xyXG5cclxuXHJcbiAgICAgICAgICAgIC8vIE5vdCBzdXJlIGFsbCBEYXRhX09iamVjdHMgd2lsbCBuZWVkIGNvbnRleHRzLlxyXG4gICAgICAgICAgICAvLyAgSXQncyBtYWlubHkgdXNlZnVsIGZvciBDb250cm9scyBzbyBmYXJcclxuXHJcblxyXG5cclxuXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gZ2V0IHRoZSBvYmplY3QncyBpZC4uLlxyXG5cclxuICAgICAgICAgICAgLy8gc2V0dGluZyB0aGUgcGFyZW50Li4uIHRoZSBwYXJlbnQgbWF5IGhhdmUgYSBjb250ZXh0LlxyXG5cclxuXHJcblxyXG5cclxuXHJcbiAgICAgICAgfVxyXG4gICAgfSlcclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IERhdGFfVmFsdWU7XHJcbiIsIi8qXHJcblxyXG5pZiAodHlwZW9mIGRlZmluZSAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgdmFyIGRlZmluZSA9IHJlcXVpcmUoJ2FtZGVmaW5lJykobW9kdWxlKTtcclxufVxyXG5cclxuZGVmaW5lKFtcIi4vanNndWktbGFuZy11dGlsXCIsIFwiLi9kYXRhLW9iamVjdC1maWVsZHMtY29sbGVjdGlvblwiXSwgZnVuY3Rpb24oanNndWksIEZpZWxkc19Db2xsZWN0aW9uKSB7XHJcbiAgICAqL1xyXG5cclxudmFyIGpzZ3VpID0gcmVxdWlyZSgnLi9qc2d1aS1sYW5nLXV0aWwnKTtcclxudmFyIERhdGFfVmFsdWUgPSByZXF1aXJlKCcuL2RhdGEtdmFsdWUnKTtcclxudmFyIERhdGFfT2JqZWN0ID0gcmVxdWlyZSgnLi9kYXRhLW9iamVjdCcpO1xyXG52YXIgRmllbGRzX0NvbGxlY3Rpb24gPSByZXF1aXJlKCcuL2RhdGEtb2JqZWN0LWZpZWxkcy1jb2xsZWN0aW9uJyk7XHJcblxyXG52YXIgRGF0YV9PYmplY3QgPSBqc2d1aS5EYXRhX09iamVjdDtcclxudmFyIENvbGxlY3Rpb24gPSBqc2d1aS5Db2xsZWN0aW9uO1xyXG52YXIgZ2V0X2Ffc2lnID0ganNndWkuZ2V0X2Ffc2lnO1xyXG52YXIgZnAgPSBqc2d1aS5mcDtcclxudmFyIHN0cmluZ2lmeSA9IGpzZ3VpLnN0cmluZ2lmeTtcclxuLy8gVXNpbmcgYWN0dWFsIEphdmFTY3JpcHQgb2JqZWN0cyBsaWtlIFN0cmluZyBzaG91bGQgYmUgcXVpdGUgZ29vZC5cclxuLy8gIEphdmFTY3JpcHQgUHJpbWl0aXZlIENvbnRydWN0b3JzLlxyXG5cclxudmFyIGlzX2RlZmluZWQgPSBqc2d1aS5pc19kZWZpbmVkLCBsbF9nZXQgPSBqc2d1aS5sbF9nZXQsIGdldF9pdGVtX3NpZyA9IGpzZ3VpLmdldF9pdGVtX3NpZztcclxuXHJcbi8vIEhhdmluZyBhIENvbGxlY3Rpb24gb2Ygc3RyaW5ncyBoZXJlLi4uXHJcbi8vICBNYXkgbmVlZCB0byBjaG9vc2UgdGhlIHJpZ2h0IGNvbGxlY3Rpb24gY29udGV4dC5cclxuLy8gIERvbid0IHdhbnQgdG8gaGF2ZSB0byBkZWFsIHdpdGggdGhlc2UgY29udGV4dHMgYWxsIHRoZSB0aW1lIHRob3VnaC5cclxuLy8gICBPciBtYWtlIGl0IHZlcnkgZmFzdCB0byBkbyBzby5cclxuXHJcbi8vIEEgZnVuY3Rpb24gdG8gZW5zdXJlIHRoZSBsYXRlc3QgZGF0YSB0eXBlcz9cclxuXHJcbi8vIE1vZHVsZSBsZXZlbCBmdW5jdGlvbnMgdG8gcmVnaXN0ZXIgLyBzeW5jcm9uaXNlIHRoaW5ncy4uLlxyXG4vLyAgVGhhdCBtYWtlcyBhIGxvdCBvZiBzZW5zZS5cclxuXHJcbnZhciByZWdpc3Rlcl9kYXRhX3R5cGUgPSBmdW5jdGlvbihkYXRhX3R5cGVfbmFtZSwgZGVmKSB7XHJcbiAgICBqc2d1aS5kYXRhX3R5cGVzX2luZm9bZGF0YV90eXBlX25hbWVdID0gZGVmO1xyXG59XHJcblxyXG52YXIgZW5zdXJlX2RhdGFfdHlwZV9kYXRhX29iamVjdF9jb25zdHJ1Y3RvciA9IGZ1bmN0aW9uKGRhdGFfdHlwZV9uYW1lKSB7XHJcbiAgICAvL2NvbnNvbGUubG9nKCdFTkggZW5zdXJlX2RhdGFfdHlwZV9kYXRhX29iamVjdF9jb25zdHJ1Y3RvcicpO1xyXG4gICAgLy9jb25zb2xlLmxvZygnZGF0YV90eXBlX25hbWUgJyArIGRhdGFfdHlwZV9uYW1lKTtcclxuXHJcbiAgICBpZiAoIWpzZ3VpLm1hcF9kYXRhX3R5cGVfZGF0YV9vYmplY3RfY29uc3RydWN0b3JzW2RhdGFfdHlwZV9uYW1lXSkge1xyXG5cclxuICAgICAgICAvLyBDYW4gd2UgZ2V0IGl0IGZyb20gdGhlIG1vc3QgdXAtdG8tZGF0ZSBtb2R1bGU/XHJcbiAgICAgICAgLy8gIE9yIGV2ZW4gbWFrZSB1c2Ugb2YgYSBnbG9iYWwgdmFyaWFibGU/XHJcbiAgICAgICAgLy8gIEpTR1VJP1xyXG5cclxuXHJcblxyXG5cclxuICAgICAgICB2YXIgZHRvID0ganNndWkuZGF0YV90eXBlc19pbmZvW2RhdGFfdHlwZV9uYW1lXTtcclxuICAgICAgICAvL2NvbnNvbGUubG9nKCdkdG8gJyArIHN0cmluZ2lmeShkdG8pKTtcclxuXHJcbiAgICAgICAgLy8gRG8gd2UgbmVlZCB0byBiZSBhY2Nlc3NpbmcgdGhlIGxhdGVzdCBkYXRhIGhlcmU/XHJcbiAgICAgICAgLy8gIENhbiB3ZSBwYXRjaCB0aGUgcmVxdWlyZWQgY29tcG9uZW50IGJhY2t3YXJkcz9cclxuXHJcblxyXG5cclxuICAgICAgICB2YXIgZHRjID0gRW5oYW5jZWRfRGF0YV9PYmplY3QuZXh0ZW5kKHtcclxuICAgICAgICAgICAgJ2ZpZWxkcyc6IGR0b1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAganNndWkubWFwX2RhdGFfdHlwZV9kYXRhX29iamVjdF9jb25zdHJ1Y3RvcnNbZGF0YV90eXBlX25hbWVdID0gZHRjO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGpzZ3VpLm1hcF9kYXRhX3R5cGVfZGF0YV9vYmplY3RfY29uc3RydWN0b3JzW2RhdGFfdHlwZV9uYW1lXTtcclxufVxyXG4vLyBNYXliZSB0aGUgRW5oYW5jZWRfRGF0YV9PYmplY3Qgd2lsbCBoYXZlIGFjY2VzcyB0byBDb2xsZWN0aW9uP1xyXG52YXIgZG9wID0gRGF0YV9PYmplY3QucHJvdG90eXBlO1xyXG52YXIgZG9faW5pdCA9IGRvcC5pbml0O1xyXG52YXIgZG9fZ2V0ID0gZG9wLmdldDtcclxuXHJcbi8vIEFuZCBtYWtpbmcgaXQgYSBjb2xsZWN0aW9uIHdpbGwgZ2l2ZSBpdCBnb29kIGVub3VnaCBpbmRleGluZyBhbnl3YXkuXHJcbnZhciBFbmhhbmNlZF9EYXRhX09iamVjdCA9IERhdGFfT2JqZWN0LmV4dGVuZCh7XHJcbiAgICAvLyBDYW4gd2UgZGVmaW5lIGEgQ29sbGVjdGlvbiBsaWtlIHRoYXQ/XHJcblxyXG4gICAgLy8gdGhlIGZsYWdzIGlzIGEgY29sbGVjdGlvbiBvZiBzdHJpbmdzLi4uIGJ1dCB3ZSB3YW50IHRvIGNvbm5lY3QgdGhlIGZsYWdzLlxyXG5cclxuICAgIC8vIEJ1dCB3ZSBjYW4gY2hvb3NlIHRoZSBjb250ZXh0IGZvciB0aGUgb2JqZWN0LlxyXG4gICAgLy8gIFdpbGwgbmVlZCB0byBkbyB0aGF0LlxyXG5cclxuICAgIC8vIEJ1dCBtYXliZSBvYmplY3QgY291bGQgb25seSBoYXZlIGZsYWdzIGlmIHRoZXkgYXJlIHVzZWQ/XHJcbiAgICAvLyAgRG9ybWFudCBmaWVsZHM/XHJcblxyXG4gICAgLy8gQ29sbGVjdGlvbihTdHJpbmcpIGJlaW5nIGluIHRoZSBnZW5lcmFsIGNvbnRleHQ/XHJcbiAgICAvLyAgSXQgY291bGQgYmUgYSBzcGVjaWFsIGNhc2UsIGZvciBhYnN0cmFjdCBjb2xsZWN0aW9ucy5cclxuICAgIC8vICBBbHNvLCBub3QgdXNpbmcgdGhlICduZXcnIGtleXdvcmQuXHJcblxyXG4gICAgJ2ZpZWxkcyc6IFtbJ2ZsYWdzJywgQ29sbGVjdGlvbihTdHJpbmcpXV0sXHJcblxyXG4gICAgLy8gQ29sbGVjdGlvbihTdHJpbmcpIG1heSBiZSBoYXJkIHRvIHVuZGVyc3RhbmQuLi4gQ29sbGVjdGlvbiBpcyBhIENsYXNzIGFuZCBpcyBub3JtYWxseSBjYWxsZWQgd2l0aCBhIGNvbnN0cnVjdG9yLlxyXG4gICAgLy8gIEl0IGhhcyBub3Qgbm9ybWFsbHkgYmVlbiBkZWNsYXJlZCB3aXRoIGEgbmF0aXZlIGRhdGEgdHlwZSBpbnNpZGUgKG9yIGFueSBkYXRhIHR5cGUpIGJ1dCBpdCBjb3VsZCBiZSBkb25lIGFuZCBpcyBjb252ZW5pZW50XHJcbiAgICAvLyAgIHN5bnRheC4gSSB0aGluayB3aXRob3V0IHRoZSBjb25zdHJ1Y3RvciwgYnV0IHdpdGggdGhlIG9iamVjdCBpbnNpZGUsIGl0IGNvdWxkIGJlIGFuIGFic3RyYWN0IG9yIHJlcHJlc2VudGF0aXZlIG9iamVjdCxcclxuICAgIC8vICAgYW5kIHVzZWQgc28gdGhhdCB3ZSBrbm93IENvbGxlY3Rpb24oU3RyaW5nKSBpcyBhIGNvbGxlY3Rpb24gb2Ygc3RyaW5ncyAocHJvYmFibHkgaW1wbGVtZW50ZWQgdXNpbmcgRGF0YV9WYWx1ZSBvYmplY3RzKS5cclxuXHJcbiAgICAvLyBzbyB3aWxsIHRoaXMgZmxhZ3MgZmllbGQgc3RhcnQgdXAgT0s/XHJcbiAgICAvLyAgdGhhdCBzaG91bGQgYmUgZW5vdWdoIHRvIGdldCB0aGUgZmxhZ3MgZmllbGQgdGhlcmUuXHJcblxyXG4gICAgLy8naW5pdCc6IGZ1bmN0aW9uKHNwZWMpIHtcclxuICAgIC8vXHR0aGlzLl9zdXBlcihzcGVjKTtcclxuICAgIC8vfSxcclxuXHJcbiAgICAvKlxyXG5cclxuICAgICdpbml0JzogZnVuY3Rpb24oc3BlYykge1xyXG4gICAgICAgIC8vdGhpcy5fc3VwZXIoc3BlYyk7XHJcbiAgICAgICAgZG9faW5pdC5jYWxsKHRoaXMsIHNwZWMpO1xyXG4gICAgICAgIC8vIG5lZWQgdG8gcmVzcG9uZCB0byBmbGFnIGZpZWxkcyBiZWluZyBhZGRlZCBhbmQgcmVtb3ZlZC5cclxuICAgICAgICAvLyAgd2hlbiBhIGZsYWcgZ2V0cyBhZGRlZCwgdGhlcmUgbmVlZHMgdG8gYmUgdGhlIGZsYWcncyBjb25uZWN0ZWQgZnVuY3Rpb24uXHJcblxyXG4gICAgICAgIC8vLmZsYWdzKCkuc2VsZWN0ZWQ/XHJcbiAgICAgICAgLy8uZmxhZ3MoJ3NlbGVjdGVkJyk7XHJcblxyXG4gICAgICAgIC8vIC5zZWxlY3RlZCh0cnVlKTsgLnNlbGVjdGVkKDEpO1xyXG5cclxuICAgICAgICAvLyBjYW4gbGVhdmUgdGhlIGZsYWdzIHVuY29ubmVjdGVkIGZvciB0aGUgbW9tZW50LCBhbmQgcmV0dXJuIHRvIHRoZSBmbGFncyBjb25uZWN0aW9uIHNvIHRoZXJlIGlzXHJcbiAgICAgICAgLy8gIGVhc2llciBzeW50YXggYW5kIHByb2JhYmx5IGZhc3RlciBjb2RlLlxyXG5cclxuICAgICAgICAvLyBidXQgd2FudCBpdCBzbyB3ZSBrbm93IHdoZW4gZmxhZ3MgaGF2ZSBjaGFuZ2VkICh0aGUgY29sbGVjdGlvbiBvZiBmbGFncyk/XHJcblxyXG4gICAgICAgIC8vIGFsc28gd2hlbiBhbnkgZmxhZ3MnIHZhbHVlIGhhcyBjaGFuZ2VkLlxyXG5cclxuICAgICAgICAvLyBjYW4gcXVpdGUgc2ltcGx5IGFkZCBhbmQgcmVtb3ZlIGZsYWdzIGZyb20gYW4gb2JqZWN0LlxyXG4gICAgICAgIC8vICBhbHNvIG1heSBwYXkgc29tZSBhdHRlbnRpb24gdG8gYSByZXN0cmljdGVkIGxpc3Qgb2YgZmxhZ3MsIHdoZXJlIGlmIHRoZSBmbGFncyBhcmUgbm90IHNldCB0aGVuIHdlIGtub3dcclxuICAgICAgICAvLyAgdGhlIHZhbHVlcyBhcmUgZmFsc2UuXHJcblxyXG4gICAgICAgIC8vIHdhbnQgdG8gbWFrZSBpdCBlYXN5IHRvIGRlYWwgd2l0aCBmbGFncyB0aGF0IGNvcnJlc3BvbmQgdG8gY3NzIGFzIHdlbGwuXHJcblxyXG4gICAgfSxcclxuICAgICovXHJcbiAgICAvLyBvciBhbiBlbmhhbmNlZCB2ZXJzaW9uIG9mIHRoZSBzZXQgZnVuY3Rpb24gdGhhdCBkZWFscyB3aXRoIG1vcmUgaW5wdXQgcHJvY2Vzc29ycz9cclxuICAgIC8vICBPciBoYXZlIHRoZSBzdXBlcmNhbHNzZWQgc2V0IGZ1bmN0aW9uIHNlbmQgbWFjayB0aGUgaW5wdXQgcHJvY2Vzc29ycyBpbiBwYXJhbWV0ZXJzLlxyXG4gICAgLy8gICBJIHRoaW5rIHRoYXQgaXMgdGhlIGJlc3Qgb3B0aW9uLlxyXG5cclxuICAgICdfZ2V0X2lucHV0X3Byb2Nlc3NvcnMnOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAvL3Rocm93ICdzdG9wJztcclxuICAgICAgICByZXR1cm4ganNndWkuaW5wdXRfcHJvY2Vzc29ycztcclxuICAgIH0sXHJcbiAgICAnYWRkX2ZsYWcnOiBmdW5jdGlvbihmbGFnX25hbWUpIHtcclxuICAgICAgICB2YXIgZmxhZ3MgPSB0aGlzLmdldCgnZmxhZ3MnKTtcclxuICAgICAgICAvL2NvbnNvbGUubG9nKCdmbGFncyAnICsgc3RyaW5naWZ5KGZsYWdzKSk7XHJcbiAgICAgICAgdmFyIGZpZWxkcyA9IHRoaXMuZmllbGRzKCk7XHJcbiAgICAgICAgLy9jb25zb2xlLmxvZygnZmllbGRzICcgKyBzdHJpbmdpZnkoZmllbGRzKSk7XHJcbiAgICAgICAgLy8gdW5mb3J0dW5hdGUgdGhhdCBubyBmaWVsZHMgYXJlIGZvdW5kPz8/XHJcbiAgICAgICAgLy8gIHNob3VsZCBwcm9iYWJseSBiZSBhIGZldy5cclxuICAgICAgICBpZiAoIWZsYWdzLmhhcyhmbGFnX25hbWUpKSB7XHJcbiAgICAgICAgICAgIGZsYWdzLmFkZChmbGFnX25hbWUpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICAncmVtb3ZlX2ZsYWcnOiBmdW5jdGlvbihmbGFnX25hbWUpIHtcclxuICAgICAgICB2YXIgZmxhZ3MgPSB0aGlzLmdldCgnZmxhZ3MnKTtcclxuICAgICAgICAvL2NvbnNvbGUubG9nKCdmbGFncyAnICsgc3RyaW5naWZ5KGZsYWdzKSk7XHJcbiAgICAgICAgLy90aHJvdyAnc3RvcCc7XHJcbiAgICAgICAgdmFyIGhhc19mbGFnID0gZmxhZ3MuaGFzKGZsYWdfbmFtZSk7XHJcbiAgICAgICAgLy9jb25zb2xlLmxvZygnaGFzX2ZsYWcgJyArIGhhc19mbGFnKTtcclxuXHJcbiAgICAgICAgaWYgKGhhc19mbGFnKSB7XHJcbiAgICAgICAgICAgIGZsYWdzLnJlbW92ZShmbGFnX25hbWUpO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnZmxhZ3MgJyArIHN0cmluZ2lmeShmbGFncykpO1xyXG5cclxuICAgICAgICAgICAgZmxhZ3MgPSB0aGlzLmdldCgnZmxhZ3MnKTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ2ZsYWdzICcgKyBzdHJpbmdpZnkoZmxhZ3MpKTtcclxuICAgICAgICAgICAgLy90aHJvdyAnc3RvcCc7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcbiAgICAnaGFzX2ZsYWcnOiBmdW5jdGlvbihmbGFnX25hbWUpIHtcclxuICAgICAgICB2YXIgZmxhZ3MgPSB0aGlzLmdldCgnZmxhZ3MnKTtcclxuICAgICAgICByZXR1cm4gZmxhZ3MuaGFzKGZsYWdfbmFtZSk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vIGNvcGllZCBmcm9tIERhdGFfT2JqZWN0IGJlY2F1c2UgRGF0YV9PYmplY3Qgd2FzIG5vdCBhYmxlIHRvIGRlYWwgd2l0aCBjb2xsZWN0aW9ucyB3aXRoaW4gaXRzZWxmLlxyXG4gICAgLy8gIGNvZGUgd29ya3MsIGJ1dCBzaG91bGQgbWFrZSB0aGlzIGNhbGwgZGF0YV9vYmplY3QgY29kZSB3aGVyZSBwb3NzaWJsZS5cclxuXHJcbiAgICAvLyBDYW5kaWRhdGUgZm9yIG9wdGltaXphdGlvblxyXG5cclxuICAgIC8vJ2dldCc6IGZwKGZ1bmN0aW9uKGEsIHNpZykge1xyXG4gICAgJ2dldCc6IChmdW5jdGlvbigpIHtcclxuICAgICAgdmFyIGEgPSBhcmd1bWVudHM7XHJcbiAgICAgIGEubCA9IGFyZ3VtZW50cy5sZW5ndGg7XHJcbiAgICAgIHZhciBzaWcgPSBnZXRfYV9zaWcoYXJndW1lbnRzLCAxKTtcclxuXHJcbiAgICAgICAgLy8gTW9yZSBkaWZmaWN1bHQgdG8gbWFpbnRhaW4gd2l0aCB0aGUgc2VwYXJhdGUgZ2V0IGNvZGUuXHJcbiAgICAgICAgLy8gIEhhbmRsZSBzcGVjaWZpYyBjYXNlcyBoZXJlLCBvdGhlcndpc2UgdXNlIF9zdXBlci5cclxuXHJcbiAgICAgICAgLy8gSW4gc29tZSBjYXNlcywgYW4gYXV0b21hdGljYWxseSBjb25zdHJ1Y3RlZCBvYmplY3QsIGxpa2UgYSBjb250cm9sX2RvbSwgc2hvdWxkIGhhdmUgZmllbGRzLlxyXG5cclxuICAgICAgICAvLyBidXQgd2hlbiBuZXN0ZWQgaXMgaW4gcGxhY2UsIGlzIGl0IHN0aWxsIHdvcmtpbmcgcmlnaHQ/XHJcbiAgICAgICAgLy8gYWxzbyB3aWxsIGhhdmUgdG8gZGVhbCB3aXRoIHBhcnRpY3VsYXIgb3V0cHV0IGZvcm1hdHMuXHJcbiAgICAgICAgLy8gIG1hbnkgY29udHJvbHMgLyBkYXRhIHR5cGVzIGZvciB0aGUgbW9tZW50IHdpbGwgaGF2ZSBkZWZhdWx0IG91dHB1dCBhcyBIVE1MIGZvcm1hdHRlZC5cclxuICAgICAgICAvL2NvbnNvbGUubG9nKCdEYXRhX09iamVjdCBnZXQgdGhpcy5fX2RhdGFfdHlwZV9uYW1lICcgKyB0aGlzLl9fZGF0YV90eXBlX25hbWUpO1xyXG4gICAgICAgIC8vY29uc29sZS5sb2coJ0VuaGFuY2VkX0RhdGFfT2JqZWN0IGdldCBhICcgKyBzdHJpbmdpZnkoYSkpO1xyXG4gICAgICAgIC8vY29uc29sZS5sb2coJ0VuaGFuY2VkX0RhdGFfT2JqZWN0IGdldCBzaWcgJyArIHNpZyk7XHJcbiAgICAgICAgLy8gd2lsbCBhbHNvIGJlIGxvb2tpbmcgYXQgdGhlIG91dHB1dCBwcm9jZXNzb3JzLlxyXG4gICAgICAgIC8vY29uc29sZS5sb2coJ3RoaXMuX19kYXRhX3R5cGVfbmFtZSAnICsgdGhpcy5fX2RhdGFfdHlwZV9uYW1lKTtcclxuICAgICAgICAvL2lmIChpc19kZWZpbmVkKHRoaXMuX19kYXRhX3R5cGVfbmFtZSkpIHtcclxuICAgICAgICBpZiAodHlwZW9mIHRoaXMuX19kYXRhX3R5cGVfbmFtZSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIHNob3VsZCBwb3NzaWJseSBoYXZlIHRoaXMgYXNzaWduZWQgZm9yIGNvbnRyb2xzLi4uXHJcbiAgICAgICAgICAgIC8vdmFyIHJhd19pbnB1dCA9IGE7XHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3RoaXMuX19kYXRhX3R5cGVfbmFtZSBpcyBkZWZpbmVkOiAnICsgdGhpcy5fX2RhdGFfdHlwZV9uYW1lKTtcclxuXHJcbiAgICAgICAgICAgIC8vdmFyIHBhcnNlZF9pbnB1dF9vYmogPSBqc2d1aS5pbnB1dF9wcm9jZXNzb3JzW3RoaXMuX19kYXRhX3R5cGVfbmFtZV0ocmF3X2lucHV0KTtcclxuICAgICAgICAgICAgLy90aGlzLl9zdXBlci5hcHBseSh0aGlzLCBhKTtcclxuICAgICAgICAgICAgZG9fZ2V0LmFwcGx5KHRoaXMsIGEpO1xyXG5cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBjaGVjayB0byBzZWUgaWYgdGhlcmUgaXMgYSBmaWVsZCBkZWZpbmVkLlxyXG4gICAgICAgICAgICBpZiAoc2lnID09PSAnW3NdJykge1xyXG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnZ2V0IHBhcmFtOiAnICsgYVswXSk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmZjKSB0aGlzLmZjID0gbmV3IEZpZWxkc19Db2xsZWN0aW9uKHtcclxuICAgICAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgICAgIC8vJ2NvbnRhaW5pbmdfb2JqZWN0JzogdGhpc1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGZjID0gdGhpcy5mYztcclxuXHJcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdmYyAnICsgKGZjKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnZmMuZ2V0KCkgJyArIHN0cmluZ2lmeShmYy5nZXQoKSkpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGZpZWxkX25hbWUgPSBhWzBdO1xyXG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnZmllbGRfbmFtZSAnICsgZmllbGRfbmFtZSk7XHJcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCd0aGlzLmZpZWxkcygpICcgKyBzdHJpbmdpZnkodGhpcy5maWVsZHMoKSkpO1xyXG4gICAgICAgICAgICAgICAgLy8gY291bGQgaGF2ZSAucyBpbiBpdCwgbWFraW5nIGl0IG5lc3RlZCwgYW5kIGhhdmUgcmVtb3ZlZCBuZXN0ZWQgZnJvbSBoZXJlLlxyXG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygncHJlIGZjIGdldCcpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGZpZWxkID0gZmMuZ2V0KGZpZWxkX25hbWUpO1xyXG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnRURPIGZpZWxkICcgKyBzdHJpbmdpZnkoZmllbGQpKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoZmllbGRfbmFtZS5pbmRleE9mKCcuJykgPiAtMSkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdFRE8gZ2V0IGhhcyBmaWVsZCAnICsgZmllbGRfbmFtZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZW4gd2UgYXJlIGRlYWxpbmcgd2l0aCBhIHJlcXVlc3QgZm9yIGEgbmVzdGVkIG9iamVjdC5cclxuICAgICAgICAgICAgICAgICAgICAvLyBTcGxpdCB1cCB0aGUgZmllbGRfbmFtZSBpbnRvIHRoZSB2YXJpb3VzIGZpZWxkIG5hbWVzIGZvciB0aGUgbGV2ZWxzLCB0aGVuIGhhdmUgYSByZWN1cnNpdmUgZnVuY3Rpb24gaGVyZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vICBwcm9jZXNzIHRocm91Z2ggdGhlIGxldmVscy4gV2lsbCBrZWVwIHRoZSByZWN1cnNpdmUgcGFydCBzbWFsbCBpbiBzaXplIGFuZCBsb2NhdGVkIGhlcmUuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTWF5IG5vdCBuZWVkIHRvIGV2ZW4gYmUgcmVjdXJzaXZlLlxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhcnJfZmllbGRfbmFtZXMgPSBmaWVsZF9uYW1lLnNwbGl0KCcuJyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBsZXZlbCA9IDAsIGwgPSBhcnJfZmllbGRfbmFtZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjdXJyZW50X29iaiA9IHRoaXMsIG5ld19vYmosIGZuYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChsZXZlbCA8IGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm5hbWUgPSBhcnJfZmllbGRfbmFtZXNbbGV2ZWxdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdfb2JqID0gY3VycmVudF9vYmouZ2V0KGZuYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnZm5hbWUgJyArIGZuYW1lKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNvLCB3aGVuIHRoZSBkb20gb2JqZWN0IGlzIG9idGFpbmVkLCBpdCBzaG91bGQgaGF2ZSBpdHMgb3duIGZpZWxkcy5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gIFRoZSAnZ2V0JyBmdW5jdGlvbiB3aWxsIG5lZWQgdG8gYmUgbW9kaWZpZWQgdG8gcmV0dXJuIG9iamVjdHMgb2YgdGhlIHJpZ2h0IHR5cGUgLyBjbGFzcy5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ25ld19vYmogJyArIHN0cmluZ2lmeShuZXdfb2JqKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2N1cnJlbnRfb2JqICcgKyBzdHJpbmdpZnkoY3VycmVudF9vYmopKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldmVsKys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRfb2JqID0gbmV3X29iajtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRfb2JqO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2ZpZWxkICcgKyBzdHJpbmdpZnkoZmllbGQpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBmaWVsZHMgc2VlbSB0byBzdG9wIGhhdmluZyBiZWVuIHNldCB1cCBwcm9wZXJseS5cclxuXHJcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdmaWVsZCAnICsgKGZpZWxkKSk7XHJcblxyXG5cclxuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJyogZmllbGRfbmFtZSAnICsgZmllbGRfbmFtZSk7XHJcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCcqIGZpZWxkICcgKyBzdHJpbmdpZnkoZmllbGQpKTtcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGZpZWxkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTWF5IG5vdCBiZSBhYmxlIHRvIHN0cmluZ2lmeSB0aGUgZmllbGQgb2JqZWN0IHdpdGhvdXQgbWFraW5nIGFuIGluZmluaXRlIGxvb3AgLyBjYWxsIHN0YWNrIGVycm9yLlxyXG4gICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3RoaXMuX1tmaWVsZF9uYW1lXSAnICsgc3RyaW5naWZ5KHRoaXMuX1tmaWVsZF9uYW1lXSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2ZpZWxkX25hbWUgJyArIGZpZWxkX25hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFNvIHRoZSBET00gYXR0cmlidXRlcyB3ZXJlIG5vdCBjcmVhdGVkIHByb3Blcmx5LlxyXG5cclxuXHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX1tmaWVsZF9uYW1lXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdkb2VzIG5vdCBoYXZlIGZpZWxkIGFscmVhZHknKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzaWdfZmllbGQgPSBnZXRfaXRlbV9zaWcoZmllbGQsIDIwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJy0tLS0tLS0tLS0tLS0tLScpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCcnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnZW5oYW5jZWQgZGF0YV9vYmplY3Qgc2lnX2ZpZWxkICcgKyBzdHJpbmdpZnkoc2lnX2ZpZWxkKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2ZpZWxkICcgKyBzdHJpbmdpZnkoZmllbGQpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3NpZ19maWVsZCAnICsgc2lnX2ZpZWxkKTtcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2lnX2ZpZWxkID09ICdbcyxbcyx1XV0nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpdCBsb29rcyBsaWtlIGl0IGhhcyBnb25lIHdyb25nLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0YWNrID0gbmV3IEVycm9yKCkuc3RhY2s7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhzdGFjayk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNzP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzLHMsYlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgdGhlIGxhc3QgcGFyYW0gaXMgdGhlIGRlZmF1bHQgdmFsdWU/Pz9cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICBub3QgcmlnaHQgbm93LlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNpZ19maWVsZCA9PSAnW3MscyxvXScpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmaWVsZF9uYW1lID0gZmllbGRbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmllbGRfdHlwZV9uYW1lID0gZmllbGRbMV07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGVmYXVsdF92YWx1ZT9cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmllbGRfaW5mbyA9IGZpZWxkWzJdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2ZpZWxkX3R5cGVfbmFtZSAnICsgZmllbGRfdHlwZV9uYW1lKTtcclxuXHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaWVsZF90eXBlX25hbWUgPT0gJ2NvbGxlY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnbGF6eSBsb2FkaW5nIC0gY3JlYXRpbmcgbmV3IGNvbGxlY3Rpb24nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9bZmllbGRfbmFtZV0gPSBuZXcganNndWkuQ29sbGVjdGlvbih7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdjb250ZXh0JzogdGhpcy5fY29udGV4dFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9bZmllbGRfbmFtZV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIGl0J3MganVzdCBhIHN0cmluZz9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmllbGRfdHlwZV9uYW1lID09ICdvcmRlcmVkX3N0cmluZ19saXN0Jykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3NsID0gbmV3IE9yZGVyZWRfU3RyaW5nX0xpc3QoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX1tmaWVsZF9uYW1lXSA9IG9zbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9yZXR1cm4gdGhpcy5fW2ZpZWxkX25hbWVdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZmllbGRfdHlwZV9uYW1lID09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVzZSBhIERhdGFfVmFsdWU/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERhdGEgdmFsdWUgd2l0aCBubyBjb250ZXh0P1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy92YXIgZHYgPSBuZXcgRGF0YV9WYWx1ZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLydjb250ZXh0JzogdGhpcy5fY29udGV4dFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL30pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUZWxsIHRoZSBEYXRhX1ZhbHVlIGl0J3MgYSBzdHJpbmcgb25seT9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29udGV4dD9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGR2ID0gbmV3IERhdGFfVmFsdWUoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2NvbnRleHQnOiB0aGlzLl9jb250ZXh0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpZWxkX2luZm8uZGVmYXVsdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHYuc2V0KGZpZWxkX2luZm8uZGVmYXVsdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR2LnBhcmVudCh0aGlzKTtcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2R2LnNldCgpXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fW2ZpZWxkX25hbWVdID0gZHY7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3JldHVybiB0aGlzLl9bZmllbGRfbmFtZV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2ZpZWxkX3R5cGVfbmFtZSAnICsgZmllbGRfdHlwZV9uYW1lKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZWZhdWx0X3ZhbHVlID0gZmllbGRfaW5mby5kZWZhdWx0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCcnKVxyXG5cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3ZhciBkdG9jID0gdGhpcy5tb2RfbGluaygpLmVuc3VyZV9kYXRhX3R5cGVfZGF0YV9vYmplY3RfY29uc3RydWN0b3IoZmllbGRfdHlwZV9uYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGR0b2MgPSBlbnN1cmVfZGF0YV90eXBlX2RhdGFfb2JqZWN0X2NvbnN0cnVjdG9yKGZpZWxkX3R5cGVfbmFtZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29udGV4dCA9IHRoaXMuY29udGV4dDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRleHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmaWVsZF92YWwgPSBuZXcgZHRvYyh7J2NvbnRleHQnOiB0aGlzLl9jb250ZXh0fSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmllbGRfdmFsID0gbmV3IGR0b2MoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNfZGVmaW5lZChkZWZhdWx0X3ZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmllbGRfdmFsLnNldChkZWZhdWx0X3ZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy90aHJvdyAnc3RvcCc7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWVsZF92YWwucGFyZW50KHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9bZmllbGRfbmFtZV0gPSBmaWVsZF92YWw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9bZmllbGRfbmFtZV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzaWdfZmllbGQgPT0gJ1tzLHNdJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnISEhISEnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2ZpZWxkICcgKyBzdHJpbmdpZnkoZmllbGQpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmaWVsZF9uYW1lID0gZmllbGRbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmllbGRfdHlwZV9uYW1lID0gZmllbGRbMV07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnZmllbGRfbmFtZSAnICsgZmllbGRfbmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdmaWVsZF90eXBlX25hbWUgJyArIGZpZWxkX3R5cGVfbmFtZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcGVyaGFwcyBnZXR0aW5nIGNvbGxlY3Rpb24gZmllbGRzIHNob3VsZCBiZSBtb3ZlZCB0byBlbmhhbmNlZF9kYXRhX29iamVjdD9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICBub3Qga2VlbiBvbiBpbnRlcmRlcGVuZGVuY2llcyBoZXJlLlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaWVsZF90eXBlX25hbWUgPT09ICdjb2xsZWN0aW9uJykge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBsYXp5IGNyZWF0aW9uIG9mIGZpZWxkcy5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy90aHJvdyAnbm90IHN1cHBvcnRlZCBoZXJlLiBzaG91bGQgdXNlIGNvZGUgaW4gZW5oYW5jZWQtZGF0YS1vYmplY3QuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNvLCBDb2xsZWN0aW9uIGhhcyBiZWVuIGFkZGVkIHRvIGpzZ3VpIGJ5IG5vdy5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdwcmUgbWFrZSBjb2xsJyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1heWJlIENvbGxlY3Rpb24gaGFzIG5vdCBiZWVuIGFkZGVkIHRvIGpzZ3VpLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICBOZWVkIHRvIGVuc3VyZSBpdCBkb2VzIGdldCBhZGRlZCB3aGVuIGl0J3MgZ2V0dGluZyB1c2VkLlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzZWVtcyBsaWtlIHRoZSBDb2xsZWN0aW9uIG9iamVjdCBkb2VzIG5vdCBnZXQgcHV0IGJhY2sgb24gdGhpcy4uLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICBvciBhdCBsZWFzdCBub3QgYWx3YXlzLlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBsb29rcyBsaWtlIHdlIHVzZSB0aGUgbW9kdWxlIGFzIGl0IGlzLlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29sbCA9IG5ldyBqc2d1aS5Db2xsZWN0aW9uKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2NvbnRleHQnOiB0aGlzLl9jb250ZXh0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3ByZSBzZXQgY29sbCBwYXJlbnQnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xsLnBhcmVudCh0aGlzKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fW2ZpZWxkX25hbWVdID0gY29sbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fW2ZpZWxkX25hbWVdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZmllbGRfdHlwZV9uYW1lID09PSAnY29udHJvbCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3YW50IHRvIHB1dCB0aGUgY29udHJvbCBpbiBwbGFjZSBiYXNpY2FsbHkuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gIGJ1dCBpdCB0aGUgY29udHJvbCBpcyBub3QgdGhlcmUsIHdlIGNhbid0IGdldCBpdC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBubyBsYXp5IGxvYWRpbmcgb2YgY29udHJvbHMgbGlrZSBmb3Igb3RoZXIgZGF0YSBpdGVtcy5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGZpZWxkX3R5cGVfbmFtZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZHYgPSBuZXcgRGF0YV9WYWx1ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR2LnBhcmVudCh0aGlzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9bZmllbGRfbmFtZV0gPSBkdjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGEgZGlmZmVyZW50IGZ1bmN0aW9uP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICB3ZSBjb3VsZCBsb29rIGZvciB0aGUgaW5wdXQgcHJvY2Vzc29ycz9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGVuIHVzZSB0aGUgaW5wdXQgcHJvY2Vzc29yIHRvIGNyZWF0ZSBhIERhdGEgT2JqZWN0IG9yIERhdGEgVmFsdWUuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlucHV0X3Byb2Nlc3NvcnM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGFfdHlwZV9pbmZvO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtb2R1bGVfanNndWkgPSB0aGlzLl9tb2R1bGVfanNndWk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnbW9kdWxlX2pzZ3VpICcgKyBtb2R1bGVfanNndWkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOZWVkIGEgd2F5IHRvIGdldCBiYWNrIHRvIHRoZSBjb21tb24ganNndWkgbW9kdWxlLlxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1vZHVsZV9qc2d1aSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dF9wcm9jZXNzb3JzID0gbW9kdWxlX2pzZ3VpLmlucHV0X3Byb2Nlc3NvcnM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFfdHlwZXNfaW5mbyA9IG1vZHVsZV9qc2d1aS5kYXRhX3R5cGVzX2luZm87XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdkYXRhX3R5cGVzX2luZm8gJyArIHN0cmluZ2lmeShkYXRhX3R5cGVzX2luZm8pKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNvIHdlIG1heSBoYXZlIHRoZSBpbmZvcm1hdGlvbiBuZWVkZWQgdG8gY29uc3RydWN0IHN1Y2ggYSBEYXRhX09iamVjdC5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgbmVlZHMgdG8gYmUgc2V0IGluIHZhcmlvdXMgb2JqZWN0cy5cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTaG91ZGwgbWFrZSBiZSBjYXJlZnVsIHRvIGVuc3VyZSB0aGVzZSBleGlzdC4uLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgTmVlZCB0aGUgY29uc3RydWN0b3IgZm9yIHRoZSBjb250cm9sX2RvbSBvYmplY3QuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBQZXJoYXBzIGRvaW5nIGEgc3ViLXByb2plY3Qgb24gdGhlIGRhdGEgc3lzdGVtIGlzIHdvcnRoIGl0P1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgT3IgZG8gdGhhdCBvbmNlIHRoZSBiYXNpcyBpcyB3b3JraW5nIGZvciBIVE1MIHNlcnZpbmc/XHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYnV0IHdpbGwgd2UgaGF2ZSBkYXRhIG9iamVjdCBjb25zdHJ1Y3RvcnMgZm9yIHRoaXMgeWV0P1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmplY3RfY29uc3RydWN0b3IgPSBtb2R1bGVfanNndWkubWFwX2RhdGFfdHlwZV9kYXRhX29iamVjdF9jb25zdHJ1Y3RvcnNbZmllbGRfdHlwZV9uYW1lXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ29iamVjdF9jb25zdHJ1Y3RvciAnICsgc3RyaW5naWZ5KG9iamVjdF9jb25zdHJ1Y3RvcikpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZW5zdXJlX2RhdGFfdHlwZV9kYXRhX29iamVjdF9jb25zdHJ1Y3RvclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgdGhhdCBpcyB1c2VkIHdoZXJlIHdlIGhhdmUgdGhlIGRhdGEgdHlwZSBkZWZpbml0aW9uIGZvciB0aGF0IGRhdGEgdHlwZS5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuZCBsb29rIGF0IHRoZSBkYXRhIHR5cGVzIG9iamVjdCBjb25zdHJ1Y3RvcnM/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICBvciBkYXRhIHR5cGVzIGNvbnN0cnVjdG9zLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob2JqZWN0X2NvbnN0cnVjdG9yKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9iaiA9IG5ldyBvYmplY3RfY29uc3RydWN0b3Ioeydjb250ZXh0JzogdGhpcy5fY29udGV4dH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqLnBhcmVudCh0aGlzKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9bZmllbGRfbmFtZV0gPSBvYmo7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2JqO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy90aHJvdyAnc3RvcCc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3RoaXMuXyAnICsgc3RyaW5naWZ5KHRoaXMuXykpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9bZmllbGRfbmFtZV07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNpZ19maWVsZCA9PT0gJ1tzLFtzLHNdXScpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmaWVsZF9uYW1lID0gZmllbGRbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmllbGRfaW5mbyA9IGZpZWxkWzFdO1xyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdmaWVsZF9pbmZvICcgKyBzdHJpbmdpZnkoZmllbGRfaW5mbykpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaWVsZF9pbmZvWzBdID09PSAnY29sbGVjdGlvbicpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29sbGVjdGlvbl90eXBlX25hbWUgPSBmaWVsZF9pbmZvWzFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuY29sbCA9IG5ldyBqc2d1aS5Db2xsZWN0aW9uKHsnY29udGV4dCc6IHRoaXMuX2NvbnRleHR9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuY29sbC5wYXJlbnQodGhpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fW2ZpZWxkX25hbWVdID0gbmNvbGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX1tmaWVsZF9uYW1lXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzaWdfZmllbGQgPT09ICdbcyxbcyxvXV0nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBbZmllbGROYW1lLFsnY29sbGVjdGlvbicsIG9iakRlZl1dXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZWcgZmllbGQgW1wiZW50cmllc1wiLCBbXCJjb2xsZWN0aW9uXCIsIHtcImFkZHJlc3NcIjogXCJzdHJpbmdcIiwgXCJmYW1pbHlcIjogXCJzdHJpbmdcIiwgXCJpbnRlcm5hbFwiOiBcImJvb2xlYW5cIn1dXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXQncyBhIGNvbGxlY3Rpb24/PyAoY2hlY2ssIHdpdGggdGhlIHBhcnRpY3VsYXIgZGF0YSB0eXBlKVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmaWVsZF9uYW1lID0gZmllbGRbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmllbGRfaW5mbyA9IGZpZWxkWzFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGFfdHlwZV9uYW1lID0gZmllbGRfaW5mb1swXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YV90eXBlX25hbWUgPT09ICdjb2xsZWN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvYmpEZWYgPSBmaWVsZF9pbmZvWzFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdGhyb3cgJ25vdCBzdXBwb3J0ZWQgaGVyZS4gc2hvdWxkIHVzZSBjb2RlIGluIGVuaGFuY2VkLWRhdGEtb2JqZWN0Lic7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5lZWQgdG8gZG8gbW9yZSB0aGFuIHRoaXMuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gIERlZmluaW5nIGEgY29sbGVjdGlvbiB3aXRoIGEgc3BlY2lmaWVkIGRhdGEgdHlwZS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmNvbGwgPSBuZXcganNndWkuQ29sbGVjdGlvbih7J2NvbnRleHQnOiB0aGlzLl9jb250ZXh0fSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3BlY2lmeWluZyBhIGNvbGxlY3Rpb24gY29uc3RyYWludCBhcyB3ZWxsIChwZXJoYXBzIHRoZXNlIGFyZSBmaWVsZHMgZm9yIHRoZSBvYmVqY3RzKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICBJIHRoaW5rIGNhbGxpbmcgaXQgYSBjb2xsZWN0aW9uIGNvbnN0cmFpbnQgd2l0aCBzcGVjaWZpZWQgZmllbGRzIGZvciB0aGUgb2JqZWN0cyBtYWtlc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICBzZW5zZS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdvYmpEZWYgJyArIHN0cmluZ2lmeShvYmpEZWYpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3aWxsIGJlIGFuIG9iamVjdCByYXRoZXIgdGhhbiBhcnJheSAoZm9yIG5vdyBhdCBsZWFzdClcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm90IHN1cmUgYWJvdXQgc2V0dGluZyB0aHJvdWdoIGZpZWxkcy4uLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5jb2xsLmZpZWxkcyhvYmpEZWYpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoYXQgc2hvdWxkIHNldCB0aGUgY29uc3RyYWludCBhcyB3ZWxsLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vbmNvbGwuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNwZWNpZnlpbmcgZmllbGRzIG9uIGEgY29sbGVjdGlvbi5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgTmVlZCB0byBzYXkgaXRlbUZpZWxkcywgYXMgYSBjb2xsZWN0aW9uIGl0c2VsZiBjb3VsZCBoYXZlIGZpZWxkcyBhcyB3ZWxsIGFzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICBpdGVtcyBjb250YWluZWQ/IE9yIHRoZSBjb2xsZWN0aW9uJ3MgZmllbGRzIGFwcGx5IHRvIGVhY2ggaXRlbS5cclxuXHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3ZhciBuY29sbCA9IG5ldyBqc2d1aS5Db2xsZWN0aW9uKGNvbGxlY3Rpb25fdHlwZV9uYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fY29udGV4dCkgbmNvbGwuX2NvbnRleHQgPSB0aGlzLl9jb250ZXh0O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuY29sbC5wYXJlbnQodGhpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fW2ZpZWxkX25hbWVdID0gbmNvbGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX1tmaWVsZF9uYW1lXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX1tmaWVsZF9uYW1lXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3RoaXMuXyAnICsgc3RyaW5naWZ5KHRoaXMuXykpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzID0gbGxfZ2V0KHRoaXMuXywgYVswXSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghcmVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaWVsZF9uYW1lLmluZGV4T2YoJy4nKSA+IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyAnbm90IHlldCBoYW5kbGVkJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcyA9IHRoaXNbYVswXV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3JlcyAnICsgcmVzKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9pZiAoIWlzX2RlZmluZWQocmVzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBObywgZG9uJ3QgdGhpbiB3ZSBqdXN0IGNyZWF0ZSBhIG5ldyBvbmUuIEl0IG1heSBuZWVkIHRvIGdldCBvdmVyd3JpdHRlbiBieSBzb21lIG90aGVyIGNvZGUuXHJcblxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vcmVzID0gbmV3IEVuaGFuY2VkX0RhdGFfT2JqZWN0KHsnY29udGV4dCc6IHRoaXMuX2NvbnRleHR9KTtcclxuICAgICAgICAgICAgICAgICAgICAvL31cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygncHJvcGVydHlfbmFtZSAnICsgcHJvcGVydHlfbmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygncmVzICcgKyByZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYS5sID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSlcclxuXHJcblxyXG59KTtcclxuXHJcbi8vIERhdGFfT2JqZWN0LmV4dGVuZCA9IGZ1bmN0aW9uKHByb3AsIG5hbWVzcGNFeHRlbnNpb24sIHByb3BzVG9NZXJnZSkge1xyXG5cclxuRW5oYW5jZWRfRGF0YV9PYmplY3QuZXh0ZW5kID0gZnVuY3Rpb24ocHJvcCwgbmFtZXNwY0V4dGVuc2lvbiwgcHJvcHNUb01lcmdlKSB7XHJcbiAgICAvL3ZhciByZXMgPSBEYXRhX09iamVjdC5leHRlbmQocHJvcCwgbmFtZXNwY0V4dGVuc2lvbiwgcHJvcHNUb01lcmdlKTtcclxuICAgIHZhciByZXMgPSBEYXRhX09iamVjdC5leHRlbmQuY2FsbCh0aGlzLCBwcm9wLCBuYW1lc3BjRXh0ZW5zaW9uLCBwcm9wc1RvTWVyZ2UpO1xyXG4gICAgLy8gYnV0IHRoZSBmaWVsZHMgYXJlIG5vdCBnb2luZyBpbiBwcm9wZXJseS4/Pz9cclxuICAgIC8vIHF1aXRlIHBvc3NpYmx5IG5lZWQgdG8gc2V0IHVwIHRoZSBmaWVsZHMgKF9maWVsZHMgb24gdGhlIEVuaGFuY2VkX0RhdGFfT2JqZWN0IG9iamVjdC5cclxuICAgIC8vIGJ1dCBuZWVkIHRvIG1lcmdlIHRoZSBwcm9wZXJ0aWVzIGZyb20gdGhpcy4uLlxyXG4gICAgLy8gYnV0IGFsc28gbmVlZCB0byBsb29rIG91dCBmb3IgdGhlIGZsYWdzLlxyXG4gICAgLy8gaWYgaW4gdGhlIHByb3Agb3IgbWFwX3Byb3BzIHRoZXJlIGlzIHNvbWV0aGluZyBjYWxsZWQgJ2ZsYWdzJyB3ZSBuZWVkIHRvIHBheSBhdHRlbnRpb24uXHJcbiAgICAvLyAgVGhhdCB3aWxsIHRoZW4gZ2V0IHB1dCBpbiB0aGUgcHJvdG90eXBlIChvciBjb25zdHJ1Y3Rvcj8pXHJcbiAgICAvKlxyXG4gICAgZm9yICh2YXIgbmFtZSBpbiBwcm9wKSB7XHJcblxyXG4gICAgfVxyXG4gICAgKi9cclxuICAgIGlmIChwcm9wLmZsYWdzKSB7XHJcbiAgICAgICAgLy9yZXNbXHJcbiAgICAgICAgcmVzLl9mbGFncyA9IHByb3AuZmxhZ3M7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzO1xyXG59XHJcblxyXG5cclxuanNndWkuZW5zdXJlX2RhdGFfdHlwZV9kYXRhX29iamVjdF9jb25zdHJ1Y3RvciA9IGVuc3VyZV9kYXRhX3R5cGVfZGF0YV9vYmplY3RfY29uc3RydWN0b3I7XHJcblxyXG5FbmhhbmNlZF9EYXRhX09iamVjdC5tYXBfZGF0YV90eXBlX2RhdGFfb2JqZWN0X2NvbnN0cnVjdG9ycyA9IERhdGFfT2JqZWN0Lm1hcF9kYXRhX3R5cGVfZGF0YV9vYmplY3RfY29uc3RydWN0b3JzO1xyXG5FbmhhbmNlZF9EYXRhX09iamVjdC5NaW5pX0NvbnRleHQgPSBEYXRhX09iamVjdC5NaW5pX0NvbnRleHQ7XHJcblxyXG5EYXRhX09iamVjdC5zZXRfRW5oYW5jZWRfRGF0YV9PYmplY3QoRW5oYW5jZWRfRGF0YV9PYmplY3QpO1xyXG5cclxuRW5oYW5jZWRfRGF0YV9PYmplY3QucmVnaXN0ZXJfZGF0YV90eXBlID0gcmVnaXN0ZXJfZGF0YV90eXBlO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBFbmhhbmNlZF9EYXRhX09iamVjdDtcclxuXHJcblx0Ly9yZXR1cm4gRW5oYW5jZWRfRGF0YV9PYmplY3Q7XHJcbi8vfSk7XHJcbiIsInZhciBqc2d1aSA9IHJlcXVpcmUoJy4vanNndWktbGFuZy1lc3NlbnRpYWxzJyk7XHJcblxyXG52YXIgaiA9IGpzZ3VpO1xyXG52YXIgQ2xhc3MgPSBqLkNsYXNzO1xyXG52YXIgZWFjaCA9IGouZWFjaDtcclxudmFyIGlzX2FycmF5ID0gai5pc19hcnJheTtcclxudmFyIGlzX2RvbV9ub2RlID0gai5pc19kb21fbm9kZTtcclxudmFyIGlzX2N0cmwgPSBqLmlzX2N0cmw7XHJcbnZhciBleHRlbmQgPSBqLmV4dGVuZDtcclxudmFyIGdldF90cnV0aF9tYXBfZnJvbV9hcnIgPSBqLmdldF90cnV0aF9tYXBfZnJvbV9hcnI7XHJcbnZhciBnZXRfbWFwX2Zyb21fYXJyID0gai5nZXRfbWFwX2Zyb21fYXJyO1xyXG52YXIgYXJyX2xpa2VfdG9fYXJyID0gai5hcnJfbGlrZV90b19hcnI7XHJcbnZhciB0b2YgPSBqLnRvZjtcclxudmFyIGlzX2RlZmluZWQgPSBqLmlzX2RlZmluZWQ7XHJcbnZhciBzdHJpbmdpZnkgPSBqLnN0cmluZ2lmeTtcclxudmFyIGZ1bmN0aW9uYWxfcG9seW1vcnBoaXNtID0gai5mdW5jdGlvbmFsX3BvbHltb3JwaGlzbTtcclxudmFyIGZwID0gai5mcDtcclxudmFyIGFycmF5aWZ5ID0gai5hcnJheWlmeTtcclxudmFyIG1hcGlmeSA9IGoubWFwaWZ5O1xyXG52YXIgYXJlX2VxdWFsID0gai5hcmVfZXF1YWw7XHJcbnZhciBnZXRfaXRlbV9zaWcgPSBqLmdldF9pdGVtX3NpZztcclxudmFyIHNldF92YWxzID0gai5zZXRfdmFscztcclxudmFyIHRydXRoID0gai50cnV0aDtcclxudmFyIHRyaW1fc2lnX2JyYWNrZXRzID0gai50cmltX3NpZ19icmFja2V0cztcclxudmFyIGxsX3NldCA9IGoubGxfc2V0O1xyXG52YXIgbGxfZ2V0ID0gai5sbF9nZXQ7XHJcbnZhciBpbnB1dF9wcm9jZXNzb3JzID0gai5pbnB1dF9wcm9jZXNzb3JzO1xyXG52YXIgaXRlcmF0ZV9hbmNlc3Rvcl9jbGFzc2VzID0gai5pdGVyYXRlX2FuY2VzdG9yX2NsYXNzZXM7XHJcbnZhciBpc19hcnJfb2ZfYXJycyA9IGouaXNfYXJyX29mX2FycnM7XHJcbnZhciBpc19hcnJfb2Zfc3RycyA9IGouaXNfYXJyX29mX3N0cnM7XHJcbnZhciBpc19hcnJfb2ZfdCA9IGouaXNfYXJyX29mX3Q7XHJcbnZhciBjbG9uZSA9IGpzZ3VpLmNsb25lO1xyXG5cclxudmFyIEV2ZW50ZWRfQ2xhc3MgPSBDbGFzcy5leHRlbmQoe1xyXG5cclxuICAgIC8vIE5lZWRzIHRvIGluaXRpYWxpemUgdGhlIGJvdW5kIGV2ZW50cyB0byBzdGFydCB3aXRoLlxyXG5cclxuICAgICdpbml0JzogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy5fYm91bmRfZXZlbnRzID0ge307XHJcbiAgICB9LFxyXG5cclxuICAgICdyYWlzZV9ldmVudCc6IGZwKGZ1bmN0aW9uKGEsIHNpZykge1xyXG5cclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGMsIGw7XHJcblxyXG4gICAgICAgIC8vY29uc29sZS5sb2coJ3JhaXNlX2V2ZW50IHNpZycsIHNpZyk7XHJcblxyXG4gICAgICAgIGlmIChzaWcgPT0gJ1tzXScpIHtcclxuICAgICAgICAgICAgLy8ganVzdCByYWlzZSBhbiBldmVudCwgZ2l2ZW4gd2l0aCBubyBwYXJhbWV0ZXJzLFxyXG4gICAgICAgICAgICAvLyAgbWF5YmUgbGlrZSAnc3RhcnRlZCcuXHJcblxyXG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpcztcclxuICAgICAgICAgICAgdmFyIGV2ZW50X25hbWUgPSBhWzBdO1xyXG5cclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnRGF0YV9PYmplY3QgcmFpc2VfZXZlbnQgJyArIGV2ZW50X25hbWUpO1xyXG5cclxuICAgICAgICAgICAgdmFyIGJnaCA9IHRoaXMuX2JvdW5kX2dlbmVyYWxfaGFuZGxlcjtcclxuXHJcbiAgICAgICAgICAgIHZhciBiZSA9IHRoaXMuX2JvdW5kX2V2ZW50cztcclxuICAgICAgICAgICAgdmFyIHJlcyA9IFtdO1xyXG4gICAgICAgICAgICBpZiAoYmdoKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGMgPSAwLCBsID0gYmdoLmxlbmd0aDsgYyA8IGw7IGMrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlcy5wdXNoKGJnaFtjXS5jYWxsKHRhcmdldCwgZXZlbnRfbmFtZSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoYmUpIHtcclxuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYXR0YWNoaW5nIGV2ZW50cyB0byB0aGUgc2FtZSBvYmplY3QuXHJcbiAgICAgICAgICAgICAgICAvLyAgTm90IHN1cmUgd2h5LCBidXQgdGhpcyBuZWVkcyB0byBiZSBmaXhlZC5cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGJlaSA9IGJlW2V2ZW50X25hbWVdO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2JlaScsIGJlaSk7XHJcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCd0b2YgYmVpJywgdG9mKGJlaSkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRvZihiZWkpID09ICdhcnJheScpIHtcclxuICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCcxKSByYWlzZV9ldmVudCBiZWkubGVuZ3RoICcgKyBiZWkubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICAvL3ZhciByZXMgPSBbXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjID0gMCwgbCA9IGJlaS5sZW5ndGg7IGMgPCBsOyBjKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgIHJlcy5wdXNoKGJlaVtjXS5jYWxsKHRhcmdldCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnRXZlbnRlZF9DbGFzcyByYWlzZV9ldmVudCBbc10gcmVzJywgcmVzKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgICAgICAgICAgICAgfS8vIGVsc2UgaWYgKHRvZihiZWkpID09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgIC8vXHRiZWkuY2FsbCh0YXJnZXQsIHRhcmdldCwgZXZlbnRfbmFtZSk7XHJcbiAgICAgICAgICAgICAgICAvL31cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGEubCA+IDIpIHtcclxuICAgICAgICAgICAgdmFyIHRhcmdldCA9IHRoaXM7XHJcbiAgICAgICAgICAgIHZhciBldmVudF9uYW1lID0gYVswXTtcclxuXHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2V2ZW50X25hbWUgJyArIGV2ZW50X25hbWUpO1xyXG5cclxuICAgICAgICAgICAgdmFyIGFkZGl0aW9uYWxfYXJncyA9IFtdO1xyXG4gICAgICAgICAgICB2YXIgYmdoX2FyZ3MgPSBbZXZlbnRfbmFtZV07XHJcblxyXG4gICAgICAgICAgICBmb3IgKGMgPSAxLCBsID0gYS5sOyBjIDwgbDsgYysrKSB7XHJcbiAgICAgICAgICAgICAgICBhZGRpdGlvbmFsX2FyZ3MucHVzaChhW2NdKTtcclxuICAgICAgICAgICAgICAgIGJnaF9hcmdzLnB1c2goYVtjXSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBiZSA9IHRoaXMuX2JvdW5kX2V2ZW50cztcclxuICAgICAgICAgICAgdmFyIGJnaCA9IHRoaXMuX2JvdW5kX2dlbmVyYWxfaGFuZGxlcjtcclxuXHJcbiAgICAgICAgICAgIHZhciByZXMgPSBbXTtcclxuXHJcbiAgICAgICAgICAgIGlmIChiZ2gpIHtcclxuICAgICAgICAgICAgICAgIGZvciAoYyA9IDAsIGwgPSBiZ2gubGVuZ3RoOyBjIDwgbDsgYysrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2goYmdoW2NdLmFwcGx5KHRhcmdldCwgYmdoX2FyZ3MpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2JlICcgKyB0b2YoYmUpKTtcclxuICAgICAgICAgICAgaWYgKGJlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGUgY29udHJvbHMgdGhhdCBhcmUgYWN0aXZhdGVkIG9uIHRoZSBjbGllbnRzIG5lZWQgdG8gaGF2ZSBib3VuZCBldmVudHMuXHJcblxyXG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnZXZlbnRfbmFtZScsIGV2ZW50X25hbWUpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGJlaSA9IGJlW2V2ZW50X25hbWVdO1xyXG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnYmVpICcsIGJlaSk7XHJcbiAgICAgICAgICAgICAgICBpZiAodG9mKGJlaSkgPT0gJ2FycmF5Jykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJzEpIHJhaXNlX2V2ZW50IGJlaS5sZW5ndGggJyArIGJlaS5sZW5ndGgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoYmVpLmxlbmd0aCA+IDApIHtcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGV5IGFyZSBoYW5kbGVycyB0aGF0IGdldCBjYWxsZWQuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGMgPSAwLCBsID0gYmVpLmxlbmd0aDsgYyA8IGw7IGMrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiZWlbY10pIHJlcy5wdXNoKGJlaVtjXS5hcHBseSh0YXJnZXQsIGFkZGl0aW9uYWxfYXJncykpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJzIpIHJhaXNlZCB0aGUgYm91bmQgZXZlbnRzJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBPciBpZiBpdCdzIGp1c3QgYSBmdW5jdGlvbj9cclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoc2lnID09ICdbcyxvXScpIHtcclxuICAgICAgICAgICAgdmFyIGJlID0gdGhpcy5fYm91bmRfZXZlbnRzO1xyXG5cclxuICAgICAgICAgICAgLy8gQW5kIGl0cyBnZW5lcmFsIGJvdW5kIGV2ZW50cyBhcyB3ZWxsLlxyXG4gICAgICAgICAgICB2YXIgYmdoID0gdGhpcy5fYm91bmRfZ2VuZXJhbF9oYW5kbGVyO1xyXG4gICAgICAgICAgICB2YXIgZXZlbnRfbmFtZSA9IGFbMF07XHJcblxyXG4gICAgICAgICAgICB2YXIgcmVzID0gW107XHJcbiAgICAgICAgICAgIGlmIChiZ2gpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdiZ2gubGVuZ3RoJywgYmdoLmxlbmd0aCk7XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yIChjID0gMCwgbCA9IGJnaC5sZW5ndGg7IGMgPCBsOyBjKyspIHtcclxuICAgICAgICAgICAgICAgICAgICByZXMucHVzaChiZ2hbY10uY2FsbCh0YXJnZXQsIGV2ZW50X25hbWUsIGFbMV0pKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3RoaXMuX2JvdW5kX2V2ZW50cycsIHRoaXMuX2JvdW5kX2V2ZW50cyk7XHJcbiAgICAgICAgICAgIGlmIChiZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGJlaSA9IGJlW2V2ZW50X25hbWVdO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2JlaS5sZW5ndGgnLCBiZWkubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3RvZiBiZWknLCB0b2YoYmVpKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAodG9mKGJlaSkgPT09ICdhcnJheScpIHtcclxuICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCcxKSByYWlzZV9ldmVudCBiZWkubGVuZ3RoICcgKyBiZWkubGVuZ3RoKTtcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoYyA9IDAsIGwgPSBiZWkubGVuZ3RoOyBjIDwgbDsgYysrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICByZXMucHVzaChiZWlbY10uY2FsbCh0YXJnZXQsIGFbMV0pKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vZWFjaChiZWksIGZ1bmN0aW9uKGksIHYpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyAgICByZXMucHVzaCh2LmNhbGwodGFyZ2V0LCBhWzFdKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy99KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnRXZlbnRlZF9DbGFzcyByYWlzZV9ldmVudCBbc10gcmVzJywgcmVzKTtcclxuICAgICAgICAgICAgICAgICAgICAvL3JldHVybiByZXM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9KSxcclxuXHJcbiAgICAvLyBhbHNvIGp1c3QgcmFpc2UgYW5kIHRyaWdnZXI/XHJcblxyXG4gICAgLy8ncmFpc2UnOiBmdW5jdGlvbigpIHtcclxuICAgIC8vICAgIHJldHVybiB0aGlzLnJhaXNlX2V2ZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgLy99LFxyXG4gICAgLy8ndHJpZ2dlcic6IGZ1bmN0aW9uKCkge1xyXG4gICAgLy8gICAgcmV0dXJuIHRoaXMucmFpc2VfZXZlbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgIC8vfSxcclxuXHJcblxyXG4gICAgJ2FkZF9ldmVudF9saXN0ZW5lcicgOiBmcChmdW5jdGlvbihhLCBzaWcpIHtcclxuXHJcbiAgICAgICAgLy8gZXZlbnQgbGlzdGVuZXIgZm9yIGFsbCBldmVudHMuLi5cclxuICAgICAgICAvLyAgdGhhdCBjb3VsZCB3b3JrIHdpdGggZGVsZWdhdGlvbiwgYW5kIHRoZW4gd2hlbiB0aGUgY29kZSBmaW5kcyB0aGUgZXZlbnQgaXQgaW50ZXJwcmV0cyBpdC5cclxuICAgICAgICAvL2NvbnNvbGUubG9nKCcnKTtcclxuICAgICAgICAvL2NvbnNvbGUubG9nKCdkYXRhX29iamVjdCBhZGRfZXZlbnRfbGlzdGVuZXIgc2lnICcgKyBzaWcpO1xyXG5cclxuICAgICAgICAvLyBXaHkgaXMgdGhpcyBnZXR0aW5nIGNhbGxlZCBzbyBtYW55IHRpbWVzLCBmb3IgdGhlIHNhbWUgb2JqZWN0P1xyXG5cclxuXHJcblxyXG4gICAgICAgIC8vY29uc29sZS5sb2coJycpO1xyXG4gICAgICAgIC8vIFdoeSBpcyB0aGUgYm91bmQgZXZlbnRzIGFycmF5IGdldHRpbmcgc28gYmlnP1xyXG5cclxuICAgICAgICBpZiAoc2lnID09ICdbZl0nKSB7XHJcbiAgICAgICAgICAgIC8vdmFyIHN0YWNrID0gbmV3IEVycm9yKCkuc3RhY2s7XHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coc3RhY2spO1xyXG4gICAgICAgICAgICAvL3Rocm93ICdzdG9wJztcclxuXHJcblxyXG5cclxuICAgICAgICAgICAgdGhpcy5fYm91bmRfZ2VuZXJhbF9oYW5kbGVyID0gdGhpcy5fYm91bmRfZ2VuZXJhbF9oYW5kbGVyIHx8IFtdO1xyXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLl9ib3VuZF9nZW5lcmFsX2hhbmRsZXIpKSB7XHJcbiAgICAgICAgICAgIC8vaWYgKHRvZih0aGlzLl9ib3VuZF9nZW5lcmFsX2hhbmRsZXIpID09ICdhcnJheScpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2JvdW5kX2dlbmVyYWxfaGFuZGxlci5wdXNoKGFbMF0pO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBXaHkgZG9lcyBhIGNoYW5nZSBldmVudCBsaXN0ZW5lciBnZXQgYm91bmQgdG8gdGhlIHdyb25nIGNvbnRyb2wsIG9yIGJvdW5kIG11bHRpcGxlIHRpbWVzP1xyXG4gICAgICAgIC8vICBDaGFuZ2VzIGdldHRpbmcgcHVzaGVkIHVwIHRocm91Z2ggdGhlIHRyZWU/XHJcblxyXG5cclxuICAgICAgICBpZiAoc2lnID09ICdbcyxmXScpIHtcclxuICAgICAgICAgICAgLy8gYm91bmQgdG8gYSBwYXJ0aWN1bGFyIGV2ZW50IG5hbWVcclxuXHJcbiAgICAgICAgICAgIC8vIHdhbnQgdGhlIGdlbmVyYWwgdHJpZ2dlcmluZyBmdW5jdGlvbnMgdG8gYmUgZG9uZSB0b28uXHJcbiAgICAgICAgICAgIC8vICB3aXRoIGEgZGlmZmVyZW50IGZ1bmN0aW9uXHJcbiAgICAgICAgICAgIHZhciBldmVudF9uYW1lID0gYVswXSwgZm5fbGlzdGVuZXIgPSBhWzFdO1xyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdldmVudF9uYW1lICcgKyBldmVudF9uYW1lKTtcclxuICAgICAgICAgICAgdGhpcy5fYm91bmRfZXZlbnRzID0gdGhpcy5fYm91bmRfZXZlbnRzIHx8IHt9O1xyXG5cclxuICAgICAgICAgICAgLy8gcmVtb3ZpbmcgZnJvbSBhIGJvdW5kIGdlbmVyYWwgaGFuZGxlciBiZWluZyBzbG93P1xyXG4gICAgICAgICAgICAvLyAgcGVyaGFwcy4uLiBidXQgd2Ugd29uJ3QgaGF2ZSBzbyBtYW55IG9mIHRoZXNlIGFueXdheS5cclxuICAgICAgICAgICAgLy8gIGNvdWxkIGdldCBpZCBmb3Igb2JqZWN0IGFuZCBoYXZlIGl0IHdpdGhpbiBjb2xsZWN0aW9uLlxyXG4gICAgICAgICAgICAvLyAgIEJ1dCBub3Qgc3VyZSBhYm91dCB1c2luZyBjb2xsZWN0aW9ucyBmb3IgZXZlbnRzLi4uIGNvbGxlY3Rpb25zIHVzZSBldmVudHMuLi4/XHJcblxyXG4gICAgICAgICAgICAvLyBEaWZmZXJlbnQgY29udHJvbHMgYmluZGluZyB0byB0aGUgc2FtZSBhcnJheSBvZiBldmVudHM/XHJcblxyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2JvdW5kX2V2ZW50c1tldmVudF9uYW1lXSkgdGhpcy5fYm91bmRfZXZlbnRzW2V2ZW50X25hbWVdID0gW107XHJcblxyXG4gICAgICAgICAgICB2YXIgYmVpID0gdGhpcy5fYm91bmRfZXZlbnRzW2V2ZW50X25hbWVdO1xyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCd0aGlzLl9pZCgpICcgKyB0aGlzLl9pZCgpKTtcclxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYmVpKSkge1xyXG4gICAgICAgICAgICAvL2lmICh0b2YoYmVpKSA9PSAnYXJyYXknKSB7XHJcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCd0aGlzJywgdGhpcyk7XHJcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdhZGRfZXZlbnRfbGlzdGVuZXIgYmVpLmxlbmd0aCAnICsgYmVpLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICBiZWkucHVzaChmbl9saXN0ZW5lcik7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0pLFxyXG5cclxuICAgIC8vIEEgd2F5IG9mIHByb3h5aW5nIGZ1bmN0aW9ucyBiZWxvdz9cclxuICAgIC8vICBPciBzaW1wbHkgdXNlIGZ1bmN0aW9uIGFsaWFzP1xyXG4gICAgJ29uJzogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgLy8gSG93ZXZlciwgbmVlZCB0byBtYWtlIHVzZSBvZiBzb21lIGRvY3VtZW50IGV2ZW50cy5cclxuICAgICAgICAvLyAgV2l0aCBzb21lIGNvbnRyb2xzLCB3ZSBuZWVkIHRvIHBhc3MgdGhyb3VnaFxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5hZGRfZXZlbnRfbGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuXHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAncmVtb3ZlX2V2ZW50X2xpc3RlbmVyJzogZnVuY3Rpb24oZXZlbnRfbmFtZSwgZm5fbGlzdGVuZXIpIHtcclxuXHJcblxyXG4gICAgICAgIC8vIFRPRE9cclxuICAgICAgICAvLyBBbmQgcmVtb3ZlIHNvbWV0aGluZyB0aGF0J3MgYm91bmQgdG8gdGhlIGdlbmVyYWwgaGFuZGxlci4uLj9cclxuXHJcblxyXG5cclxuICAgICAgICAvLyBuZWVkcyB0byBnbyB0aHJvdWdoIHRoZSB3aG9sZSBhcnJheT9cclxuICAgICAgICAvLyB0aGluayBzby4uLi5cclxuXHJcbiAgICAgICAgLy9jb25zb2xlLmxvZygncmVtb3ZlX2V2ZW50X2xpc3RlbmVyJyk7XHJcbiAgICAgICAgLy9jb25zb2xlLmxvZygndGhpcy5fYm91bmRfZXZlbnRzJywgdGhpcy5fYm91bmRfZXZlbnRzKTtcclxuICAgICAgICBpZiAodGhpcy5fYm91bmRfZXZlbnRzKSB7XHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2V2ZW50X25hbWUnLCBldmVudF9uYW1lKTtcclxuICAgICAgICAgICAgdmFyIGJlaSA9IHRoaXMuX2JvdW5kX2V2ZW50c1tldmVudF9uYW1lXSB8fCBbXTtcclxuXHJcbiAgICAgICAgICAgIC8vdmFyIHRiZWkgPSB0b2YoYmVpKTtcclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygndGJlaScsIHRiZWkpO1xyXG5cclxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYmVpKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gYmVpLnB1c2goZm5fbGlzdGVuZXIpO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBjID0gMCwgbCA9IGJlaS5sZW5ndGgsIGZvdW5kID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnbCcsIGwpO1xyXG5cclxuICAgICAgICAgICAgICAgIHdoaWxlICghZm91bmQgJiYgYyA8IGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYmVpW2NdID09PSBmbl9saXN0ZW5lcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYysrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2ZvdW5kJywgZm91bmQpO1xyXG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnYycsIGMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYmVpLnNwbGljZShjLCAxKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgJ29mZic6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIC8vIEhvd2V2ZXIsIG5lZWQgdG8gbWFrZSB1c2Ugb2Ygc29tZSBkb2N1bWVudCBldmVudHMuXHJcbiAgICAgICAgLy8gIFdpdGggc29tZSBjb250cm9scywgd2UgbmVlZCB0byBwYXNzIHRocm91Z2hcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlX2V2ZW50X2xpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcblxyXG4gICAgfSxcclxuICAgICdvbmUnOiBmdW5jdGlvbihldmVudF9uYW1lLCBmbl9oYW5kbGVyKSB7XHJcblxyXG4gICAgICAgIHZhciBpbm5lcl9oYW5kbGVyID0gZnVuY3Rpb24oZSkge1xyXG5cclxuICAgICAgICAgICAgLy92YXIgcmVzdWx0ID0gZm5faGFuZGxlci5jYWxsKHRoaXMsIGUpO1xyXG4gICAgICAgICAgICBmbl9oYW5kbGVyLmNhbGwodGhpcywgZSk7XHJcbiAgICAgICAgICAgIHRoaXMub2ZmKGV2ZW50X25hbWUsIGlubmVyX2hhbmRsZXIpO1xyXG4gICAgICAgICAgICAvL3JldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdGhpcy5vbihldmVudF9uYW1lLCBpbm5lcl9oYW5kbGVyKTtcclxuICAgIH1cclxufSk7XHJcblxyXG52YXIgcCA9IEV2ZW50ZWRfQ2xhc3MucHJvdG90eXBlO1xyXG5wLnJhaXNlID0gcC5yYWlzZV9ldmVudDtcclxucC50cmlnZ2VyID0gcC5yYWlzZV9ldmVudDtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRXZlbnRlZF9DbGFzcztcclxuIiwiXG5cbi8qXG5pZiAodHlwZW9mIGRlZmluZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBkZWZpbmUgPSByZXF1aXJlKCdhbWRlZmluZScpKG1vZHVsZSk7XG59XG5cblxuLy8gTWF5IHN3YXkgaW1wbGVtZW50YXRpb25zIG9mIHRoZSBwYXJ0aWN1bGFyIGl0ZW1zIG1vcmUgZWFzaWx5IHdoZW4gdGhleSBhcmUgaW4gdGhlaXIgb3duIGZpbGVzLlxuXG5kZWZpbmUoW1wiLi9qc2d1aS1sYW5nLWVzc2VudGlhbHNcIiwgXCIuL2pzZ3VpLWRhdGEtc3RydWN0dXJlcy1zdGlmZmFycmF5XCJdLCBmdW5jdGlvbiAoanNndWksIFN0aWZmQXJyYXkpIHtcbiovXG5cbnZhciBqc2d1aSA9IHJlcXVpcmUoJy4vanNndWktbGFuZy1lc3NlbnRpYWxzJyk7XG52YXIgU3RpZmZBcnJheSA9IHJlcXVpcmUoJy4vanNndWktZGF0YS1zdHJ1Y3R1cmVzLXN0aWZmYXJyYXknKTtcblxuICAgIC8qKiBcbiAgICAqIEIrIFRyZWUgbW9kdWxlLlxuICAgICogQG1vZHVsZSBjb3JlL2pzZ3VpLWRhdGEtc3RydWN0dXJlcy1iLXBsdXMtdHJlZVxuICAgICogQGV4cG9ydHMgY29yZS9qc2d1aS1kYXRhLXN0cnVjdHVyZXMtYi1wbHVzLXRyZWVcbiAgICAqL1xuXG4gICAgLy8gQisgVHJlZVxuXG4gICAgLy8gc29tZSBCKyBUcmVlIGRlc2NyaXB0aW9uIGNhbiBiZSBmb3VuZCBoZXJlOlxuICAgIC8vIGh0dHA6Ly93d3cuY3MuYmVya2VsZXkuZWR1L35rYW1pbC90ZWFjaGluZy9zdTAyLzA4MDgwMi5wZGZcbiAgICAvLyBodHRwOi8vYmF6ZS5mcmkudW5pLWxqLnNpL2Rva3VtZW50aS9CKyUyMFRyZWVzLnBkZlxuXG5cbiAgICAvLyBzYW1wbGUgdHJlZSBjbGFzc2ljIHByZXNlbnRhdGlvbjpcbiAgICAvL1xuICAgIC8vXHQgICAgICAgICAgICAgIFtdIDcgW11cbiAgICAvL1x0ICAgICAgICAgICAgICAvICAgICBcXFxuICAgIC8vXHQgICAgICAgICAgICAgLyAgICAgICAtLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vXHQgICAgICAgICAgICAvICAgICAgICAgICAgICAgICAgICAgICAgIFxcXG4gICAgLy9cdCAgICAgICAgICAgLyAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcXG4gICAgLy9cdCAgICAgW10gMyBbXSA1IFtdICAgICAgICAgICAgICAgICAgW10gOCBbXSA4IFtdXG4gICAgLy9cdCAgICAgLyAgICB8ICAgICBcXCAgICAgICAgICAgICAgICAgIC8gICAgIFxcICAgIFxcXG4gICAgLy9cdCAgICAvICAgICB8ICAgICAgXFwgICAgICAgICAgICAgICAgLyAgICAgICB8ICAgIC0tLS1cbiAgICAvLyAgICAgLyAgICAgIHwgICAgICAgXFwgICAgICAgICAgICAgIC8gICAgICAgICBcXCAgICAgICBcXFxuICAgIC8vICB7MSwyfSAgIHszLDR9ICAgIHs1LDYsN30gICAgICB7OCw4LDh9ICAgIHs4LDh9ICAgIHs4LDl9XG4gICAgLy9cbiAgICAvLyAgIHRoZSBkaWFncmFtIG5vdGF0aW9uOlxuICAgIC8vICAgbnVtYmVycyBhcmUgXCJrZXlzXCIgYXJyYXkgaXRlbXNcbiAgICAvLyAgIFwiW11cIiBmaWd1cmVzIGFyZSBcImNoaWxkcmVuXCIgYXJyYXkgaXRlbXNcblxuXG4gICAgLy8gc2FtcGxlIHRyZWUgdG9UZXh0KCkgcHJlc2VudGF0aW9uOlxuICAgIC8vXG4gICAgLy9cdCAgICAgIHsxLDJ9XG4gICAgLy9cdCAgICAzXG4gICAgLy9cdCAgICAgIHszLDR9XG4gICAgLy9cdCAgICA1XG4gICAgLy9cdCAgICAgIHs1LDYsN31cbiAgICAvLyAgN1xuICAgIC8vXHQgICAgICB7OCw4LDh9XG4gICAgLy9cdCAgICA4XG4gICAgLy9cdCAgICAgIHs4LDh9XG4gICAgLy9cdCAgICA4XG4gICAgLy9cdCAgICAgIHs4LDl9XG5cblxuICAgIC8vIHNhbXBsZSB0cmVlIHRvU3RyaW5nKCkgcHJlc2VudGF0aW9uOlxuICAgIC8vXG4gICAgLy8ge3t7MSwyfTN7Myw0fTV7NSw2LDd9fTd7ezgsOCw4fTh7OCw4fTh7OCw5fX19XG5cblxuICAgIC8vIHNvbWUgcmVtYXJrczpcbiAgICAvL1xuICAgIC8vICBjaGlsZHJlbi5sZW5ndGggPT0ga2V5cy5sZW5ndGggKyAxXG4gICAgLy9cbiAgICAvLyAgKG1heCBjaGlsZHJlbltpXSBrZXkpIDw9IChrZXlzW2ldKSA8PSAobWluIGNoaWxkcmVuW2krMV0ga2V5KVxuICAgIC8vXG4gICAgLy8gIHRoZSBub2RlIG92ZXJmbG93IHRocmVzaG9sZCByZWZlcnJlZCBzb21ld2hlcmUgYXMgXCJub2RlIG9yZGVyXCIgaXMgcmVmZXJyZWQgYXMgXCJub2RlIGNhcGFjaXR5XCIgaGVyZVxuXG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vXG4gICAgLy9cdCAgICAgICAgICAgICAgZ2xvYmFsIHZhcmlhYmxlczpcbiAgICAvL1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvL3ZhciBCX1BsdXNfVHJlZV9OZXh0Tm9kZURlYnVnSWQgPSAxO1xuICAgIC8vIHVuY29tbWVudCB0aGUgbGluZSBhYm92ZSB0byBpbmNsdWRlIHVuaXF1ZSBub2RlIElEcyBcbiAgICAvLyB0byB0aGUgdG9TdHJpbmcoKSBhbmQgdG9UZXN0KCkgb3V0cHV0XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vXG4gICAgLy9cdCAgICAgICAgICAgICAgQl9QbHVzX05vZGU6XG4gICAgLy9cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgLy8gTGlrZWx5IHRvIGdldCB0aGlzIGludG8gdGhlIGNvcmUsIGFuZCBkbyBzb21lIG1vcmUgcG9seW1vcnBoaWMgb3B0aW1pemF0aW9uIHRvIHJlZHVjZSBmaWxlIHNpemUuXG4gICAgLy8gIE9uZSB2YXJpb3VzIHRoaW5ncyBhcmUgcnVubmluZywgSSB3aWxsIGZvY3VzIG9uIHNvbWUgY29kZSBzaXplIG9wdGltaXphdGlvbnMgdG8gYnJpbmcgdGhpbmdzIGRvd24gdG8gcmVhbGx5IHNtYWxsIHNpemVzIHdoZW4gdXNlZCBpblxuICAgIC8vICBjb25qdW5jdGlvbiB3aXRoIEVzc2VudGlhbHMuXG5cbiAgICAvLyBOb3Qgc3VyZSBhYm91dCB0aGUgQisgdHJlZSBtYWtpbmcgdXNlIG9mIENvbGxlY3Rpb25zIGJ1dCB3aXRoIG5vIGluZGV4aW5nP1xuICAgIC8vICBJIHRoaW5rIGJ5IG1ha2luZyBDb2xsZWN0aW9uIHJlYWxseSBmbGV4aWJsZSwgYW5kIGEgdmVyc2lvbiB0aGF0IG1peGVzIGluIG90aGVyIGZ1bmN0aW9uYWxpdHkgdG8gYSBtb3JlIGJhc2ljIG9uZSxcbiAgICAvLyAgaXQgd291bGQgYmUgcG9zc2libGUgdG8gbWFrZSB0aGUgQisgdHJlZSB1c2UgYSBDb2xsZWN0aW9uIHdpdGggU3RpZmZBcnJheSBjYXBhYmlsaXRpZXMuXG4gICAgLy8gICBOb3Qgd29ydGggaXQgcmlnaHQgbm93LiBLZWVwIFN0aWZmQXJyYXkgYXMgYSBsb3cgbGV2ZWwgY29tcG9uZW50IHVzZWQgZm9yIHRoZSB0cmVlLiBNYXliZSBtb3ZlIGl0IG91dCBvZiBpdHMgb3duIEphdmFTY3JpcHQgZmlsZSwgbm90IHN1cmUgaXRcbiAgICAvLyAgICB3aWxsIGJlIHVzZWQgZm9yIHRoYXQgbXVjaCBlbHNlLiBOb3Qgc3VyZSwgY291bGQgYmUgZ29vZCBmb3Igd2hlbiBiaW5hcnkgc2VhcmNoZXMgYXJlIHJlcXVpcmVkLlxuXG5cblxuXG5cblxuXG5cbiAgICAvLyBCKyB0cmVlIGluZGV4IG5vZGU6XG5cbiAgICB2YXIgQl9QbHVzX05vZGUgPSBmdW5jdGlvbiAobm9kZUNhcGFjaXR5KSB7XG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gICAgICAgICAgICAgIHB1YmxpYyBpbnRlcmZhY2U6XG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgdmFyIG1fcHVibGljID0ge1xuICAgICAgICAgICAgaXNMZWFmOiBmYWxzZSxcbiAgICAgICAgICAgIHBhcmVudDogbnVsbCxcbiAgICAgICAgICAgIGtleXM6IG5ldyBTdGlmZkFycmF5KG5vZGVDYXBhY2l0eSArIDEpLCAgICAgLy8gKzE6IHRvIGFsbG93IHRlbXBvcmFyeSBvd2VyZmxvd1xuICAgICAgICAgICAgY2hpbGRyZW46IG5ldyBTdGlmZkFycmF5KG5vZGVDYXBhY2l0eSArIDIpIC8vICsyOiBjaGlsZHJlbi5sZW5ndGggPT0ga2V5cy5sZW5ndGggKyAxXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICBkZWJ1ZyBJRDpcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICAvL2lmICh0eXBlb2YgKEJfUGx1c19UcmVlX05leHROb2RlRGVidWdJZCkgIT0gXCJ1bmRlZmluZWRcIikgbV9wdWJsaWMuZGVidWdJZCA9IEJfUGx1c19UcmVlX05leHROb2RlRGVidWdJZCsrO1xuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vICAgICAgIHJldHVybiB0aGUgcHVibGljIGludGVyZmFjZTpcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICByZXR1cm4gbV9wdWJsaWM7XG4gICAgfTtcblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy9cbiAgICAvL1x0ICAgICAgICAgICAgICBCX1BsdXNfTGVhZjpcbiAgICAvL1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvLyBCKyB0cmVlIGxlYWYgbm9kZTpcblxuICAgIHZhciBCX1BsdXNfTGVhZiA9IGZ1bmN0aW9uIChub2RlQ2FwYWNpdHkpIHtcblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyAgICAgICAgICAgICAgcHVibGljIGludGVyZmFjZTpcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICB2YXIgbV9wdWJsaWMgPSB7XG4gICAgICAgICAgICBpc0xlYWY6IHRydWUsXG4gICAgICAgICAgICBwYXJlbnQ6IG51bGwsXG4gICAgICAgICAgICBrZXlzOiBuZXcgU3RpZmZBcnJheShub2RlQ2FwYWNpdHkgKyAxKSxcbiAgICAgICAgICAgIHZhbHVlczogbmV3IFN0aWZmQXJyYXkobm9kZUNhcGFjaXR5ICsgMSksXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gbGVhZnMgY2hhaW46XG4gICAgICAgICAgICBwcmV2TGVhZjogbnVsbCxcbiAgICAgICAgICAgIG5leHRMZWFmOiBudWxsXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICBkZWJ1ZyBJRDpcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICAvL2lmICh0eXBlb2YoQl9QbHVzX1RyZWVfTmV4dE5vZGVEZWJ1Z0lkKSAhPSBcInVuZGVmaW5lZFwiKSBtX3B1YmxpYy5kZWJ1Z0lkID0gQl9QbHVzX1RyZWVfTmV4dE5vZGVEZWJ1Z0lkKys7XG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gICAgICAgcmV0dXJuIHRoZSBwdWJsaWMgaW50ZXJmYWNlOlxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgIHJldHVybiBtX3B1YmxpYztcbiAgICB9O1xuXG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vXG4gICAgLy9cdCAgICAgICAgICAgICAgQl9QbHVzX1RyZWU6XG4gICAgLy9cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgLy8gQisgdHJlZTpcblxuICAgIC8vIFVzaW5nIENyb2NrZm9yZCdzIE1vZHVsZSBQYXR0ZXJuLlxuICAgIC8vICBOZWVkIHRvIGJlIGNhcmVmdWwgYWJvdXQgaG93IGl0IGlzIG5vdCBpbml0aWFsaXplZCB3aXRoIGEgY29uc3RydWN0b3IgYW5kIHRoZSAnbmV3JyBrZXl3b3JkLlxuXG4gICAgLyoqXG4gICAgKlxuICAgICogQGNvbnN0cnVjdG9yXG4gICAgKiBAY2xhc3NkZXNjXG4gICAgKlxuICAgICogVGhpcyBjbGFzcyBpcyB1c2VkIGZvciB0aGUgZmluZEZpcnN0L2ZpbmROZXh0IGl0ZXJhdGlvbiBwYXR0ZXJuOlxuICAgICogLSBmaW5kRmlyc3QoKSBnZXRzIHRoZSBzZWFyY2ggY3JpdGVyaWEsIGZpbmRzIHRoZSBmaXJzdCBpdGVtLCBzdG9yZSB0aGUgc2VhcmNoIHN0YXRlIHRvIEZpbmRJbmZvXG4gICAgKiAoaW5jbHVkaW5nIHRoZSBjcml0ZXJpYSwgZm91bmQgaXRlbSwgYW5kIGFsbCBvdGhlciByZWxhdGVkIGluZm9ybWF0aW9uKSwgYW5kIHJldHVybnMgdGhlIEZpbmRJbmZvLlxuICAgICogLSB0aGUgY2xpZW50IHByb2Nlc3MgdGhlIGZvdW5kIGl0ZW0gKGZyb20gdGhlIHJldHVybmVkIEZpbmRJbmZvKSwgYW5kIGNhbGxzIGZpbmROZXh0KCkgcGFzc2luZyB0aGUgRmluZEluZm8uXG4gICAgKiAtIGZpbmROZXh0KCkgdXNlcyB0aGUgc2VhcmNoIHN0YXRlIGZyb20gRmluZEluZm8gdG8gZmluZCBuZXh0IGl0ZW0sIHVwZGF0ZXMgdGhlIHNlYXJjaCBzdGF0ZSwgYW5kIHJldHVybnMgdGhlIHVwZGF0ZWQgRmluZEluZm8uXG4gICAgKiAtIHRoZSBjbGllbnQgcHJvY2VzcyB0aGUgZm91bmQgaXRlbSwgYW5kIGNhbGxzIGZpbmROZXh0KCkgYWdhaW4gYW5kIGFnYWluIC0gdW50aWwgbnVsbCB3aWxsIGJlIHJldHVybmVkLlxuICAgICpcbiAgICAqIFRoZSBGaW5kSW5mbygpIGNvbnN0cnVjdG9yIGlzIGludGVuZGVkIGZvciBpbnRlcm5hbCB1c2Ugb25seS4gWW91IHNob3VsZCBjYWxsIGZpbmRGaXJzdCgpLCBmaW5kTmV4dCgpLCBmaW5kTGFzdCgpIGV0Yy4gdG8gZ2V0IHRoZSBGaW5kSW5mbyBvYmplY3QuXG4gICAgKlxuICAgICogQC0tcGFyYW0geyp9IGtleVxuICAgICogQC0tcGFyYW0geyp9IHZhbHVlXG4gICAgKiBALS1wYXJhbSB7Ym9vbGVhbn0gaXNQcmVmaXhTZWFyY2hcbiAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29yZS9qc2d1aS1kYXRhLXN0cnVjdHVyZXMtYi1wbHVzLXRyZWVcbiAgICAqIFxuICAgICogQGV4YW1wbGVcbiAgICAqIFxuICAgICogICAgIC8vIGdldCBhbGwgdGhlIGtleS92YWx1ZSBwYWlyczpcbiAgICAqIFxuICAgICogICAgIHZhciBmaW5kSW5mbyA9IHRyZWUuZmluZEZpcnN0KCk7XG4gICAgKiAgICAgd2hpbGUgKGZpbmRJbmZvICE9PSBudWxsKSB7XG4gICAgKiAgICAgICBjb25zb2xlLmxvZyhcImtleT1cIiArIGZpbmRJbmZvLmZvdW5kS2V5KCkgKyBcIiB2YWx1ZT1cIiArIGZpbmRJbmZvLmZvdW5kVmFsdWUoKSk7XG4gICAgKiAgICAgICBmaW5kSW5mbyA9IHRyZWUuZmluZE5leHQoZmluZEluZm8pO1xuICAgICogICAgIH1cbiAgICAqIFxuICAgICogXG4gICAgKiAgICAgLy8gZ2V0IGFsbCB0aGUga2V5L3ZhbHVlIHBhaXJzIGluIHJldmVyc2Ugb3JkZXI6XG4gICAgKiBcbiAgICAqICAgICB2YXIgZmluZEluZm8gPSB0cmVlLmZpbmRMYXN0KCk7XG4gICAgKiAgICAgd2hpbGUgKGZpbmRJbmZvICE9PSBudWxsKSB7XG4gICAgKiAgICAgICBjb25zb2xlLmxvZyhcImtleT1cIiArIGZpbmRJbmZvLmZvdW5kS2V5KCkgKyBcIiB2YWx1ZT1cIiArIGZpbmRJbmZvLmZvdW5kVmFsdWUoKSk7XG4gICAgKiAgICAgICBmaW5kSW5mbyA9IHRyZWUuZmluZFByZXZpb3VzKGZpbmRJbmZvKTtcbiAgICAqICAgICB9XG4gICAgKiBcbiAgICAqIFxuICAgICogICAgIC8vIGdldCBhbGwgdGhlIHZhbHVlcyBmb3IgXCIwMTBcIiBrZXk6XG4gICAgKiBcbiAgICAqICAgICB2YXIgZmluZEluZm8gPSB0cmVlLmZpbmRGaXJzdChcIjAxMFwiKTtcbiAgICAqICAgICB3aGlsZSAoZmluZEluZm8gIT09IG51bGwpIHtcbiAgICAqICAgICAgIGNvbnNvbGUubG9nKFwia2V5PVwiICsgZmluZEluZm8uZm91bmRLZXkoKSArIFwiIHZhbHVlPVwiICsgZmluZEluZm8uZm91bmRWYWx1ZSgpKTtcbiAgICAqICAgICAgIGZpbmRJbmZvID0gdHJlZS5maW5kTmV4dChmaW5kSW5mbyk7XG4gICAgKiAgICAgfVxuICAgICogXG4gICAgKiBcbiAgICAqICAgICAvLyBnZXQgYWxsIHRoZSBrZXkvdmFsdWUgcGFpcnMgcHJlZml4ZWQgYnkgXCIwMVwiIGluIHJldmVyc2Ugb3JkZXI6XG4gICAgKiBcbiAgICAqICAgICB2YXIgZmluZEluZm8gPSB0cmVlLmZpbmRMYXN0UHJlZml4KFwiMDFcIik7XG4gICAgKiAgICAgd2hpbGUgKGZpbmRJbmZvICE9PSBudWxsKSB7XG4gICAgKiAgICAgICBjb25zb2xlLmxvZyhcImtleT1cIiArIGZpbmRJbmZvLmZvdW5kS2V5KCkgKyBcIiB2YWx1ZT1cIiArIGZpbmRJbmZvLmZvdW5kVmFsdWUoKSk7XG4gICAgKiAgICAgICBmaW5kSW5mbyA9IHRyZWUuZmluZFByZXZpb3VzKGZpbmRJbmZvKTtcbiAgICAqICAgICB9XG4gICAgKiBcbiAgICAqIFxuICAgICogXG4gICAgKi9cblxuICAgIHZhciBGaW5kSW5mbyA9IGZ1bmN0aW9uIChrZXksIHZhbHVlLCBpc1ByZWZpeFNlYXJjaCkge1xuICAgICAgICBpc1ByZWZpeFNlYXJjaCA9ICEhaXNQcmVmaXhTZWFyY2g7XG4gICAgICAgIHZhciBpc0tleVByZXNlbnQgPSAoa2V5ICE9IHVuZGVmaW5lZCk7XG4gICAgICAgIHZhciBpc1ZhbHVlUHJlc2VudCA9ICh2YWx1ZSAhPSB1bmRlZmluZWQpO1xuICAgICAgICB2YXIgcHJlZml4TGVuZ3RoID0gMDtcbiAgICAgICAgaWYgKGlzUHJlZml4U2VhcmNoKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIChrZXkpICE9IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBpc1ByZWZpeFNlYXJjaCA9IGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcmVmaXhMZW5ndGggPSBrZXkubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAvKiAqIFxuICAgICAgICAgICAgKiBrZXkgdG8gZmluZCAoaWYgcHJlc2VudClcbiAgICAgICAgICAgICogQG1lbWJlcm9mIG1vZHVsZTpjb3JlL2pzZ3VpLWRhdGEtc3RydWN0dXJlcy1iLXBsdXMtdHJlZS5GaW5kSW5mby5wcm90b3R5cGUgXG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAga2V5OiBrZXksICAgICAvLyBrZXkgdG8gZmluZCAoaWYgcHJlc2VudClcbiAgICAgICAgICAgIC8qICogXG4gICAgICAgICAgICAqIHZhbHVlIHRvIGZpbmQgKGlmIHByZXNlbnQpXG4gICAgICAgICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29yZS9qc2d1aS1kYXRhLXN0cnVjdHVyZXMtYi1wbHVzLXRyZWUuRmluZEluZm8ucHJvdG90eXBlIFxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSwgLy8gdmFsdWUgdG8gZmluZCAoaWYgcHJlc2VudClcbiAgICAgICAgICAgIC8qICogXG4gICAgICAgICAgICAqIHByZWZpeCBzZWFyY2ggbW9kZVxuICAgICAgICAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvcmUvanNndWktZGF0YS1zdHJ1Y3R1cmVzLWItcGx1cy10cmVlLkZpbmRJbmZvLnByb3RvdHlwZSBcbiAgICAgICAgICAgICovXG4gICAgICAgICAgICBpc1ByZWZpeFNlYXJjaDogaXNQcmVmaXhTZWFyY2gsIC8vIHByZWZpeCBzZWFyY2ggbW9kZVxuICAgICAgICAgICAgLyogKiBcbiAgICAgICAgICAgICogZm91bmQgbGVhZlxuICAgICAgICAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvcmUvanNndWktZGF0YS1zdHJ1Y3R1cmVzLWItcGx1cy10cmVlLkZpbmRJbmZvLnByb3RvdHlwZSBcbiAgICAgICAgICAgICovXG4gICAgICAgICAgICBsZWFmOiBudWxsLCAgIC8vIGZvdW5kIGxlYWZcbiAgICAgICAgICAgIC8qICogXG4gICAgICAgICAgICAqIGZvdW5kIGxlYWYgaXRlbSBpbmRleFxuICAgICAgICAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvcmUvanNndWktZGF0YS1zdHJ1Y3R1cmVzLWItcGx1cy10cmVlLkZpbmRJbmZvLnByb3RvdHlwZSBcbiAgICAgICAgICAgICovXG4gICAgICAgICAgICBpbmRleDogLTEsICAgIC8vIGZvdW5kIGxlYWYgaXRlbSBpbmRleFxuICAgICAgICAgICAgLyogKiBcbiAgICAgICAgICAgICogaXMgdGhlIHNlYXJjaCBjcml0ZXJpYSBjb250YWlucyBrZXlcbiAgICAgICAgICAgICogQG1lbWJlcm9mIG1vZHVsZTpjb3JlL2pzZ3VpLWRhdGEtc3RydWN0dXJlcy1iLXBsdXMtdHJlZS5GaW5kSW5mby5wcm90b3R5cGUgXG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgaXNLZXlQcmVzZW50OiBpc0tleVByZXNlbnQsIC8vIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMua2V5ICE9PSB1bmRlZmluZWQ7IH0sIC8vIGlzIHRoZSBzZWFyY2ggY3JpdGVyaWEgY29udGFpbnMga2V5XG4gICAgICAgICAgICAvKiAqIFxuICAgICAgICAgICAgKiBpcyB0aGUgc2VhcmNoIGNyaXRlcmlhIGNvbnRhaW5zIHZhbHVlXG4gICAgICAgICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29yZS9qc2d1aS1kYXRhLXN0cnVjdHVyZXMtYi1wbHVzLXRyZWUuRmluZEluZm8ucHJvdG90eXBlIFxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlzVmFsdWVQcmVzZW50OiBpc1ZhbHVlUHJlc2VudCwgLy8gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy52YWx1ZSAhPT0gdW5kZWZpbmVkOyB9LCAvLyBpcyB0aGUgc2VhcmNoIGNyaXRlcmlhIGNvbnRhaW5zIHZhbHVlXG4gICAgICAgICAgICAvKiogXG4gICAgICAgICAgICAqIGZvdW5kIGl0ZW1zJ3Mga2V5XG4gICAgICAgICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29yZS9qc2d1aS1kYXRhLXN0cnVjdHVyZXMtYi1wbHVzLXRyZWUuRmluZEluZm8ucHJvdG90eXBlIFxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZvdW5kS2V5OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmxlYWYua2V5cy5pdGVtc1t0aGlzLmluZGV4XTsgfSwgLy8gZm91bmQgaXRlbXMncyBrZXlcbiAgICAgICAgICAgIC8qKiBcbiAgICAgICAgICAgICogZm91bmQgaXRlbSdzIHZhbHVlXG4gICAgICAgICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29yZS9qc2d1aS1kYXRhLXN0cnVjdHVyZXMtYi1wbHVzLXRyZWUuRmluZEluZm8ucHJvdG90eXBlIFxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZvdW5kVmFsdWU6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMubGVhZi52YWx1ZXMuaXRlbXNbdGhpcy5pbmRleF07IH0sIC8vIGZvdW5kIGl0ZW0ncyB2YWx1ZVxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIHByZWZpeF9sZW5ndGg6IHByZWZpeExlbmd0aCwgLy8gcHJlZml4IGxlbmd0aFxuICAgICAgICAgICAgY2hlY2tfcHJlZml4OiBmdW5jdGlvbiAoKSB7ICAvLyBjaGVjayB0aGUgY3VycmVudCBrZXkgdG8gbWF0Y2ggdGhlIHByZWZpeFxuICAgICAgICAgICAgICAgIGlmICghaXNQcmVmaXhTZWFyY2gpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pbmRleCA+PSB0aGlzLmxlYWYua2V5cy5jb3VudCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIHZhciBrZXlUb0NoZWNrID0gdGhpcy5mb3VuZEtleSgpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnByZWZpeF9sZW5ndGggPiBrZXlUb0NoZWNrLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybiAoa2V5VG9DaGVjay5zdWJzdHIoMCwgdGhpcy5wcmVmaXhfbGVuZ3RoKSA9PSB0aGlzLmtleSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xuXG5cblxuICAgIHZhciBCX1BsdXNfVHJlZSA9IGZ1bmN0aW9uIChub2RlQ2FwYWNpdHkpIHtcblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyAgICAgICAgICAgIGFyZ3VtZW50cyBwcm9jZXNzaW5nOlxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgIGlmIChub2RlQ2FwYWNpdHkgPT09IHVuZGVmaW5lZCkgbm9kZUNhcGFjaXR5ID0gMTA7XG4gICAgICAgIGlmIChub2RlQ2FwYWNpdHkgPCA0KSB0aHJvdyBcIkJfUGx1c19UcmVlKCk6IG5vZGUgY2FwYWNpdHkgbXVzdCBiZSA+PSA0XCI7XG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gICAgICAgICAgICAgIHB1YmxpYyBpbnRlcmZhY2U6XG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgLyoqXG4gICAgICAgICogQ3JlYXRlcyB0aGUgQisgVHJlZS5cbiAgICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAgKiBAY2xhc3NkZXNjIFxuICAgICAgICAqXG4gICAgICAgICogQisgVHJlZVxuICAgICAgICAqXG4gICAgICAgICogc29tZSBCKyBUcmVlIGRlc2NyaXB0aW9uIGNhbiBiZSBmb3VuZCBoZXJlOlxuICAgICAgICAqXG4gICAgICAgICoge0BsaW5rIGh0dHA6Ly93d3cuY3MuYmVya2VsZXkuZWR1L35rYW1pbC90ZWFjaGluZy9zdTAyLzA4MDgwMi5wZGZ9XG4gICAgICAgICpcbiAgICAgICAgKiB7QGxpbmsgaHR0cDovL2JhemUuZnJpLnVuaS1sai5zaS9kb2t1bWVudGkvQislMjBUcmVlcy5wZGZ9XG4gICAgICAgICpcbiAgICAgICAgKiBzYW1wbGUgdHJlZSBjbGFzc2ljIHByZXNlbnRhdGlvbjpcbiAgICAgICAgKlxuICAgICAgICAqIDxwcmU+XG4gICAgICAgICogPGNvZGU+XG4gICAgICAgICogICAgICAgICAgICAgICAgIFtdIDcgW11cbiAgICAgICAgKiAgICAgICAgICAgICAgICAgLyAgICAgXFxcbiAgICAgICAgKiAgICAgICAgICAgICAgICAvICAgICAgIC0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICogICAgICAgICAgICAgICAvICAgICAgICAgICAgICAgICAgICAgICAgIFxcXG4gICAgICAgICogICAgICAgICAgICAgIC8gICAgICAgICAgICAgICAgICAgICAgICAgICBcXFxuICAgICAgICAqICAgICAgICBbXSAzIFtdIDUgW10gICAgICAgICAgICAgICAgICBbXSA4IFtdIDggW11cbiAgICAgICAgKiAgICAgICAgLyAgICB8ICAgICBcXCAgICAgICAgICAgICAgICAgIC8gICAgIFxcICAgIFxcXG4gICAgICAgICogICAgICAgLyAgICAgfCAgICAgIFxcICAgICAgICAgICAgICAgIC8gICAgICAgfCAgICAtLS0tXG4gICAgICAgICogICAgICAvICAgICAgfCAgICAgICBcXCAgICAgICAgICAgICAgLyAgICAgICAgIFxcICAgICAgIFxcXG4gICAgICAgICogICB7MSwyfSAgIHszLDR9ICAgIHs1LDYsN30gICAgICB7OCw4LDh9ICAgIHs4LDh9ICAgIHs4LDl9XG4gICAgICAgICogPC9jb2RlPlxuICAgICAgICAqIDwvcHJlPlxuICAgICAgICAqXG4gICAgICAgICogICB0aGUgZGlhZ3JhbSBub3RhdGlvbjpcbiAgICAgICAgKiAgLSBudW1iZXJzIGFyZSBcImtleXNcIiBhcnJheSBpdGVtc1xuICAgICAgICAqICAtIFwiW11cIiBmaWd1cmVzIGFyZSBcImNoaWxkcmVuXCIgYXJyYXkgaXRlbXNcbiAgICAgICAgKlxuICAgICAgICAqIEBhbGlhcyBCX1BsdXNfVHJlZVxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbm9kZUNhcGFjaXR5PTEwXSAtIHRyZWUgbm9kZSBjYXBhY2l0eSAobWF4aW11bSBwb3NzaWJsZSBudW1iZXIgb2YgaXRlbXMgaW4gZWFjaCBub2RlKS5cbiAgICAgICAgKiBAbWVtYmVyb2YgIG1vZHVsZTpjb3JlL2pzZ3VpLWRhdGEtc3RydWN0dXJlcy1iLXBsdXMtdHJlZVxuICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICpcbiAgICAgICAgKiB2YXIgdHJlZSA9IG5ldyBCX1BsdXNfVHJlZSgpO1xuICAgICAgICAqL1xuXG5cbiAgICAgICAgdmFyIG1fcHVibGljID0ge1xuICAgICAgICAgICAgLyoqIFxuICAgICAgICAgICAgKiB0aGUgdHJlZSByb290IG5vZGVcbiAgICAgICAgICAgICogQHR5cGUge0JfUGx1c19Ob2RlfEJfUGx1c19MZWFmfVxuICAgICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICAgICovXG4gICAgICAgICAgICAvLyB0cmVlIHJvb3Q6XG4gICAgICAgICAgICByb290OiBuZXcgQl9QbHVzX0xlYWYobm9kZUNhcGFjaXR5KSxcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvKiogXG4gICAgICAgICAgICAqIGZpcnN0IGxlYWYgaW4gdGhlIFwiYWxsIGxlYXZlc1wiIGNoYWluXG4gICAgICAgICAgICAqIEB0eXBlIHtCX1BsdXNfTGVhZn1cbiAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgLy8gbGVhZnMgY2hhaW46XG4gICAgICAgICAgICBmaXJzdExlYWY6IG51bGwsXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLyoqIFxuICAgICAgICAgICAgKiBsYXN0IGxlYWYgaW4gdGhlIFwiYWxsIGxlYXZlc1wiIGNoYWluXG4gICAgICAgICAgICAqIEB0eXBlIHtCX1BsdXNfTGVhZn1cbiAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgbGFzdExlYWY6IG51bGwsXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgICAvLyAgICAgZWRpdGluZzpcbiAgICAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8qKiBcbiAgICAgICAgICAgICogY2xlYXIgdGhlIHRyZWUgKHJlbW92ZSBhbGwgaXRlbXMpXG4gICAgICAgICAgICAqIEBmdW5jXG4gICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8vIGNsZWFyIHRoZSB0cmVlOlxuICAgICAgICAgICAgY2xlYXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBwX0NsZWFyKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy9cblxuICAgICAgICAgICAgLyoqIFxuICAgICAgICAgICAgKiBpbnNlcnQga2V5IGFuZCB2YWx1ZVxuICAgICAgICAgICAgKiBAbmFtZSBpbnNlcnRcbiAgICAgICAgICAgICogQGZ1bmNcbiAgICAgICAgICAgICogQHZhcmlhdGlvbiAxXG4gICAgICAgICAgICAqIEBwYXJhbSB7Kn0ga2V5XG4gICAgICAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29yZS9qc2d1aS1kYXRhLXN0cnVjdHVyZXMtYi1wbHVzLXRyZWUuQl9QbHVzX1RyZWVcbiAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgIC8qKiBcbiAgICAgICAgICAgICogaW5zZXJ0IGtleSBhbmQgdmFsdWU6IGtleSBpcyBhcnJbMF0sIHZhbHVlIGlzIGFyclsxXTsgaS5lLiBgaW5zZXJ0KFtrZXksIHZhbHVlXSlgXG4gICAgICAgICAgICAqIEBmdW5jXG4gICAgICAgICAgICAqIEB2YXJpYXRpb24gMlxuICAgICAgICAgICAgKiBAcGFyYW0ge2FycmF5fSBhcnJcbiAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICAvLyBpbnNlcnQoa2V5LCB2YWx1ZSlcbiAgICAgICAgICAgIC8vIGluc2VydChba2V5LCB2YWx1ZV0pXG4gICAgICAgICAgICBpbnNlcnQ6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcF9JbnNlcnQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBfSW5zZXJ0KGtleVswXSwga2V5WzFdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy9cblxuICAgICAgICAgICAgLyoqIFxuICAgICAgICAgICAgKiByZW1vdmUgYWxsIHZhbHVlcyB3aXRoIGdpdmVuIGtleVxuICAgICAgICAgICAgKiBAbmFtZSByZW1vdmVcbiAgICAgICAgICAgICogQGZ1bmNcbiAgICAgICAgICAgICogQHBhcmFtIHsqfSBrZXlcbiAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29yZS9qc2d1aS1kYXRhLXN0cnVjdHVyZXMtYi1wbHVzLXRyZWUuQl9QbHVzX1RyZWVcbiAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgIC8qKiBcbiAgICAgICAgICAgICogcmVtb3ZlIG9uZSB2YWx1ZSBvY2N1cnJlbmNlXG4gICAgICAgICAgICAqIEBmdW5jXG4gICAgICAgICAgICAqIEBwYXJhbSB7Kn0ga2V5XG4gICAgICAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAqL1xuXG5cbiAgICAgICAgICAgIC8vIHJlbW92ZShrZXkpIC0gcmVtb3ZlIGFsbCB2YWx1ZXMgd2l0aCBnaXZlbiBrZXlcbiAgICAgICAgICAgIC8vIHJlbW92ZShrZXksIHZhbHVlKSAtIHJlbW92ZSBvbmUgdmFsdWUgb2NjdXJyZW5jZVxuICAgICAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBfUmVtb3ZlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBfUmVtb3ZlS2V5KGtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgIC8vICAgICAgIGZpbmRpbmc6XG4gICAgICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgIC8vXG5cbiAgICAgICAgICAgIC8qKiBcbiAgICAgICAgICAgICogZmluZCB0aGUgdmVyeSBmaXJzdCBpdGVtXG4gICAgICAgICAgICAqIEBmdW5jXG4gICAgICAgICAgICAqIEBuYW1lIGZpbmRGaXJzdFxuICAgICAgICAgICAgKiBAdmFyaWF0aW9uIDFcbiAgICAgICAgICAgICogQHJldHVybnMge21vZHVsZTpjb3JlL2pzZ3VpLWRhdGEtc3RydWN0dXJlcy1iLXBsdXMtdHJlZS5GaW5kSW5mb30gLSBmaW5kIGluZm9cbiAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29yZS9qc2d1aS1kYXRhLXN0cnVjdHVyZXMtYi1wbHVzLXRyZWUuQl9QbHVzX1RyZWVcbiAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgIC8qKiBcbiAgICAgICAgICAgICogZmluZCB0aGUgZmlyc3QgaXRlbSBmb3IgdGhlIGdpdmVuIGtleVxuICAgICAgICAgICAgKiBAZnVuY1xuICAgICAgICAgICAgKiBAbmFtZSBmaW5kRmlyc3RcbiAgICAgICAgICAgICogQHZhcmlhdGlvbiAyXG4gICAgICAgICAgICAqIEBwYXJhbSB7Kn0ga2V5XG4gICAgICAgICAgICAqIEByZXR1cm5zIHttb2R1bGU6Y29yZS9qc2d1aS1kYXRhLXN0cnVjdHVyZXMtYi1wbHVzLXRyZWUuRmluZEluZm99IC0gZmluZCBpbmZvXG4gICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvcmUvanNndWktZGF0YS1zdHJ1Y3R1cmVzLWItcGx1cy10cmVlLkJfUGx1c19UcmVlXG4gICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICAvKiogXG4gICAgICAgICAgICAqIGZpbmQgdGhlIGZpcnN0IGtleSt2YWx1ZSBvY2N1cnJlbmNlXG4gICAgICAgICAgICAqIEBmdW5jXG4gICAgICAgICAgICAqIEBuYW1lIGZpbmRGaXJzdFxuICAgICAgICAgICAgKiBAdmFyaWF0aW9uIDNcbiAgICAgICAgICAgICogQHBhcmFtIHsqfSBrZXlcbiAgICAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAgICAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmNvcmUvanNndWktZGF0YS1zdHJ1Y3R1cmVzLWItcGx1cy10cmVlLkZpbmRJbmZvfSAtIGZpbmQgaW5mb1xuICAgICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICAgICogQG1lbWJlcm9mIG1vZHVsZTpjb3JlL2pzZ3VpLWRhdGEtc3RydWN0dXJlcy1iLXBsdXMtdHJlZS5CX1BsdXNfVHJlZVxuICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgLy8gZmluZEZpcnN0KCkgLSBmaW5kIHRoZSB2ZXJ5IGZpcnN0IGl0ZW1cbiAgICAgICAgICAgIC8vIGZpbmRGaXJzdChrZXkpIC0gZmluZCB0aGUgZmlyc3QgaXRlbSBmb3IgdGhlIGdpdmVuIGtleVxuICAgICAgICAgICAgLy8gZmluZEZpcnN0KGtleSwgdmFsdWUpIC0gZmluZCB0aGUgZmlyc3Qga2V5K3ZhbHVlIG9jY3VycmVuY2VcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyByZXR1cm5zIHRoZSBGaW5kSW5mbyBvYmplY3Q6XG4gICAgICAgICAgICAvLyAgICBrZXk6IGtleSwgICAgIC8vIGtleSB0byBmaW5kIChpZiBwcmVzZW50KVxuICAgICAgICAgICAgLy8gICAgdmFsdWU6IHZhbHVlLCAvLyB2YWx1ZSB0byBmaW5kIChpZiBwcmVzZW50KVxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vICAgIGxlYWY6IG51bGwsICAgLy8gdGhlIGN1cnJlbnQgZm91bmQgbGVhZlxuICAgICAgICAgICAgLy8gICAgaW5kZXg6IC0xLCAgICAvLyB0aGUgY3VycmVudCBmb3VuZCBpbmRleFxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vICAgIGZvdW5kS2V5KCk6ICAgLy8gdGhlIGN1cnJlbnQgZm91bmQga2V5XG4gICAgICAgICAgICAvLyAgICBmb3VuZFZhbHVlKCk6IC8vIHRoZSBjdXJyZW50IGZvdW5kIHZhbHVlXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgZmluZEZpcnN0OiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwX0ZpbmRGaXJzdChrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLyoqIFxuICAgICAgICAgICAgKiBmaW5kIGZpcnN0IGtleSBtYXRjaGluZyB0aGUgcHJlZml4XG4gICAgICAgICAgICAqIEBmdW5jXG4gICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcmVmaXhcbiAgICAgICAgICAgICogQHJldHVybnMge21vZHVsZTpjb3JlL2pzZ3VpLWRhdGEtc3RydWN0dXJlcy1iLXBsdXMtdHJlZS5GaW5kSW5mb30gLSBmaW5kIGluZm9cbiAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29yZS9qc2d1aS1kYXRhLXN0cnVjdHVyZXMtYi1wbHVzLXRyZWUuQl9QbHVzX1RyZWVcbiAgICAgICAgICAgICovXG4gICAgICAgICAgICAvLyBmaW5kIGZpcnN0IGtleSBtYXRjaGluZyB0aGUgcHJlZml4OlxuICAgICAgICAgICAgZmluZEZpcnN0UHJlZml4OiBmdW5jdGlvbiAocHJlZml4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBfRmluZEZpcnN0KHByZWZpeCwgdW5kZWZpbmVkLCB0cnVlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLyoqIFxuICAgICAgICAgICAgKiBmaW5kIG5leHQgc2VhcmNoIGNvbmRpdGlvbnMgb2NjdXJlbmNlXG4gICAgICAgICAgICAqIEBmdW5jXG4gICAgICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOmNvcmUvanNndWktZGF0YS1zdHJ1Y3R1cmVzLWItcGx1cy10cmVlLkZpbmRJbmZvfSBmaW5kSW5mb1xuICAgICAgICAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmNvcmUvanNndWktZGF0YS1zdHJ1Y3R1cmVzLWItcGx1cy10cmVlLkZpbmRJbmZvfSAtIGZpbmQgaW5mb1xuICAgICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICAgICogQG1lbWJlcm9mIG1vZHVsZTpjb3JlL2pzZ3VpLWRhdGEtc3RydWN0dXJlcy1iLXBsdXMtdHJlZS5CX1BsdXNfVHJlZVxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8vIGZpbmQgbmV4dCBzZWFyY2ggY29uZGl0aW9ucyBvY2N1cmVuY2VcbiAgICAgICAgICAgIGZpbmROZXh0OiBmdW5jdGlvbiAoZmluZEluZm8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcF9GaW5kTmV4dChmaW5kSW5mbyk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvKiogXG4gICAgICAgICAgICAqIGZpbmQgdGhlIHZlcnkgbGFzdCBpdGVtXG4gICAgICAgICAgICAqIEBmdW5jXG4gICAgICAgICAgICAqIEBuYW1lIGZpbmRMYXN0XG4gICAgICAgICAgICAqIEB2YXJpYXRpb24gMVxuICAgICAgICAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmNvcmUvanNndWktZGF0YS1zdHJ1Y3R1cmVzLWItcGx1cy10cmVlLkZpbmRJbmZvfSAtIGZpbmQgaW5mb1xuICAgICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICAgICogQG1lbWJlcm9mIG1vZHVsZTpjb3JlL2pzZ3VpLWRhdGEtc3RydWN0dXJlcy1iLXBsdXMtdHJlZS5CX1BsdXNfVHJlZVxuICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgLyoqIFxuICAgICAgICAgICAgKiBmaW5kIHRoZSBsYXN0IGl0ZW0gZm9yIHRoZSBnaXZlbiBrZXlcbiAgICAgICAgICAgICogQGZ1bmNcbiAgICAgICAgICAgICogQG5hbWUgZmluZExhc3RcbiAgICAgICAgICAgICogQHZhcmlhdGlvbiAyXG4gICAgICAgICAgICAqIEBwYXJhbSB7Kn0ga2V5XG4gICAgICAgICAgICAqIEByZXR1cm5zIHttb2R1bGU6Y29yZS9qc2d1aS1kYXRhLXN0cnVjdHVyZXMtYi1wbHVzLXRyZWUuRmluZEluZm99IC0gZmluZCBpbmZvXG4gICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvcmUvanNndWktZGF0YS1zdHJ1Y3R1cmVzLWItcGx1cy10cmVlLkJfUGx1c19UcmVlXG4gICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICAvKiogXG4gICAgICAgICAgICAqICBmaW5kIHRoZSBsYXN0IGtleSt2YWx1ZSBvY2N1cnJlbmNlXG4gICAgICAgICAgICAqIEBmdW5jXG4gICAgICAgICAgICAqIEBuYW1lIGZpbmRMYXN0XG4gICAgICAgICAgICAqIEB2YXJpYXRpb24gM1xuICAgICAgICAgICAgKiBAcGFyYW0geyp9IGtleVxuICAgICAgICAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICAgICAgICAqIEByZXR1cm5zIHttb2R1bGU6Y29yZS9qc2d1aS1kYXRhLXN0cnVjdHVyZXMtYi1wbHVzLXRyZWUuRmluZEluZm99IC0gZmluZCBpbmZvXG4gICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvcmUvanNndWktZGF0YS1zdHJ1Y3R1cmVzLWItcGx1cy10cmVlLkJfUGx1c19UcmVlXG4gICAgICAgICAgICAqL1xuXG5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBmaW5kTGFzdCgpIC0gZmluZCB0aGUgdmVyeSBsYXN0IGl0ZW1cbiAgICAgICAgICAgIC8vIGZpbmRMYXN0KGtleSkgLSBmaW5kIHRoZSBsYXN0IGl0ZW0gZm9yIHRoZSBnaXZlbiBrZXlcbiAgICAgICAgICAgIC8vIGZpbmRMYXN0KGtleSwgdmFsdWUpIC0gZmluZCB0aGUgbGFzdCBrZXkrdmFsdWUgb2NjdXJyZW5jZVxuICAgICAgICAgICAgZmluZExhc3Q6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBfRmluZExhc3Qoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8qKiBcbiAgICAgICAgICAgICogZmluZCBsYXN0IGtleSBtYXRjaGluZyB0aGUgcHJlZml4XG4gICAgICAgICAgICAqIEBmdW5jXG4gICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcmVmaXhcbiAgICAgICAgICAgICogQHJldHVybnMge21vZHVsZTpjb3JlL2pzZ3VpLWRhdGEtc3RydWN0dXJlcy1iLXBsdXMtdHJlZS5GaW5kSW5mb30gLSBmaW5kIGluZm9cbiAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29yZS9qc2d1aS1kYXRhLXN0cnVjdHVyZXMtYi1wbHVzLXRyZWUuQl9QbHVzX1RyZWVcbiAgICAgICAgICAgICovXG4gICAgICAgICAgICAvLyBmaW5kIGxhc3Qga2V5IG1hdGNoaW5nIHRoZSBwcmVmaXg6XG4gICAgICAgICAgICBmaW5kTGFzdFByZWZpeDogZnVuY3Rpb24gKHByZWZpeCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwX0ZpbmRMYXN0KHByZWZpeCwgdW5kZWZpbmVkLCB0cnVlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLyoqIFxuICAgICAgICAgICAgKiBmaW5kIHByZXZpb3VzIHNlYXJjaCBjb25kaXRpb25zIG9jY3VyZW5jZVxuICAgICAgICAgICAgKiBAZnVuY1xuICAgICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTpjb3JlL2pzZ3VpLWRhdGEtc3RydWN0dXJlcy1iLXBsdXMtdHJlZS5GaW5kSW5mb30gZmluZEluZm9cbiAgICAgICAgICAgICogQHJldHVybnMge21vZHVsZTpjb3JlL2pzZ3VpLWRhdGEtc3RydWN0dXJlcy1iLXBsdXMtdHJlZS5GaW5kSW5mb30gLSBmaW5kIGluZm9cbiAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29yZS9qc2d1aS1kYXRhLXN0cnVjdHVyZXMtYi1wbHVzLXRyZWUuQl9QbHVzX1RyZWVcbiAgICAgICAgICAgICovXG4gICAgICAgICAgICAvLyBmaW5kIHByZXZpb3VzIHNlYXJjaCBjb25kaXRpb25zIG9jY3VyZW5jZVxuICAgICAgICAgICAgZmluZFByZXZpb3VzOiBmdW5jdGlvbiAoZmluZEluZm8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcF9GaW5kUHJldihmaW5kSW5mbyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgLy8gZGljdGlvbmFyeS1saWtlIHVzYWdlOlxuICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLyoqIFxuICAgICAgICAgICAgKiBnZXQgb25lIHZhbHVlIGJ5IGtleSAob3IgbnVsbCBpZiB0aGUga2V5IG5vdCBmb3VuZClcbiAgICAgICAgICAgICpcbiAgICAgICAgICAgICogW2dldFZhbHVlKClde0BsaW5rIG1vZHVsZTpjb3JlL2pzZ3VpLWRhdGEtc3RydWN0dXJlcy1iLXBsdXMtdHJlZS5CX1BsdXNfVHJlZSNnZXRWYWx1ZX0gYW5kIFtzZXRWYWx1ZSgpXXtAbGluayBtb2R1bGU6Y29yZS9qc2d1aS1kYXRhLXN0cnVjdHVyZXMtYi1wbHVzLXRyZWUuQl9QbHVzX1RyZWUjc2V0VmFsdWV9IG1ldGhvZHMgcGFpciBwcm92aWRlcyBhIGRpY3Rpb25hcnktbGlrZSB1c2FnZSBwYXR0ZXJuLlxuICAgICAgICAgICAgKlxuICAgICAgICAgICAgKiBAZnVuY1xuICAgICAgICAgICAgKiBAcGFyYW0geyp9IGtleVxuICAgICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICAgICpcbiAgICAgICAgICAgICogdmFyIHRyZWUgPSBuZXcgQl9QbHVzX1RyZWUoKTtcbiAgICAgICAgICAgICogLy9cbiAgICAgICAgICAgICogdHJlZS5zZXRWYWx1ZSgxMDEsIFwidmFsdWUgMTAxXCIpO1xuICAgICAgICAgICAgKiB0cmVlLnNldFZhbHVlKDEwMSwgXCJ2YWx1ZSAxMDEuMlwiKTtcbiAgICAgICAgICAgICpcbiAgICAgICAgICAgICogdHJlZS5nZXRWYWx1ZSgxMDEpIC8vIFwidmFsdWUgMTAxLjJcIlxuICAgICAgICAgICAgKiB0cmVlLmdldFZhbHVlKDEwMikgLy8gbnVsbFxuICAgICAgICAgICAgKlxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8vIGdldCBvbmUgdmFsdWUgYnkga2V5IChvciBudWxsKTpcbiAgICAgICAgICAgIGdldFZhbHVlOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBfR2V0VmFsdWUoa2V5KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvKiogXG4gICAgICAgICAgICAqIHNldCBvbmUgdmFsdWUgYnkga2V5IChpbnNlcnQgb3IgdXBkYXRlKVxuICAgICAgICAgICAgKlxuICAgICAgICAgICAgKiBbZ2V0VmFsdWUoKV17QGxpbmsgbW9kdWxlOmNvcmUvanNndWktZGF0YS1zdHJ1Y3R1cmVzLWItcGx1cy10cmVlLkJfUGx1c19UcmVlI2dldFZhbHVlfSBhbmQgW3NldFZhbHVlKClde0BsaW5rIG1vZHVsZTpjb3JlL2pzZ3VpLWRhdGEtc3RydWN0dXJlcy1iLXBsdXMtdHJlZS5CX1BsdXNfVHJlZSNzZXRWYWx1ZX0gbWV0aG9kcyBwYWlyIHByb3ZpZGVzIGEgZGljdGlvbmFyeS1saWtlIHVzYWdlIHBhdHRlcm4uXG4gICAgICAgICAgICAqXG4gICAgICAgICAgICAqIEBmdW5jXG4gICAgICAgICAgICAqIEBwYXJhbSB7Kn0ga2V5XG4gICAgICAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAgICAqXG4gICAgICAgICAgICAqIHZhciB0cmVlID0gbmV3IEJfUGx1c19UcmVlKCk7XG4gICAgICAgICAgICAqIC8vXG4gICAgICAgICAgICAqIHRyZWUuc2V0VmFsdWUoMTAxLCBcInZhbHVlIDEwMVwiKTsgICAvLyBpbnNlcnRcbiAgICAgICAgICAgICogdHJlZS5zZXRWYWx1ZSgxMDEsIFwidmFsdWUgMTAxLjJcIik7IC8vIHVwZGF0ZVxuICAgICAgICAgICAgKlxuICAgICAgICAgICAgKiB0cmVlLmdldFZhbHVlKDEwMSkgLy8gXCJ2YWx1ZSAxMDEuMlwiXG4gICAgICAgICAgICAqIHRyZWUuZ2V0VmFsdWUoMTAyKSAvLyBudWxsXG4gICAgICAgICAgICAqXG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgLy8gc2V0IG9uZSB2YWx1ZSBieSBrZXkgKGluc2VydCBvciB1cGRhdGUpOlxuICAgICAgICAgICAgc2V0VmFsdWU6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcF9TZXRWYWx1ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgLy8gICBvdGhlciBmdW5jdGlvbnM6XG4gICAgICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgIC8vXG5cbiAgICAgICAgICAgIC8qKiBcbiAgICAgICAgICAgICogY291bnQgYWxsIHZhbHVlc1xuICAgICAgICAgICAgKiBAbmFtZSBjb3VudFxuICAgICAgICAgICAgKiBAZnVuY1xuICAgICAgICAgICAgKiBAdmFyaWF0aW9uIDFcbiAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29yZS9qc2d1aS1kYXRhLXN0cnVjdHVyZXMtYi1wbHVzLXRyZWUuQl9QbHVzX1RyZWVcbiAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgIC8qKiBcbiAgICAgICAgICAgICogY291bnQgdmFsdWVzIHdpdGggdGhlIGdpdmVuIGtleVxuICAgICAgICAgICAgKiBAZnVuY1xuICAgICAgICAgICAgKiBAdmFyaWF0aW9uIDJcbiAgICAgICAgICAgICogQHBhcmFtIHsqfSBrZXlcbiAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICAvLyBjb3VudCgpIC0gY291bnQgYWxsIHZhbHVlc1xuICAgICAgICAgICAgLy8gY291bnQoa2V5KSAtIGNvdW50IHZhbHVlcyB3aXRoIHRoZSBnaXZlbiBrZXlcbiAgICAgICAgICAgIGNvdW50OiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcF9Db3VudEtleShrZXkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwX0NvdW50KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vXG5cbiAgICAgICAgICAgIC8qKiBcbiAgICAgICAgICAgICogcmV0dXJucyB0aGUgdHJlZSBub2RlcyBjYXBhY2l0eSAoYWxzbyByZWZlcnJlZCBzb21ld2hlcmUgYXMgXCJub2RlIG9yZGVyXCIpXG4gICAgICAgICAgICAqIEBmdW5jXG4gICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8vIHRyZWUgY2FwYWNpdHk6XG4gICAgICAgICAgICBnZXRDYXBhY2l0eTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtX25vZGVNYXhDb3VudDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgICAvLyBhZGRpdGlvbmFsIGZ1bmN0aW9uczpcbiAgICAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8qKiBcbiAgICAgICAgICAgICogaXRlcmF0ZSB0aHJvdWdoIGVhY2gga2V5ICsgdmFsdWUgcGFpcjxiciAvPlxuICAgICAgICAgICAgKiBjYWxsYmFjayBpcyBgZnVuY3Rpb24oa2V5LCB2YWx1ZSlgXG4gICAgICAgICAgICAqIEBmdW5jXG4gICAgICAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgICAgKlxuICAgICAgICAgICAgKiB2YXIgdHJlZSA9IG5ldyBCX1BsdXNfVHJlZSgpO1xuICAgICAgICAgICAgKiAvL1xuICAgICAgICAgICAgKiB0cmVlLmluc2VydCgxMDEsIFwidmFsdWUgMTAxXCIpO1xuICAgICAgICAgICAgKiB0cmVlLmluc2VydCgxMDIsIFwidmFsdWUgMTAyXCIpO1xuICAgICAgICAgICAgKiB0cmVlLmluc2VydCgxMDMsIFwidmFsdWUgMTAzXCIpO1xuICAgICAgICAgICAgKiAvL1xuICAgICAgICAgICAgKiB0cmVlLmVhY2goZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgKiAgIGNvbnNvbGUubG9nKFwia2V5PVwiICsga2V5ICsgXCIgdmFsdWU9XCIgKyB2YWx1ZSk7XG4gICAgICAgICAgICAqIH0pO1xuICAgICAgICAgICAgKlxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8vIGl0ZXJhdGUgdGhyb3VnaCBlYWNoIGtleSArIHZhbHVlIHBhaXJcbiAgICAgICAgICAgIC8vIGNhbGxiYWNrIGlzIGZ1bmN0aW9uKGtleSwgdmFsdWUpXG4gICAgICAgICAgICAnZWFjaCc6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHJldHVybiBwX2VhY2goY2FsbGJhY2spO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvKiogXG4gICAgICAgICAgICAqIGdldCBhbGwga2V5c1xuICAgICAgICAgICAgKiBAZnVuY1xuICAgICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICAgICpcbiAgICAgICAgICAgICogdmFyIHRyZWUgPSBuZXcgQl9QbHVzX1RyZWUoKTtcbiAgICAgICAgICAgICogLy9cbiAgICAgICAgICAgICogdHJlZS5pbnNlcnQoMTAxLCBcInZhbHVlIDEwMVwiKTtcbiAgICAgICAgICAgICogdHJlZS5pbnNlcnQoMTAyLCBcInZhbHVlIDEwMlwiKTtcbiAgICAgICAgICAgICogdHJlZS5pbnNlcnQoMTAzLCBcInZhbHVlIDEwM1wiKTtcbiAgICAgICAgICAgICogLy9cbiAgICAgICAgICAgICogY29uc29sZS5sb2codHJlZS5rZXlzKCkpOyAvLyAxMDEsMTAyLDEwM1xuICAgICAgICAgICAgKlxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8vIGdldCBhbGwga2V5c1xuICAgICAgICAgICAgJ2tleXMnOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBfa2V5cygpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvKiogXG4gICAgICAgICAgICAqIGdldCBhbGwgW2tleSwgdmFsdWVdIHBhaXJzXG4gICAgICAgICAgICAqIEBmdW5jXG4gICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgICAgKlxuICAgICAgICAgICAgKiB2YXIgdHJlZSA9IG5ldyBCX1BsdXNfVHJlZSgpO1xuICAgICAgICAgICAgKiAvL1xuICAgICAgICAgICAgKiB0cmVlLmluc2VydCgxMDEsIFwidmFsdWUgMTAxXCIpO1xuICAgICAgICAgICAgKiB0cmVlLmluc2VydCgxMDIsIFwidmFsdWUgMTAyXCIpO1xuICAgICAgICAgICAgKiB0cmVlLmluc2VydCgxMDMsIFwidmFsdWUgMTAzXCIpO1xuICAgICAgICAgICAgKiAvL1xuICAgICAgICAgICAgKiBjb25zb2xlLmxvZyh0cmVlLmtleXNfYW5kX3ZhbHVlcygpKTsgLy8gWzEwMSxcInZhbHVlIDEwMVwiXSxbMTAyLFwidmFsdWUgMTAyXCJdLFsxMDMsXCJ2YWx1ZSAxMDNcIl1cbiAgICAgICAgICAgICpcbiAgICAgICAgICAgICovXG4gICAgICAgICAgICAvLyBnZXQgYWxsIFtrZXksIHZhbHVlXSBwYWlyc1xuICAgICAgICAgICAgJ2tleXNfYW5kX3ZhbHVlcyc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcF9rZXlzX2FuZF92YWx1ZXMoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8qKiBcbiAgICAgICAgICAgICogZ2V0IGtleXMgYW5kIHZhbHVlcyBieSBwcmVmaXhcbiAgICAgICAgICAgICogQGZ1bmNcbiAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHByZWZpeFxuICAgICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICAgICpcbiAgICAgICAgICAgICogdmFyIHRyZWUgPSBuZXcgQl9QbHVzX1RyZWUoKTtcbiAgICAgICAgICAgICogLy9cbiAgICAgICAgICAgICogdHJlZS5pbnNlcnQoXCIxMTFcIiwgXCJ2YWx1ZSAxMTFcIik7XG4gICAgICAgICAgICAqIHRyZWUuaW5zZXJ0KFwiMTIyXCIsIFwidmFsdWUgMTIyXCIpO1xuICAgICAgICAgICAgKiB0cmVlLmluc2VydChcIjEyM1wiLCBcInZhbHVlIDEyM1wiKTtcbiAgICAgICAgICAgICogLy9cbiAgICAgICAgICAgICogY29uc29sZS5sb2codHJlZS5nZXRfYnlfcHJlZml4KFwiMTJcIikpOyAvLyBbXCIxMjJcIixcInZhbHVlIDEyMlwiXSxbXCIxMjNcIixcInZhbHVlIDEyM1wiXVxuICAgICAgICAgICAgKlxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8vIGdldCBrZXlzIGFuZCB2YWx1ZXMgYnkgcHJlZml4XG4gICAgICAgICAgICAnZ2V0X2J5X3ByZWZpeCc6IGZ1bmN0aW9uIChwcmVmaXgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcF9nZXRfYnlfcHJlZml4KHByZWZpeCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8qKiBcbiAgICAgICAgICAgICogZ2V0IGtleXMgYnkgcHJlZml4XG4gICAgICAgICAgICAqIEBmdW5jXG4gICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcmVmaXhcbiAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAgICAqXG4gICAgICAgICAgICAqIHZhciB0cmVlID0gbmV3IEJfUGx1c19UcmVlKCk7XG4gICAgICAgICAgICAqIC8vXG4gICAgICAgICAgICAqIHRyZWUuaW5zZXJ0KFwiMTExXCIsIFwidmFsdWUgMTExXCIpO1xuICAgICAgICAgICAgKiB0cmVlLmluc2VydChcIjEyMlwiLCBcInZhbHVlIDEyMlwiKTtcbiAgICAgICAgICAgICogdHJlZS5pbnNlcnQoXCIxMjNcIiwgXCJ2YWx1ZSAxMjNcIik7XG4gICAgICAgICAgICAqIC8vXG4gICAgICAgICAgICAqIGNvbnNvbGUubG9nKHRyZWUuZ2V0X2tleXNfYnlfcHJlZml4KFwiMTJcIikpOyAvLyBcIjEyMlwiLFwiMTIzXCJcbiAgICAgICAgICAgICpcbiAgICAgICAgICAgICovXG4gICAgICAgICAgICAvLyBnZXQga2V5cyBieSBwcmVmaXhcbiAgICAgICAgICAgICdnZXRfa2V5c19ieV9wcmVmaXgnOiBmdW5jdGlvbiAocHJlZml4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBfZ2V0X2tleXNfYnlfcHJlZml4KHByZWZpeCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8qKiBcbiAgICAgICAgICAgICogZ2V0IHZhbHVlcyByZWxhdGVkIHRvIHRoZSBwYXNzZWQga2V5XG4gICAgICAgICAgICAqIEBmdW5jXG4gICAgICAgICAgICAqIEBwYXJhbSB7Kn0ga2V5XG4gICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgICAgKlxuICAgICAgICAgICAgKiB2YXIgdHJlZSA9IG5ldyBCX1BsdXNfVHJlZSgpO1xuICAgICAgICAgICAgKiAvL1xuICAgICAgICAgICAgKiB0cmVlLmluc2VydChcIjEwMVwiLCBcInZhbHVlIDEwMVwiKTtcbiAgICAgICAgICAgICogdHJlZS5pbnNlcnQoXCIxMDJcIiwgXCJ2YWx1ZSAxMDIuMVwiKTtcbiAgICAgICAgICAgICogdHJlZS5pbnNlcnQoXCIxMDJcIiwgXCJ2YWx1ZSAxMDIuMlwiKTtcbiAgICAgICAgICAgICogLy9cbiAgICAgICAgICAgICogY29uc29sZS5sb2codHJlZS5nZXRfdmFsdWVzX2J5X2tleShcIjEwMlwiKSk7IC8vIFwidmFsdWUgMTAyLjFcIixcInZhbHVlIDEwMi4yXCJcbiAgICAgICAgICAgICpcbiAgICAgICAgICAgICovXG4gICAgICAgICAgICAvLyBnZXQgdmFsdWVzIGF0IGtleS4uLlxuICAgICAgICAgICAgJ2dldF92YWx1ZXNfYnlfa2V5JzogZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwX2dldF92YWx1ZXNfYnlfa2V5KGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gICAgICAgICAgICAgIGluaXRpYWxpemF0aW9uOlxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgIG1fcHVibGljLmZpcnN0TGVhZiA9IG1fcHVibGljLnJvb3Q7XG4gICAgICAgIG1fcHVibGljLmxhc3RMZWFmID0gbV9wdWJsaWMucm9vdDtcblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyAgICAgICAgICAgICAgcHJpdmF0ZSB2YXJpYWJsZXM6XG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgdmFyIG1fbm9kZU1heENvdW50ID0gbm9kZUNhcGFjaXR5O1xuICAgICAgICB2YXIgbV9ub2RlTWluQ291bnQgPSBNYXRoLmZsb29yKG1fbm9kZU1heENvdW50IC8gMik7XG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gICAgICAgICAgICAgICAgIGNsZWFyKCk6XG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgLy8gY2xlYXIgdGhlIHRyZWVcbiAgICAgICAgLy8gKGp1c3QgY3JlYXRlIG5ldyBlbXB0eSByb290KVxuICAgICAgICB2YXIgcF9DbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIG1fcHVibGljLnJvb3QgPSBuZXcgQl9QbHVzX0xlYWYobV9ub2RlTWF4Q291bnQpO1xuICAgICAgICAgICAgbV9wdWJsaWMuZmlyc3RMZWFmID0gbV9wdWJsaWMucm9vdDtcbiAgICAgICAgICAgIG1fcHVibGljLmxhc3RMZWFmID0gbV9wdWJsaWMucm9vdDtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyAgICAgICAgICAgICAgICBpdGVyYXRpb25zOlxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgIHZhciBwX2tleXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmVzID0gW107XG4gICAgICAgICAgICBfcF9lYWNoX2tleShmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgcmVzLnB1c2goa2V5KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwX2tleXNfYW5kX3ZhbHVlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByZXMgPSBbXTtcbiAgICAgICAgICAgIHBfZWFjaChmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJlcy5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgX3BfZWFjaF9rZXkgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHZhciBmaW5kSW5mbyA9IHBfRmluZEZpcnN0KCk7XG4gICAgICAgICAgICB3aGlsZSAoZmluZEluZm8gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhciBmayA9IGZpbmRJbmZvLmZvdW5kS2V5KCk7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZmspO1xuICAgICAgICAgICAgICAgIGZpbmRJbmZvID0gcF9GaW5kTmV4dChmaW5kSW5mbyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcF9lYWNoID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB2YXIgZmluZEluZm8gPSBwX0ZpbmRGaXJzdCgpO1xuXG4gICAgICAgICAgICB2YXIgZG9TdG9wID0gZmFsc2U7XG4gICAgICAgICAgICBcblxuICAgICAgICAgICAgd2hpbGUgKGZpbmRJbmZvICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvL3ZhciBzdG9wID0gXG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnZG9TdG9wICcgKyBkb1N0b3ApO1xuICAgICAgICAgICAgICAgIHZhciBmayA9IGZpbmRJbmZvLmZvdW5kS2V5KCk7XG4gICAgICAgICAgICAgICAgdmFyIGZ2ID0gZmluZEluZm8uZm91bmRWYWx1ZSgpO1xuICAgICAgICAgICAgICAgIC8vIGNhbGxiYWNrIHdpdGggdGhlIGtleSBhbmQgdGhlIHZhbHVlXG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZmssIGZ2LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgLy90aHJvdyAnc3RvcCc7XG4gICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3N0b3AhISEnKTtcbiAgICAgICAgICAgICAgICAgICAgZG9TdG9wID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCcyKSBkb1N0b3AgJyArIGRvU3RvcCk7XG4gICAgICAgICAgICAgICAgaWYgKGRvU3RvcCkge1xuICAgICAgICAgICAgICAgICAgICBmaW5kSW5mbyA9IG51bGw7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZmluZEluZm8gPSBwX0ZpbmROZXh0KGZpbmRJbmZvKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyAgICAgICAgICAgICAgICBpbnNlcnQoKTpcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICAvLyBpbnNlcnQgKGtleSwgdmFsdWUpIGl0ZW0gdG8gdGhlIHRyZWVcbiAgICAgICAgdmFyIHBfSW5zZXJ0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBzZWFyY2ggbGVhZiB0byBpbnNlcnQ6XG4gICAgICAgICAgICB2YXIgc2VhcmNoUmVzdWx0ID0gc2VhcmNoTGVhZihrZXkpO1xuICAgICAgICAgICAgdmFyIGxlYWYgPSBzZWFyY2hSZXN1bHQubm9kZTtcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBpbnNlcnQgdG8gdGhlIGxlYWY6XG4gICAgICAgICAgICBsZWFmLmtleXMuaW5zZXJ0KHNlYXJjaFJlc3VsdC5pbmRleCwga2V5KTtcbiAgICAgICAgICAgIGxlYWYudmFsdWVzLmluc2VydChzZWFyY2hSZXN1bHQuaW5kZXgsIHZhbHVlKTtcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBpZiBvdmVyZmxvdzpcbiAgICAgICAgICAgIGlmIChsZWFmLmtleXMuY291bnQgPiBtX25vZGVNYXhDb3VudCkge1xuICAgICAgICAgICAgICAgIGlmICgobGVhZi5wcmV2TGVhZiAhPSBudWxsKSAmJiAobGVhZi5wcmV2TGVhZi5rZXlzLmNvdW50IDwgbV9ub2RlTWF4Q291bnQpICYmIChsZWFmLnByZXZMZWFmLnBhcmVudCA9PSBsZWFmLnBhcmVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcm90YXRlQW1vbmdMZWF2ZXNUb0xlZnQobGVhZi5wcmV2TGVhZiwgbGVhZik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICgobGVhZi5uZXh0TGVhZiAhPSBudWxsKSAmJiAobGVhZi5uZXh0TGVhZi5rZXlzLmNvdW50IDwgbV9ub2RlTWF4Q291bnQpICYmIChsZWFmLm5leHRMZWFmLnBhcmVudCA9PSBsZWFmLnBhcmVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcm90YXRlQW1vbmdMZWF2ZXNUb1JpZ2h0KGxlYWYsIGxlYWYubmV4dExlYWYpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNwbGl0TGVhZihsZWFmKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gc3BsaXQgbGVhZiB0byAyIGxlYXZlc1xuICAgICAgICAvLyAoY3JlYXRlIHJpZ2h0IHNpYmxpbmcpXG4gICAgICAgIHZhciBzcGxpdExlYWYgPSBmdW5jdGlvbiAobGVhZikge1xuICAgICAgICAgICAgdmFyIGxlZnRDb3VudCA9IG1fbm9kZU1pbkNvdW50O1xuICAgICAgICAgICAgdmFyIHJpZ2h0Q291bnQgPSBsZWFmLmtleXMuY291bnQgLSBsZWZ0Q291bnQ7XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gY3JlYXRlIHJpZ2h0IGxlYWY6XG4gICAgICAgICAgICB2YXIgbmV3UmlnaHRMZWFmID0gbmV3IEJfUGx1c19MZWFmKG1fbm9kZU1heENvdW50KTtcbiAgICAgICAgICAgIG5ld1JpZ2h0TGVhZi5wYXJlbnQgPSBsZWFmLnBhcmVudDtcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBjb3B5IHRvIHRoZSByaWdodDpcbiAgICAgICAgICAgIG5ld1JpZ2h0TGVhZi5rZXlzLmNvcHlfZnJvbShsZWFmLmtleXMsIGxlZnRDb3VudCwgcmlnaHRDb3VudCk7XG4gICAgICAgICAgICBuZXdSaWdodExlYWYudmFsdWVzLmNvcHlfZnJvbShsZWFmLnZhbHVlcywgbGVmdENvdW50LCByaWdodENvdW50KTtcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyB1cGRhdGUgdGhlIGxlZnQ6XG4gICAgICAgICAgICBsZWFmLmtleXMuY291bnQgPSBsZWZ0Q291bnQ7XG4gICAgICAgICAgICBsZWFmLnZhbHVlcy5jb3VudCA9IGxlZnRDb3VudDtcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyB1cGRhdGUgbGVhZnMgY2hhaW46XG4gICAgICAgICAgICBuZXdSaWdodExlYWYubmV4dExlYWYgPSBsZWFmLm5leHRMZWFmO1xuICAgICAgICAgICAgaWYgKG5ld1JpZ2h0TGVhZi5uZXh0TGVhZiAhPSBudWxsKSBuZXdSaWdodExlYWYubmV4dExlYWYucHJldkxlYWYgPSBuZXdSaWdodExlYWY7XG4gICAgICAgICAgICBuZXdSaWdodExlYWYucHJldkxlYWYgPSBsZWFmO1xuICAgICAgICAgICAgbGVhZi5uZXh0TGVhZiA9IG5ld1JpZ2h0TGVhZjtcbiAgICAgICAgICAgIGlmIChtX3B1YmxpYy5sYXN0TGVhZiA9PSBsZWFmKSBtX3B1YmxpYy5sYXN0TGVhZiA9IG5ld1JpZ2h0TGVhZjtcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyB1cGRhdGUgcGFyZW50OlxuICAgICAgICAgICAgaWYgKGxlYWYucGFyZW50ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGVhZkluZGV4ID0gY2FsY0NoaWxkSW5kZXgobGVhZi5wYXJlbnQsIGxlYWYpO1xuICAgICAgICAgICAgICAgIGluc2VydFRvUGFyZW50KGxlYWYucGFyZW50LCBuZXdSaWdodExlYWYsIG5ld1JpZ2h0TGVhZi5rZXlzLmZpcnN0KCksIGxlYWZJbmRleCArIDEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjcmVhdGVOZXdSb290KGxlYWYsIG5ld1JpZ2h0TGVhZiwgbmV3UmlnaHRMZWFmLmtleXMuZmlyc3QoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gY3JlYXRlIG5ldyByb290XG4gICAgICAgIHZhciBjcmVhdGVOZXdSb290ID0gZnVuY3Rpb24gKG5vZGVMZWZ0LCBub2RlUmlnaHQsIGtleSkge1xuICAgICAgICAgICAgLy8gY3JlYXRlIG5ldyByb290IGNvbnRhaW5pbmcgbm9kZUxlZnQgYW5kIG5vZGVSaWdodCBjaGlsZHJlblxuICAgICAgICAgICAgLy8gYnR3IG5vZGVMZWZ0IGFuZCBub2RlUmlnaHQgY2FuIGJlIGxlYXZlc1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIGNyZWF0ZSB0aGUgcm9vdCBub2RlOlxuICAgICAgICAgICAgdmFyIG5ld1Jvb3QgPSBuZXcgQl9QbHVzX05vZGUobV9ub2RlTWF4Q291bnQpO1xuICAgICAgICAgICAgbmV3Um9vdC5rZXlzLmFkZChrZXkpO1xuICAgICAgICAgICAgbmV3Um9vdC5jaGlsZHJlbi5hZGQobm9kZUxlZnQpO1xuICAgICAgICAgICAgbmV3Um9vdC5jaGlsZHJlbi5hZGQobm9kZVJpZ2h0KTtcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyB1cGRhdGUgcGFyZW50IHJlZmVyZW5jZXM6XG4gICAgICAgICAgICBub2RlTGVmdC5wYXJlbnQgPSBuZXdSb290O1xuICAgICAgICAgICAgbm9kZVJpZ2h0LnBhcmVudCA9IG5ld1Jvb3Q7XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gdXBkYXRlIHJvb3QgcmVmZXJlbmNlOlxuICAgICAgICAgICAgbV9wdWJsaWMucm9vdCA9IG5ld1Jvb3Q7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gaW5zZXJ0IG5ld0NoaWxkTm9kZSB3aXRoIGtleSBuZXdDaGlsZEZpcnN0S2V5IGludG8gdGhlIHBhcmVudE5vZGVcbiAgICAgICAgLy8gdGhlIG5ld0NoaWxkTm9kZSBpbnNlcnRzIGludG8gdGhlIG5ld0NoaWxkSW5kZXggcG9zaXRpb24gaW4gdGhlIGNoaWxkcmVuXG4gICAgICAgIHZhciBpbnNlcnRUb1BhcmVudCA9IGZ1bmN0aW9uIChwYXJlbnROb2RlLCBuZXdDaGlsZE5vZGUsIG5ld0NoaWxkRmlyc3RLZXksIG5ld0NoaWxkSW5kZXgpIHtcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBpbnNlcnQgY2hpbGQgaW5mbzpcbiAgICAgICAgICAgIHBhcmVudE5vZGUua2V5cy5pbnNlcnQobmV3Q2hpbGRJbmRleCAtIDEsIG5ld0NoaWxkRmlyc3RLZXkpOyAvLyAtMTogdGhlIHJlbGF0ZWQga2V5IGlzIFwiYmVmb3JlXCIgdGhlIGNoaWxkXG4gICAgICAgICAgICBwYXJlbnROb2RlLmNoaWxkcmVuLmluc2VydChuZXdDaGlsZEluZGV4LCBuZXdDaGlsZE5vZGUpO1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIHVwZGF0ZSBwYXJlbnQgcmVmZXJlbmNlOlxuICAgICAgICAgICAgbmV3Q2hpbGROb2RlLnBhcmVudCA9IHBhcmVudE5vZGU7XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gdXBkYXRlIHBhcmVudCBpZiBvdmVyZmxvdzpcbiAgICAgICAgICAgIGlmIChwYXJlbnROb2RlLmtleXMuY291bnQgPiBtX25vZGVNYXhDb3VudCkge1xuICAgICAgICAgICAgICAgIHNwbGl0Tm9kZShwYXJlbnROb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBzcGxpdCB0aGUgb3ZlcmZsb3dlZCBub2RlIGludG8gMiBub2Rlc1xuICAgICAgICB2YXIgc3BsaXROb2RlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIC8vIHNwbGl0IG5vZGU6IGNyZWF0ZSByaWdodCBzaWJsaW5nXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgdmFyIG5ld0xlZnRDb3VudCA9IG1fbm9kZU1pbkNvdW50O1xuICAgICAgICAgICAgdmFyIG5ld1JpZ2h0Q291bnQgPSBtX25vZGVNYXhDb3VudCAtIG5ld0xlZnRDb3VudDtcbiAgICAgICAgICAgIHZhciBtaWRkbGVLZXkgPSBub2RlLmtleXMuaXRlbXNbbmV3TGVmdENvdW50XTsgLy8ga2V5IHRvIG1vdmUgdXBcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBjcmVhdGUgcmlnaHQgbm9kZTpcbiAgICAgICAgICAgIHZhciBuZXdSaWdodE5vZGUgPSBuZXcgQl9QbHVzX05vZGUobV9ub2RlTWF4Q291bnQpO1xuICAgICAgICAgICAgbmV3UmlnaHROb2RlLmtleXMuY29weV9mcm9tKG5vZGUua2V5cywgbmV3TGVmdENvdW50ICsgMSwgbmV3UmlnaHRDb3VudCk7XG4gICAgICAgICAgICBuZXdSaWdodE5vZGUuY2hpbGRyZW4uY29weV9mcm9tKG5vZGUuY2hpbGRyZW4sIG5ld0xlZnRDb3VudCArIDEsIG5ld1JpZ2h0Q291bnQgKyAxKTtcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyB1cGRhdGUgdGhlIG5vZGU6XG4gICAgICAgICAgICBub2RlLmtleXMuY291bnQgPSBuZXdMZWZ0Q291bnQ7XG4gICAgICAgICAgICBub2RlLmNoaWxkcmVuLmNvdW50ID0gbmV3TGVmdENvdW50ICsgMTtcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyB1cGRhdGUgY2hpbGRyZW4ncyBwYXJlbnQ6XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5ld1JpZ2h0Tm9kZS5jaGlsZHJlbi5jb3VudDsgaSsrKSBuZXdSaWdodE5vZGUuY2hpbGRyZW4uaXRlbXNbaV0ucGFyZW50ID0gbmV3UmlnaHROb2RlO1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIHVwZGF0ZSBwYXJlbnQ6XG4gICAgICAgICAgICBpZiAobm9kZS5wYXJlbnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNyZWF0ZU5ld1Jvb3Qobm9kZSwgbmV3UmlnaHROb2RlLCBtaWRkbGVLZXkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZUluZGV4ID0gY2FsY0NoaWxkSW5kZXgobm9kZS5wYXJlbnQsIG5vZGUpO1xuICAgICAgICAgICAgICAgIGluc2VydFRvUGFyZW50KG5vZGUucGFyZW50LCBuZXdSaWdodE5vZGUsIG1pZGRsZUtleSwgbm9kZUluZGV4ICsgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gICAgICAgICAgICAgICAgcmVtb3ZlKCk6XG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgLy8gcmVtb3ZlIChrZXksIHZhbHVlKSBpdGVtIGZyb20gdGhlIHRyZWVcbiAgICAgICAgdmFyIHBfUmVtb3ZlID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBzZWFyY2hSZXN1bHQgPSBzZWFyY2hMZWFmVmFsdWUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICBpZiAoIXNlYXJjaFJlc3VsdC5mb3VuZCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIHJlbW92ZUZyb21MZWFmKHNlYXJjaFJlc3VsdC5ub2RlLCBzZWFyY2hSZXN1bHQuaW5kZXgpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gcmVtb3ZlIGFsbCB0aGUgaXRlbXMgd2l0aCBnaXZlbiBrZXlcbiAgICAgICAgdmFyIHBfUmVtb3ZlS2V5ID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VhcmNoUmVzdWx0ID0gc2VhcmNoTGVhZihrZXkpO1xuICAgICAgICAgICAgICAgIGlmICghc2VhcmNoUmVzdWx0LmZvdW5kKSBicmVhaztcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIHJlbW92ZUZyb21MZWFmKHNlYXJjaFJlc3VsdC5ub2RlLCBzZWFyY2hSZXN1bHQuaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIHJlbW92ZSB0aGUgaXRlbSBmcm9tIGluZGV4IHBvc2l0aW9uIG9mIHRoZSBsZWFmXG4gICAgICAgIHZhciByZW1vdmVGcm9tTGVhZiA9IGZ1bmN0aW9uIChsZWFmLCBpbmRleCkge1xuICAgICAgICAgICAgbGVhZi5rZXlzLnJlbW92ZUF0KGluZGV4KTtcbiAgICAgICAgICAgIGxlYWYudmFsdWVzLnJlbW92ZUF0KGluZGV4KTtcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyB0aGUgaXRlbSBpcyByZW1vdmVkOyB0aGVuIHVwZGF0ZSB0aGUgdHJlZSBpZiB0aGUgbGVhZiBpcyB1bmRlcmZsb3dlZDpcbiAgICAgICAgICAgIGlmIChsZWFmLmtleXMuY291bnQgPCBtX25vZGVNaW5Db3VudCkge1xuICAgICAgICAgICAgICAgIGlmICgobGVhZi5wcmV2TGVhZiAhPSBudWxsKSAmJiAobGVhZi5wYXJlbnQgPT0gbGVhZi5wcmV2TGVhZi5wYXJlbnQpICYmIChsZWFmLnByZXZMZWFmLmtleXMuY291bnQgPiBtX25vZGVNaW5Db3VudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcm90YXRlQW1vbmdMZWF2ZXNUb1JpZ2h0KGxlYWYucHJldkxlYWYsIGxlYWYpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoKGxlYWYubmV4dExlYWYgIT0gbnVsbCkgJiYgKGxlYWYucGFyZW50ID09IGxlYWYubmV4dExlYWYucGFyZW50KSAmJiAobGVhZi5uZXh0TGVhZi5rZXlzLmNvdW50ID4gbV9ub2RlTWluQ291bnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvdGF0ZUFtb25nTGVhdmVzVG9MZWZ0KGxlYWYsIGxlYWYubmV4dExlYWYpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1lcmdlTGVhZihsZWFmKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBtZXJnZSB0aGUgdW5kZXJmbG93ZWQgbGVhZiB3aXRoIGxlZnQgb3IgcmlnaHQgc2libGluZyBcbiAgICAgICAgdmFyIG1lcmdlTGVhZiA9IGZ1bmN0aW9uIChsZWFmKSB7XG4gICAgICAgICAgICAvLyBpZiB0aGUgbGVhZiBpcyByb290LCB0aGVuIHVuZGVyZmxvdyBpcyBhbGxvd2VkOlxuICAgICAgICAgICAgaWYgKGxlYWYucGFyZW50ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gY2FsY3VsYXRlIGtleXMgY291bnQgaW4gbGVmdCBhbmQgcmlnaHQgc2libGluZzpcbiAgICAgICAgICAgIHZhciBsZWZ0Q291bnQgPSBtX25vZGVNYXhDb3VudCArIDE7XG4gICAgICAgICAgICB2YXIgcmlnaHRDb3VudCA9IG1fbm9kZU1heENvdW50ICsgMTtcbiAgICAgICAgICAgIGlmICgobGVhZi5wcmV2TGVhZiAhPSBudWxsKSAmJiAobGVhZi5wcmV2TGVhZi5wYXJlbnQgPT0gbGVhZi5wYXJlbnQpKSB7XG4gICAgICAgICAgICAgICAgbGVmdENvdW50ID0gbGVhZi5wcmV2TGVhZi5rZXlzLmNvdW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChsZWFmLm5leHRMZWFmICE9IG51bGwpICYmIChsZWFmLm5leHRMZWFmLnBhcmVudCA9PSBsZWFmLnBhcmVudCkpIHtcbiAgICAgICAgICAgICAgICByaWdodENvdW50ID0gbGVhZi5uZXh0TGVhZi5rZXlzLmNvdW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIHNlbGVjdCBzaWJsaW5nIHRvIG1lcmdlOlxuICAgICAgICAgICAgaWYgKGxlZnRDb3VudCA8IHJpZ2h0Q291bnQpIHtcbiAgICAgICAgICAgICAgICBpZiAobGVmdENvdW50ICsgbGVhZi5rZXlzLmNvdW50ID4gbV9ub2RlTWF4Q291bnQpIHRocm93IFwiQl9QbHVzX1RyZWUubWVyZ2VMZWFmKCk6IGxlZnRDb3VudFwiO1xuICAgICAgICAgICAgICAgIG1lcmdlTGVhdmVzKGxlYWYucHJldkxlYWYsIGxlYWYpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAocmlnaHRDb3VudCArIGxlYWYua2V5cy5jb3VudCA+IG1fbm9kZU1heENvdW50KSB0aHJvdyBcIkJfUGx1c19UcmVlLm1lcmdlTGVhZigpOiByaWdodENvdW50XCI7XG4gICAgICAgICAgICAgICAgbWVyZ2VMZWF2ZXMobGVhZiwgbGVhZi5uZXh0TGVhZik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gbWVyZ2UgMiBsZWFmIG5vZGVzOiBsZWFmTGVmdCBhbmQgbGVhZlJpZ2h0XG4gICAgICAgIHZhciBtZXJnZUxlYXZlcyA9IGZ1bmN0aW9uIChsZWFmTGVmdCwgbGVhZlJpZ2h0KSB7IC8vIG1lcmdlIChsZWZ0ICsgcmlnaHQpIC0+IGxlZnRcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBhZGQgcmlnaHQgdG8gbGVmdDpcbiAgICAgICAgICAgIGxlYWZMZWZ0LmtleXMuYWRkX2Zyb20obGVhZlJpZ2h0LmtleXMpO1xuICAgICAgICAgICAgbGVhZkxlZnQudmFsdWVzLmFkZF9mcm9tKGxlYWZSaWdodC52YWx1ZXMpO1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIHVwZGF0ZSBsZWFmcyBjaGFpbjpcbiAgICAgICAgICAgIGxlYWZMZWZ0Lm5leHRMZWFmID0gbGVhZlJpZ2h0Lm5leHRMZWFmO1xuICAgICAgICAgICAgaWYgKGxlYWZMZWZ0Lm5leHRMZWFmICE9IG51bGwpIGxlYWZMZWZ0Lm5leHRMZWFmLnByZXZMZWFmID0gbGVhZkxlZnQ7XG4gICAgICAgICAgICBpZiAobV9wdWJsaWMubGFzdExlYWYgPT0gbGVhZlJpZ2h0KSBtX3B1YmxpYy5sYXN0TGVhZiA9IGxlYWZMZWZ0O1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIHJlbW92ZSByaWdodCBmcm9tIHBhcmVudDpcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSBsZWFmUmlnaHQucGFyZW50O1xuICAgICAgICAgICAgdmFyIGxlYWZSaWdodEluZGV4ID0gY2FsY0NoaWxkSW5kZXgocGFyZW50LCBsZWFmUmlnaHQpO1xuICAgICAgICAgICAgcGFyZW50LmtleXMucmVtb3ZlQXQobGVhZlJpZ2h0SW5kZXggLSAxKTtcbiAgICAgICAgICAgIHBhcmVudC5jaGlsZHJlbi5yZW1vdmVBdChsZWFmUmlnaHRJbmRleCk7XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gdXBkYXRlIHBhcmVudCBpZiB1bmRlcmZsb3c6XG4gICAgICAgICAgICBpZiAocGFyZW50LmtleXMuY291bnQgPCBtX25vZGVNaW5Db3VudCkge1xuICAgICAgICAgICAgICAgIG1lcmdlTm9kZShwYXJlbnQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBmaXggdW5kZXJmbG93ZXIgaW5kZXggKG5vbi1sZWFmKSBub2RlOlxuICAgICAgICAvLyByb3RhdGUgYW1vbmcgc2libGluZywgb3IgbWVyZ2Ugd2l0aCBzaWJsaW5nXG4gICAgICAgIHZhciBtZXJnZU5vZGUgPSBmdW5jdGlvbiAobm9kZSkgeyAvLyBtZXJnZSB0aGUgbm9kZSB3aXRoIHNpYmxpbmdcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSBub2RlLnBhcmVudDtcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyByZW1vdmUgcm9vdCBpZiB0aGUgbm9kZSBiZWNhbWUgZW1wdHkgcm9vdDpcbiAgICAgICAgICAgIGlmIChub2RlLnBhcmVudCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUua2V5cy5jb3VudCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG1fcHVibGljLnJvb3QgPSBub2RlLmNoaWxkcmVuLml0ZW1zWzBdO1xuICAgICAgICAgICAgICAgICAgICBtX3B1YmxpYy5yb290LnBhcmVudCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBmaW5kIGxlZnQgYW5kIHJpZ2h0IHNpYmxpbmdzOlxuICAgICAgICAgICAgdmFyIG5vZGVJbmRleCA9IGNhbGNDaGlsZEluZGV4KHBhcmVudCwgbm9kZSk7XG4gICAgICAgICAgICB2YXIgbGVmdFNpYmxpbmcgPSAobm9kZUluZGV4ID4gMCkgPyBwYXJlbnQuY2hpbGRyZW4uaXRlbXNbbm9kZUluZGV4IC0gMV0gOiBudWxsO1xuICAgICAgICAgICAgdmFyIHJpZ2h0U2libGluZyA9ICgobm9kZUluZGV4ICsgMSkgPCBwYXJlbnQuY2hpbGRyZW4uY291bnQpID8gcGFyZW50LmNoaWxkcmVuLml0ZW1zW25vZGVJbmRleCArIDFdIDogbnVsbDtcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyB0cnkgcm90YXRpb246XG4gICAgICAgICAgICBpZiAoKGxlZnRTaWJsaW5nICE9IG51bGwpICYmIChsZWZ0U2libGluZy5rZXlzLmNvdW50ID4gbV9ub2RlTWluQ291bnQpKSB7XG4gICAgICAgICAgICAgICAgcm90YXRlQW1vbmdOb2Rlc1RvUmlnaHQobGVmdFNpYmxpbmcsIG5vZGUpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgocmlnaHRTaWJsaW5nICE9IG51bGwpICYmIChyaWdodFNpYmxpbmcua2V5cy5jb3VudCA+IG1fbm9kZU1pbkNvdW50KSkge1xuICAgICAgICAgICAgICAgIHJvdGF0ZUFtb25nTm9kZXNUb0xlZnQobm9kZSwgcmlnaHRTaWJsaW5nKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gY2FsY3VsYXRlIHNpYmxpbmdzIGtleSBjb3VudDpcbiAgICAgICAgICAgIHZhciBsZWZ0Q291bnQgPSBtX25vZGVNYXhDb3VudCArIDE7XG4gICAgICAgICAgICB2YXIgcmlnaHRDb3VudCA9IG1fbm9kZU1heENvdW50ICsgMTtcbiAgICAgICAgICAgIGlmIChsZWZ0U2libGluZyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbGVmdENvdW50ID0gbGVmdFNpYmxpbmcua2V5cy5jb3VudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyaWdodFNpYmxpbmcgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJpZ2h0Q291bnQgPSByaWdodFNpYmxpbmcua2V5cy5jb3VudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBzZWxlY3Qgc2libGluZyB0byBtZXJnZTpcbiAgICAgICAgICAgIGlmIChsZWZ0Q291bnQgPCByaWdodENvdW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKGxlZnRTaWJsaW5nID09IG51bGwpIHRocm93IFwiQl9QbHVzX1RyZWUubWVyZ2VOb2RlKCk6IGxlZnRTaWJsaW5nXCI7XG4gICAgICAgICAgICAgICAgbWVyZ2VOb2RlcyhsZWZ0U2libGluZywgbm9kZSwgbm9kZUluZGV4KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHJpZ2h0U2libGluZyA9PSBudWxsKSB0aHJvdyBcIkJfUGx1c19UcmVlLm1lcmdlTm9kZSgpOiByaWdodFNpYmxpbmdcIjtcbiAgICAgICAgICAgICAgICBtZXJnZU5vZGVzKG5vZGUsIHJpZ2h0U2libGluZywgbm9kZUluZGV4ICsgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gbWVyZ2UgMiBpbmRleCAobm9uLWxlYWYpIG5vZGVzIG5vZGVMZWZ0IGFuZCBub2RlUmlnaHQgaW50byBvbmUgbm9kZVxuICAgICAgICAvLyB0aGUgbm9kZVJpZ2h0SW5kZXggaXMgdGhlIG5vZGVSaWdodCBpbmRleCBpbiBwYXJlbnQncyBjaGlsZHJlbiBhcnJheTtcbiAgICAgICAgLy8gdGhlIG5vZGVSaWdodEluZGV4IGlzIGtub3duIGluIGNhbGxlciwgc28gaXQncyBub3QgbmVlZGVkIHRvIGNhbGN1bGF0ZSBpdCBoZXJlXG4gICAgICAgIHZhciBtZXJnZU5vZGVzID0gZnVuY3Rpb24gKG5vZGVMZWZ0LCBub2RlUmlnaHQsIG5vZGVSaWdodEluZGV4KSB7IC8vIG1lcmdlIChsZWZ0ICsgcmlnaHQpIC0+IGxlZnRcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSBub2RlTGVmdC5wYXJlbnQ7XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gdXBkYXRlIHJpZ2h0IGNoaWxkcmVuIHBhcmVudDpcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZVJpZ2h0LmNoaWxkcmVuLmNvdW50OyBpKyspIG5vZGVSaWdodC5jaGlsZHJlbi5pdGVtc1tpXS5wYXJlbnQgPSBub2RlTGVmdDtcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBtb3ZlIGRvd24ga2V5IGZyb20gcGFyZW50OlxuICAgICAgICAgICAgbm9kZUxlZnQua2V5cy5hZGQobm9kZUxlZnQucGFyZW50LmtleXMuaXRlbXNbbm9kZVJpZ2h0SW5kZXggLSAxXSk7XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gYWRkIHJpZ2h0IHRvIGxlZnQ6XG4gICAgICAgICAgICBub2RlTGVmdC5rZXlzLmFkZF9mcm9tKG5vZGVSaWdodC5rZXlzKTtcbiAgICAgICAgICAgIG5vZGVMZWZ0LmNoaWxkcmVuLmFkZF9mcm9tKG5vZGVSaWdodC5jaGlsZHJlbik7XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gcmVtb3ZlIHJpZ2h0IGZyb20gcGFyZW50OlxuICAgICAgICAgICAgcGFyZW50LmtleXMucmVtb3ZlQXQobm9kZVJpZ2h0SW5kZXggLSAxKTtcbiAgICAgICAgICAgIHBhcmVudC5jaGlsZHJlbi5yZW1vdmVBdChub2RlUmlnaHRJbmRleCk7XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gdXBkYXRlIHBhcmVudCBpZiB1bmRlcmZsb3c6XG4gICAgICAgICAgICBpZiAocGFyZW50LmtleXMuY291bnQgPCBtX25vZGVNaW5Db3VudCkge1xuICAgICAgICAgICAgICAgIG1lcmdlTm9kZShwYXJlbnQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcblxuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vICAgICAgICAgIGZpbmRGaXJzdCgpIC8gZmluZE5leHQoKTpcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICAvLyBGaW5kSW5mbyBuZXN0ZWQgY2xhc3NcbiAgICAgICAgLy8gY29udGFpbnMgdGhlIHNlYXJjaCBjcml0ZXJpYSAoa2V5LCB2YWx1ZSkgYW5kIHNlYXJjaCByZXN1bHQgKGxlYWYsIGluZGV4KVxuXG5cbiAgICAgICAgLy8gZmluZCBmaXJzdCBpdGVtIG1hdGNoaW5nIChrZXksIHZhbHVlKSBzZWFyY2ggY3JpdGVyaWFcbiAgICAgICAgLy8gdXNlIGNhc2VzOlxuICAgICAgICAvLyBwX0ZpbmRGaXJzdCgpXG4gICAgICAgIC8vIHBfRmluZEZpcnN0KGtleSlcbiAgICAgICAgLy8gcF9GaW5kRmlyc3Qoa2V5LCB2YWx1ZSlcbiAgICAgICAgLy8gcF9GaW5kRmlyc3Qoa2V5LCB1bmRlZmluZWQsIHRydWUpXG4gICAgICAgIHZhciBwX0ZpbmRGaXJzdCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlLCBpc1ByZWZpeFNlYXJjaCkge1xuICAgICAgICAgICAgdmFyIGZpbmRJbmZvID0gbmV3IEZpbmRJbmZvKGtleSwgdmFsdWUsIGlzUHJlZml4U2VhcmNoKTtcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICBpZiAoZmluZEluZm8uaXNLZXlQcmVzZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpbmRJbmZvLmlzUHJlZml4U2VhcmNoICYmIGZpbmRJbmZvLmlzVmFsdWVQcmVzZW50KSB0aHJvdyBcIkJfUGx1c19UcmVlLnBfRmluZEZpcnN0KCk6IGFyZ3VtZW50cyBlcnJvcjogaXNQcmVmaXhTZWFyY2gsIGJ1dCB2YWx1ZSBpcyBwcmVzZW50XCI7XG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICB2YXIgc2VhcmNoUmVzdWx0ID0gZmluZEluZm8uaXNWYWx1ZVByZXNlbnQgPyBzZWFyY2hMZWFmVmFsdWUoa2V5LCB2YWx1ZSkgOiBzZWFyY2hMZWFmKGtleSk7XG4gICAgICAgICAgICAgICAgZmluZEluZm8ubGVhZiA9IHNlYXJjaFJlc3VsdC5ub2RlO1xuICAgICAgICAgICAgICAgIGZpbmRJbmZvLmluZGV4ID0gc2VhcmNoUmVzdWx0LmluZGV4O1xuICAgICAgICAgICAgICAgIGlmICghc2VhcmNoUmVzdWx0LmZvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZmluZEluZm8uY2hlY2tfcHJlZml4KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoZmluZEluZm8uaXNWYWx1ZVByZXNlbnQpIHRocm93IFwiQl9QbHVzX1RyZWUuZmluZEZpcnN0KCk6IGFyZ3VtZW50cyBlcnJvcjoga2V5IGlzIG5vdCBwcmVzZW50LCBidXQgdmFsdWUgaXMgcHJlc2VudFwiO1xuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgZmluZEluZm8ubGVhZiA9IG1fcHVibGljLmZpcnN0TGVhZjtcbiAgICAgICAgICAgICAgICBmaW5kSW5mby5pbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKGZpbmRJbmZvLmxlYWYua2V5cy5jb3VudCA8PSAwKSByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICByZXR1cm4gZmluZEluZm87XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gZmluZCBsYXN0IGl0ZW0gbWF0Y2hpbmcgKGtleSwgdmFsdWUpIHNlYXJjaCBjcml0ZXJpYVxuICAgICAgICAvLyB1c2UgY2FzZXM6XG4gICAgICAgIC8vIHBfRmluZExhc3QoKVxuICAgICAgICAvLyBwX0ZpbmRMYXN0KGtleSlcbiAgICAgICAgLy8gcF9GaW5kTGFzdChrZXksIHZhbHVlKVxuICAgICAgICAvLyBwX0ZpbmRMYXN0KGtleSwgdW5kZWZpbmVkLCB0cnVlKVxuICAgICAgICB2YXIgcF9GaW5kTGFzdCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlLCBpc1ByZWZpeFNlYXJjaCkge1xuICAgICAgICAgICAgdmFyIGZpbmRJbmZvID0gbmV3IEZpbmRJbmZvKGtleSwgdmFsdWUsIGlzUHJlZml4U2VhcmNoKTtcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICBpZiAoZmluZEluZm8uaXNLZXlQcmVzZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpbmRJbmZvLmlzUHJlZml4U2VhcmNoICYmIGZpbmRJbmZvLmlzVmFsdWVQcmVzZW50KSB0aHJvdyBcIkJfUGx1c19UcmVlLnBfRmluZExhc3QoKTogYXJndW1lbnRzIGVycm9yOiBpc1ByZWZpeFNlYXJjaCwgYnV0IHZhbHVlIGlzIHByZXNlbnRcIjtcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIGlmIChmaW5kSW5mby5pc1ByZWZpeFNlYXJjaCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2VhcmNoUmVzdWx0ID0gc2VhcmNoTGFzdExlYWZCeVByZWZpeChrZXkpO1xuICAgICAgICAgICAgICAgICAgICBmaW5kSW5mby5sZWFmID0gc2VhcmNoUmVzdWx0Lm5vZGU7XG4gICAgICAgICAgICAgICAgICAgIGZpbmRJbmZvLmluZGV4ID0gc2VhcmNoUmVzdWx0LmluZGV4O1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNlYXJjaFJlc3VsdC5mb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2VhcmNoUmVzdWx0ID0gZmluZEluZm8uaXNWYWx1ZVByZXNlbnQgPyBzZWFyY2hMYXN0TGVhZlZhbHVlKGtleSwgdmFsdWUpIDogc2VhcmNoTGFzdExlYWYoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgZmluZEluZm8ubGVhZiA9IHNlYXJjaFJlc3VsdC5ub2RlO1xuICAgICAgICAgICAgICAgICAgICBmaW5kSW5mby5pbmRleCA9IHNlYXJjaFJlc3VsdC5pbmRleDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzZWFyY2hSZXN1bHQuZm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoZmluZEluZm8uaXNWYWx1ZVByZXNlbnQpIHRocm93IFwiQl9QbHVzX1RyZWUuZmluZExhc3QoKTogYXJndW1lbnRzIGVycm9yOiBrZXkgaXMgbm90IHByZXNlbnQsIGJ1dCB2YWx1ZSBpcyBwcmVzZW50XCI7XG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICBmaW5kSW5mby5sZWFmID0gbV9wdWJsaWMubGFzdExlYWY7XG4gICAgICAgICAgICAgICAgZmluZEluZm8uaW5kZXggPSBmaW5kSW5mby5sZWFmLmtleXMuY291bnQgLSAxO1xuICAgICAgICAgICAgICAgIGlmIChmaW5kSW5mby5pbmRleCA8IDApIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIHJldHVybiBmaW5kSW5mbztcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBtb3ZlIHRvIG5leHQgaXRlbVxuICAgICAgICB2YXIgZmluZEdvVG9OZXh0ID0gZnVuY3Rpb24gKGZpbmRJbmZvKSB7XG4gICAgICAgICAgICBmaW5kSW5mby5pbmRleCsrO1xuICAgICAgICAgICAgaWYgKGZpbmRJbmZvLmluZGV4ID49IGZpbmRJbmZvLmxlYWYua2V5cy5jb3VudCkge1xuICAgICAgICAgICAgICAgIGZpbmRJbmZvLmxlYWYgPSBmaW5kSW5mby5sZWFmLm5leHRMZWFmO1xuICAgICAgICAgICAgICAgIGZpbmRJbmZvLmluZGV4ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICByZXR1cm4gKGZpbmRJbmZvLmxlYWYgIT0gbnVsbCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gbW92ZSB0byBwcmV2aW91cyBpdGVtXG4gICAgICAgIHZhciBmaW5kR29Ub1ByZXYgPSBmdW5jdGlvbiAoZmluZEluZm8pIHtcbiAgICAgICAgICAgIGZpbmRJbmZvLmluZGV4LS07XG4gICAgICAgICAgICBpZiAoZmluZEluZm8uaW5kZXggPCAwKSB7XG4gICAgICAgICAgICAgICAgZmluZEluZm8ubGVhZiA9IGZpbmRJbmZvLmxlYWYucHJldkxlYWY7XG4gICAgICAgICAgICAgICAgaWYgKGZpbmRJbmZvLmxlYWYgPT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIGZpbmRJbmZvLmluZGV4ID0gZmluZEluZm8ubGVhZi5rZXlzLmNvdW50IC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBmaW5kIG5leHQgaXRlbSBhZnRlciB0aGUgZmluZEluZm8ncyBmb3VuZCBpdGVtLCBtYXRjaGluZyB0aGUgZmluZEluZm8ncyBzZWFyY2ggY3JpdGVyaWFcbiAgICAgICAgdmFyIHBfRmluZE5leHQgPSBmdW5jdGlvbiAoZmluZEluZm8pIHtcbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFmaW5kR29Ub05leHQoZmluZEluZm8pKSByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIGlmIChmaW5kSW5mby5pc1ByZWZpeFNlYXJjaCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWZpbmRJbmZvLmNoZWNrX3ByZWZpeCgpKSByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmluZEluZm8uaXNLZXlQcmVzZW50ICYmIChmaW5kSW5mby5rZXkgIT0gZmluZEluZm8uZm91bmRLZXkoKSkpIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIGlmIChmaW5kSW5mby5pc1ZhbHVlUHJlc2VudCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmluZEluZm8udmFsdWUgPT0gZmluZEluZm8uZm91bmRWYWx1ZSgpKSByZXR1cm4gZmluZEluZm87XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpbmRJbmZvO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBmaW5kIHByZXZpb3VzIGl0ZW0gYWZ0ZXIgdGhlIGZpbmRJbmZvJ3MgZm91bmQgaXRlbSwgbWF0Y2hpbmcgdGhlIGZpbmRJbmZvJ3Mgc2VhcmNoIGNyaXRlcmlhXG4gICAgICAgIHZhciBwX0ZpbmRQcmV2ID0gZnVuY3Rpb24gKGZpbmRJbmZvKSB7XG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgIGlmICghZmluZEdvVG9QcmV2KGZpbmRJbmZvKSkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvL2lmIChmaW5kSW5mby5pc0tleVByZXNlbnQgJiYgKGZpbmRJbmZvLmtleSAhPSBmaW5kSW5mby5mb3VuZEtleSgpKSkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKGZpbmRJbmZvLmlzUHJlZml4U2VhcmNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZmluZEluZm8uY2hlY2tfcHJlZml4KCkpIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaW5kSW5mby5pc0tleVByZXNlbnQgJiYgKGZpbmRJbmZvLmtleSAhPSBmaW5kSW5mby5mb3VuZEtleSgpKSkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgaWYgKGZpbmRJbmZvLmlzVmFsdWVQcmVzZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaW5kSW5mby52YWx1ZSA9PSBmaW5kSW5mby5mb3VuZFZhbHVlKCkpIHJldHVybiBmaW5kSW5mbztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmluZEluZm87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vICAgICAgICAgIGFkZGl0aW9uYWwgbWV0aG9kczpcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICAvLyBnZXQgdmFsdWVzIGF0IGtleS4uLlxuICAgICAgICAvLyAgbWFrZSB0aGlzIGFsd2F5cyByZXR1cm4gYW4gYXJyYXksIGV2ZW4gaWYgdGhlcmUgaXMgb25lIGl0ZW0uXG4gICAgICAgIC8vICB3aWxsIG1ha2UgaW50ZXJwcmV0YXRpb24gZWFzaWVyLlxuXG4gICAgICAgIC8vIHdpbGwgbW92ZSB0aGUgcHJlZml4IHNlYXJjaCBjb2RlIGludG8gaGVyZS5cblxuICAgICAgICAvLyBpdGVyYXRlIG5vZGVzIGJ5IHByZWZpeC4uLiB0aGF0IG1heSBiZSBhIG1vcmUgZWZmaWNpZW50IHdheSBvZiBkb2luZyB0aGlzLCBtYXkgYmUgbGVzcyBlZmZpY2llbnQsIGl0IGFzc2lnbnMgb25lIG1vcmUgdGhpbmcgSSB0aGluay5cbiAgICAgICAgLy8gIHBvc3NpYmx5IGEgZmFzdCBpdGVyYXRvcj9cblxuICAgICAgICAvLyAgZGVmaW5pdGVseSB3b3VsZCBiZSBlYXNpZXIgY29kZSwgSSB0aGluayBpdCB3b3VsZCBiZSB3b3J0aCBkb2luZy5cbiAgICAgICAgLy8gIGNvdWxkIGFsc28gYmUgZ2l2ZW4gaXRzIG93biBjaGVjayBmdW5jdGlvbi5cbiAgICAgICAgLy8gICBtYXliZSBnZXRzIGdpdmVuIHN0YXJ0aW5nIGxvY2F0aW9uLitcblxuXG4gICAgICAgIHZhciBwX2dldF92YWx1ZXNfYnlfa2V5ID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgdmFyIHJlcyA9IFtdO1xuICAgICAgICAgICAgdmFyIGZpbmRJbmZvID0gcF9GaW5kRmlyc3Qoa2V5KTtcbiAgICAgICAgICAgIHdoaWxlIChmaW5kSW5mbyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzLnB1c2goZmluZEluZm8uZm91bmRWYWx1ZSgpKTtcbiAgICAgICAgICAgICAgICBmaW5kSW5mbyA9IHBfRmluZE5leHQoZmluZEluZm8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGdldCBrZXlzIGFuZCB2YWx1ZXMgYnkgcHJlZml4XG5cbiAgICAgICAgdmFyIHBfZ2V0X2J5X3ByZWZpeCA9IGZ1bmN0aW9uIChwcmVmaXgpIHtcbiAgICAgICAgICAgIHZhciByZXMgPSBbXTtcbiAgICAgICAgICAgIHZhciBmaW5kSW5mbyA9IG1fcHVibGljLmZpbmRGaXJzdFByZWZpeChwcmVmaXgpO1xuICAgICAgICAgICAgd2hpbGUgKGZpbmRJbmZvICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXMucHVzaChbZmluZEluZm8uZm91bmRLZXkoKSwgZmluZEluZm8uZm91bmRWYWx1ZSgpXSk7XG4gICAgICAgICAgICAgICAgZmluZEluZm8gPSBtX3B1YmxpYy5maW5kTmV4dChmaW5kSW5mbyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZ2V0IGtleXMgYnkgcHJlZml4XG5cbiAgICAgICAgdmFyIHBfZ2V0X2tleXNfYnlfcHJlZml4ID0gZnVuY3Rpb24gKHByZWZpeCkge1xuICAgICAgICAgICAgdmFyIHJlcyA9IFtdO1xuICAgICAgICAgICAgdmFyIGZpbmRJbmZvID0gbV9wdWJsaWMuZmluZEZpcnN0UHJlZml4KHByZWZpeCk7XG4gICAgICAgICAgICB3aGlsZSAoZmluZEluZm8gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlcy5wdXNoKGZpbmRJbmZvLmZvdW5kS2V5KCkpO1xuICAgICAgICAgICAgICAgIGZpbmRJbmZvID0gbV9wdWJsaWMuZmluZE5leHQoZmluZEluZm8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfVxuXG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gICAgICAgICAgZ2V0VmFsdWUoKSAvIHNldFZhbHVlKCk6XG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgLy8gZ2V0IHZhbHVlIGZvciB0aGUgZ2l2ZW4ga2V5XG4gICAgICAgIHZhciBwX0dldFZhbHVlID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgdmFyIHNlYXJjaFJlc3VsdCA9IHNlYXJjaExlYWYoa2V5KTtcbiAgICAgICAgICAgIGlmICghc2VhcmNoUmVzdWx0LmZvdW5kKSByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBzZWFyY2hSZXN1bHQubm9kZS52YWx1ZXMuaXRlbXNbc2VhcmNoUmVzdWx0LmluZGV4XTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBzZXQgdmFsdWUgZm9yIHRoZSBnaXZlbiBrZXlcbiAgICAgICAgdmFyIHBfU2V0VmFsdWUgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIHNlYXJjaFJlc3VsdCA9IHNlYXJjaExlYWYoa2V5KTtcbiAgICAgICAgICAgIGlmIChzZWFyY2hSZXN1bHQuZm91bmQpIHtcbiAgICAgICAgICAgICAgICByZW1vdmVGcm9tTGVhZihzZWFyY2hSZXN1bHQubm9kZSwgc2VhcmNoUmVzdWx0LmluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICBwX0luc2VydChrZXksIHZhbHVlKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgY291bnQoKTpcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICAvLyBjb3VudCBhbGwgdGhlIHZhbHVlIGl0ZW1zIGluIHRoZSB0cmVlXG4gICAgICAgIC8vIGlzIHRoYXQgYW4gZWFzaWVyIHdheSB0byBpdGVyYXRlP1xuXG4gICAgICAgIHZhciBwX0NvdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IDA7XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgdmFyIGxlYWYgPSBtX3B1YmxpYy5maXJzdExlYWY7XG4gICAgICAgICAgICB3aGlsZSAobGVhZiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IGxlYWYua2V5cy5jb3VudDtcbiAgICAgICAgICAgICAgICBsZWFmID0gbGVhZi5uZXh0TGVhZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGNvdW50IHRoZSB2YWx1ZSBpdGVtcyB3aXRoIGdpdmVuIGtleSBpbiB0aGUgdHJlZVxuICAgICAgICB2YXIgcF9Db3VudEtleSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSAwO1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIHZhciBmaW5kSW5mbyA9IG1fcHVibGljLmZpbmRGaXJzdChrZXkpO1xuICAgICAgICAgICAgd2hpbGUgKGZpbmRJbmZvICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQrKztcbiAgICAgICAgICAgICAgICBmaW5kSW5mbyA9IG1fcHVibGljLmZpbmROZXh0KGZpbmRJbmZvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICB0b1RleHQoKTpcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICAvLyByZXR1cm5zIG11bHRpLWxpbmUgdGV4dCBwcmVzZW50YXRpb24gZm9yIHRoZSB0cmVlXG5cbiAgICAgICAgLypcblx0ICAgIFxuICAgICAgICB2YXIgX3BfVG9UZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gbV9wdWJsaWMucm9vdC50b1RleHQoXCJcIik7XG4gICAgICAgIC8vXG4gICAgICAgIGlmICh0eXBlb2YgKEJfUGx1c19UcmVlX05leHROb2RlRGVidWdJZCkgIT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAvLyBwcmludCBsZWFmcyBjaGFpbjpcbiAgICAgICAgcmVzdWx0ICs9IFwiXFxyXFxuXCI7XG4gICAgICAgIHZhciBsZWFmID0gbV9wdWJsaWMuZmlyc3RMZWFmO1xuICAgICAgICB3aGlsZSAobGVhZiAhPSBudWxsKSB7XG4gICAgICAgIHJlc3VsdCArPSBcIihcIiArIGxlYWYuZGVidWdJZCArIFwiKSBcIjtcbiAgICAgICAgbGVhZiA9IGxlYWYubmV4dExlYWY7XG4gICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvL1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuXG4gICAgICAgICovXG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gICAgICAgICAgICAgICAgcm90YXRpb25zOlxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgIC8vIFwicm90YXRpb25cIiBtZWFucyBtb3ZpbmcgaXRlbXMgYmV0d2VlbiBzaWJsaW5ncyBpbnN0ZWFkIG9mIHNwbGl0L21lcmdlXG5cbiAgICAgICAgLy8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSB0cnVlIHdoZW4gcm90YXRpb24gaXMgY2FsbGVkOlxuICAgICAgICAvLyBsZWZ0Tm9kZS5wYXJlbnQgPT0gcmlnaHROb2RlLnBhcmVudFxuICAgICAgICAvLyBsZWZ0TGVhZi5wYXJlbnQgPT0gcmlnaHRMZWFmLnBhcmVudFxuXG4gICAgICAgIC8vIG1vdmUgYSBrZXkgaXRlbSB0byB0aGUgbGVmdCBiZXR3ZWVuIGxlZnROb2RlIGFuZCByaWdodE5vZGUgaW5kZXggKG5vbi1sZWFmKSBub2Rlc1xuICAgICAgICAvLyByaWdodCBub2RlIGZpcnN0IGl0ZW0gLT4gcGFyZW50XG4gICAgICAgIC8vIHBhcmVudCBpdGVtIC0+IGxlZnQgbm9kZVxuICAgICAgICB2YXIgcm90YXRlQW1vbmdOb2Rlc1RvTGVmdCA9IGZ1bmN0aW9uIChsZWZ0Tm9kZSwgcmlnaHROb2RlKSB7XG4gICAgICAgICAgICAvLyBtb3ZlIGl0ZW0gZnJvbSByaWdodE5vZGUgdG8gTGVmdE5vZGVcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICB2YXIgcGFyZW50ID0gcmlnaHROb2RlLnBhcmVudDtcbiAgICAgICAgICAgIHZhciByaWdodEluZGV4ID0gY2FsY0NoaWxkSW5kZXgocGFyZW50LCByaWdodE5vZGUpO1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIG1vdmUgdGhlIGtleTpcbiAgICAgICAgICAgIGxlZnROb2RlLmtleXMuYWRkKHBhcmVudC5rZXlzLml0ZW1zW3JpZ2h0SW5kZXggLSAxXSk7IC8vIGNvcHkgdGhlIGtleSBkb3duXG4gICAgICAgICAgICBwYXJlbnQua2V5cy5pdGVtc1tyaWdodEluZGV4IC0gMV0gPSByaWdodE5vZGUua2V5cy5maXJzdCgpOyAvLyBjb3B5IHRoZSBrZXkgdXBcbiAgICAgICAgICAgIHJpZ2h0Tm9kZS5rZXlzLnJlbW92ZUZpcnN0KCk7IC8vIHJlbW92ZSBmcm9tIHJpZ2h0XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gbW92ZSB0aGUgY2hpbGQgcmVmZXJlbmNlOlxuICAgICAgICAgICAgcmlnaHROb2RlLmNoaWxkcmVuLmZpcnN0KCkucGFyZW50ID0gbGVmdE5vZGU7IC8vIHVwZGF0ZSBwYXJlbnQgcmVmZXJlbmNlXG4gICAgICAgICAgICBsZWZ0Tm9kZS5jaGlsZHJlbi5hZGQocmlnaHROb2RlLmNoaWxkcmVuLmZpcnN0KCkpOyAvLyBjb3B5IHRvIGxlZnRcbiAgICAgICAgICAgIHJpZ2h0Tm9kZS5jaGlsZHJlbi5yZW1vdmVGaXJzdCgpOyAvLyByZW1vdmUgZnJvbSByaWdodFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIG1vdmUgYSBrZXkgaXRlbSB0byB0aGUgcmlnaHQgYmV0d2VlbiBsZWZ0Tm9kZSBhbmQgcmlnaHROb2RlIGluZGV4IChub24tbGVhZikgbm9kZXNcbiAgICAgICAgLy8gbGVmdCBub2RlIGxhc3QgaXRlbSAtPiBwYXJlbnRcbiAgICAgICAgLy8gcGFyZW50IGl0ZW0gLT4gcmlnaHQgbm9kZVxuICAgICAgICB2YXIgcm90YXRlQW1vbmdOb2Rlc1RvUmlnaHQgPSBmdW5jdGlvbiAobGVmdE5vZGUsIHJpZ2h0Tm9kZSkge1xuICAgICAgICAgICAgLy8gbW92ZSBpdGVtIGZyb20gbGVmdE5vZGUgdG8gcmlnaHROb2RlXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgdmFyIHBhcmVudCA9IHJpZ2h0Tm9kZS5wYXJlbnQ7XG4gICAgICAgICAgICB2YXIgcmlnaHRJbmRleCA9IGNhbGNDaGlsZEluZGV4KHBhcmVudCwgcmlnaHROb2RlKTtcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBtb3ZlIHRoZSBrZXk6XG4gICAgICAgICAgICByaWdodE5vZGUua2V5cy5pbnNlcnQoMCwgcGFyZW50LmtleXMuaXRlbXNbcmlnaHRJbmRleCAtIDFdKTsgLy8gY29weSB0aGUga2V5IGRvd25cbiAgICAgICAgICAgIHBhcmVudC5rZXlzLml0ZW1zW3JpZ2h0SW5kZXggLSAxXSA9IGxlZnROb2RlLmtleXMubGFzdCgpOyAvLyBjb3B5IHRoZSBrZXkgdXBcbiAgICAgICAgICAgIGxlZnROb2RlLmtleXMucmVtb3ZlTGFzdCgpOyAvLyByZW1vdmUgZnJvbSBsZWZ0XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gbW92ZSB0aGUgY2hpbGQgcmVmZXJlbmNlOlxuICAgICAgICAgICAgcmlnaHROb2RlLmNoaWxkcmVuLmluc2VydCgwLCBsZWZ0Tm9kZS5jaGlsZHJlbi5sYXN0KCkpOyAvLyBjb3B5IHRvIHJpZ2h0XG4gICAgICAgICAgICByaWdodE5vZGUuY2hpbGRyZW4uZmlyc3QoKS5wYXJlbnQgPSByaWdodE5vZGU7IC8vIHVwZGF0ZSBwYXJlbnQgcmVmZXJlbmNlXG4gICAgICAgICAgICBsZWZ0Tm9kZS5jaGlsZHJlbi5yZW1vdmVMYXN0KCk7IC8vIHJlbW92ZSBmcm9tIGxlZnRcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBtb3ZlIGFuIGl0ZW0gdG8gdGhlIGxlZnQgYmV0d2VlbiBsZWZ0TGVhZiBhbmQgcmlnaHRMZWFmIGxlYWYgbm9kZXNcbiAgICAgICAgLy8gcmlnaHQgbGVhZiBmaXJzdCBpdGVtIC0+IGxlZnQgbGVhZlxuICAgICAgICB2YXIgcm90YXRlQW1vbmdMZWF2ZXNUb0xlZnQgPSBmdW5jdGlvbiAobGVmdExlYWYsIHJpZ2h0TGVhZikge1xuICAgICAgICAgICAgLy8gbW92ZSBpdGVtIGZyb20gcmlnaHRMZWFmIHRvIGxlZnRMZWFmXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgdmFyIHJpZ2h0SW5kZXggPSBjYWxjQ2hpbGRJbmRleChyaWdodExlYWYucGFyZW50LCByaWdodExlYWYpO1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIGNvcHkgdG8gbGVmdDpcbiAgICAgICAgICAgIGxlZnRMZWFmLmtleXMuYWRkKHJpZ2h0TGVhZi5rZXlzLmZpcnN0KCkpO1xuICAgICAgICAgICAgbGVmdExlYWYudmFsdWVzLmFkZChyaWdodExlYWYudmFsdWVzLmZpcnN0KCkpO1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIHJlbW92ZSBmcm9tIHJpZ2h0OlxuICAgICAgICAgICAgcmlnaHRMZWFmLmtleXMucmVtb3ZlRmlyc3QoKTtcbiAgICAgICAgICAgIHJpZ2h0TGVhZi52YWx1ZXMucmVtb3ZlRmlyc3QoKTtcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyB1cGRhdGUgcGFyZW50OlxuICAgICAgICAgICAgcmlnaHRMZWFmLnBhcmVudC5rZXlzLml0ZW1zW3JpZ2h0SW5kZXggLSAxXSA9IHJpZ2h0TGVhZi5rZXlzLmZpcnN0KCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gbW92ZSBhbiBpdGVtIHRvIHRoZSByaWdodCBiZXR3ZWVuIGxlZnRMZWFmIGFuZCByaWdodExlYWYgbGVhZiBub2Rlc1xuICAgICAgICAvLyBsZWZ0IGxlYWYgbGFzdCBpdGVtIC0+IHJpZ2h0IGxlYWZcbiAgICAgICAgdmFyIHJvdGF0ZUFtb25nTGVhdmVzVG9SaWdodCA9IGZ1bmN0aW9uIChsZWZ0TGVhZiwgcmlnaHRMZWFmKSB7XG4gICAgICAgICAgICAvLyBtb3ZlIGZyb20gbGVmdExlYWYgdG8gcmlnaHRMZWFmXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgdmFyIHJpZ2h0SW5kZXggPSBjYWxjQ2hpbGRJbmRleChyaWdodExlYWYucGFyZW50LCByaWdodExlYWYpO1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIGNvcHkgdG8gcmlnaHQ6XG4gICAgICAgICAgICByaWdodExlYWYua2V5cy5pbnNlcnQoMCwgbGVmdExlYWYua2V5cy5sYXN0KCkpO1xuICAgICAgICAgICAgcmlnaHRMZWFmLnZhbHVlcy5pbnNlcnQoMCwgbGVmdExlYWYudmFsdWVzLmxhc3QoKSk7XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gcmVtb3ZlIGZyb20gbGVmdDpcbiAgICAgICAgICAgIGxlZnRMZWFmLmtleXMucmVtb3ZlTGFzdCgpO1xuICAgICAgICAgICAgbGVmdExlYWYudmFsdWVzLnJlbW92ZUxhc3QoKTtcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyB1cGRhdGUgcGFyZW50OlxuICAgICAgICAgICAgcmlnaHRMZWFmLnBhcmVudC5rZXlzLml0ZW1zW3JpZ2h0SW5kZXggLSAxXSA9IHJpZ2h0TGVhZi5rZXlzLmZpcnN0KCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gICAgICAgICAgICAgaW50ZXJuYWwgc2VhcmNoZXM6XG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgLy8gc2hvcnQgZGVzY3JpcHRpb246IHJldHVybnMgdGhlIFwiY2hpbGRcIiBpbmRleCBpbiB0aGUgXCJub2RlXCJcbiAgICAgICAgLy8gbG9uZyBkZXNjcmlwdGlvbjogY2FsY3VsYXRlcyB0aGUgXCJjaGlsZFwiIG5vZGUgaW5kZXggaW4gdGhlIFwibm9kZS5jaGlsZHJlblwiIGFycmF5XG4gICAgICAgIC8vICh1c3VhbGx5IG5vZGUgPT0gY2hpbGQucGFyZW4pXG4gICAgICAgIHZhciBjYWxjQ2hpbGRJbmRleCA9IGZ1bmN0aW9uIChub2RlLCBjaGlsZCkge1xuICAgICAgICAgICAgdmFyIGtleSA9IGNoaWxkLmtleXMuZmlyc3QoKTtcbiAgICAgICAgICAgIHZhciBzZWFyY2hSZXN1bHQgPSBub2RlLmtleXMuc2VhcmNoX2ZpcnN0KGtleSk7XG4gICAgICAgICAgICBpZiAoIXNlYXJjaFJlc3VsdC5mb3VuZCkge1xuICAgICAgICAgICAgICAgIGlmIChub2RlLmNoaWxkcmVuLml0ZW1zW3NlYXJjaFJlc3VsdC5pbmRleF0gIT0gY2hpbGQpIHRocm93IFwiQl9QbHVzVHJlZS5jYWxjQ2hpbGRJbmRleCgpOiAxXCI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlYXJjaFJlc3VsdC5pbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICB2YXIgaW5kZXggPSBzZWFyY2hSZXN1bHQuaW5kZXg7XG4gICAgICAgICAgICBmb3IgKDsgOyApIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5jaGlsZHJlbi5pdGVtc1tpbmRleF0gPT0gY2hpbGQpIHJldHVybiBpbmRleDtcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID49IG5vZGUuY2hpbGRyZW4uY291bnQpIGJyZWFrO1xuICAgICAgICAgICAgICAgIGlmIChub2RlLmtleXMuaXRlbXNbaW5kZXggLSAxXSAhPSBrZXkpIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgXCJCX1BsdXNUcmVlLmNhbGNDaGlsZEluZGV4KCk6IDJcIjtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyByZXR1cm5zIGxlYWYgbm9kZSBjb250YWluaW5nIGFuIGl0ZW0gd2l0aCB0aGUgZ2l2ZW4ga2V5XG4gICAgICAgIHZhciBzZWFyY2hMZWFmID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgLy8gXG4gICAgICAgICAgICB2YXIgZG9TZWFyY2hMZWFmID0gZnVuY3Rpb24gKG5vZGUsIGtleSkge1xuICAgICAgICAgICAgICAgIHZhciBzZWFyY2hSZXN1bHQgPSBub2RlLmtleXMuc2VhcmNoX2ZpcnN0KGtleSk7XG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICBpZiAobm9kZS5pc0xlYWYpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgbm9kZTogbm9kZSwgZm91bmQ6IHNlYXJjaFJlc3VsdC5mb3VuZCwgaW5kZXg6IHNlYXJjaFJlc3VsdC5pbmRleCB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIGlmIChzZWFyY2hSZXN1bHQuZm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWxsdXN0cmF0aW9uOiBbbGVmdCBjaGlsZF0ga2V5IFtyaWdodCBjaGlsZF1cbiAgICAgICAgICAgICAgICAgICAgLy8gYm90aCBjaGlsZHJlbiAobGVmdCBhbmQgcmlnaHQgaS5lLiBiZWZvcmUgYW5kIGFmdGVyIHRoZSBrZXkpIGNhbiBjb250YWluIHRoZSBrZXlcbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgLy8gdHJ5IHRoZSBsZWZ0IGNoaWxkIGZpcnN0OlxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0TGVmdCA9IGRvU2VhcmNoTGVhZihub2RlLmNoaWxkcmVuLml0ZW1zW3NlYXJjaFJlc3VsdC5pbmRleF0sIGtleSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHRMZWZ0LmZvdW5kKSByZXR1cm4gcmVzdWx0TGVmdDtcbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgLy8gdHJ5IHRoZSByaWdodCBjaGlsZFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZG9TZWFyY2hMZWFmKG5vZGUuY2hpbGRyZW4uaXRlbXNbc2VhcmNoUmVzdWx0LmluZGV4ICsgMV0sIGtleSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHBvaW50ZWQga2V5IGlzIGdyZWF0ZXIgdGhhbiB0aGUgc2VhcmNoZWQga2V5LiBPbmx5IGxlZnQgY2hpbGQgY2FuIGJlIGNvbnNpZGVyZWQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkb1NlYXJjaExlYWYobm9kZS5jaGlsZHJlbi5pdGVtc1tzZWFyY2hSZXN1bHQuaW5kZXhdLCBrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgcmV0dXJuIGRvU2VhcmNoTGVhZihtX3B1YmxpYy5yb290LCBrZXkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIHJldHVybnMgbGFzdCBsZWFmIG5vZGUgY29udGFpbmluZyBhbiBpdGVtIHdpdGggdGhlIGdpdmVuIGtleVxuICAgICAgICB2YXIgc2VhcmNoTGFzdExlYWYgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAvLyBcbiAgICAgICAgICAgIHZhciBkb1NlYXJjaExhc3RMZWFmID0gZnVuY3Rpb24gKG5vZGUsIGtleSkge1xuICAgICAgICAgICAgICAgIHZhciBzZWFyY2hSZXN1bHQgPSBub2RlLmtleXMuc2VhcmNoX2xhc3Qoa2V5KTtcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIGlmIChub2RlLmlzTGVhZikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBub2RlOiBub2RlLCBmb3VuZDogc2VhcmNoUmVzdWx0LmZvdW5kLCBpbmRleDogc2VhcmNoUmVzdWx0LmluZGV4IH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgaWYgKHNlYXJjaFJlc3VsdC5mb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpbGx1c3RyYXRpb246IFtsZWZ0IGNoaWxkXSBrZXkgW3JpZ2h0IGNoaWxkXVxuICAgICAgICAgICAgICAgICAgICAvLyBib3RoIGNoaWxkcmVuIChsZWZ0IGFuZCByaWdodCBpLmUuIGJlZm9yZSBhbmQgYWZ0ZXIgdGhlIGtleSkgY2FuIGNvbnRhaW4gdGhlIGtleVxuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAvLyB0cnkgdGhlIHJpZ2h0IGNoaWxkIGZpcnN0OlxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0UmlnaHQgPSBkb1NlYXJjaExhc3RMZWFmKG5vZGUuY2hpbGRyZW4uaXRlbXNbc2VhcmNoUmVzdWx0LmluZGV4ICsgMV0sIGtleSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHRSaWdodC5mb3VuZCkgcmV0dXJuIHJlc3VsdFJpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAvLyB0cnkgdGhlIGxlZnQgY2hpbGRcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRvU2VhcmNoTGFzdExlYWYobm9kZS5jaGlsZHJlbi5pdGVtc1tzZWFyY2hSZXN1bHQuaW5kZXhdLCBrZXkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBwb2ludGVkIGtleSBpcyBncmVhdGVyIHRoYW4gdGhlIHNlYXJjaGVkIGtleS4gT25seSBsZWZ0IGNoaWxkIGNhbiBiZSBjb25zaWRlcmVkOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZG9TZWFyY2hMYXN0TGVhZihub2RlLmNoaWxkcmVuLml0ZW1zW3NlYXJjaFJlc3VsdC5pbmRleF0sIGtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICByZXR1cm4gZG9TZWFyY2hMYXN0TGVhZihtX3B1YmxpYy5yb290LCBrZXkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIHJldHVybnMgbGFzdCBsZWFmIG5vZGUgY29udGFpbmluZyBhbiBpdGVtIHdpdGggdGhlIGdpdmVuIHByZWZpeFxuICAgICAgICB2YXIgc2VhcmNoTGFzdExlYWZCeVByZWZpeCA9IGZ1bmN0aW9uIChwcmVmaXgpIHtcbiAgICAgICAgICAgIC8vIFxuICAgICAgICAgICAgdmFyIGRvU2VhcmNoTGFzdExlYWZCeVByZWZpeCA9IGZ1bmN0aW9uIChub2RlLCBwcmVmaXgpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VhcmNoUmVzdWx0ID0gbm9kZS5rZXlzLnNlYXJjaF9sYXN0X3ByZWZpeChwcmVmaXgpO1xuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuaXNMZWFmKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IG5vZGU6IG5vZGUsIGZvdW5kOiBzZWFyY2hSZXN1bHQuZm91bmQsIGluZGV4OiBzZWFyY2hSZXN1bHQuaW5kZXggfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICBpZiAoc2VhcmNoUmVzdWx0LmZvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlsbHVzdHJhdGlvbjogW2xlZnQgY2hpbGRdIGtleSBbcmlnaHQgY2hpbGRdXG4gICAgICAgICAgICAgICAgICAgIC8vIGJvdGggY2hpbGRyZW4gKGxlZnQgYW5kIHJpZ2h0IGkuZS4gYmVmb3JlIGFuZCBhZnRlciB0aGUga2V5KSBjYW4gY29udGFpbiB0aGUgcHJlZml4XG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIC8vIHRyeSB0aGUgcmlnaHQgY2hpbGQgZmlyc3Q6XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHRSaWdodCA9IGRvU2VhcmNoTGFzdExlYWZCeVByZWZpeChub2RlLmNoaWxkcmVuLml0ZW1zW3NlYXJjaFJlc3VsdC5pbmRleCArIDFdLCBwcmVmaXgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0UmlnaHQuZm91bmQpIHJldHVybiByZXN1bHRSaWdodDtcbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgLy8gdHJ5IHRoZSBsZWZ0IGNoaWxkXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkb1NlYXJjaExhc3RMZWFmQnlQcmVmaXgobm9kZS5jaGlsZHJlbi5pdGVtc1tzZWFyY2hSZXN1bHQuaW5kZXhdLCBwcmVmaXgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBwb2ludGVkIGtleSBpcyBncmVhdGVyIHRoYW4gdGhlIHNlYXJjaGVkIHByZWZpeC4gT25seSBsZWZ0IGNoaWxkIGNhbiBiZSBjb25zaWRlcmVkOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZG9TZWFyY2hMYXN0TGVhZkJ5UHJlZml4KG5vZGUuY2hpbGRyZW4uaXRlbXNbc2VhcmNoUmVzdWx0LmluZGV4XSwgcHJlZml4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIHJldHVybiBkb1NlYXJjaExhc3RMZWFmQnlQcmVmaXgobV9wdWJsaWMucm9vdCwgcHJlZml4KTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyByZXR1cm5zIGxlYWYgbm9kZSBjb250YWluaW5nIGFuIGl0ZW0gd2l0aCB0aGUgZ2l2ZW4ga2V5IGFuZCB2YWx1ZVxuICAgICAgICB2YXIgc2VhcmNoTGVhZlZhbHVlID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIC8vIHNlYXJjaCB0aGUga2V5OlxuICAgICAgICAgICAgdmFyIHNlYXJjaFJlc3VsdCA9IHNlYXJjaExlYWYoa2V5KTtcbiAgICAgICAgICAgIGlmICghc2VhcmNoUmVzdWx0LmZvdW5kKSByZXR1cm4gc2VhcmNoUmVzdWx0O1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIHNlYXJjaCB0aGUgdmFsdWUgKGlmIHRoZXJlIGFyZSBzZXZlcmFsIHRoZSBzYW1lIGtleXMpOlxuICAgICAgICAgICAgdmFyIHZhbHVlRm91bmQgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBsZWFmID0gc2VhcmNoUmVzdWx0Lm5vZGU7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBzZWFyY2hSZXN1bHQuaW5kZXg7XG4gICAgICAgICAgICBmb3IgKDsgOyApIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPj0gbGVhZi52YWx1ZXMuY291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGVhZiA9IGxlYWYubmV4dExlYWY7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsZWFmID09IG51bGwpIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChsZWFmLmtleXMuaXRlbXNbaW5kZXhdICE9IGtleSkgYnJlYWs7XG4gICAgICAgICAgICAgICAgaWYgKGxlYWYudmFsdWVzLml0ZW1zW2luZGV4XSA9PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZUZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgcmV0dXJuIHsgbm9kZTogbGVhZiwgZm91bmQ6IHZhbHVlRm91bmQsIGluZGV4OiBpbmRleCB9O1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIHJldHVybnMgbGFzdCBsZWFmIG5vZGUgY29udGFpbmluZyBhbiBpdGVtIHdpdGggdGhlIGdpdmVuIGtleSBhbmQgdmFsdWVcbiAgICAgICAgdmFyIHNlYXJjaExhc3RMZWFmVmFsdWUgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgLy8gc2VhcmNoIHRoZSBrZXk6XG4gICAgICAgICAgICB2YXIgc2VhcmNoUmVzdWx0ID0gc2VhcmNoTGFzdExlYWYoa2V5KTtcbiAgICAgICAgICAgIGlmICghc2VhcmNoUmVzdWx0LmZvdW5kKSByZXR1cm4gc2VhcmNoUmVzdWx0O1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIHNlYXJjaCB0aGUgdmFsdWUgKGlmIHRoZXJlIGFyZSBzZXZlcmFsIHRoZSBzYW1lIGtleXMpOlxuICAgICAgICAgICAgdmFyIHZhbHVlRm91bmQgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBsZWFmID0gc2VhcmNoUmVzdWx0Lm5vZGU7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBzZWFyY2hSZXN1bHQuaW5kZXg7XG4gICAgICAgICAgICAvL3ZhciBmb3VuZEluZGV4ID0gMDtcbiAgICAgICAgICAgIGZvciAoOyA7ICkge1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbGVhZiA9IGxlYWYucHJldkxlYWY7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsZWFmID09IG51bGwpIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGxlYWYudmFsdWVzLmNvdW50IC0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGxlYWYua2V5cy5pdGVtc1tpbmRleF0gIT0ga2V5KSBicmVhaztcbiAgICAgICAgICAgICAgICBpZiAobGVhZi52YWx1ZXMuaXRlbXNbaW5kZXhdID09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlRm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW5kZXgtLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICByZXR1cm4geyBub2RlOiBsZWFmLCBmb3VuZDogdmFsdWVGb3VuZCwgaW5kZXg6IGluZGV4IH07XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gICAgICAgcmV0dXJuIHRoZSBwdWJsaWMgaW50ZXJmYWNlOlxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgIHJldHVybiBtX3B1YmxpYztcbiAgICB9O1xuXG4gICAgQl9QbHVzX1RyZWUuRmluZEluZm8gPSBGaW5kSW5mbztcblxuICAgIC8vcmV0dXJuIEJfUGx1c19UcmVlO1xuICAgIG1vZHVsZS5leHBvcnRzID0gQl9QbHVzX1RyZWU7XG5cblxuLy99KTtcblxuXG4iLCJcbi8vIGNvdWxkIHJlbmFtZSB0aGlzIGRzX2RvdWJseV9saW5rZWRfbGlzdC5qc1xuXG4vLyBtYXliZSBub3QgcmVhbGx5IGEgcGFydCBvZiBqc2d1aT9cblxuLypcbmlmICh0eXBlb2YgZGVmaW5lICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIGRlZmluZSA9IHJlcXVpcmUoJ2FtZGVmaW5lJykobW9kdWxlKTtcbn1cblxuXG5cbmRlZmluZShbXCIuL2pzZ3VpLWxhbmctZXNzZW50aWFsc1wiXSwgZnVuY3Rpb24oanNndWkpIHtcblxuKi9cblxudmFyIGpzZ3VpID0gcmVxdWlyZSgnLi9qc2d1aS1sYW5nLWVzc2VudGlhbHMnKTtcblxuICAgIC8qKiBcbiAgICAqIERvdWJseSBsaW5rZWQgbGlzdCBtb2R1bGUuXG4gICAgKiBAbW9kdWxlIGNvcmUvanNndWktZGF0YS1zdHJ1Y3R1cmVzLWRvdWJseS1saW5rZWQtbGlzdCBcbiAgICAqIEBleHBvcnRzIERvdWJseV9MaW5rZWRfTGlzdFxuICAgICovXG5cblx0Ly8gRXNzZW50aWFscyBwcm92aWRlcyBhIGZhaXIgZmV3IHRoaW5ncy4uLiBhdCBsZWFzdCBJIGNhbiB1c2UgZnVuY3Rpb25hbCBwb2x5bW9ycGhpc20uXG5cblx0dmFyIGogPSBqc2d1aTtcblx0dmFyIENsYXNzID0gai5DbGFzcztcblx0dmFyIGVhY2ggPSBqLmVhY2g7XG5cdHZhciBpc19hcnJheSA9IGouaXNfYXJyYXk7XG5cdHZhciBpc19kb21fbm9kZSA9IGouaXNfZG9tX25vZGU7XG5cdHZhciBpc19jdHJsID0gai5pc19jdHJsO1xuXHR2YXIgZXh0ZW5kID0gai5leHRlbmQ7XG5cdHZhciB4X2Nsb25lcyA9IGoueF9jbG9uZXM7XG5cdHZhciBnZXRfdHJ1dGhfbWFwX2Zyb21fYXJyID0gai5nZXRfdHJ1dGhfbWFwX2Zyb21fYXJyO1xuXHR2YXIgZ2V0X21hcF9mcm9tX2FyciA9IGouZ2V0X21hcF9mcm9tX2Fycjtcblx0dmFyIGFycl9saWtlX3RvX2FyciA9IGouYXJyX2xpa2VfdG9fYXJyO1xuXHR2YXIgdG9mID0gai50b2Y7XG5cdHZhciBpc19kZWZpbmVkID0gai5pc19kZWZpbmVkO1xuXHR2YXIgc3RyaW5naWZ5ID0gai5zdHJpbmdpZnk7XG5cdHZhciBmdW5jdGlvbmFsX3BvbHltb3JwaGlzbSA9IGouZnVuY3Rpb25hbF9wb2x5bW9ycGhpc207XG5cdHZhciBmcCA9IGouZnA7XG5cdHZhciBhcnJheWlmeSA9IGouYXJyYXlpZnk7XG5cdHZhciBhcmVfZXF1YWwgPSBqLmFyZV9lcXVhbDtcblx0dmFyIGdldF9pdGVtX3NpZyA9IGouZ2V0X2l0ZW1fc2lnO1xuXHR2YXIgc2V0X3ZhbHMgPSBqLnNldF92YWxzO1xuXHR2YXIgdHJ1dGggPSBqLnRydXRoO1xuXHR2YXIgdHJpbV9zaWdfYnJhY2tldHMgPSBqLnRyaW1fc2lnX2JyYWNrZXRzO1xuXHRcbi8vIFRoaXMgbWF5IHVzZSBzb21lIG1vcmUgZ2VuZXJpYyBncmFwaCBub2RlP1xuXHRcblx0Ly8gVGhpcyBtYXkgbmVlZCB0byBnZXQgYWRhcHRlZCBmdXJ0aGVyIGZvciB1c2UgaW4gc29tZSBvdGhlciBjb21wb25lbnRzLlxuXHRcblx0Ly8gTm9kZXMgaGF2aW5nIGEga2V5IC0gdGhleSBnZXQgaW5zZXJ0ZWQgaW4gYSBwYXJ0aWN1bGFyIHBvc2l0aW9uLlxuXHQvLyAgSGF2aW5nIGEgdmFsdWUgdG9vPyBBIGtleSB2YWx1ZSBwYWlyIGFycmF5P1xuXHQvLyAgIFBvc3NpYmx5IGNvdWxkIG1haW50YWluIHRoZSBzb3J0ZWQgb3JkZXIgb2YgYSBsaXN0LiBUaGF0IHdpbGwgZ2V0IHVzZWQgZm9yIHRoZSBCKyB0cmVlLlxuXHRcblx0Ly8gRWFjaCBub2RlIGhhcyBhIHBhcmVudCwgYW5kIHZhcmlvdXMgY2hpbGRyZW4gLyBicmFuY2hlcy5cblx0Ly8gIEkgdGhpbmsgdGhlcmUgY2FuIGJlIHNvbWUgcmVsYXRpdmVseSBnZW5lcmljIHRyZWUgLyBub2RlIHN5c3RlbXMsIHdpdGggYisgZnVuY3Rpb25hbGl0eSBpbXBsZW1lbnRlZCBvbiB0b3Agb2YgdGhhdC5cblx0XG5cdC8vIFRoZSBCKyB0cmVlIG5vZGUgY291bGQgYmUgYW4gZXh0ZW5zaW9uIGZyb20gU29ydGVkX0RvdWJseV9MaW5rZWRfbGlzdFxuXHQvLyAgSXQgd2lsbCBvdmVycmlkZSBpbnNlcnQgY29kZSB3aXRoIGNvZGUgdGhhdCBjYW4gaW5zZXJ0IHdpdGhpbiBvdGhlciBOb2RlIG9iamVjdHMgd2l0aGluIGl0LlxuXHRcblx0Ly8gVGhlcmUgd2lsbCBiZSBhIEIrIHRyZWUgY2xhc3MgdGhhdCBtYWtlcyB1c2Ugb2YgdGhlc2Ugbm9kZXMsIGFuZCB3aWxsIHBlcmZvcm0gcmViYWxhbmNpbmcgd2hlcmUgbmVjZXNzYXJ5LlxuXHRcblx0Ly8gV2FudCBhbiBpbnRlcmZhY2UsIGxpbmtlZF9oYXNoX21hcCwgdGhhdCBoYXMgdGhlIGxpbmtlZCBsaXN0IGludGVybmFsbHlcblx0Ly8gTGlua2VkIGxpc3QgdGhhdCBoYXMgYW4gb2JqZWN0IGluc2lkZSBlYWNoIG5vZGUuXG5cdFxuXHRcblx0Ly8gRG9pbmcgbW9yZSB3b3JrIG9uIGEgbGlua2VkIGxpc3QsIGFuZCBsaW5rZWQgbWFwcGVkIGxpc3Qgd2lsbCBiZSBoZWxwZnVsLlxuXHQvLyAgU29ydGVkX0tWUywgT3JkZXJlZF9LVlM/XG5cdC8vICBPcmRlcmVkX0xpc3Q/XG5cdC8vICBPcmRlcmVkX0tWUyBtYWtlcyBzZW5zZSB3aGVuIGVhY2ggdmFsdWUgaGFzIGEga2V5IGJ1dCB0aGUgb3JkZXIgbmVlZHMgdG8gYmUgcHJlc2VydmVkLlxuXHQvLyAgIENvdWxkIGJlIGEgd3JhcHBlciBhcm91bmQgTGlua2VkX01hcC5cblx0XG4gICAgLyoqXG4gICAgKiBDcmVhdGVzIHRoZSBub2RlLlxuICAgICogQGNvbnN0cnVjdG9yXG4gICAgKiBAY2xhc3NkZXNjIFJlcHJlc2VudHMgYSBkb3VibHkgbGlua2VkIGxpc3QgaXRlbSAobmFtZWQgXCJub2RlXCIpLlxuICAgICogQGFsaWFzIERvdWJseV9MaW5rZWRfTGlzdC5Ob2RlXG4gICAgKiBAcGFyYW0ge29iamVjdH0gc3BlYyAtIHt2YWx1ZTogKG5vZGUgdmFsdWUpfVxuICAgICogQG1lbWJlcm9mIG1vZHVsZTpjb3JlL2pzZ3VpLWRhdGEtc3RydWN0dXJlcy1kb3VibHktbGlua2VkLWxpc3RcbiAgICAqIEBleGFtcGxlXG4gICAgKlxuICAgICogdmFyIG5vZGUxMDEgPSBuZXcgRG91Ymx5X0xpbmtlZF9MaXN0Lk5vZGUoeyB2YWx1ZTogMTAxIH0pO1xuICAgICovXG5cdHZhciBOb2RlID0gQ2xhc3MuZXh0ZW5kKHtcblx0XHQnaW5pdCc6IGZ1bmN0aW9uKHNwZWMpIHtcblx0XHRcdC8vIHByZXZpb3VzIGFuZCBuZXh0IGhlbGQgYXMgYW4gYXJyYXkuXG5cdFx0XHRcblx0XHRcdC8vIG5laWdoYm91cnNcblx0XHRcdC8vICBpdCBjb3VsZCBoYXZlIG5vIG5laWdoYm91cnMuXG5cdFx0XHQvLyAgIGEgbGlzdCB3aWxsIGJlIGVtcHR5LCB3aXRoIG5vIG5vZGVzLlxuXHRcdFx0Ly8gICB0aGVuIGl0IHdpbGwgaGF2ZSBhIG5vZGUgd2l0aCBubyBuZWlnaGJvdXJzLCB3aGljaCBpcyBib3RoIHRoZSBmaXJzdCBhbmQgdGhlIGxhc3Qgbm9kZS5cblx0XHRcdC8vICAgdGhlbiAyIG5vZGVzLCAxIHdpdGggZWFjaCBuZWlnaGJvdXJcblx0XHRcdC8vICAgdGhlbiAzIG5vZGVzLCB3aXRoIHRoZSBlbmQgbm9kZXMgc3RpbGwgaGF2aW5nIG5vIG5laWdoYm91cnMuXG5cdFx0XHRcblx0XHRcdC8vIFRoaXMgd2lsbCBqdXN0IGJlIGZvciBpdGVyYXRpbmcgdGhyb3VnaCB0aGUgbGlzdCwgYWRkaW5nLCByZW1vdmluZywgZG9pbmcgYmFzaWMgb3BlcmF0aW9ucy5cblx0XHRcdC8vICBJIG1heSBsZWF2ZSBpbmVmZmljaWVudCBvcGVyYXRpb25zIG91dCwgc28gdGhlIGxpbmtlZCBsaXN0IGdldHMgdXNlZCBmb3Igd2hhdCBpdCBpcyBiZXN0IGF0LlxuXHRcdFx0Ly8gICBCdXQgdGhlIGluZWZmaWNpZW50L2xlc3MgZWZmaWNpZW50IG9wZXJhdGlvbnMgbWF5IGJlIGRvbmUgdG8gbG93ZXIgYW1vdW50cywgc3VjaCBhcyAxMiwgYnkgbWFpbnRhaW5pbmcgc21hbGwgTExzIGluIGRhdGEgc3RydWN0dXJlcyBzdWNoIGFzIEIrIHRyZWVzLlxuXHRcdFx0XG5cdFx0XHR0aGlzLm5laWdoYm91cnMgPSBzcGVjLm5laWdoYm91cnMgfHwgW107XG5cdFx0XHRcblx0XHQgICAgLyoqXG4gICAgICAgICAgICAqIFRoZSBub2RlJ3MgdmFsdWUuXG4gICAgICAgICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29yZS9qc2d1aS1kYXRhLXN0cnVjdHVyZXMtZG91Ymx5LWxpbmtlZC1saXN0LkRvdWJseV9MaW5rZWRfTGlzdC5Ob2RlXG4gICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAgKiBAbmFtZSB2YWx1ZVxuICAgICAgICAgICAgKi9cblx0XHQgICAgLy8gQWRkaW5nIGFuZCByZW1vdmluZyB3aGlsZSBtYWludGFpbmluZyBhbiBvcmRlcj9cblx0XHRcdHRoaXMudmFsdWUgPSBzcGVjLnZhbHVlO1xuXHRcdFx0XG5cdFx0XHRcblx0XHRcdC8vIHBhcmVudFxuXHRcdFx0XG5cdFx0fSxcblx0ICAgIC8qKlxuICAgICAgICAqIFJldHVybnMgcHJldmlvdXMgbm9kZSBpbiB0aGUgbGlzdC5cbiAgICAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvcmUvanNndWktZGF0YS1zdHJ1Y3R1cmVzLWRvdWJseS1saW5rZWQtbGlzdC5Eb3VibHlfTGlua2VkX0xpc3QuTm9kZS5wcm90b3R5cGVcbiAgICAgICAgKi9cblx0XHQncHJldmlvdXMnOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5uZWlnaGJvdXJzWzBdO1xuXHRcdH0sXG5cdCAgICAvKipcbiAgICAgICAgKiBSZXR1cm5zIG5leHQgbm9kZSBpbiB0aGUgbGlzdC5cbiAgICAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvcmUvanNndWktZGF0YS1zdHJ1Y3R1cmVzLWRvdWJseS1saW5rZWQtbGlzdC5Eb3VibHlfTGlua2VkX0xpc3QuTm9kZS5wcm90b3R5cGVcbiAgICAgICAgKi9cblx0XHQnbmV4dCc6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiB0aGlzLm5laWdoYm91cnNbMV07XG5cdFx0fVxuXHR9KTtcblx0XG5cdC8vIERvIHRoZXNlIGxpbmtlZCBsaXN0IG5vZGVzIG5lZWQgdG8gaGF2ZSBhbnl0aGluZz9cblx0Ly8gIEp1c3QgdGhlIG1lYW5zIHRvIGluc2VydCB0aGVpciBub2RlcyBldGM/XG5cdC8vICAgVGhlbiB0aGVpciBub2RlcyBjb3VsZCBiZSBtYWRlIHRvIGNhcnJ5IG90aGVyIGRhdGEgYnkgb3RoZXIgY29tcG9uZW50cy5cblx0XG5cdC8vIERvdWJseV9MaW5rZWRfTGlzdCBjb3VsZCBleHRlbmQgTm9kZS5cblx0Ly8gIFRoYXQgd2F5IGl0IGNhbiBiZSBwdXQgaW4gYSB0cmVlLCBhbmQgdXNlZCBmb3IgaG9sZGluZyB0aGUgZGF0YSBpbiBhIHRyZWUuXG5cdC8vICBXYW50IGEgQisgdHJlZSBzbyB0aGF0IGl0ZW1zIGNhbiBnZXQgcHV0IGluIGNvcnJlY3RseS5cblx0XG5cdC8vIEhhdmluZyBhIHdob2xlIHRyZWUgbWFkZSB1cCBvZiBhIGRvdWJseSBsaW5rZWQgbGlzdCwgd2l0aCBvdGhlciBzdHJ1Y3R1cmVzIGluZGV4aW5nIGl0P1xuXHQvLyAgTmVlZCBzb21lIG1vcmUgZnVuZGFtZW50YWwgZGF0YSBzdHJ1Y3R1cmVzLiBUaGUgQ29sbGVjdGlvbiBhbmQgRGF0YV9PYmplY3Qgd2lsbCBiZSBnb29kLCBidXQgaXQgd2lsbCBiZSBnb29kIHRvIHN0b3JlIHRoZSBmaWVsZHMgaW4gYW4gYXBwcm9wcmlhdGUgb2JqZWN0LlxuXHRcblx0XG5cdC8vIE9yZGVyZWRfS1ZTIC0gbWF5IGJlIGEgdXNlZnVsIG9uZS5cblx0Ly8gIFdvdWxkIGhhdmUgdGhlIGRvdWJsZSBsaW5rZWQgbGlzdCBpbnNpZGUgYW5kIG1hcC5cblx0XG5cdFxuXHQvLyBNYXBwZWRfTGlua2VkX0xpc3Q/IHdvdWxkIG5lZWQgdG8ga25vdyB3aGF0IGZpZWxkIHRvIGxvb2sgYXQuXG5cdFxuXHR2YXIgbm9kaWZ5ID0gZnVuY3Rpb24oZm4pIHtcblx0XHRcblx0XHR2YXIgcmVzID0gZnVuY3Rpb24odmFsKSB7XG5cdFx0XHRpZiAodmFsIGluc3RhbmNlb2YgTm9kZSkge1xuXHRcdFx0XHRyZXR1cm4gZm4odmFsKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBub2RlID0gbmV3IE5vZGUoeyd2YWx1ZSc6IHZhbH0pO1xuXHRcdFx0XHRyZXR1cm4gZm4obm9kZSk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHR9O1xuXHRcdHJldHVybiByZXM7XG5cdFx0XG5cdH1cblx0XG5cdFxuICAgIC8qKlxuICAgICogQ3JlYXRlcyB0aGUgZG91Ymx5IGxpbmtlZCBsaXN0LlxuICAgICogQGNvbnN0cnVjdG9yXG4gICAgKiBAY2xhc3NkZXNjIFJlcHJlc2VudHMgYSBkb3VibHkgbGlua2VkIGxpc3QuXG4gICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvcmUvanNndWktZGF0YS1zdHJ1Y3R1cmVzLWRvdWJseS1saW5rZWQtbGlzdFxuICAgICovXG5cdHZhciBEb3VibHlfTGlua2VkX0xpc3QgPSBDbGFzcy5leHRlbmQoe1xuXHRcdCdpbml0JzogZnVuY3Rpb24oc3BlYykge1xuXHRcdFx0Ly8gc3BlYyBjb3VsZCBiZSB0aGUgaW5pdGlhbCBpdGVtcyBmb3IgdGhlIGxpc3QuXG5cdFx0XHRcblx0XHRcdHRoaXMuZmlyc3QgPSBudWxsO1xuXHRcdFx0dGhpcy5sYXN0ID0gbnVsbDtcblx0XHRcdFxuXHRcdFx0dGhpcy5sZW5ndGggPSAwO1xuXHRcdFx0Ly8gaGFyZGVyIHRvIG1haW50YWluIHRoZSBsZW5ndGggd2hlbiBub2RlcyBjb3VsZCBiZSBtb3ZlZCBhcm91bmQgdGhlIGxpc3QuXG5cdFx0XHQvLyAgd291bGQgbmVlZCB0byBiZSBhYmxlIHRvIHNlZSBpZiBhIG5vZGUgaXMgaW4gdGhlIGxpc3QgdG8gYmVnaW4gd2l0aC4uLlxuXHRcdFx0Ly8gICBzbyBlYWNoIG5vZGUgY291bGQgaGF2ZSBhIGNvbnRhaW5lciBvYmplY3QsIGFuZCBpZiBpdCBpcyBzZXQgdG8gdGhlIGxpc3QgYWxyZWFkeSB3aGVuIGFuIGluc2VydCBpcyBkb25lLCB0aGVuIHRoZSBsaXN0IHdpbGwgYmUgYWJsZSB0byBrZWVwIHRyYWNrIG9mXG5cdFx0XHQvLyAgICBpdHMgbGVuZ3RoLiBUaGF0IHdvdWxkIGJlIGJldHRlciB0aGFuIGhhdmluZyB0byBjb3VudCB0aGVtLlxuXHRcdFx0XG5cdFx0fSxcblx0XHRcblx0ICAgIC8qKlxuICAgICAgICAqIEl0ZXJhdGVzIG92ZXIgdGhlIGxpc3Qgbm9kZXMgY2FsbGluZyB0aGUgZnVuY3Rpb24gZm9yIGVhY2ggbm9kZS5cbiAgICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayAtIGNhbGxiYWNrIGZ1bmN0aW9uOiBjYWxsYmFjayhub2RlLCBzdG9wKVxuICAgICAgICAqIC0gbm9kZTogdGhlIGxpc3Qgbm9kZVxuICAgICAgICAqIC0gc3RvcDogZnVuY3Rpb24gdG8gYnJlYWsgaXRlcmF0aW9ucy5cbiAgICAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvcmUvanNndWktZGF0YS1zdHJ1Y3R1cmVzLWRvdWJseS1saW5rZWQtbGlzdC5Eb3VibHlfTGlua2VkX0xpc3QucHJvdG90eXBlXG4gICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgKlxuICAgICAgICAqIGZ1bmN0aW9uIGdldE5vZGVzKGxpc3QpIHtcbiAgICAgICAgKiAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICAqICAgICAvL1xuICAgICAgICAqICAgICBsaXN0LmVhY2hfbm9kZShmdW5jdGlvbiAobm9kZSkgeyByZXN1bHQucHVzaChub2RlKTsgfSk7XG4gICAgICAgICogICAgIC8vXG4gICAgICAgICogICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICogfVxuICAgICAgICAqXG4gICAgICAgICovXG5cdFx0J2VhY2hfbm9kZSc6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuXHRcdFx0Ly9jb25zb2xlLmxvZygnZWFjaF9ub2RlIHRoaXMubGVuZ3RoICcgKyB0aGlzLmxlbmd0aCk7XG5cdFx0XHRcblx0XHRcdHZhciBub2RlID0gdGhpcy5maXJzdDtcblx0XHRcdHZhciBjdHUgPSB0cnVlO1xuXHRcdFx0dmFyIHN0b3AgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0Y3R1ID0gZmFsc2U7XG5cdFx0XHR9O1xuXHRcdFx0d2hpbGUgKG5vZGUgJiYgY3R1KSB7XG5cdFx0XHRcdGNhbGxiYWNrKG5vZGUsIHN0b3ApO1xuXHRcdFx0XHRub2RlID0gbm9kZS5uZWlnaGJvdXJzWzFdO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XG5cdCAgICAvKipcbiAgICAgICAgKiBJdGVyYXRlcyBvdmVyIHRoZSBsaXN0IG5vZGVzIGNhbGxpbmcgdGhlIGZ1bmN0aW9uIGZvciBlYWNoIG5vZGUncyB2YWx1ZS5cbiAgICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayAtIGNhbGxiYWNrIGZ1bmN0aW9uOiBjYWxsYmFjayh2YWx1ZSwgc3RvcClcbiAgICAgICAgKiAtIHZhbHVlOiB0aGUgbGlzdCBub2RlIHZhbHVlXG4gICAgICAgICogLSBzdG9wOiBmdW5jdGlvbiB0byBicmVhayBpdGVyYXRpb25zLlxuICAgICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29yZS9qc2d1aS1kYXRhLXN0cnVjdHVyZXMtZG91Ymx5LWxpbmtlZC1saXN0LkRvdWJseV9MaW5rZWRfTGlzdC5wcm90b3R5cGVcbiAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAqXG4gICAgICAgICogZnVuY3Rpb24gZ2V0VmFsdWVzKGxpc3QpIHtcbiAgICAgICAgKiAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICAqICAgICAvL1xuICAgICAgICAqICAgICBsaXN0LmVhY2goZnVuY3Rpb24gKHZhbHVlKSB7IHJlc3VsdC5wdXNoKHZhbHVlKTsgfSk7XG4gICAgICAgICogICAgIC8vXG4gICAgICAgICogICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICogfVxuICAgICAgICAqXG4gICAgICAgICovXG5cdFx0J2VhY2gnOiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcblx0XHRcdHRoaXMuZWFjaF9ub2RlKGZ1bmN0aW9uKG5vZGUsIHN0b3ApIHtcblx0XHRcdFx0Y2FsbGJhY2sobm9kZS52YWx1ZSwgc3RvcCk7XG5cdFx0XHR9KTtcblx0XHR9LFxuXHRcdFxuXHQgICAgLyoqXG4gICAgICAgICogUmVtb3ZlcyB0aGUgbm9kZSBmcm9tIHRoZSBsaXN0LlxuICAgICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZSAtIG5vZGUgdG8gcmVtb3ZlXG4gICAgICAgICogQG1lbWJlcm9mIG1vZHVsZTpjb3JlL2pzZ3VpLWRhdGEtc3RydWN0dXJlcy1kb3VibHktbGlua2VkLWxpc3QuRG91Ymx5X0xpbmtlZF9MaXN0LnByb3RvdHlwZVxuICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICpcbiAgICAgICAgKiB2YXIgbGlzdCA9IG5ldyBEb3VibHlfTGlua2VkX0xpc3QoKTtcbiAgICAgICAgKiB2YXIgbm9kZTEwMSA9IG5ldyBEb3VibHlfTGlua2VkX0xpc3QuTm9kZSh7IHZhbHVlOiAxMDEgfSk7XG4gICAgICAgICpcbiAgICAgICAgKiBsaXN0LnB1c2gobm9kZTEwMSk7XG4gICAgICAgICogbGlzdC5yZW1vdmUobm9kZTEwMSk7XG4gICAgICAgICpcbiAgICAgICAgKiAvLyB0aGUgbGlzdCBpcyBlbXB0eSBub3dcbiAgICAgICAgKi9cblx0XHQncmVtb3ZlJzogKGZ1bmN0aW9uIChub2RlKSB7XG5cdFx0XHRcblx0XHRcdC8vIGNhbiBub3QgcmVtb3ZlIGEgdmFsdWUuLi4gaGF2ZSB0byByZW1vdmUgYSBub2RlLlxuXHRcdFx0Ly8gIHRoaXMgd2lsbCBiZSBtb3JlIHVzZWZ1bCB3aGVuIHRoZXJlIGlzIGEgbWFwIG9mIHZhbHVlcy5cblx0XHRcdFxuXHRcdFx0aWYgKG5vZGUubmVpZ2hib3Vyc1swXSkge1xuXHRcdFx0XHRub2RlLm5laWdoYm91cnNbMF0ubmVpZ2hib3Vyc1sxXSA9IG5vZGUubmVpZ2hib3Vyc1sxXTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuZmlyc3QgPSBub2RlLm5laWdoYm91cnNbMV07XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGlmIChub2RlLm5laWdoYm91cnNbMV0pIHtcblx0XHRcdFx0bm9kZS5uZWlnaGJvdXJzWzFdLm5laWdoYm91cnNbMF0gPSBub2RlLm5laWdoYm91cnNbMF07XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLmxhc3QgPSBub2RlLm5laWdoYm91cnNbMF07XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdG5vZGUubmVpZ2hib3VycyA9IFtdO1xuXHRcdFx0XG5cdFx0XHRpZiAobm9kZS5wYXJlbnQgPT0gdGhpcykge1xuXHRcdFx0XHRkZWxldGUgbm9kZS5wYXJlbnQ7XG5cdFx0XHRcdHRoaXMubGVuZ3RoLS07XG5cdFx0XHR9XG5cdFx0XHRcblx0XHR9KSxcblx0XHRcblx0XHQvLyBjaGVjayB0byBzZWUgaWYgdGhlIGl0ZW0gaXMgYSAnbm9kZScgb2JqZWN0LlxuXHRcdC8vICBpZiBpdCBpcywgY2FuIGluc2VydCBpdCBhcyBhIG5vZGUsIG90aGVyd2lzZSBjcmVhdGUgdGhlIG5vZGUgb2JqZWN0IGFuZCBpbnNlcnQgaXQuXG5cdFx0Ly8gICBhIGJpdCBsaWtlIHdyYXBwaW5nIHZhbHVlcyBpbiBEYXRhX1ZhbHVlLlxuXHRcdFxuXHQgICAgLyoqXG4gICAgICAgICogSW5zZXJ0cyB0aGUgbm9kZSBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBsaXN0LlxuICAgICAgICAqIEBwYXJhbSB7Tm9kZXwqfSBub2RlIC0gbm9kZSB0byBpbnNlcnQsIG9yIG5vZGUgdmFsdWVcbiAgICAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvcmUvanNndWktZGF0YS1zdHJ1Y3R1cmVzLWRvdWJseS1saW5rZWQtbGlzdC5Eb3VibHlfTGlua2VkX0xpc3QucHJvdG90eXBlXG4gICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgKlxuICAgICAgICAqIHZhciBsaXN0ID0gbmV3IERvdWJseV9MaW5rZWRfTGlzdCgpO1xuICAgICAgICAqIHZhciBub2RlMTAxID0gbmV3IERvdWJseV9MaW5rZWRfTGlzdC5Ob2RlKHsgdmFsdWU6IDEwMSB9KTtcbiAgICAgICAgKlxuICAgICAgICAqIGxpc3QuaW5zZXJ0X2JlZ2lubmluZyhub2RlMTAxKTtcbiAgICAgICAgKiBsaXN0Lmluc2VydF9iZWdpbm5pbmcoMTAyKTtcbiAgICAgICAgKlxuICAgICAgICAqIC8vIGxpc3QgdmFsdWVzOiAxMDIsIDEwMVxuICAgICAgICAqL1xuXHRcdCdpbnNlcnRfYmVnaW5uaW5nJzogZnVuY3Rpb24gKHZhbCkge1xuXHRcdFx0aWYgKHZhbCBpbnN0YW5jZW9mIE5vZGUpIHtcblx0XHRcdFx0aWYgKHRoaXMuZmlyc3QgPT0gbnVsbCkge1xuXHRcdFx0XHRcdHRoaXMuZmlyc3QgPSB2YWw7XG5cdFx0XHRcdFx0dGhpcy5sYXN0ID0gdmFsO1xuXHRcdFx0XHRcdHZhbC5uZWlnaGJvdXJzID0gW107XG5cdFx0XHRcdFx0aWYgKHZhbC5wYXJlbnQgIT0gdGhpcykge1xuXHRcdFx0XHRcdFx0dmFsLnBhcmVudCA9IHRoaXM7XG5cdFx0XHRcdFx0XHR0aGlzLmxlbmd0aCsrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBpbnNlcnQgaXQgYmVmb3JlIGZpcnN0IGl0ZW0uXG5cdFx0XHRcdFx0dGhpcy5pbnNlcnRfYmVmb3JlKHZhbCwgdGhpcy5maXJzdCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHZhbDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBub2RlID0gbmV3IE5vZGUoeyd2YWx1ZSc6IHZhbH0pO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5pbnNlcnRfYmVnaW5uaW5nKG5vZGUpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XG5cdFx0Ly8gY291bGQgdXNlIGEgbm9kaWZ5IGZ1bmN0aW9uLlxuXHRcdC8vICBvciBlbnN1cmVfZGF0YV93cmFwcGVyXG5cdFx0XG5cdCAgICAvKipcbiAgICAgICAgKiBJbnNlcnRzIHRoZSBub2RlIGJlZm9yZSB0aGUgc3BlY2lmaWVkIG5vZGUuXG4gICAgICAgICogQHBhcmFtIHtOb2RlfCp9IHZhbCAtIG5vZGUgdG8gaW5zZXJ0LCBvciBub2RlIHZhbHVlXG4gICAgICAgICogQHBhcmFtIHtOb2RlfSBub2RlIC0gaW5zZXJ0IHBvaW50XG4gICAgICAgICogQG1lbWJlcm9mIG1vZHVsZTpjb3JlL2pzZ3VpLWRhdGEtc3RydWN0dXJlcy1kb3VibHktbGlua2VkLWxpc3QuRG91Ymx5X0xpbmtlZF9MaXN0LnByb3RvdHlwZVxuICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICpcbiAgICAgICAgKiB2YXIgbGlzdCA9IG5ldyBEb3VibHlfTGlua2VkX0xpc3QoKTtcbiAgICAgICAgKiB2YXIgbm9kZTEwMSA9IG5ldyBEb3VibHlfTGlua2VkX0xpc3QuTm9kZSh7IHZhbHVlOiAxMDEgfSk7XG4gICAgICAgICpcbiAgICAgICAgKiBsaXN0LnB1c2gobm9kZTEwMSk7XG4gICAgICAgICogbGlzdC5pbnNlcnRfYmVmb3JlKDEwMiwgbm9kZTEwMSk7XG4gICAgICAgICpcbiAgICAgICAgKiAvLyBsaXN0IHZhbHVlczogMTAyLCAxMDFcbiAgICAgICAgKi9cblx0XHQnaW5zZXJ0X2JlZm9yZSc6IGZ1bmN0aW9uICh2YWwsIG5vZGUpIHtcblx0XHRcdC8vIGNoZWNrIHRvIHNlZSBpZiB0aGUgbmV3IHZhbHVlIGlzIGEgbm9kZS5cblx0XHRcdFxuXHRcdFx0aWYgKHZhbCBpbnN0YW5jZW9mIE5vZGUpIHtcblx0XHRcdFx0dmFsLm5laWdoYm91cnMgPSBbbm9kZS5uZWlnaGJvdXJzWzBdLCBub2RlXTtcblx0XHRcdFx0aWYgKG5vZGUubmVpZ2hib3Vyc1swXSA9PSBudWxsKSB7XG5cdFx0XHRcdFx0dGhpcy5maXJzdCA9IHZhbDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRub2RlLm5laWdoYm91cnNbMF0ubmVpZ2hib3Vyc1sxXSA9IHZhbDtcblx0XHRcdFx0fVxuXHRcdFx0XHRub2RlLm5laWdoYm91cnNbMF0gPSB2YWw7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAodmFsLnBhcmVudCAhPSB0aGlzKSB7XG5cdFx0XHRcdFx0dmFsLnBhcmVudCA9IHRoaXM7XG5cdFx0XHRcdFx0dGhpcy5sZW5ndGgrKztcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdmFsO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIG5ld19ub2RlID0gbmV3IE5vZGUoeyd2YWx1ZSc6IHZhbH0pO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5pbnNlcnRfYmVmb3JlKG5ld19ub2RlLCBub2RlKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdH0sXG5cdFx0XG5cdCAgICAvKipcbiAgICAgICAgKiBJbnNlcnRzIHRoZSBub2RlIGFmdGVyIHRoZSBzcGVjaWZpZWQgbm9kZS5cbiAgICAgICAgKiBAcGFyYW0ge05vZGV8Kn0gdmFsIC0gbm9kZSB0byBpbnNlcnQsIG9yIG5vZGUgdmFsdWVcbiAgICAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgLSBpbnNlcnQgcG9pbnRcbiAgICAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvcmUvanNndWktZGF0YS1zdHJ1Y3R1cmVzLWRvdWJseS1saW5rZWQtbGlzdC5Eb3VibHlfTGlua2VkX0xpc3QucHJvdG90eXBlXG4gICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgKlxuICAgICAgICAqIHZhciBsaXN0ID0gbmV3IERvdWJseV9MaW5rZWRfTGlzdCgpO1xuICAgICAgICAqIHZhciBub2RlMTAxID0gbmV3IERvdWJseV9MaW5rZWRfTGlzdC5Ob2RlKHsgdmFsdWU6IDEwMSB9KTtcbiAgICAgICAgKlxuICAgICAgICAqIGxpc3QucHVzaChub2RlMTAxKTtcbiAgICAgICAgKiBsaXN0Lmluc2VydF9hZnRlcigxMDIsIG5vZGUxMDEpO1xuICAgICAgICAqXG4gICAgICAgICogLy8gbGlzdCB2YWx1ZXM6IDEwMSwgMTAyXG4gICAgICAgICovXG5cdFx0J2luc2VydF9hZnRlcic6IGZ1bmN0aW9uICh2YWwsIG5vZGUpIHtcblx0XHRcdGlmICh2YWwgaW5zdGFuY2VvZiBOb2RlKSB7XG5cdFx0XHRcdC8vY29uc29sZS5sb2coJ2luc2VydCBhZnRlciBub2RlICcgKyBub2RlKTtcblx0XHRcdFx0XG5cdFx0XHRcdHZhbC5uZWlnaGJvdXJzID0gW25vZGUsIG5vZGUubmVpZ2hib3Vyc1sxXV07XG5cdFx0XHRcdGlmIChub2RlLm5laWdoYm91cnNbMV0gPT0gbnVsbCkge1xuXHRcdFx0XHRcdHRoaXMubGFzdCA9IHZhbDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRub2RlLm5laWdoYm91cnNbMV0ubmVpZ2hib3Vyc1swXSA9IHZhbDtcblx0XHRcdFx0XHRcblx0XHRcdFx0fVxuXHRcdFx0XHRub2RlLm5laWdoYm91cnNbMV0gPSB2YWw7XG5cdFx0XHRcdFxuXHRcdFx0XHQvL25vZGUubmVpZ2hib3Vyc1swXS5uZWlnaGJvdXJzWzFdID0gdmFsO1xuXHRcdFx0XHRpZiAodmFsLnBhcmVudCAhPSB0aGlzKSB7XG5cdFx0XHRcdFx0dmFsLnBhcmVudCA9IHRoaXM7XG5cdFx0XHRcdFx0dGhpcy5sZW5ndGgrKztcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdmFsO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIG5ld19ub2RlID0gbmV3IE5vZGUoeyd2YWx1ZSc6IHZhbH0pO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5pbnNlcnRfYWZ0ZXIobmV3X25vZGUsIG5vZGUpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0Ly8gbm90IHdyYXBwaW5nIHRoZSBpdGVtIGluIGEgbm9kZT9cblx0XHRcblx0XHQvLyB3YW50IG9uZSB3aGVyZSB3ZSBhcmUgbm90IHB1c2hpbmcgbm9kZXMsIGJ1dCBpdGVtcyBzdG9yZWQgaW4gbm9kZXMuXG5cdFx0Ly8gIFBlcmhhcHMgdGhpcyBpcyBhIERhdGFfVmFsdWU/XG5cdFx0Ly8gT3IgYSBkb3VibHlfbGlua2VkX25vZGUuXG5cdFx0XG5cdFx0Ly8gRG91Ymx5X0xpbmtlZF9Ob2RlIGNvdWxkIHRha2UgdGhlIGZvcm0gW3ByZXYsIGl0ZW0sIG5leHRdXG5cdFx0Ly8gIFtwcmV2LCBpdGVtLCBrZXksIG5leHRdPyBwcm9iYWJseSBub3Rcblx0XHRcblx0XHQvLyAgTWF5YmUgd2UgY291bGQgcHV0IG1vcmUgcHJpdmF0ZSB2YXJpYWJsZXMsIHN1Y2ggYXMgJ25laWdoYm91cnMnIGFzIGEgdmFyIHdpdGhpbiB0aGUgaW5pdCBzdGF0ZW1lbnQuXG5cdFx0XG5cdCAgICAvKipcbiAgICAgICAgKiBJbnNlcnRzIHRoZSBub2RlIGF0IHRoZSBlbmQgb2YgdGhlIGxpc3QuXG4gICAgICAgICogQHBhcmFtIHtOb2RlfCp9IHZhbCAtIG5vZGUgdG8gaW5zZXJ0LCBvciBub2RlIHZhbHVlXG4gICAgICAgICogQG1lbWJlcm9mIG1vZHVsZTpjb3JlL2pzZ3VpLWRhdGEtc3RydWN0dXJlcy1kb3VibHktbGlua2VkLWxpc3QuRG91Ymx5X0xpbmtlZF9MaXN0LnByb3RvdHlwZVxuICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICpcbiAgICAgICAgKiB2YXIgbGlzdCA9IG5ldyBEb3VibHlfTGlua2VkX0xpc3QoKTtcbiAgICAgICAgKiB2YXIgbm9kZTEwMSA9IG5ldyBEb3VibHlfTGlua2VkX0xpc3QuTm9kZSh7IHZhbHVlOiAxMDEgfSk7XG4gICAgICAgICpcbiAgICAgICAgKiBsaXN0LnB1c2gobm9kZTEwMSk7XG4gICAgICAgICogbGlzdC5wdXNoKDEwMik7XG4gICAgICAgICpcbiAgICAgICAgKiAvLyBsaXN0IHZhbHVlczogMTAxLCAxMDJcbiAgICAgICAgKi9cblx0XHQncHVzaCc6IGZ1bmN0aW9uICh2YWwpIHtcblx0XHRcdFxuXHRcdFx0aWYgKHZhbCBpbnN0YW5jZW9mIE5vZGUpIHtcblx0XHRcdFx0aWYgKHRoaXMubGFzdCA9PSBudWxsKSB7XG5cdFx0XHRcdFx0dGhpcy5pbnNlcnRfYmVnaW5uaW5nKHZhbCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuaW5zZXJ0X2FmdGVyKHZhbCwgdGhpcy5sYXN0KTtcblx0XHRcdFx0XHQvKlxuXHRcdFx0XHRcdHZhciBsYXN0ID0gdGhpcy5sYXN0O1xuXHRcdFx0XHRcdGxhc3QubmVpZ2hib3Vyc1sxXSA9IHZhbDtcblx0XHRcdFx0XHR0aGlzLmxhc3QgPSB2YWw7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Ly9jb25zb2xlLmxvZygndmFsLnBhcmVudCAnICsgdmFsLnBhcmVudCk7XG5cdFx0XHRcdFx0Ly9jb25zb2xlLmxvZygndGhpcyAnICsgdGhpcyk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKHZhbC5wYXJlbnQgIT0gdGhpcykge1xuXHRcdFx0XHRcdFx0dmFsLnBhcmVudCA9IHRoaXM7XG5cdFx0XHRcdFx0XHR0aGlzLmxlbmd0aCsrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQqL1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB2YWw7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgbmV3X25vZGUgPSBuZXcgTm9kZSh7J3ZhbHVlJzogdmFsfSk7XG5cdFx0XHRcdHJldHVybiB0aGlzLnB1c2gobmV3X25vZGUpO1xuXHRcdFx0fVxuXHRcdFx0Ly8gdGhlIGl0ZW0gZ2V0cyB3cmFwcGVkIGluIGEgbm9kZS4/XG5cdFx0XHRcblx0XHRcdFxuXHRcdFx0XG5cdFx0fVxuXHR9KTtcblx0XG4gICAgLyoqXG4gICAgKiBUaGUgbGlzdCBub2RlIGNsYXNzLlxuICAgICogQG1lbWJlcm9mIG1vZHVsZTpjb3JlL2pzZ3VpLWRhdGEtc3RydWN0dXJlcy1kb3VibHktbGlua2VkLWxpc3QuRG91Ymx5X0xpbmtlZF9MaXN0XG4gICAgKiBAbmFtZSBEb3VibHlfTGlua2VkX0xpc3QuTm9kZVxuICAgICovXG5cblx0RG91Ymx5X0xpbmtlZF9MaXN0Lk5vZGUgPSBOb2RlO1xuXHRcblx0XG5cdC8vIHZhciBqc2d1aSA9IHt9O1xuXHQvLyBhbGVydCgncmV0dXJuaW5nIGpzZ3VpIGZyb20ganNndWktbGFuZycpO1xuXHQvL3JldHVybiBqc2d1aTtcbm1vZHVsZS5leHBvcnRzID0gRG91Ymx5X0xpbmtlZF9MaXN0O1xuXG5cdC8vcmV0dXJuIERvdWJseV9MaW5rZWRfTGlzdDtcblx0XG5cdFxuLy99KTtcbiIsIlxuLy8gVGhpcyBpcyByZXN1bHRpbmcgaW4gc21hbGxlciBjb2RlIGluIG90aGVyIHBhcnRzIG9mIHRoZSBmcmFtZXdvcmsuXG4vLyAgVGhpcyBzZWN0aW9uIGlzIGdldHRpbmcgcXVpdGUgYmlnIChhZ2Fpbilcbi8vICBTdGlsbCBuZWVkIHRvIG1ha2UgdXNlIG9mIHRoZSBCKyBmcmVlIGZvciBvcmRlcmVkIGluZGV4aW5nLlxuXG4vLyBNb3Zpbmcgc29tZSBjb2RlIHRvIGpzZ3VpLWxhbmctZXNzZW50aWFsc1xuLy8gIFdpbGwgYmUgcHVibGlzaGluZyBhIDAuNCB2ZXJzaW9uIG9mIHRoYXQgYmVmb3JlIHNvIGxvbmc/XG4vLyAgIE1heWJlIHdpdGggbW9yZSBleHBsYW5hdGlvbj9cblxuLy8gSXQgbWF5IGJlIHdvcnRoIHB1Ymxpc2hpbmcgdGhpcywgYW5kIGEgZGlzY3Vzc2lvbiBmb3J1bSBhYm91dCBpdCBvbiBteSBvd24gd2ViIGZvcnVtLlxuLy8gIFBlcmhhcHMgdGhhdCBjb3VsZCBjb21lIGxhdGVyLCBidXQganNndWktbGFuZy1lc3NlbnRpYWxzIG1heSBiZSBhIGdvb2Qgc3RlcC4gQ291bGQgY2FsbCBpdCB2ZXJzaW9uIDAuMzUuXG4vLyAgIENvdWxkIGhhdmUgYSBmZXcgZXhhbXBsZXNcbi8vICAgV291bGQgYmUgYSB1c2VmdWwgdG9vbGtpdCBJIGNvdWxkIHVzZSB3aGlsZSB3b3JraW5nIGVsc2V3aGVyZS5cblxuLy8gIEkgdGhpbmsgdGhhdCB3ZWIgc2l0ZSB3b3VsZCBiZSBsaWdodGVuaW5nIGZhc3QsIGFuZCBpbXByZXNzIHBlb3BsZSB3aXRoIGl0cyBzcGVlZCBjb21wYXJlZCB0byBvdGhlciB3ZWIgcGxhdGZvcm1zIHRoYXQgdGhleSBhcmUgdXNlZCB0b1xuLy8gICAodGhvdWdoIEZhY2Vib29rIGlzIE9LKVxuXG4vKlxuaWYgKHR5cGVvZiBkZWZpbmUgIT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgZGVmaW5lID0gcmVxdWlyZSgnYW1kZWZpbmUnKShtb2R1bGUpO1xufVxuXG5cbi8vIE1heSBzd2F5IGltcGxlbWVudGF0aW9ucyBvZiB0aGUgcGFydGljdWxhciBpdGVtcyBtb3JlIGVhc2lseSB3aGVuIHRoZXkgYXJlIGluIHRoZWlyIG93biBmaWxlcy5cblxuZGVmaW5lKFtcIi4vanNndWktbGFuZy1lc3NlbnRpYWxzXCJdLCBmdW5jdGlvbiAoanNndWkpIHtcbiAgICAqL1xudmFyIGpzZ3VpID0gcmVxdWlyZSgnLi9qc2d1aS1sYW5nLWVzc2VudGlhbHMnKTtcblxuICAgIC8vIFN0aWZmQXJyYXk6IGFuIGFycmF5IHdpdGggcHJlLWFsbG9jYXRlZCBpdGVtc1xuICAgIC8vIGl0IHNlZW1zIHRoYXQgdGhpcyBhcnJheSBpcyB1c3VhbGx5IGZhc3RlciAoZXhjbHVkaW5nIElFIGphdmFzY3JpcHQgZW5naW5lKVxuICAgIC8vIHByb2JhYmx5IHRoZXJlIGlzIGEgcmVhc29uIHRvIHByb3ZpZGUgSUUgaW1wbGVtZW50YXRpb24gYmFzZWQgb24gdXN1YWwgZHluYW1pYyBhcnJheXNcblxuICAgIC8qKiBcbiAgICAqIFN0aWZmIEFycmF5IG1vZHVsZS5cbiAgICAqIEBtb2R1bGUgY29yZS9qc2d1aS1kYXRhLXN0cnVjdHVyZXMtc3RpZmZhcnJheVxuICAgICogQGV4cG9ydHMgU3RpZmZBcnJheVxuICAgICovXG5cblxuICAgIHZhciBTdGlmZkFycmF5ID0gZnVuY3Rpb24gKGNhcGFjaXR5KSB7XG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gICAgICAgICAgICAgIHB1YmxpYyBpbnRlcmZhY2U6XG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgLyoqXG4gICAgICAgICogQ3JlYXRlcyB0aGUgc3RpZmYgYXJyYXkuXG4gICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgICogQGNsYXNzZGVzYyBcbiAgICAgICAgKiBBbiBhcnJheSB3aXRoIHByZS1hbGxvY2F0ZWQgaXRlbXMuXG4gICAgICAgICogSXQgc2VlbXMgdGhhdCB0aGlzIGFycmF5IGlzIHVzdWFsbHkgZmFzdGVyIChleGNsdWRpbmcgSUUgamF2YXNjcmlwdCBlbmdpbmUpLlxuICAgICAgICAqIFByb2JhYmx5IHRoZXJlIGlzIGEgcmVhc29uIHRvIHByb3ZpZGUgSUUgaW1wbGVtZW50YXRpb24gYmFzZWQgb24gdXN1YWwgZHluYW1pYyBhcnJheXMuXG4gICAgICAgICpcbiAgICAgICAgKiBAYWxpYXMgU3RpZmZBcnJheVxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjYXBhY2l0eSAtIGFycmF5IGNhcGFjaXR5IChtYXhpbXVtIHBvc3NpYmxlIG51bWJlciBvZiBpdGVtcykuXG4gICAgICAgICogQG1lbWJlcm9mICBtb2R1bGU6Y29yZS9qc2d1aS1kYXRhLXN0cnVjdHVyZXMtc3RpZmZhcnJheVxuICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICpcbiAgICAgICAgKiB2YXIgYXJyYXkgPSBuZXcgU3RpZmZBcnJheSg3KTtcbiAgICAgICAgKi9cblxuICAgICAgICB2YXIgbV9wdWJsaWMgPSB7XG4gICAgICAgICAgICAvKiogXG4gICAgICAgICAgICAqIGludGVybmFsIHN0b3JhZ2UgYXJyYXkgXG4gICAgICAgICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgaXRlbXM6IG5ldyBBcnJheShjYXBhY2l0eSksXG4gICAgICAgICAgICAvKiogXG4gICAgICAgICAgICAqIGl0ZW1zIGNvdW50XG4gICAgICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNvdW50OiAwLFxuICAgICAgICAgICAgLyoqIFxuICAgICAgICAgICAgKiBSZXR1cm5zIHRoZSBmaXJzdCBpdGVtXG4gICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZpcnN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY291bnQgPT0gMCkgdGhyb3cgXCJTdGlmZkFycmF5LmZpcnN0KClcIjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pdGVtc1swXTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvKiogXG4gICAgICAgICAgICAqIFJldHVybnMgdGhlIGxhc3QgaXRlbVxuICAgICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICAgICovXG4gICAgICAgICAgICBsYXN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY291bnQgPT0gMCkgdGhyb3cgXCJTdGlmZkFycmF5Lmxhc3QoKVwiO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZW1zW3RoaXMuY291bnQgLSAxXTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvKiogXG4gICAgICAgICAgICAqIEFkZHMgaXRlbVxuICAgICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICAgICogQHBhcmFtIHsqfSBpdGVtIC0gaXRlbSB0byBhZGRcbiAgICAgICAgICAgICovXG4gICAgICAgICAgICBhZGQ6IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY291bnQgPj0gY2FwYWNpdHkpIHRocm93IFwiU3RpZmZBcnJheS5hZGQoKVwiO1xuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgdGhpcy5pdGVtc1t0aGlzLmNvdW50KytdID0gaXRlbTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvKiogXG4gICAgICAgICAgICAqIEFkZHMgYWxsIHRoZSBpdGVtcyBmcm9tIHRoZSAgc291cmNlICh0byB0aGUgZW5kIG9mIHRoZSBleGlzdGluZyBpdGVtcylcbiAgICAgICAgICAgICogQHBhcmFtIHtTdGlmZkFycmF5fSBzb3VyY2UgLSBzb3VyY2Ugc3RpZmYgYXJyYXlcbiAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgYWRkX2Zyb206IGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb3VudCArIHNvdXJjZS5jb3VudCA+IGNhcGFjaXR5KSB0aHJvdyBcIlN0aWZmQXJyYXkuYWRkX2Zyb20oKVwiO1xuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzb3VyY2UuY291bnQ7IGkrKykgdGhpcy5pdGVtc1t0aGlzLmNvdW50KytdID0gc291cmNlLml0ZW1zW2ldO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8qKiBcbiAgICAgICAgICAgICogSW5zZXJ0cyB0aGUgaXRlbSBhdCB0aGUgc3BlY2lmaWVkIGluZGV4LlxuICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSBpbmRleCBmb3IgdGhlIG5ldyBpdGVtICh6ZXJvLWJhc2VkKVxuICAgICAgICAgICAgKiBAcGFyYW0geyp9IGl0ZW0gLSBpdGVtIHRvIGluc2VydFxuICAgICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICAgICovXG4gICAgICAgICAgICBpbnNlcnQ6IGZ1bmN0aW9uIChpbmRleCwgaXRlbSkge1xuICAgICAgICAgICAgICAgIGlmICgoaW5kZXggPCAwKSB8fCAoaW5kZXggPiB0aGlzLmNvdW50KSkgdGhyb3cgXCJTdGlmZkFycmF5Lmluc2VydCgpOiBpbmRleFwiO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvdW50ID49IGNhcGFjaXR5KSB0aHJvdyBcIlN0aWZmQXJyYXkuaW5zZXJ0KCk6IG92ZXJmbG93XCI7XG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5jb3VudDsgaSA+IGluZGV4OyBpLS0pIHRoaXMuaXRlbXNbaV0gPSB0aGlzLml0ZW1zW2kgLSAxXTtcbiAgICAgICAgICAgICAgICB0aGlzLml0ZW1zW2luZGV4XSA9IGl0ZW07XG4gICAgICAgICAgICAgICAgdGhpcy5jb3VudCsrO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8qKiBcbiAgICAgICAgICAgICogUmVtb3ZlcyB0aGUgaXRlbSBhdCB0aGUgc3BlY2lmaWVkIGluZGV4LlxuICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSBpbmRleCBvZiB0aGUgcmVtb3ZpbmcgaXRlbSAoemVyby1iYXNlZClcbiAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgcmVtb3ZlQXQ6IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgICAgICAgIGlmICgoaW5kZXggPCAwKSB8fCAoaW5kZXggPj0gdGhpcy5jb3VudCkpIHRocm93IFwiU3RpZmZBcnJheS5yZW1vdmVBdCgpXCI7XG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICB0aGlzLmNvdW50LS07XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IGluZGV4OyBpIDwgdGhpcy5jb3VudDsgaSsrKSB0aGlzLml0ZW1zW2ldID0gdGhpcy5pdGVtc1tpICsgMV07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLyoqIFxuICAgICAgICAgICAgKiBSZW1vdmVzIHRoZSBmaXJzdCBpdGVtLlxuICAgICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICAgICovXG4gICAgICAgICAgICByZW1vdmVGaXJzdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlQXQoMCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLyoqIFxuICAgICAgICAgICAgKiBSZW1vdmVzIHRoZSBsYXN0IGl0ZW0uXG4gICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHJlbW92ZUxhc3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUF0KHRoaXMuY291bnQgLSAxKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvKiogXG4gICAgICAgICAgICAqIFJlcGxhY2VzIGFsbCB0aGUgaXRlbXMgdG8gdGhlIHN1YnNldCBvZiB0aGUgb3RoZXIgU3RpZmZBcnJheSBpdGVtcy5cbiAgICAgICAgICAgICogQHBhcmFtIHtTdGlmZkFycmF5fSBzb3VyY2UgLSBzb3VyY2Ugc3RpZmYgYXJyYXlcbiAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gaW5kZXggb2YgdGhlIGZpcnN0IGl0ZW0gb2YgdGhlIHN1YnNldFxuICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gY291bnQgLSBudW1iZXIgb2YgaXRlbXMgaW4gdGhlIHN1YnNldFxuICAgICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICAgICovXG4gICAgICAgICAgICBjb3B5X2Zyb206IGZ1bmN0aW9uIChzb3VyY2UsIGluZGV4LCBjb3VudCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLml0ZW1zW2ldID0gc291cmNlLml0ZW1zW2kgKyBpbmRleF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuY291bnQgPSBjb3VudDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvKiogXG4gICAgICAgICAgICAqIFBlcmZvcm1zIGEgYmluYXJ5IHNlYXJjaCBmb3IgdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgdGhlIGl0ZW0gaW4gdGhlIHN0aWZmIGFycmF5LiBVc2VzIGFuIHVzdWFsIEphdmFTY3JpcHQgaXRlbXMgY29tcGFyaXNvbjogaXRlbTEgPCBpdGVtMi5cbiAgICAgICAgICAgICogQHBhcmFtIHsqfSBpdGVtIC0gaXRlbSB0byBzZWFyY2hcbiAgICAgICAgICAgICogQHJldHVybnMge29iamVjdH0geyBmb3VuZDogZiwgaW5kZXg6IGkgfSBvYmplY3Q6XG4gICAgICAgICAgICAqIC0gZm91bmQ6IHRydWUgaWYgdGhlIGl0ZW0gaXMgZm91bmQsIGZhbHNlIG90aGVyd2lzZVxuICAgICAgICAgICAgKiAtIGluZGV4OiBpbmRleCBvZiB0aGUgZm91bmQgaXRlbSwgb3IgaW5kZXggdG8gaW5zZXJ0IG5ldyAobm9uLWZvdW5kKSBpdGVtXG4gICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgICAgKlxuICAgICAgICAgICAgKiB2YXIgYXJyID0gbmV3IFN0aWZmQXJyYXkoMTApO1xuICAgICAgICAgICAgKiBhcnIuYWRkKDEpOyAvLyBbMF1cbiAgICAgICAgICAgICogYXJyLmFkZCgyKTsgLy8gWzFdXG4gICAgICAgICAgICAqIGFyci5hZGQoMik7IC8vIFsyXVxuICAgICAgICAgICAgKiBhcnIuYWRkKDMpOyAvLyBbM11cbiAgICAgICAgICAgICogYXJyLmFkZCgzKTsgLy8gWzRdXG4gICAgICAgICAgICAqIGFyci5hZGQoMyk7IC8vIFs1XVxuICAgICAgICAgICAgKlxuICAgICAgICAgICAgKiBhcnIuc2VhcmNoX2ZpcnN0KDApICA9PT4gIHsgZm91bmQ6IGZhbHNlLCBpbmRleDogMCB9XG4gICAgICAgICAgICAqIGFyci5zZWFyY2hfZmlyc3QoMSkgID09PiAgeyBmb3VuZDogdHJ1ZSwgaW5kZXg6IDAgfVxuICAgICAgICAgICAgKiBhcnIuc2VhcmNoX2ZpcnN0KDIpICA9PT4gIHsgZm91bmQ6IHRydWUsIGluZGV4OiAxIH1cbiAgICAgICAgICAgICogYXJyLnNlYXJjaF9maXJzdCgzKSAgPT0+ICB7IGZvdW5kOiB0cnVlLCBpbmRleDogMyB9XG4gICAgICAgICAgICAqIGFyci5zZWFyY2hfZmlyc3QoNCkgID09PiAgeyBmb3VuZDogZmFsc2UsIGluZGV4OiA2IH1cbiAgICAgICAgICAgICovXG4gICAgICAgICAgICBzZWFyY2hfZmlyc3Q6IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNudCA9IHRoaXMuY291bnQ7XG4gICAgICAgICAgICAgICAgdmFyIGZpcnN0ID0gMDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoY250ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RlcCA9IE1hdGguZmxvb3IoY250IC8gMik7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IGZpcnN0ICsgc3RlcDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaXRlbXNbaW5kZXhdIDwgaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3QgPSBpbmRleCArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbnQgLT0gKHN0ZXAgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNudCA9IHN0ZXA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICBpZiAoZmlyc3QgPCB0aGlzLmNvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGZvdW5kOiAodGhpcy5pdGVtc1tmaXJzdF0gPT0gaXRlbSksIGluZGV4OiBmaXJzdCB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geyBmb3VuZDogZmFsc2UsIGluZGV4OiBmaXJzdCB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8qKiBcbiAgICAgICAgICAgICogUGVyZm9ybXMgYSBiaW5hcnkgc2VhcmNoIGZvciB0aGUgbGFzdCBvY2N1cnJlbmNlIG9mIHRoZSBpdGVtIGluIHRoZSBzdGlmZiBhcnJheS4gVXNlcyBhbiB1c3VhbCBKYXZhU2NyaXB0IGl0ZW1zIGNvbXBhcmlzb246IGl0ZW0xID49IGl0ZW0yLlxuICAgICAgICAgICAgKiBAcGFyYW0geyp9IGl0ZW0gLSBpdGVtIHRvIHNlYXJjaFxuICAgICAgICAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSB7IGZvdW5kOiBmLCBpbmRleDogaSB9IG9iamVjdDpcbiAgICAgICAgICAgICogLSBmb3VuZDogdHJ1ZSBpZiB0aGUgaXRlbSBpcyBmb3VuZCwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICAgICAgICAqIC0gaW5kZXg6IGluZGV4IG9mIHRoZSBmb3VuZCBpdGVtLCBvciBpbmRleCB0byBpbnNlcnQgbmV3IChub24tZm91bmQpIGl0ZW1cbiAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAgICAqXG4gICAgICAgICAgICAqIHZhciBhcnIgPSBuZXcgU3RpZmZBcnJheSgxMCk7XG4gICAgICAgICAgICAqIGFyci5hZGQoMSk7IC8vIFswXVxuICAgICAgICAgICAgKiBhcnIuYWRkKDIpOyAvLyBbMV1cbiAgICAgICAgICAgICogYXJyLmFkZCgyKTsgLy8gWzJdXG4gICAgICAgICAgICAqIGFyci5hZGQoMyk7IC8vIFszXVxuICAgICAgICAgICAgKiBhcnIuYWRkKDMpOyAvLyBbNF1cbiAgICAgICAgICAgICogYXJyLmFkZCgzKTsgLy8gWzVdXG4gICAgICAgICAgICAqXG4gICAgICAgICAgICAqIGFyci5zZWFyY2hfbGFzdCgwKSAgPT0+ICB7IGZvdW5kOiBmYWxzZSwgaW5kZXg6IDAgfVxuICAgICAgICAgICAgKiBhcnIuc2VhcmNoX2xhc3QoMSkgID09PiAgeyBmb3VuZDogdHJ1ZSwgaW5kZXg6IDAgfVxuICAgICAgICAgICAgKiBhcnIuc2VhcmNoX2xhc3QoMikgID09PiAgeyBmb3VuZDogdHJ1ZSwgaW5kZXg6IDIgfVxuICAgICAgICAgICAgKiBhcnIuc2VhcmNoX2xhc3QoMykgID09PiAgeyBmb3VuZDogdHJ1ZSwgaW5kZXg6IDUgfVxuICAgICAgICAgICAgKiBhcnIuc2VhcmNoX2xhc3QoNCkgID09PiAgeyBmb3VuZDogZmFsc2UsIGluZGV4OiA2IH1cbiAgICAgICAgICAgICovXG4gICAgICAgICAgICBzZWFyY2hfbGFzdDogZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICB2YXIgY250ID0gdGhpcy5jb3VudDtcbiAgICAgICAgICAgICAgICB2YXIgZmlyc3QgPSAwO1xuICAgICAgICAgICAgICAgIHdoaWxlIChjbnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGVwID0gTWF0aC5mbG9vcihjbnQgLyAyKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gZmlyc3QgKyBzdGVwO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbSA+PSB0aGlzLml0ZW1zW2luZGV4XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3QgPSBpbmRleCArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbnQgLT0gKHN0ZXAgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNudCA9IHN0ZXA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICBpZiAoKGZpcnN0ID4gMCkgJiYgKGZpcnN0IDw9IHRoaXMuY291bnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLml0ZW1zW2ZpcnN0IC0gMV0gPT0gaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZm91bmQ6IHRydWUsIGluZGV4OiBmaXJzdCAtIDEgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geyBmb3VuZDogZmFsc2UsIGluZGV4OiBmaXJzdCB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8qKiBcbiAgICAgICAgICAgICogUGVyZm9ybXMgYSBiaW5hcnkgc2VhcmNoIGZvciB0aGUgbGFzdCBvY2N1cnJlbmNlIG9mIHRoZSBwcmVmaXggaW4gdGhlIHN0aWZmIGFycmF5LiBVc2VmdWwgd2hlbiB0aGUgc3RpZmYgYXJyYXkgaXRlbXMgYXJlIHN0cmluZ3MuXG4gICAgICAgICAgICAqXG4gICAgICAgICAgICAqIEEgc2VhcmNoX2ZpcnN0X3ByZWZpeCgpIG1ldGhvZCBpcyBub3QgaW1wbGVtZW50ZWQgYmVjYXVzZSBzZWFyY2hfZmlyc3QoKSBjYW4gYmUgdXNlZCBpbnN0ZWFkOyBidXQgc2VhcmNoX2xhc3QoKSBjYW5ub3QgYmUgdXNlZCBpbnN0ZWFkIG9mIHRoZSBzZWFyY2hfbGFzdF9wcmVmaXgoKS5cbiAgICAgICAgICAgICpcbiAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHByZWZpeCAtIHByZWZpeCB0byBzZWFyY2hcbiAgICAgICAgICAgICogQHJldHVybnMge29iamVjdH0geyBmb3VuZDogZiwgaW5kZXg6IGkgfSBvYmplY3Q6XG4gICAgICAgICAgICAqIC0gZm91bmQ6IHRydWUgaWYgdGhlIHByZWZpeGVkIGl0ZW0gaXMgZm91bmQsIGZhbHNlIG90aGVyd2lzZVxuICAgICAgICAgICAgKiAtIGluZGV4OiBpbmRleCBvZiB0aGUgZm91bmQgaXRlbSwgb3IgaW5kZXggdG8gaW5zZXJ0IG5ldyAobm9uLWZvdW5kKSBpdGVtXG4gICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgICAgKlxuICAgICAgICAgICAgKiB2YXIgYXJyID0gbmV3IFN0aWZmQXJyYXkoMTApO1xuICAgICAgICAgICAgKiBhcnIuYWRkKFwiMTExXCIpOyAvLyBbMF1cbiAgICAgICAgICAgICogYXJyLmFkZChcIjEyMVwiKTsgLy8gWzFdXG4gICAgICAgICAgICAqIGFyci5hZGQoXCIxMjJcIik7IC8vIFsyXVxuICAgICAgICAgICAgKiBhcnIuYWRkKFwiMTMxXCIpOyAvLyBbM11cbiAgICAgICAgICAgICpcbiAgICAgICAgICAgICogYXJyLnNlYXJjaF9sYXN0X3ByZWZpeChcIlwiKSAgPT0+ICB7IGZvdW5kOiB0cnVlLCBpbmRleDogMyB9XG4gICAgICAgICAgICAqXG4gICAgICAgICAgICAqIGFyci5zZWFyY2hfbGFzdF9wcmVmaXgoXCIwXCIpICA9PT4gIHsgZm91bmQ6IGZhbHNlLCBpbmRleDogMCB9XG4gICAgICAgICAgICAqIGFyci5zZWFyY2hfbGFzdF9wcmVmaXgoXCIxXCIpICA9PT4gIHsgZm91bmQ6IHRydWUsIGluZGV4OiAzIH1cbiAgICAgICAgICAgICogYXJyLnNlYXJjaF9sYXN0X3ByZWZpeChcIjJcIikgID09PiAgeyBmb3VuZDogZmFsc2UsIGluZGV4OiA0IH1cbiAgICAgICAgICAgICpcbiAgICAgICAgICAgICogYXJyLnNlYXJjaF9sYXN0X3ByZWZpeChcIjEwXCIpICA9PT4gIHsgZm91bmQ6IGZhbHNlLCBpbmRleDogMCB9XG4gICAgICAgICAgICAqIGFyci5zZWFyY2hfbGFzdF9wcmVmaXgoXCIxMVwiKSAgPT0+ICB7IGZvdW5kOiB0cnVlLCBpbmRleDogMCB9XG4gICAgICAgICAgICAqIGFyci5zZWFyY2hfbGFzdF9wcmVmaXgoXCIxMlwiKSAgPT0+ICB7IGZvdW5kOiB0cnVlLCBpbmRleDogMiB9XG4gICAgICAgICAgICAqIGFyci5zZWFyY2hfbGFzdF9wcmVmaXgoXCIxM1wiKSAgPT0+ICB7IGZvdW5kOiB0cnVlLCBpbmRleDogMyB9XG4gICAgICAgICAgICAqIGFyci5zZWFyY2hfbGFzdF9wcmVmaXgoXCIxNFwiKSAgPT0+ICB7IGZvdW5kOiBmYWxzZSwgaW5kZXg6IDQgfVxuICAgICAgICAgICAgKlxuICAgICAgICAgICAgKlxuICAgICAgICAgICAgKlxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHNlYXJjaF9sYXN0X3ByZWZpeDogZnVuY3Rpb24gKHByZWZpeCkge1xuICAgICAgICAgICAgICAgIHZhciBwcmVmaXhfbGVuZ3RoID0gcHJlZml4Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIHZhciBjaGVja19wcmVmaXggPSBmdW5jdGlvbiAoaXRlbSkgeyAgXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmVmaXhfbGVuZ3RoID4gaXRlbS5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChpdGVtLnN1YnN0cigwLCBwcmVmaXhfbGVuZ3RoKSA9PSBwcmVmaXgpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgdmFyIGNudCA9IHRoaXMuY291bnQ7XG4gICAgICAgICAgICAgICAgdmFyIGZpcnN0ID0gMDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoY250ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RlcCA9IE1hdGguZmxvb3IoY250IC8gMik7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IGZpcnN0ICsgc3RlcDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSB0aGlzLml0ZW1zW2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChwcmVmaXggPiBpdGVtKSB8fCBjaGVja19wcmVmaXgoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0ID0gaW5kZXggKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgY250IC09IChzdGVwICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbnQgPSBzdGVwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgaWYgKChmaXJzdCA+IDApICYmIChmaXJzdCA8PSB0aGlzLmNvdW50KSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hlY2tfcHJlZml4KHRoaXMuaXRlbXNbZmlyc3QgLSAxXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGZvdW5kOiB0cnVlLCBpbmRleDogZmlyc3QgLSAxIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZm91bmQ6IGZhbHNlLCBpbmRleDogZmlyc3QgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZW1zLnNsaWNlKDAsIHRoaXMuY291bnQpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyAgICAgICByZXR1cm4gdGhlIHB1YmxpYyBpbnRlcmZhY2U6XG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgcmV0dXJuIG1fcHVibGljO1xuICAgIH07XG5tb2R1bGUuZXhwb3J0cyA9IFN0aWZmQXJyYXk7XG5cblxuICAgIC8vcmV0dXJuIFN0aWZmQXJyYXk7XG5cblxuLy99KTtcblxuXG4iLCIvLyBUaGlzIGlzIHJlc3VsdGluZyBpbiBzbWFsbGVyIGNvZGUgaW4gb3RoZXIgcGFydHMgb2YgdGhlIGZyYW1ld29yay5cbi8vICBUaGlzIHNlY3Rpb24gaXMgZ2V0dGluZyBxdWl0ZSBiaWcgKGFnYWluKVxuLy8gIFN0aWxsIG5lZWQgdG8gbWFrZSB1c2Ugb2YgdGhlIEIrIGZyZWUgZm9yIG9yZGVyZWQgaW5kZXhpbmcuXG5cbi8vIE1vdmluZyBzb21lIGNvZGUgdG8ganNndWktbGFuZy1lc3NlbnRpYWxzXG4vLyAgV2lsbCBiZSBwdWJsaXNoaW5nIGEgMC40IHZlcnNpb24gb2YgdGhhdCBiZWZvcmUgc28gbG9uZz9cbi8vICAgTWF5YmUgd2l0aCBtb3JlIGV4cGxhbmF0aW9uP1xuXG4vLyBJdCBtYXkgYmUgd29ydGggcHVibGlzaGluZyB0aGlzLCBhbmQgYSBkaXNjdXNzaW9uIGZvcnVtIGFib3V0IGl0IG9uIG15IG93biB3ZWIgZm9ydW0uXG4vLyAgUGVyaGFwcyB0aGF0IGNvdWxkIGNvbWUgbGF0ZXIsIGJ1dCBqc2d1aS1sYW5nLWVzc2VudGlhbHMgbWF5IGJlIGEgZ29vZCBzdGVwLiBDb3VsZCBjYWxsIGl0IHZlcnNpb24gMC4zNS5cbi8vICAgQ291bGQgaGF2ZSBhIGZldyBleGFtcGxlc1xuLy8gICBXb3VsZCBiZSBhIHVzZWZ1bCB0b29sa2l0IEkgY291bGQgdXNlIHdoaWxlIHdvcmtpbmcgZWxzZXdoZXJlLlxuXG4vLyAgSSB0aGluayB0aGF0IHdlYiBzaXRlIHdvdWxkIGJlIGxpZ2h0ZW5pbmcgZmFzdCwgYW5kIGltcHJlc3MgcGVvcGxlIHdpdGggaXRzIHNwZWVkIGNvbXBhcmVkIHRvIG90aGVyIHdlYiBwbGF0Zm9ybXMgdGhhdCB0aGV5IGFyZSB1c2VkIHRvXG4vLyAgICh0aG91Z2ggRmFjZWJvb2sgaXMgT0spXG5cblxuXG5cbi8vIE1heSBzd2F5IGltcGxlbWVudGF0aW9ucyBvZiB0aGUgcGFydGljdWxhciBpdGVtcyBtb3JlIGVhc2lseSB3aGVuIHRoZXkgYXJlIGluIHRoZWlyIG93biBmaWxlcy5cblxuLy8gSXQgbG9va3MgbGlrZSB0aGluZ3MgYXJlIHBvaW50aW5nIHRvd2FyZHMgdGhlIENvbXByZXNzZWQgRHluYW1pYyBTdWZmaXggQXJyYXkuXG5cbi8vICBXYW50IHNvbWV0aGluZyB0aGF0IHByb3ZpZGVzIGZ1bGwtdGV4dCBtYXRjaGVzLlxuLy8gICBTb21lIHNpbXBsZXIgZGF0YSBzdHJ1Y3R1cmVzIG1heSB3b3JrIGJldHRlciB0byBzdGFydCB3aXRoLlxuLy8gICBGb3IgdW5pdCB0ZXN0cywgY291bGQgY29tcGFyZSB0aGVtIHRvIGEgdmVyeSBzaW1wbGUgYW5kIGluZWZmaWNpZW50IGFsZ29yaXRobSB0aGF0IGdvZXMgdGhyb3VnaCB0aGUgd2hvbGUgc3RyaW5nLlxuXG4vLyBTdWZmaXhlcyBzZWVtIGxpa2Ugb25lIG9mIHRoZSBpbXBvcnRhbnQgdGhpbmdzIHRvIGZvY3VzIG9uLlxuXG4vLyAgUHJlZml4IHRyZWVzIHNlZW1lZCBsaWtlIGEgZ29vZCB3YXkgb2YgZG9pbmcgdGhpbmdzIGJlZm9yZS5cblxuLy8gSSB0aGluayBzdWZmaXggYXJyYXlzLCBjb21wcmVzc2VkIHN1ZmZpeCBhcnJheXMsIGFuZCBjb21wcmVzc2VkIGR5bmFtaWMgb25lcyBzZWVtIGxpa2UgdGhlIG1ham9yIHJvdXRlIHRvIHRha2UuXG4vLyBTdWZmaXggdHJlZXMgdG9vLCB0aG9zZSBtYXkgbGVhZCB0byBzdWZmaXggYXJyYXlzIGFzIHdlbGwuXG4vLyAgRGVmaW5pdGVseSBkbyB3YW50IHRoZXNlIGZhaXJseSBkaWZmaWN1bHQgZmVhdHVyZXMuXG5cbi8vIENEU0FzIGFyZSBub3QgbmVjZXNzYXJpbHkgTWlrYWVsIFNhbHNvbidzIHZlcnNpb24gZWl0aGVyLlxuLy8gIENvdWxkIGFwcHJvYWNoIGl0IG15c2VsZi5cbi8vICBOZWVkIHRoZSBzdWZmaXggYXJyYXlcbi8vICBOZWVkIHRvIGNvbXByZXNzIGl0XG4vLyAgIENoYW5naW5nIHRoZSB1bmNvbXByZXNzZWQgc3VmZml4IGFycmF5XG4vLyAgIENoYW5naW5nIGEgY29tcHJlc3NlZCBzdWZmaXggYXJyYXlcblxuLy8gR29pbmcgZnJvbSB0aGUgb3BlcmF0aW9uLCBkb2luZyBzb21ldGhpbmcsIHRvIGFsbCB0aGUgc3RlcHMgbmVlZGVkIHRvIGNoYW5nZSB0aGUgYXJyYXkuXG4vLyAgQ2FuIGRvIHNvbWUgZXhwZXJpbWVudHMgd2l0aCB0aGUgc3VmZml4IGFycmF5cywgY29tcHJlc3NpbmcgdGhlbSB0byBhbm90aGVyIHR5cGUgb2Ygc3VmZml4IGFycmF5LCBhbmQgZGVjb21wcmVzc2luZyB0aGVtIGFzIHdlbGwuXG4vLyAgIFBlcmZvcm1pbmcgc2VhcmNoIG9wZXJhdGlvbnMgb24gdGhlIGNvbXByZXNzZWQgc3VmZml4IGFycmF5LlxuLypcbmlmICh0eXBlb2YgZGVmaW5lICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIGRlZmluZSA9IHJlcXVpcmUoJ2FtZGVmaW5lJykobW9kdWxlKTtcbn1cblxuZGVmaW5lKFtcIi4vanNndWktbGFuZy1lc3NlbnRpYWxzXCIsIFwiLi9qc2d1aS1kYXRhLXN0cnVjdHVyZXMtZG91Ymx5LWxpbmtlZC1saXN0XCIsIFwiLi9qc2d1aS1kYXRhLXN0cnVjdHVyZXMtYi1wbHVzLXRyZWVcIl0sIGZ1bmN0aW9uKGpzZ3VpLCBEb3VibHlfTGlua2VkX0xpc3QsIEJfUGx1c19UcmVlKSB7XG4gICAgKi9cbiAgICB2YXIganNndWkgPSByZXF1aXJlKCcuL2pzZ3VpLWxhbmctZXNzZW50aWFscycpO1xudmFyIERvdWJseV9MaW5rZWRfTGlzdCA9IHJlcXVpcmUoJy4vanNndWktZGF0YS1zdHJ1Y3R1cmVzLWRvdWJseS1saW5rZWQtbGlzdCcpO1xudmFyIEJfUGx1c19UcmVlID0gcmVxdWlyZSgnLi9qc2d1aS1kYXRhLXN0cnVjdHVyZXMtYi1wbHVzLXRyZWUnKTtcblxuICAgIC8qKiBcbiAgICAqIERhdGEgc3RydWN0dXJlcyBtb2R1bGUuXG4gICAgKiBAbW9kdWxlIGNvcmUvanNndWktZGF0YS1zdHJ1Y3R1cmVzXG4gICAgKiBAZXhwb3J0cyBEYXRhX1N0cnVjdHVyZXNcbiAgICAqL1xuXG5cblx0Ly8gVGhlIGRhdGEgc3RydWN0dXJlcyB3aWxsIGJlIG5lZWRlZCB0byBzdXBwb3J0IHNvbWUgY29tcG9uZW50c1xuXHRcblx0dmFyIENsYXNzID0ganNndWkuQ2xhc3M7XG5cdC8vY29uc29sZS5sb2coJ0NsYXNzICcgKyBDbGFzcyk7XG5cdHZhciBtYXBpZnkgPSBqc2d1aS5tYXBpZnk7XG5cdC8vY29uc29sZS5sb2coJ21hcGlmeSAnICsgbWFwaWZ5KTtcblxuXHR2YXIgaXNfZGVmaW5lZCA9IGpzZ3VpLmlzX2RlZmluZWQ7XG5cdHZhciBzdHJpbmdpZnkgPSBqc2d1aS5zdHJpbmdpZnk7XG5cdHZhciBlYWNoID0ganNndWkuZWFjaDtcblx0dmFyIGZwID0ganNndWkuZnA7XG5cdHZhciB0b2YgPSBqc2d1aS50b2Y7XG5cblx0Ly8gQWxzbyB3aWxsIGdldCB0aGUgRG91Ymx5X0xpbmtlZF9MaXN0LlxuXHQvLyBWYXJpb3VzIGRhdGEgc3RydWN0dXJlcyB3aWxsIGJlIGRlZmluZWQgc2VwYXJhdGVseSBhbmQgdGhpcyB3aWxsIGxpbmsgdGhlbSB0b2dldGhlci5cblx0XG5cdC8vICBJIHRoaW5rIHNvbWUgZGF0YSBzdHJ1Y3R1cmVzIHdvdWxkIGJlIG5pY2Ugd2hlbiBwdWJsaXNoZWQgb25saW5lLlxuXHQvLyAgIFRoZXkgd2lsbCByZWx5IG9uIGVzc2VudGlhbHMuIEEgbWljcm9mcmFtZXdvcmsgdmVyc2lvbiBjb3VsZCBiZSBwdWJsaXNoZWQgd2l0aCB0aGUgbmVjZXNzYXJ5IGVzc2VudGlhbHMgYWxyZWFkeSBidWlsdCBpbi5cblx0XG5cdFxuXHQvLyAgQ291bGQgaW5jbHVkZSBzb21lIEphc21pbmUgdW5pdCB0ZXN0cyB3aXRoIHRoZW0uXG5cdFxuXHRcblx0Ly8gTm93IHRoYXQgdGhpcyBpcyBpc29sYXRlZCwgcmVtb3ZpbmcgaXQgYW5kIHJlcGxhY2luZyBpdCB3aXRoIGEgZGlmZmVyZW50IC8gYmV0dGVyIHZlcnNpb24gc2VlbXMgZWFzaWVyLi4uIGl0J3MganVzdCBhIGNvbXBvbmVudC5cblx0XG5cdC8vIFRoaXMgaXMgYWN0aW5nIGFzIGEgZnJpZW5kbGllciB3cmFwcGVyIHRvIHRoZSBCKyB0cmVlLlxuXHQvLyAgTm90IHNvIHN1cmUgYWJvdXQgaXQgaGF2aW5nIGl0IG1haW50YWluIGEgZGljdCBpbmRleCB0b28uLi4gYnV0IG1heWJlIGl0IGlzIGJlc3QgdG8gaGF2ZSBrc3ZzXG5cdC8vICBLU1ZTIGNvdWxkIHBvc3NpYmx5IGJlIGV4dGVuZGVkIHNvIHRoYXQgaXQgbWFrZXMgdXNlIG9mIGJvdGggdGhlIHRyZWUgYW5kIHRoZSBkaWN0LlxuXHRcblx0Ly8gSSdtIGludGVyZXN0ZWQgaW4gbWFraW5nIGEgZGF0YSBzdHJ1Y3R1cmUgdGhhdCB1c2VzIHRoZXNlIHNpYmxpbmcgbGlzdHMgYXMgd2VsbCBhcyBhIGRpY3QuIFRoYXQgd2lsbCBtZWFuIHRoZXkgY2FuIGJlIGxvY2F0ZWQgYnkgZnVsbCBrZXkgaW4gTygxKSB0aW1lLlxuXHQvLyAgVGhlbiB0aGUgdHJlZSBjYW4gYmUgbW92ZWQgdGhyb3VnaC5cblx0Ly8gICBUaGlzIHdvdWxkIG1lYW4gaW5kZXhpbmcgdGhlIGxlYWYgbm9kZSBmb3IgdGhlIG9iamVjdC4gVGhlbiBpdCB3aWxsIGJlIHBvc3NpYmxlIHRvIG1vdmUgdGhyb3VnaCB0aGUgdHJlZS5cblx0Ly8gICBGaW5kaW5nIHRoZSBwbGFjZSB3aGVyZSBhbiBpdGVtIHdvdWxkIGJlIHB1dC4uLiBzaW1pbGFyIHRvIGZpbmRpbmcgdGhlIGZpcnN0IGtleSBhZnRlciBhIGNlcnRhaW4gdmFsdWUuXG5cdC8vICAgVGhlbiBjYW4gcHJvY2VlZCB0aHJvdWdoIHRoZSB0cmVlIChxdWljayB0byBtb3ZlIHRvIHRoZSBuZXh0IG5vZGUpIHVudGlsIHdlIGhhdmUgbW92ZWQgcGFzdCBub2RlcyB3aXRoIHRoZSBzcGVjaWZpZWQgcHJlZml4LlxuXHRcblx0Ly8gVGhlIHBvaW50IGlzIHRvIGhhdmUgdmFyaW91cyBkYXRhIHN0cnVjdHVyZXMgaGVyZSB0aGF0IGFyZSBuYW1lZCwgYW5kIGhhdmUgQVBJcyBhcyBwZXIgdGhlaXIgdXNhZ2UuXG5cdC8vIEVnIEtleS1WYWx1ZS1TdG9yZSByYXRoZXIgdGhhbiBCKyB0cmVlXG5cdFxuXHQvLyBTb3J0ZWRfS1ZTXG5cdFxuXHQvLyAgQ291bGQgbWFrZSBhbiBBUEkgLyBpbnRlcmZhY2UgZm9yIHRoaXMuXG5cdFxuXHQvLyBNYXkgYmUgYmV0dGVyIHRvIHdvcmsgb24gdGhlIFhNTCBwcm9jZXNzaW5nIGZvciB0aGUgbW9tZW50P1xuXHRcblx0Ly8gVHJhbnNmb3JtaW5nIGFuIFhNTCAvIGpzZ3VpIHBhZ2UganNndWltbD8gYWN0dWFsbHkgQVNQLk5FVD9cblx0Ly8gIEpTVUkgKEplIFN1aXMsIEkgbGlrZSB0aGF0IG5hbWUsIGl0J3MgYW5ub3VuY2luZyB0aGF0IHRoaW5ncyAnYXJlJywgaXQncyBhIHZlcnkgZGVjbGFyYXRpdmUgc3RhdGVtZW50Lilcblx0Ly8gICBKU1VJLVhNTFxuXHQvLyAgIEplU3VpX1hNTFxuXHQvLyAgIEplX1N1aXNfWG1sXG5cdFxuXHQvLyAgSlNVSS1NTFxuXHRcblx0Ly8gSSB0aGluayBtYWludGFpbmluZyBhbmQgY29uc3VtaW5nIHRoZXNlIGRhdGEgc3RydWN0dXJlcyBhcyByZXNvdXJjZXMgd2lsbCBiZSBhIHZlcnkgdXNlZnVsIGZ1bmN0aW9uYWxpdHkuXG5cdC8vICBEaXN0cmlidXRlZCByZXN1bHQgZmluZGluZyBjb3VsZCBiZSB2ZXJ5IHVzZWZ1bCwgd2hlcmUgYSBmdW5jdGlvbiBpbiBleGVjdXRpb24gaXMgc2VudCBvdmVyIHRoZSBuZXR3b3JrLlxuXHQvLyAgVGhlIGZ1bmN0aW9uIGdldHMgc2VudCBvdmVyIHRvIGl0cyBuZXh0IG5vZGUgd2hlbiBpdCBoYXMgYSByZXN1bHQgZnJvbSBvbmUgbm9kZS5cblx0Ly8gICBJdCBjb3VsZCBicmFuY2ggYXMgd2VsbCB3aGVuIG5lY2Vzc2FyeSwgbWVhbmluZyBsb29rdXBzIHRha2UgcGxhY2UgaW4gcGFyYWxsZWwuXG5cdC8vICAgIFdvdWxkIG1heWJlIG5lZWQgb3IgYmVuZWZpdCBmcm9tIGhpZ2ggbGF0ZW5jeSBhbGVydCByZXBvcnRpbmcuXG5cdFxuXHQvLyBQdWJsaXNoaW5nIHZhcmlvdXMgZGF0YSBzdHJ1Y3R1cmVzIHN1Y2ggYXMgYSBzb3J0ZWQgbGlzdCBvdmVyIGEgbmV0d29yayB3b3VsZCBiZSB1c2VmdWwuXG5cdC8vICBFdmVuIGlmIHRoZSBsaXN0IGl0c2VsZiBtYXkgbm90IGJlIGRpc3RyaWJ1dGVkLCBpdCBjb3VsZCBiZSBhIGNvbXBvbmVudCBpbiBhIGRpc3RyaWJ1dGVkIHN5c3RlbS5cblx0XG5cdC8vIFRoZXJlIHdpbGwgd2luZCB1cCBiZWluZyBhIHZhcmlldHkgb2YgZGlmZmVyZW50IGNsYXNzZXMgdGhhdCBkbyBzaW1pbGFyIHRoaW5ncywgYnV0IGluIGRpZmZlcmVudCB3YXlzLlxuXHRcblx0Ly8gQ291bGQgaGF2ZSBhIGhpZ2ggdGhyb3VnaHB1dCBzeXN0ZW0uXG5cdFxuXHQvLyBUaGVyZSBjb3VsZCBiZSBhIEtWUyByZXNvdXJjZSB0aGF0IGlzIHVzZWQgYXMgYSBzaGFyZCwgd2l0aCBhIHB1Ymxpc2hlZCBpbmRleCBmb3IgdGhlIHNoYXJkaW5nIHN5c3RlbSwgYW5kIHRoZSBjbGllbnQgbWFjaGluZXNcblx0Ly8gIHVzaW5nIGEgS1ZTX1NoYXJkcyhfQ2xpZW50KSByZXNvdXJjZS4gVGhhdCB3aWxsIG1lYW4gdGhhdCBzeXN0ZW1zIHRoYXQgcmVseSBvbiBhIGxhcmdlIGFycmF5IGxpa2Ugc3RydWN0dXJlLCBsaWtlIGEgQisgdHJlZSwgY291bGQgbWFrZSB1c2Ugb2YgaXQuXG5cdC8vIENsaWVudCBhY2Nlc3MgZm9yIHVzaW5nIHRoZSBCKyB0cmVlIGNvdWxkIGJlIGRvbmUgYWNjcm9zcyB0aGUgbmV0d29yayAoaWYgaXRzIG5vdCBmb3IgbG9ja3MhKVxuXHQvLyAgTWF5IHJ1biBpbnRvIHRyb3VibGUgYmVjYXVzZSBvZiBkYXRhIGNoYW5nZSBhbmQgYWNjZXNzIHRvIGl0LlxuXHQvLyAgQ291bGQgYWxzbyBpbXBsZW1lbnQgYSBsb2NraW5nIG1lY2hhbmlzbT8gV2hhdCBleGFjdGx5IHdvdWxkIGl0IGRvPyBPciBtb3JlIGxpa2UgYSByYXBpZCB1cGRhdGUgbm90aWZpZXI/IE9yIGFnYWluIG5vIG5lZWQgYmVjYXVzZSBldmVyeXRoaW5nIGdldHMgdXBkYXRlZCBpbiB0aGUgc2hhcmRzP1xuXHQvLyAgV2FudCB0byBhdm9pZCBtdWx0aXBsZSB1cGRhdGVzIHRha2luZyBwbGFjZSBhdCBvbmNlLiBUaGUgbGFjayBvZiBsb2dpYyBjb3VsZCBiZSBtZXNzeS5cblx0Ly8gICBNYXliZSB0aGVyZSBpcyBhIHdheSB0byBwYXJ0aXRpb24gdGhpbmdzIHNvIHRoYXQgc29tZSBwYXJ0IG9mIGEgdHJlZSBiZWNvbWVzIGxvY2tlZD9cblx0XG5cdC8vIEkgdGhpbmsgYSBzaGFyZGVkIGxvd2VyIGxldmVsIHVuc29ydGVkIEtTViB3b3VsZCBiZSByZWFsbHkgdXNlZnVsIGZvciBtYWtpbmcgYSBzb3J0ZWQgS1ZTLCBhbmQgYWxzbyBhIGZ1bGwtdGV4dCBpbmRleC5cblx0Ly8gIFRoZXJlIGNvdWxkIGJlIG11bHRpcGxlIG5vZGVzIHRoYXQgYWNjZXNzIGl0LCBidXQgXG5cdFxuXHQvLyBGdWxsIHRleHQgaW5kZXg6XG5cdC8vICBLZXkoc3RyaW5nKSwgdGV4dF92YWx1ZShzdHJpbmcpXG5cdC8vICBrZXkgdXNlZCB0byBpZGVudGlmeSB0aGUgdGV4dCBhbmQgZm9yIHJldHVybmluZyB0aGUgcmVzdWx0LlxuXHRcblx0Ly8gRnVsbCB0ZXh0IGluZGV4IG9uIHRoZSBjbGllbnQgd291bGQgaW5kZWVkIGJlIHF1aXRlIHVzZWZ1bC5cblx0Ly8gIEl0IHdvdWxkIHByb2JhYmx5IGJlIHBvc3NpYmxlIHRvIG1ha2UgYSB0ZXh0IGluZGV4IGluY29ycG9yYXRpbmcgc29tZSB0aGluZ3MgbGlrZSBCV1QgZm9yIHVzZSBvbiB0aGUgY2xpZW50LlxuXHRcblx0XG5cdFxuXHQvLyBUaGUgZGF0YSBmb3IgdGhlIHRyZWUgd291bGQgYmUgZGlzdHJpYnV0ZWQgb3ZlciB0aGUgS1ZTIHNoYXJkcywgYW5kIHdvdWxkIHRoZW4gXG5cdFxuXHRcblx0Lypcblx0XG5cdHZhciBTb3J0ZWRfTGlzdCA9IENsYXNzLmV4dGVuZCh7XG5cdFx0J2luaXQnOiBmdW5jdGlvbihzcGVjKSB7XG5cdFx0XHRcblx0XHRcdHRoaXMudHJlZSA9IG5ldyBCVHJlZSgxMik7XG5cdFx0XHRcblx0XHRcdFxuXHRcdH0sXG5cdFx0J2NsZWFyJzogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLnRyZWUuY2xlYXIoKTtcblx0XHR9LFxuXHRcdCdwdXQnOiBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0dmFyIGluc2VydF9yZXMgPSB0aGlzLnRyZWUuaW5zZXJ0KGtleSk7XG5cdFx0fSxcblx0XHQnb3V0JzogZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdHRoaXMudHJlZS5yZW1vdmUoa2V5KTtcblx0XHR9LFxuXHRcdCdoYXMnOiBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0Ly8gdHJlZS5oYXM/XG5cdFx0XHRcblx0XHRcdFxuXHRcdH0sXG5cdFx0J3ZhbHVlcyc6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRcblx0XHR9LFxuXHRcdCdjb3VudCc6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XG5cdFx0fSxcblx0XHQnZ2V0X2N1cnNvcic6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XG5cdFx0fVxuXHR9KVxuXHRcblx0Ki9cblx0XG5cdFxuXHQvLyBXaWxsIGhhdmUgdGhlIG9yZGVyZWQgc3RyaW5nIGxpc3QgaGVyZSBhcyB3ZWxsXG5cdC8vICBDb21tZW50ZWQgb3V0IGZvciB0aGUgbW9tZW50XG5cdFxuXHQvKlxuXHQgKiBcblx0ICogXG5cdFxuXHR2YXIgT3JkZXJlZF9TdHJpbmdfTGlzdCA9IENsYXNzLmV4dGVuZCh7XG5cdFx0J2luaXQnIDogZnVuY3Rpb24oKSB7XG5cdFx0XHQvLyBjb25zb2xlLmxvZygnaW5pdCBvc2wgc2lnICcgKyBzaWcpO1xuXG5cdFx0XHR2YXIgYXJyID0gW107XG5cdFx0XHR2YXIgZGljdF9pbmRleGVzID0ge307XG5cblx0XHRcdHZhciByZWluZGV4X2RpY3RfaW5kZXhlcyA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkaWN0X2luZGV4ZXMgPSB7fTtcblx0XHRcdFx0Zm9yICggdmFyIGMgPSAwLCBsID0gYXJyLmxlbmd0aDsgYyA8IGw7IGMrKykge1xuXHRcdFx0XHRcdGRpY3RfaW5kZXhlc1thcnJbY11dID0gYztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyAoYWRkKSwgcmVtb3ZlLCBnZXQsIGdldF9hbGwsIGhhcywgcHV0LCBtb3ZlLCBzcGxpY2Vcblx0XHRcdHRoaXMuaGFzID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdFx0cmV0dXJuICh0eXBlb2YgZGljdF9pbmRleGVzW3ZhbHVlXSAhPT0gJ3VuZGVmaW5lZCcpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLnB1dCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRcdC8vIGJ5IGRlZmF1bHQgcHV0cyBpdCBhdCB0aGUgZW5kLlxuXHRcdFx0XHRpZiAodGhpcy5oYXModmFsdWUpKSB7XG5cdFx0XHRcdFx0Ly8gc3RheXMgaW4gc2FtZSBwbGFjZS5cblx0XHRcdFx0XHQvLyBhcnJbZGljdF9pbmRleGVzW3ZhbHVlXV1cblx0XHRcdFx0XHQvLyBkbyBub3RoaW5nXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dmFyIGluZGV4ID0gYXJyLmxlbmd0aDtcblx0XHRcdFx0XHRhcnIucHVzaCh2YWx1ZSk7XG5cdFx0XHRcdFx0ZGljdF9pbmRleGVzW3ZhbHVlXSA9IGluZGV4O1xuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0dGhpcy5vdXQgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0XHRpZiAodGhpcy5oYXModmFsdWUpKSB7XG5cdFx0XHRcdFx0dmFyIGlkeCA9IGRpY3RfaW5kZXhlc1t2YWx1ZV07XG5cdFx0XHRcdFx0YXJyLnNwbGljZShpZHgsIDEpO1xuXG5cdFx0XHRcdFx0ZGVsZXRlIGRpY3RfaW5kZXhlc1t2YWx1ZV07XG5cblx0XHRcdFx0XHRmb3IgKCB2YXIgYyA9IGlkeCwgbCA9IGFyci5sZW5ndGg7IGMgPCBsOyBjKyspIHtcblx0XHRcdFx0XHRcdHZhciBpID0gYXJyW2NdO1xuXHRcdFx0XHRcdFx0ZGljdF9pbmRleGVzW2ldLS07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIHdpbGwgbmVlZCB0aGUgaXRlbXMgYWZ0ZXIgaXQgYW5kIGxvd2VyIHRoZWlyIGluZGV4ZXMuXG5cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLnRvZ2dsZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRcdGlmICh0aGlzLmhhcyh2YWx1ZSkpIHtcblx0XHRcdFx0XHR0aGlzLm91dCh2YWx1ZSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5wdXQodmFsdWUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMubW92ZV92YWx1ZSA9IGZ1bmN0aW9uKHZhbHVlLCBpbmRleCkge1xuXHRcdFx0XHRpZiAodGhpcy5oYXModmFsdWUpICYmIGRpY3RfaW5kZXhlc1t2YWx1ZV0gIT0gaW5kZXgpIHtcblxuXHRcdFx0XHRcdC8vIGdldHMgcmVtb3ZlZCBmcm9tIGN1cnJlbnQgcG9zaXRpb24sIGNhdXNlcyBpdGVtcyBhZnRlciBpdFxuXHRcdFx0XHRcdC8vIHRvIG1vdmUgYmFjay5cblx0XHRcdFx0XHQvLyBnZXRzIHB1dCBpbiBuZXcgcG9zaXRpb24sIGdldHMgaXRlbXMgYWZ0ZXIgdGhhdCB0byBtb3ZlXG5cdFx0XHRcdFx0Ly8gZm9yd2FyZHMuXG5cblx0XHRcdFx0XHR2YXIgb2xkX2luZGV4ID0gZGljdF9pbmRleGVzW3ZhbHVlXTtcblx0XHRcdFx0XHRhcnIuc3BsaWNlKG9sZF9pbmRleCwgMSk7XG5cblx0XHRcdFx0XHRhcnIuc3BsaWNlKGluZGV4LCAwLCB2YWx1ZSk7XG5cblx0XHRcdFx0XHRpZiAoaW5kZXggPCBvbGRfaW5kZXgpIHtcblx0XHRcdFx0XHRcdC8vIG1vdmluZyBiYWNrLlxuXHRcdFx0XHRcdFx0Ly8gZGljdF9pbmRleGVzW11cblx0XHRcdFx0XHRcdGRpY3RfaW5kZXhlc1thcnJbaW5kZXhdXSA9IGluZGV4O1xuXHRcdFx0XHRcdFx0Ly8gdGhlIGluZGV4IG9iamVjdCBvZiB0aGUgb25lIGl0XG5cblx0XHRcdFx0XHRcdC8vIGZvciAodmFyIGMgPSBpbmRleCwgbCA9IGFyci5sZW5ndGg7IGMgPCBsOyBjKyspIHtcblx0XHRcdFx0XHRcdGZvciAoIHZhciBjID0gaW5kZXggKyAxOyBjIDw9IG9sZF9pbmRleDsgYysrKSB7XG5cdFx0XHRcdFx0XHRcdGRpY3RfaW5kZXhlc1thcnJbY11dKys7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChpbmRleCA+IG9sZF9pbmRleCkge1xuXHRcdFx0XHRcdFx0ZGljdF9pbmRleGVzW2FycltpbmRleF1dID0gaW5kZXg7XG5cdFx0XHRcdFx0XHRmb3IgKCB2YXIgYyA9IG9sZF9pbmRleDsgYyA8IGluZGV4OyBjKyspIHtcblx0XHRcdFx0XHRcdFx0ZGljdF9pbmRleGVzW2FycltjXV0tLTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cdFx0XHQvLyBmb3IgdGVzdGluZ1xuXG5cdFx0XHR0aGlzLl9pbmRleF9zY2FuID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGZvciAoIHZhciBjID0gMCwgbCA9IGFyci5sZW5ndGg7IGMgPCBsOyBjKyspIHtcblx0XHRcdFx0XHRjb25zb2xlLmxvZygnYyAnICsgYyArICcgYXJyW2NdICcgKyBhcnJbY10gKyAnIGlkeCAnXG5cdFx0XHRcdFx0XHRcdCsgZGljdF9pbmRleGVzW2FycltjXV0pO1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciByZXMgPSBhcnIuam9pbignICcpO1xuXHRcdFx0XHRyZXR1cm4gcmVzO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLnRvU3RyaW5nLnN0cmluZ2lmeSA9IHRydWU7XG5cblx0XHRcdHRoaXMuc2V0ID0gZnAoZnVuY3Rpb24oYSwgc2lnKSB7XG5cdFx0XHRcdGlmIChzaWcgPT0gJ1tzXScpIHtcblx0XHRcdFx0XHRhcnIgPSBhWzBdLnNwbGl0KCcgJyk7XG5cdFx0XHRcdFx0Ly8gY29uc29sZS5sb2coJ2FyciAnICsganNndWkuc3RyaW5naWZ5KGFycikpO1xuXHRcdFx0XHRcdHJlaW5kZXhfZGljdF9pbmRleGVzKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBpZiAoc2lnID09ICdbc10nKSB7XG5cdFx0XHQvLyB0aGlzLnNldChhWzBdKTtcblx0XHRcdC8vIH1cblxuXHRcdFx0dmFyIGEgPSBhcmd1bWVudHM7XG5cdFx0XHRpZiAoYS5sZW5ndGggPT0gMSkge1xuXHRcdFx0XHR2YXIgc3BlYyA9IGFbMF07XG5cdFx0XHRcdGlmICh0b2Yoc3BlYykgPT0gJ3N0cmluZycpIHtcblx0XHRcdFx0XHQvLyBjb25zb2xlLmxvZygnc2V0dGluZycpO1xuXHRcdFx0XHRcdHRoaXMuc2V0KHNwZWMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHR9XG5cdH0pO1xuXHQgKi9cblx0XG5cdFxuICAgIC8qKlxuICAgICogQ3JlYXRlcyB0aGUgU29ydGVkX0tWUy5cbiAgICAqIEBjb25zdHJ1Y3RvclxuICAgICogQGNsYXNzZGVzYyBSZXByZXNlbnRzIGEgc29ydGVkIGtleS92YWx1ZSBwYWlycyBzdG9yYWdlICh3aXRoIGZhc3QgYWNjZXNzIGJ5IHRoZSBrZXkpLlxuICAgICogQG1lbWJlcm9mIG1vZHVsZTpjb3JlL2pzZ3VpLWRhdGEtc3RydWN0dXJlc1xuICAgICovXG5cdFxuXHQvLyBNdWx0aXBsZSBpdGVtcyBjb3VsZCBiZSBzdG9yZWQgaW4gb25lIHBvc2l0aW9uLlxuXHQvLyAgVGhpcyBtYXkgaGF2ZSBhbm90aGVyIGxheWVyIG9mIGZ1bmN0aW9uYWxpdHkgYmV5b25kIHRoZSB0cmVlLlxuXHRcblx0dmFyIFNvcnRlZF9LVlMgPSBDbGFzcy5leHRlbmQoe1xuXHRcdCdpbml0JzogZnVuY3Rpb24oc3BlYykge1xuXHRcdFx0c3BlYyA9IHNwZWMgfHwge307XG5cdFx0XHQvLyBib3RoIGEgZGljdCBhbmQgYSBCVHJlZVxuXHRcdFx0Ly8gIHRoYXQgaXMgdXNlZCBpbiB0aGlzIGNhc2UgYmVjYXVzZSB0aGUgQlRyZWUgb25seSBzdG9yZXMgc3RyaW5nIGtleXMuXG5cdFx0XHQvLyAgdGhlIGltcHJvdmVkIEIrIHRyZWUgd2lsbCBoYXZlIHZhbHVlIG9iamVjdHMvcG9pbnRlcnMgd2l0aGluIHRoZW1cblx0XHRcdFxuXHRcdFx0aWYgKGlzX2RlZmluZWQoc3BlYy51bmlxdWVfa2V5cykpIHRoaXMudW5pcXVlX2tleXMgPSBzcGVjLnVuaXF1ZV9rZXlzO1xuXHRcdFx0Ly90aGlzLnRyZWUgPSBuZXcgQl9QbHVzX1RyZWUoMTIpOyAvLyBvcmRlciAxMlxuXHRcdFx0dGhpcy50cmVlID0gQl9QbHVzX1RyZWUoMTIpOyAvLyBvcmRlciAxMlxuXHRcdFx0XG5cdFx0XHRcblx0XHRcdC8vdGhpcy5kaWN0ID0ge307XG5cdFx0XHQvLyBsaWtlbHkgdG8gbWFrZSB0aGUgZGljdCByZWZlciB0byB0aGUgdHJlZSBub2RlXG5cdFx0XHRcblx0XHRcdFxuXHRcdH0sXG5cblx0ICAgIC8qKlxuICAgICAgICAqIENsZWFycyB0aGUgc3RvcmFnZSwgcmVtb3ZpbmcgYWxsIHRoZSBrZXkvdmFsdWUgcGFpcnMuXG4gICAgICAgICogQG1lbWJlcm9mIG1vZHVsZTpjb3JlL2pzZ3VpLWRhdGEtc3RydWN0dXJlcy5Tb3J0ZWRfS1ZTXG4gICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICovXG5cdFx0J2NsZWFyJzogZnVuY3Rpb24gKCkge1xuXHRcdFx0dGhpcy50cmVlLmNsZWFyKCk7XG5cdFx0XHQvL3RoaXMuZGljdCA9IHt9O1xuXHRcdH0sXG5cblx0ICAgIC8qKlxuICAgICAgICAqIFB1dHMgdGhlIGtleS92YWx1ZSBwYWlycyBmcm9tIHRoZSBwYXNzZWQgb2JqZWN0IGludG8gdGhlIHN0b3JhZ2UuXG4gICAgICAgICogQGZ1bmNcbiAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gb2JqXG4gICAgICAgICogQG1lbWJlcm9mIG1vZHVsZTpjb3JlL2pzZ3VpLWRhdGEtc3RydWN0dXJlcy5Tb3J0ZWRfS1ZTXG4gICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgKiB2YXIga3ZzID0gbmV3IERhdGFfU3RydWN0dXJlcy5Tb3J0ZWRfS1ZTKCk7XG4gICAgICAgICoga3ZzLnB1dCh7IGE6IDF9KTtcbiAgICAgICAgKiBrdnMucHV0KHsgYjogMiwgYzogM30pO1xuICAgICAgICAqL1xuXHRcdCdwdXQnOiBtYXBpZnkoZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcblx0XHRcdC8vIGluc2VydGluZyBhIGJ1bmNoIG9mIHRoaW5ncyBhdCBvbmNlLi4uIGNvdWxkIHRoYXQgYmUgZG9uZSBtb3JlIGVmZmljaWVudGx5LCBzdWNoIGFzIGluIG9uZSB0cmF2ZXJzYWw/XG5cdFx0XHQvLyAgc29ydCB0aGUgaXRlbXMsIHRoZW4gY2FuIHNraXAgdGhyb3VnaCB0aGUgdHJlZSBhIGJpdCBxdWlja2VyP1xuXHRcdFx0XG5cdFx0XHRcblx0XHRcdHZhciBpbnNlcnRfcmVzID0gdGhpcy50cmVlLmluc2VydChrZXksIHZhbHVlKTtcblx0XHRcdC8vIHdpdGggdHJlZS5pbnNlcnQgLSBuaWNlIGlmIHdlIGNhbiBrZWVwIHRoZSB0cmVlbm9kZSBhcyBhIHJlc3VsdC5cblx0XHRcdC8vICB0aGUgdHJlZSBkb2VzIG5vdCBzdG9yZSBvYmplY3RzIGluIHRoZSBub2RlLlxuXHRcdFx0Ly8gICBjb3VsZCBtYWtlIHRoZSB0cmVlIG5vZGUgaG9sZCBhIHJlZmVyZW5jZSB0byB0aGUgb2JqZWN0P1xuXHRcdFx0XG5cdFx0XHRcblx0XHRcdFxuXHRcdFx0XG5cdFx0XHQvL2NvbnNvbGUubG9nKCdwdXQgaW5zZXJ0X3JlcyAnICsgaW5zZXJ0X3Jlcyk7XG5cdFx0XHQvL3RoaXMuZGljdFtrZXldID0gdmFsdWU7XG5cdFx0fSksXG5cblxuXHQgICAgLyoqXG4gICAgICAgICogUmVtb3ZlcyBmcm9tIHRoZSBzdG9yYWdlIHZhbHVlcyBmb3IgdGhlIHBhc3NlZCBrZXkuXG4gICAgICAgICogQGZ1bmNcbiAgICAgICAgKiBAcGFyYW0geyp9IGtleVxuICAgICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29yZS9qc2d1aS1kYXRhLXN0cnVjdHVyZXMuU29ydGVkX0tWU1xuICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAqL1xuXHRcdCdvdXQnOiBmdW5jdGlvbiAoa2V5KSB7XG5cdFx0XHQvL2NvbnNvbGUubG9nKCdrZXkgJyArIGtleSk7XG5cdFx0XHQvL1xuXHRcdFxuXHRcdFx0dGhpcy50cmVlLnJlbW92ZShrZXkpO1xuXHRcdFx0Ly9jb25zb2xlLmxvZygndGhpcy50cmVlLmtleXNfYW5kX3ZhbHVlcygpICcgKyBzdHJpbmdpZnkodGhpcy50cmVlLmtleXNfYW5kX3ZhbHVlcygpKSk7XG5cdFx0XHQvL3Rocm93ICcyLnN0b3AnO1xuXHRcdFx0Ly9kZWxldGUgdGhpcy5kaWN0W2tleV07XG5cdFx0fSxcblxuXHQgICAgLyoqXG4gICAgICAgICogR2V0cyBmcm9tIHRoZSBzdG9yYWdlIHZhbHVlcyBmb3IgdGhlIHBhc3NlZCBrZXksIHJldHVybnMgdGhlIHZhbHVlcyBhcnJheS5cbiAgICAgICAgKiBAZnVuY1xuICAgICAgICAqIEBwYXJhbSB7Kn0ga2V5XG4gICAgICAgICogQG1lbWJlcm9mIG1vZHVsZTpjb3JlL2pzZ3VpLWRhdGEtc3RydWN0dXJlcy5Tb3J0ZWRfS1ZTXG4gICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICovXG5cdFx0J2dldCc6IGZ1bmN0aW9uIChrZXkpIHtcblx0XHRcdC8vY29uc29sZS5sb2coJ1NvcnRlZF9LVlMgZ2V0Jyk7XG5cdFx0XHQvL2NvbnNvbGUubG9nKCdrZXkgJyArIHN0cmluZ2lmeShrZXkpKTtcblxuXHRcdFx0XG5cdFx0XHQvLyBnZXQgYWxsIG5vZGVzIHdpdGggdGhhdCBrZXlcblx0XHRcdFxuXHRcdFx0Ly92YXIgdHJlZV9yZXMgPSB0aGlzLnRyZWUuXG5cdFx0XHQvL2NvbnNvbGUubG9nKCd0aGlzLnRyZWUua2V5cygpICcgKyBzdHJpbmdpZnkodGhpcy50cmVlLmtleXMoKSkpO1xuXHRcdFx0Ly90aHJvdyAoJ3N0b3AnKTtcblx0XHRcdFxuXHRcdFx0Ly9yZXR1cm4gXG5cdFx0XHQvLyBpZiB0aGlzIGlzIHRyZWF0aW5nIHRoZSBrZXlzIGFzIHVuaXF1ZSBpdCB3aWxsIGp1c3QgcmV0dXJuIDEgaXRlbSBvciB1bmRlZmluZWQgLyBudWxsLlxuXHRcdFx0Ly8gb3RoZXJ3aXNlIGl0IHJldHVybnMgYXJyYXkgb24gbiBpdGVtc1xuXHRcdFx0XG5cdFx0XHQvLyBkb24ndCB3YW50IEtWUHNcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHRoaXMudHJlZS5nZXRfdmFsdWVzX2J5X2tleShrZXkpO1xuXHRcdFx0XG5cdFx0XHQvL3JldHVybiB0aGlzLmRpY3Rba2V5XTtcblx0XHR9LFxuXG5cblx0ICAgIC8qKlxuICAgICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc3RvcmFnZSBjb250YWlucyB0aGUgcGFzc2VkIGtleS5cbiAgICAgICAgKiBAZnVuY1xuICAgICAgICAqIEBwYXJhbSB7Kn0ga2V5XG4gICAgICAgICogQG1lbWJlcm9mIG1vZHVsZTpjb3JlL2pzZ3VpLWRhdGEtc3RydWN0dXJlcy5Tb3J0ZWRfS1ZTXG4gICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICovXG5cdFx0J2hhcyc6IGZ1bmN0aW9uIChrZXkpIHtcblx0XHRcdC8vcmV0dXJuICh0eXBlb2YgdGhpcy5kaWN0W2tleV0gIT09ICd1bmRlZmluZWQnKTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHRoaXMua2V5X2NvdW50KGtleSkgPiAwO1xuXHRcdFx0XG5cdFx0fSxcblx0XHQnZ2V0X2N1cnNvcic6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Ly92YXIgcmVzID0gbmV3IEtTVlNfQ3Vyc29yKHRoaXMpO1xuXHRcdFx0Ly9yZXMubW92ZV9maXJzdCgpO1xuXHRcdFx0Ly9yZXR1cm4gcmVzO1xuXHRcdH0sXG5cblxuXHQgICAgLyoqXG4gICAgICAgICogUmV0dXJucyBhbiBhcnJheSBvZiBhbGwgdGhlIGtleXMgaW4gdGhlIHN0b3JhZ2UuXG4gICAgICAgICogQGZ1bmNcbiAgICAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvcmUvanNndWktZGF0YS1zdHJ1Y3R1cmVzLlNvcnRlZF9LVlNcbiAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgKi9cblx0XHQna2V5cyc6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHRoaXMudHJlZS5rZXlzKCk7XG5cdFx0XHRcblx0XHRcdC8vcmV0dXJuIHRoaXMudHJlZS5rZXlzKCk7XG5cdFx0fSxcblxuXHQgICAgLyoqXG4gICAgICAgICogUmV0dXJucyBhbiBhcnJheSBvZiBba2V5LCB2YWx1ZV0gYXJyYXlzIGZvciBhbGwgdGhlIGl0ZW1zIGluIHRoZSBzdG9yYWdlLlxuICAgICAgICAqIEBmdW5jXG4gICAgICAgICogQG1lbWJlcm9mIG1vZHVsZTpjb3JlL2pzZ3VpLWRhdGEtc3RydWN0dXJlcy5Tb3J0ZWRfS1ZTXG4gICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICovXG5cdFx0J2tleXNfYW5kX3ZhbHVlcyc6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiB0aGlzLnRyZWUua2V5c19hbmRfdmFsdWVzKCk7XG5cdFx0fSxcblx0XHRcblx0XHQvKlxuXHRcdCd2YWx1ZXMnOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBrZXlzID0gdGhpcy5rZXlzKCk7XG5cdFx0XHR2YXIgcmVzID0gW107XG5cdFx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cdFx0XHRjb25zb2xlLmxvZygna2V5cy5sZW5ndGggJyArIGtleXMubGVuZ3RoICk7XG5cdFx0XHRjb25zb2xlLmxvZygna2V5cyAnICsganNndWkuc3RyaW5naWZ5KGtleXMpKTtcblx0XHRcdFxuXHRcdFx0ZWFjaChrZXlzLCBmdW5jdGlvbihpLCB2KSB7XG5cdFx0XHRcdHJlcy5wdXNoKHRoYXQuZGljdFt2XSk7XG5cdFx0XHR9KTtcblx0XHRcdHJldHVybiByZXM7XG5cdFx0fSxcblx0XHQqL1xuXHRcdFxuXHQgICAgLyoqXG4gICAgICAgICogUmV0dXJucyBhbiBhbW91bnQgb2YgYWxsIHRoZSBrZXlzIGluIHRoZSBzdG9yYWdlLlxuICAgICAgICAqIEBuYW1lIGtleV9jb3VudFxuICAgICAgICAqIEBmdW5jXG4gICAgICAgICogQG1lbWJlcm9mIG1vZHVsZTpjb3JlL2pzZ3VpLWRhdGEtc3RydWN0dXJlcy5Tb3J0ZWRfS1ZTXG4gICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICovXG5cblx0ICAgIC8qKlxuICAgICAgICAqIFJldHVybnMgYW4gYW1vdW50IG9mIHRoZSBwYXNzZWQga2V5IG9jY3VycmVuY2VzIGluIHRoZSBzdG9yYWdlLlxuICAgICAgICAqIEBmdW5jXG4gICAgICAgICogQHBhcmFtIHsqfSBrZXlcbiAgICAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvcmUvanNndWktZGF0YS1zdHJ1Y3R1cmVzLlNvcnRlZF9LVlNcbiAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgKi9cblx0XHQna2V5X2NvdW50JzogZnVuY3Rpb24gKGtleSkge1xuXHRcdFx0XG5cdFx0XHRpZiAoaXNfZGVmaW5lZChrZXkpKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLnRyZWUuY291bnQoa2V5KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLnRyZWUuY291bnQoKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Ly8gYWxzbyB3YW50IHRvIGRvIGl0IGZvciBhIHBhcnRpY3VsYXIga2V5XG5cdFx0XHRcblx0XHRcdFxuXHRcdH0sXG5cdFx0XG5cdFx0Lypcblx0XHRcblx0XHQnZ2V0X2tleXNfYnlfcHJlZml4JzogZnVuY3Rpb24ocHJlZml4KSB7XG5cdFx0XHR2YXIgbGVhZiA9IHRoaXMudHJlZS5zZWFyY2hMZWFmKHByZWZpeCk7XG5cdFx0XHR2YXIgbm9kZSA9IGxlYWYubm9kZTtcblx0XHRcdHZhciByZXMgPSBbXTtcblx0XHRcdHZhciBpbmRleCA9IGxlYWYuaW5kZXg7XG5cdFx0XHR2YXIgcGxlbiA9IHByZWZpeC5sZW5ndGg7XG5cdFx0XHR2YXIgY2hlY2tfcHJlZml4ID0gZnVuY3Rpb24oa2V5KSB7XG5cdFx0XHRcdGlmIChwbGVuID4ga2V5Lmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRyZXR1cm4gKGtleS5zdWJzdHIoMCwgcGxlbikgPT0gcHJlZml4KVxuXHRcdFx0fVxuXHRcdFx0dmFyIGhhc19wcmVmaXggPSB0cnVlO1xuXHQgICAgICAgIHdoaWxlIChub2RlICE9IG51bGwgJiYgaGFzX3ByZWZpeCkge1xuXHQgICAgICAgIFx0Ly8gd2hhdCBpcyB0aGUgb3JpZ2luYWwgaW5kZXg/XG5cdCAgICAgICAgXHR2YXIga2V5ID0gbm9kZS5rZXlzLml0ZW1zW2luZGV4XTtcblx0ICAgICAgICBcdGNvbnNvbGUubG9nKCdrZXkgJyArIGtleSk7XG5cdCAgICAgICAgXHQvL3ZhciB2YWx1ZSA9IG5vZGUudmFsdWVzLml0ZW1zW2luZGV4XTtcblx0ICAgICAgICBcdGhhc19wcmVmaXggPSBjaGVja19wcmVmaXgoa2V5KTtcblx0ICAgICAgICBcdGlmIChoYXNfcHJlZml4KSB7XG5cdCAgICAgICAgXHRcdGlmIChpbmRleCA+PSBub2RlLmtleXMuY291bnQpIHtcblx0XHRcdCAgICAgICAgXHRyZXMucHVzaChrZXkpO1xuXHRcdFx0ICAgICAgICAgICAgbm9kZSA9IG5vZGUubmV4dExlYWY7XG5cdFx0ICAgICAgICBcdFx0aW5kZXggPSAwO1xuXHRcdCAgICAgICAgXHR9IGVsc2Uge1xuXHRcdFx0ICAgICAgICBcdHJlcy5wdXNoKGtleSk7XG5cdFx0ICAgICAgICBcdFx0aW5kZXgrKztcblx0XHQgICAgICAgIFx0fVxuXHQgICAgICAgIFx0fVxuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gcmVzO1xuXHRcdH0sXG5cdFx0XG5cdFx0Ki9cblx0XHRcblx0ICAgIC8qKlxuICAgICAgICAqIFJldHVybnMgYW4gYXJyYXkgb2YgdGhlIGtleXMgdGhhdCBzdGFydCBmcm9tIHRoZSBwYXNzZWQgcHJlZml4LlxuICAgICAgICAqIEBmdW5jXG4gICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHByZWZpeFxuICAgICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29yZS9qc2d1aS1kYXRhLXN0cnVjdHVyZXMuU29ydGVkX0tWU1xuICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAqL1xuXHRcdCdnZXRfa2V5c19ieV9wcmVmaXgnOiBmdW5jdGlvbiAocHJlZml4KSB7XG5cdFx0XHRyZXR1cm4gdGhpcy50cmVlLmdldF9rZXlzX2J5X3ByZWZpeChwcmVmaXgpO1xuXHRcdH0sXG5cdFx0XG5cdCAgICAvKipcbiAgICAgICAgKiBJbnZva2VzIHRoZSBjYWxsYmFjayBmdW5jdGlvbiBmb3IgZWFjaCBpdGVtIGluIHRoZSBzdG9yYWdlOiBgY2FsbGJhY2soa2V5LCB2YWx1ZSlgXG4gICAgICAgICogQGZ1bmNcbiAgICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29yZS9qc2d1aS1kYXRhLXN0cnVjdHVyZXMuU29ydGVkX0tWU1xuICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAqL1xuXHRcdCdlYWNoJzogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG5cdFx0XHQvLyBpdGVyYXRlIHRocm91Z2ggZXZlcnkgaXRlbVxuXHRcdFx0Ly8gIGtleSwgdmFsdWVcblx0XHRcdHJldHVybiB0aGlzLnRyZWUuZWFjaChjYWxsYmFjayk7XG5cdFx0fSxcblx0XHRcblx0ICAgIC8qKlxuICAgICAgICAqIFJldHVybnMgYW4gYXJyYXkgb2YgW2tleSwgdmFsdWVdIGFycmF5cyBmb3IgdGhlIGtleXMgdGhhdCBzdGFydCBmcm9tIHRoZSBwYXNzZWQgcHJlZml4LlxuICAgICAgICAqIEBmdW5jXG4gICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHByZWZpeFxuICAgICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29yZS9qc2d1aS1kYXRhLXN0cnVjdHVyZXMuU29ydGVkX0tWU1xuICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAqL1xuXHRcdCdnZXRfYnlfcHJlZml4JzogZnVuY3Rpb24gKHByZWZpeCkge1xuXHRcdFx0XG5cdCAgICAgICAgcmV0dXJuIHRoaXMudHJlZS5nZXRfYnlfcHJlZml4KHByZWZpeCk7XG5cdFx0fVxuXHR9KTtcblxuXG5cbiAgICAvKipcbiAgICAqIENyZWF0ZXMgdGhlIE9yZGVyZWRfS1ZTLlxuICAgICogQGNvbnN0cnVjdG9yXG4gICAgKiBAY2xhc3NkZXNjIFJlcHJlc2VudHMgYW4gdW5zb3J0ZWQga2V5L3ZhbHVlIHBhaXJzIHN0b3JhZ2UsIGJ1dCB3aXRoIGZhc3QgYWNjZXNzIGJ5IHRoZSBrZXkuIFRoZSBlYWNoKCktYmFzZWQgb3BlcmF0aW9ucyBcbiAgICAqIChlLmcuIGtleXMoKSwgdmFsdWVzKCkgZXRjLikgcmV0dXJucyB0aGUgaXRlbXMgaW4gdGhlIHNhbWUgb3JkZXIgYXMgdGhleSB3YXMgYWRkZWQuIEJ1dCB0aGUgZ2V0KCkgYW5kIG91dCgpIG9wZXJhdGlvbnMgXG4gICAgKiB1c2UgYSBmYXN0IGtleSBhY2Nlc3MuIFVuZm9ydHVuYXRlbHkgdGhlc2Ugb3BlcmF0aW9uIHdvcmtzIHdpdGggdGhlIGxhc3QgYWRkZWQgdmFsdWUgb25seSBpZiBzZXZlcmFsIHZhbHVlcyBoYXZlIGVxdWFsIGtleXMuXG4gICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvcmUvanNndWktZGF0YS1zdHJ1Y3R1cmVzXG4gICAgKi9cblxuXHQvLyBEb3VibGUgTGlua2VkIExpc3QgaW5zaWRlLCBhcyB3ZWxsIGFzIGEgc2ltcGxlIGRpY3Qgd2l0aCByZWZlcmVuY2VzIHRvIHRoZSBub2Rlcy5cblx0Ly8gVXNlIGxpa2VkIGxpc3Qgbm9kZXM/XG5cdFxuXHQvLyBJdGVtcyBhcmUgaWRlbnRpZmllZCB3aXRoIGEga2V5LCBidXQgc3RvcmVkIGluIGFueSBvcmRlci5cblx0Ly8gIFRoaXMgY291bGQgYmUgdXNlZnVsIGZvciBzdG9yaW5nIGEgbGlzdCBvZiBmaWVsZHMuIEFsbG93cyBmYXN0IHJldHJpZXZhbCBieSBmaWVsZCBuYW1lLCBhbHNvIHByZXNlcnZlcyB0aGUgb3JkZXJpbmcuXG5cdFxuXHQvLyB3aWxsIGhhdmUgZnVuY3Rpb25zIGZvciByZS1vcmRlcmluZyBhcyB3ZWxsLlxuXHRcblx0dmFyIE9yZGVyZWRfS1ZTID0gQ2xhc3MuZXh0ZW5kKHtcblx0XHQnaW5pdCc6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5kbGwgPSBuZXcgRG91Ymx5X0xpbmtlZF9MaXN0KCk7XG5cdFx0XHR0aGlzLm5vZGVfbWFwID0ge307XG5cdFx0fSxcblxuXG5cdCAgICAvKipcbiAgICAgICAgKiBSZXR1cm5zIGFuIGFtb3VudCBvZiBpdGVtcyBpbiB0aGUgc3RvcmFnZS5cbiAgICAgICAgKiBAZnVuY1xuICAgICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29yZS9qc2d1aS1kYXRhLXN0cnVjdHVyZXMuT3JkZXJlZF9LVlNcbiAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgKi9cblx0XHQnbGVuZ3RoJzogZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZGxsLmxlbmd0aDtcblx0XHR9LFxuXG5cblx0ICAgIC8qKlxuICAgICAgICAqIEFkZHMgdGhlIGtleS92YWx1ZSBwYWlyIHRvIHRoZSBzdG9yYWdlLlxuICAgICAgICAqIEBmdW5jXG4gICAgICAgICogQHBhcmFtIHsqfSBrZXlcbiAgICAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICAgICogQG1lbWJlcm9mIG1vZHVsZTpjb3JlL2pzZ3VpLWRhdGEtc3RydWN0dXJlcy5PcmRlcmVkX0tWU1xuICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAqL1xuXHRcdCdwdXQnOiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuXHRcdFx0Ly8gZG9lcyBpdCBhbHJlYWR5IGV4aXN0IHdpdGggdGhhdCBrZXkgLSBpZiBzbyB0aGF0IGl0ZW0gZ2V0cyByZXBsYWNlZCwgc3RheXMgaW4gdGhlIHNhbWUgcG9zaXRpb24/XG5cdFx0XHQvLyBvciBtYXliZSBwdXNoIC0gdGhhdCBtZWFucyB0aGUgaXRlbSB0aGF0IGdvZXMgaW4gZ2V0cyBhZGRlZCB0byB0aGUgZW5kLlxuXHRcdFx0cmV0dXJuIHRoaXMucHVzaChrZXksIHZhbHVlKTtcblx0XHR9LFxuXG5cblx0ICAgIC8qKlxuICAgICAgICAqIFJldHVybnMgdGhlIHZhbHVlIGZvciB0aGUgcGFzc2VkIGtleSwgb3IgYHVuZGVmaW5lZGAgaWYgdGhlIGtleSBkb2VzIG5vdCBleGlzdHMuIDxiciAvPlxuICAgICAgICAqIElmIHRoZSBrZXkgd2FzIGFkZGVkIHNldmVyYWwgdGltZXMsIHRoZW4gcmV0dXJucyB0aGUgbGF0ZXN0IGFkZGVkIHZhbHVlLlxuICAgICAgICAqIEBmdW5jXG4gICAgICAgICogQHBhcmFtIHsqfSBrZXlcbiAgICAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvcmUvanNndWktZGF0YS1zdHJ1Y3R1cmVzLk9yZGVyZWRfS1ZTXG4gICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICovXG5cdFx0J2dldCc6IGZ1bmN0aW9uIChrZXkpIHtcblx0XHRcdC8vY29uc29sZS5sb2coJ2dldCBrZXkgJyArIGtleSk7XG5cdFx0XHR2YXIga3ZzX25vZGUgPSB0aGlzLm5vZGVfbWFwW2tleV07XG5cdFx0XHRpZiAoa3ZzX25vZGUpIHtcblx0XHRcdFx0cmV0dXJuIGt2c19ub2RlLnZhbHVlO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0XHRcdFx0Ly90aHJvdyAnTWlzc2luZyBLVlMgbm9kZTogJyArIGtleTtcblx0XHRcdH1cblx0XHR9LFxuXG5cblx0ICAgIC8qKlxuICAgICAgICAqIEFkZHMgdGhlIGtleS92YWx1ZSBwYWlyIHRvIHRoZSBzdG9yYWdlLlxuICAgICAgICAqIEBmdW5jXG4gICAgICAgICogQHBhcmFtIHsqfSBrZXlcbiAgICAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICAgICogQG1lbWJlcm9mIG1vZHVsZTpjb3JlL2pzZ3VpLWRhdGEtc3RydWN0dXJlcy5PcmRlcmVkX0tWU1xuICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAqL1xuXHRcdCdwdXNoJzogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcblx0XHRcdC8vIGRvZXMgaXQgYWxyZWFkeSBoYXZlIGEgbm9kZSB3aXRoIHRoYXQga2V5P1xuXHRcdFx0dmFyIG5vZGUgPSB0aGlzLmRsbC5wdXNoKHZhbHVlKTtcblx0XHRcdG5vZGUua2V5ID0ga2V5O1xuXHRcdFx0dGhpcy5ub2RlX21hcFtrZXldID0gbm9kZTtcblx0XHR9LFxuXG5cdCAgICAvKipcbiAgICAgICAgKiBSZW1vdmVzIHRoZSBwYWlyIHdpdGggdGhlIHBhc3NlZCBrZXkgZnJvbSB0aGUgc3RvcmFnZS4gVGhyb3dzIGFuIGV4Y2VwdGlvbiBpZiB0aGUga2V5IGRvZXMgbm90IGV4aXN0cy4gPGJyIC8+XG4gICAgICAgICogSWYgdGhlIGtleSB3YXMgYWRkZWQgc2V2ZXJhbCB0aW1lcywgdGhlbiByZW1vdmVzIHRoZSBsYXRlc3QgYWRkZWQgcGFpciBvbmx5IChhbmQgdGhyb3dzIGFuIGV4Y2VwdGlvbiBmb3IgdGhlIG5leHQgdGltZSkuXG4gICAgICAgICogQGZ1bmNcbiAgICAgICAgKiBAcGFyYW0geyp9IGtleVxuICAgICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29yZS9qc2d1aS1kYXRhLXN0cnVjdHVyZXMuT3JkZXJlZF9LVlNcbiAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgKi9cblx0XHQnb3V0JzogZnVuY3Rpb24gKGtleSkge1xuXHRcdFx0dmFyIG5vZGUgPSB0aGlzLm5vZGVfbWFwW2tleV07XG5cdFx0XHQvL2RlbGV0ZSBub2RlLmtleTtcblx0XHRcdGRlbGV0ZSB0aGlzLm5vZGVfbWFwW2tleV1cblx0XHRcdFxuXHRcdFx0dGhpcy5kbGwucmVtb3ZlKG5vZGUpO1xuXHRcdH0sXG5cblx0ICAgIC8qKlxuICAgICAgICAqIEludm9rZXMgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGZvciBlYWNoIGl0ZW0gaW4gdGhlIHN0b3JhZ2U6IGBjYWxsYmFjayhrZXksIHZhbHVlLCBzdG9wKWBcbiAgICAgICAgKiBAZnVuY1xuICAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICAgICogQG1lbWJlcm9mIG1vZHVsZTpjb3JlL2pzZ3VpLWRhdGEtc3RydWN0dXJlcy5PcmRlcmVkX0tWU1xuICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAqL1xuXHRcdCdlYWNoJzogZnVuY3Rpb24oY2FsbGJhY2spIHtcblx0XHRcdFxuXHRcdFx0Ly8gcmV0dXJuIHRoZSBrZXkgYXMgd2VsbCBhcyB0aGUgdmFsdWUgaW4gdGhlIGNhbGxiYWNrLlxuXHRcdFx0dGhpcy5kbGwuZWFjaF9ub2RlKGZ1bmN0aW9uKG5vZGUsIHN0b3ApIHtcblx0XHRcdFx0Y2FsbGJhY2sobm9kZS5rZXksIG5vZGUudmFsdWUsIHN0b3ApO1xuXHRcdFx0fSk7XG5cdFx0XHRcblx0XHRcdFxuXHRcdFx0Ly90aGlzLmRsbC5lYWNoKGNhbGxiYWNrKTtcblx0XHR9LFxuXG5cdCAgICAvKipcbiAgICAgICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIGFsbCB0aGUgdmFsdWVzIGluIHRoZSBzdG9yYWdlLlxuICAgICAgICAqIEBmdW5jXG4gICAgICAgICogQG1lbWJlcm9mIG1vZHVsZTpjb3JlL2pzZ3VpLWRhdGEtc3RydWN0dXJlcy5PcmRlcmVkX0tWU1xuICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAqL1xuXHRcdCd2YWx1ZXMnOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgcmVzID0gW107XG5cdFx0XHR0aGlzLmVhY2goZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuXHRcdFx0XHRyZXMucHVzaCh2YWx1ZSk7XG5cdFx0XHR9KTtcblx0XHRcdHJldHVybiByZXM7XG5cdFx0fSxcblxuXHQgICAgLyoqXG4gICAgICAgICogUmV0dXJucyBhbiBhcnJheSBvZiBhbGwgdGhlIGtleXMgaW4gdGhlIHN0b3JhZ2UuXG4gICAgICAgICogQGZ1bmNcbiAgICAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvcmUvanNndWktZGF0YS1zdHJ1Y3R1cmVzLk9yZGVyZWRfS1ZTXG4gICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICovXG5cdFx0J2tleXMnOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgcmVzID0gW107XG5cdFx0XHR0aGlzLmVhY2goZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuXHRcdFx0XHRyZXMucHVzaChrZXkpO1xuXHRcdFx0fSk7XG5cdFx0XHRyZXR1cm4gcmVzO1xuXHRcdH0sXG5cblx0ICAgIC8qKlxuICAgICAgICAqIFJldHVybnMgYW4gYXJyYXkgb2YgW2tleSwgdmFsdWVdIGFycmF5cyBmb3IgYWxsIHRoZSBpdGVtcyBpbiB0aGUgc3RvcmFnZS5cbiAgICAgICAgKiBAZnVuY1xuICAgICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29yZS9qc2d1aS1kYXRhLXN0cnVjdHVyZXMuT3JkZXJlZF9LVlNcbiAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgKi9cblx0XHQna2V5c19hbmRfdmFsdWVzJzogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIHJlcyA9IFtdO1xuXHRcdFx0dGhpcy5lYWNoKGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcblx0XHRcdFx0cmVzLnB1c2goW2tleSwgdmFsdWVdKTtcblx0XHRcdH0pO1xuXHRcdFx0cmV0dXJuIHJlcztcblx0XHR9XG5cdFx0Ly8gd2lsbCBub3QgbmVlZCB0byBkZWFsIHdpdGggbm9kZXMgb24gdGhlIHVzZXIgbGV2ZWwuXG5cdFx0Ly8gd2FudCB0byBiZSBhYmxlIHRvIGFkZCBhbmQgcmVtb3ZlIGl0ZW1zLCBub3JtYWxseSBpdGVtcyB3aWxsIGdldCBwdXNoZWQgdG8gdGhlIGVuZCBvZiB0aGUgbGlzdC5cblx0XHRcblx0XHQvLyB3aWxsIHByb3ZpZGUgYSBrZXkgYW5kIHZhbHVlIGluIG9yZGVyIHRvIGRvIHRoaXMuXG5cdH0pO1xuXHQvLyBoYXZlIGEgS1NWUyBjdXJzb3IgLSB0aGlzIHdpbGwgYmUgYWJsZSB0byBnZXQgdGhlIGtleSBhbmQgdmFsdWUgYXQgYW55IHBvc2l0aW9uLlxuXHQvLyAgTmVlZCB0byBiZSBhYmxlIHRvIG1vdmUgdGhlIGN1cnNvci5cblx0XG5cdC8qXG5cdFxuXHR2YXIgU29ydGVkX0tWU19DdXJzb3IgPSBDbGFzcy5leHRlbmQoe1xuXHRcdCdpbml0JzogZnVuY3Rpb24oa3N2cykge1xuXHRcdFx0dGhpcy5rc3ZzID0ga3N2cztcblx0XHRcdHRoaXMuYl9wbHVzX2N1cnNvciA9IG5ldyBCVHJlZUN1cnNvcigpO1xuXHRcdFx0dGhpcy5iX3BsdXNfY3Vyc29yLm1vdmVfZmlyc3QoKTtcblx0XHR9LFxuXHRcdCdtb3ZlX2ZpcnN0JzogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5iX3BsdXNfY3Vyc29yLm1vdmVfZmlyc3QoKTtcblx0XHR9LFxuXHRcdCdtb3ZlX25leHQnOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLmJfcGx1c19jdXJzb3IubW92ZV9uZXh0KCk7XG5cdFx0fSxcblx0XHQnbW92ZV9wcmV2JzogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5iX3BsdXNfY3Vyc29yLm1vdmVfcHJldigpO1xuXHRcdH0sXG5cdFx0J2t2JzogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIga2V5ID0gdGhpcy5iX3BsdXNfY3Vyc29yLmdldF92YWx1ZSgpO1xuXHRcdFx0dmFyIHZhbHVlID0gdGhpcy5rc3ZzLmRpY3Rba2V5XTtcblx0XHRcdHJldHVybiBba2V5LCB2YWx1ZV07XG5cdFx0fVxuXHR9KTtcblx0Ki9cblxuXG5cbiAgICAvKipcbiAgICAqIENyZWF0ZXMgdGhlIE9yZGVyZWRfU3RyaW5nX0xpc3QuXG4gICAgKiBAY2xhc3NkZXNjIFJlcHJlc2VudHMgYW4gdW5zb3J0ZWQgc3RyaW5nIGxpc3QuXG4gICAgKiBAY29uc3RydWN0b3JcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBbdmFsdWVzXSAtIHNwYWNlLXNlcGFyYXRlZCBsaXN0IG9mIHZhbHVlc1xuICAgICogQG1lbWJlcm9mIG1vZHVsZTpjb3JlL2pzZ3VpLWRhdGEtc3RydWN0dXJlc1xuICAgICogQGV4YW1wbGVcbiAgICAqIHZhciBsaXN0MSA9IG5ldyBEYXRhX1N0cnVjdHVyZXMuT3JkZXJlZF9TdHJpbmdfTGlzdCgpO1xuICAgICogdmFyIGxpc3QyID0gbmV3IERhdGFfU3RydWN0dXJlcy5PcmRlcmVkX1N0cmluZ19MaXN0KFwidmFsdWUxIHZhbHVlMiB2YWx1ZTNcIik7XG4gICAgKi9cblxuXHQvLyBUaGlzIGNvdWxkIGJlIHVzZWZ1bCBmb3IgYSBmZXcgdGhpbmdzLCBsaWtlIHN0b3JpbmcgdGFibGVzIGluIGEgREJcblx0Ly8gc2NoZW1hLlxuXHQvLyBNYXliZSBxdWl0ZSBhIGZldyBtb3JlIHRoaW5ncy5cblxuXHQvLyBNYXkgbWFrZSBzb21lIG9iamVjdHMgd2l0aCBmcmllbmRsaWVyIGludGVyZmFjZXMuLi5cblx0Ly8gIEFuZCBtYXkgdXNlIGNvbGxlY3Rpb24gZm9yIHRoaXMgdG8gc3RvcmUgbGlzdHMgb2Ygc3RyaW5ncy5cblx0Ly8gIExpa2UgQ1NTIGZsYWdzIGF0IHRoZSBtb21lbnQuXG5cblx0Ly8gVXNlcyBwcml2YXRlIHZhcmlhYmxlcy5cblx0dmFyIE9yZGVyZWRfU3RyaW5nX0xpc3QgPSBDbGFzcy5leHRlbmQoe1xuXHRcdCdpbml0JyA6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Ly8gY29uc29sZS5sb2coJ2luaXQgb3NsIHNpZyAnICsgc2lnKTtcblxuXHRcdFx0dmFyIGFyciA9IFtdO1xuXHRcdFx0dmFyIGRpY3RfaW5kZXhlcyA9IHt9O1xuXG5cdFx0XHR2YXIgcmVpbmRleF9kaWN0X2luZGV4ZXMgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0ZGljdF9pbmRleGVzID0ge307XG5cdFx0XHRcdGZvciAoIHZhciBjID0gMCwgbCA9IGFyci5sZW5ndGg7IGMgPCBsOyBjKyspIHtcblx0XHRcdFx0XHRkaWN0X2luZGV4ZXNbYXJyW2NdXSA9IGM7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdCAgICAvKipcbiAgICAgICAgICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHBhc3NlZCB2YWx1ZSBleGlzdHMgaW4gdGhlIGxpc3QuXG4gICAgICAgICAgICAqIEBmdW5jXG4gICAgICAgICAgICAqIEBhbGlhcyBoYXNcbiAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAgICAgICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29yZS9qc2d1aS1kYXRhLXN0cnVjdHVyZXMuT3JkZXJlZF9TdHJpbmdfTGlzdFxuICAgICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICAgICovXG5cdFx0ICAgIC8vIChhZGQpLCByZW1vdmUsIGdldCwgZ2V0X2FsbCwgaGFzLCBwdXQsIG1vdmUsIHNwbGljZVxuXHRcdFx0dGhpcy5oYXMgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0XHRyZXR1cm4gKHR5cGVvZiBkaWN0X2luZGV4ZXNbdmFsdWVdICE9PSAndW5kZWZpbmVkJyk7XG5cdFx0XHR9XG5cblx0XHQgICAgLyoqXG4gICAgICAgICAgICAqIEFkZHMgdGhlIHBhc3NlZCB2YWx1ZSB0byB0aGUgZW5kIG9mIHRoZSBsaXN0LiBEb2VzIG5vdGhpbmcgaWYgdGhlIHZhbHVlIGFscmVhZHkgZXhpc3RzIGluIHRoZSBsaXN0LlxuICAgICAgICAgICAgKiBAZnVuY1xuICAgICAgICAgICAgKiBAYWxpYXMgcHV0XG4gICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgICAgICAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvcmUvanNndWktZGF0YS1zdHJ1Y3R1cmVzLk9yZGVyZWRfU3RyaW5nX0xpc3RcbiAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAqL1xuXHRcdFx0dGhpcy5wdXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRcdFx0Ly8gYnkgZGVmYXVsdCBwdXRzIGl0IGF0IHRoZSBlbmQuXG5cdFx0XHRcdGlmICh0aGlzLmhhcyh2YWx1ZSkpIHtcblx0XHRcdFx0XHQvLyBzdGF5cyBpbiBzYW1lIHBsYWNlLlxuXHRcdFx0XHRcdC8vIGFycltkaWN0X2luZGV4ZXNbdmFsdWVdXVxuXHRcdFx0XHRcdC8vIGRvIG5vdGhpbmdcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR2YXIgaW5kZXggPSBhcnIubGVuZ3RoO1xuXHRcdFx0XHRcdGFyci5wdXNoKHZhbHVlKTtcblx0XHRcdFx0XHRkaWN0X2luZGV4ZXNbdmFsdWVdID0gaW5kZXg7XG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0ICAgIC8qKlxuICAgICAgICAgICAgKiBSZW1vdmVzIHRoZSBwYXNzZWQgdmFsdWUgZnJvbSB0aGUgbGlzdC4gRG9lcyBub3RoaW5nIGlmIHRoZSB2YWx1ZSBkb2VzIG5vdCBleGlzdHMgaW4gdGhlIGxpc3QuXG4gICAgICAgICAgICAqIEBmdW5jXG4gICAgICAgICAgICAqIEBhbGlhcyBvdXRcbiAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAgICAgICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29yZS9qc2d1aS1kYXRhLXN0cnVjdHVyZXMuT3JkZXJlZF9TdHJpbmdfTGlzdFxuICAgICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICAgICovXG5cdFx0XHR0aGlzLm91dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdFx0XHRpZiAodGhpcy5oYXModmFsdWUpKSB7XG5cdFx0XHRcdFx0dmFyIGlkeCA9IGRpY3RfaW5kZXhlc1t2YWx1ZV07XG5cdFx0XHRcdFx0YXJyLnNwbGljZShpZHgsIDEpO1xuXG5cdFx0XHRcdFx0ZGVsZXRlIGRpY3RfaW5kZXhlc1t2YWx1ZV07XG5cblx0XHRcdFx0XHRmb3IgKCB2YXIgYyA9IGlkeCwgbCA9IGFyci5sZW5ndGg7IGMgPCBsOyBjKyspIHtcblx0XHRcdFx0XHRcdHZhciBpID0gYXJyW2NdO1xuXHRcdFx0XHRcdFx0ZGljdF9pbmRleGVzW2ldLS07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIHdpbGwgbmVlZCB0aGUgaXRlbXMgYWZ0ZXIgaXQgYW5kIGxvd2VyIHRoZWlyIGluZGV4ZXMuXG5cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0ICAgIC8qKlxuICAgICAgICAgICAgKiBUb2dnbGVzIHRoZSBwYXNzZWQgdmFsdWUgcHJlc2VuY2UgaW4gdGhlIGxpc3Q6IGlmIHRoZSB2YWx1ZSBhbHJlYWR5IGV4aXN0cyB0aGVuIHJlbW92ZXMgaXQsIG9yIGFkZHMgdGhlIHZhbHVlIG9uIG90aGVyIGNhc2UuXG4gICAgICAgICAgICAqIEBmdW5jXG4gICAgICAgICAgICAqIEBhbGlhcyB0b2dnbGVcbiAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAgICAgICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29yZS9qc2d1aS1kYXRhLXN0cnVjdHVyZXMuT3JkZXJlZF9TdHJpbmdfTGlzdFxuICAgICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICAgICovXG5cdFx0XHR0aGlzLnRvZ2dsZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdFx0XHRpZiAodGhpcy5oYXModmFsdWUpKSB7XG5cdFx0XHRcdFx0dGhpcy5vdXQodmFsdWUpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMucHV0KHZhbHVlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0ICAgIC8qKlxuICAgICAgICAgICAgKiBUb2dnbGVzIHRoZSBwYXNzZWQgdmFsdWUgdG8gdGhlIHNwZWNpZmllZCBwb3NpdGlvbiBpbiB0aGUgbGlzdC4gRG9lcyBub3RoaW5nIGlmIHRoZSB2YWx1ZSBkb2VzIG5vdCBleGlzdHMgaW4gdGhlIGxpc3QuXG4gICAgICAgICAgICAqIEBmdW5jXG4gICAgICAgICAgICAqIEBhbGlhcyBtb3ZlX3ZhbHVlXG4gICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSBuZXcgaW5kZXggZm9yIHRoZSB2YWx1ZSAoemVyby1iYXNlZClcbiAgICAgICAgICAgICogQG1lbWJlcm9mIG1vZHVsZTpjb3JlL2pzZ3VpLWRhdGEtc3RydWN0dXJlcy5PcmRlcmVkX1N0cmluZ19MaXN0XG4gICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgICAgKiB2YXIgbGlzdCA9IG5ldyBEYXRhX1N0cnVjdHVyZXMuT3JkZXJlZF9TdHJpbmdfTGlzdChcInYwIHYxIHYyXCIpO1xuICAgICAgICAgICAgKiBsaXN0Lm1vdmVfdmFsdWUoXCJ2MFwiLCAxKTtcbiAgICAgICAgICAgICogY29uc29sZS5sb2cobGlzdC50b1N0cmluZygpKTsgLy8gXCJ2MSB2MCB2MlwiXG4gICAgICAgICAgICAqL1xuXHRcdFx0dGhpcy5tb3ZlX3ZhbHVlID0gZnVuY3Rpb24gKHZhbHVlLCBpbmRleCkge1xuXHRcdFx0XHRpZiAodGhpcy5oYXModmFsdWUpICYmIGRpY3RfaW5kZXhlc1t2YWx1ZV0gIT0gaW5kZXgpIHtcblxuXHRcdFx0XHRcdC8vIGdldHMgcmVtb3ZlZCBmcm9tIGN1cnJlbnQgcG9zaXRpb24sIGNhdXNlcyBpdGVtcyBhZnRlciBpdFxuXHRcdFx0XHRcdC8vIHRvIG1vdmUgYmFjay5cblx0XHRcdFx0XHQvLyBnZXRzIHB1dCBpbiBuZXcgcG9zaXRpb24sIGdldHMgaXRlbXMgYWZ0ZXIgdGhhdCB0byBtb3ZlXG5cdFx0XHRcdFx0Ly8gZm9yd2FyZHMuXG5cblx0XHRcdFx0XHR2YXIgb2xkX2luZGV4ID0gZGljdF9pbmRleGVzW3ZhbHVlXTtcblx0XHRcdFx0XHRhcnIuc3BsaWNlKG9sZF9pbmRleCwgMSk7XG5cblx0XHRcdFx0XHRhcnIuc3BsaWNlKGluZGV4LCAwLCB2YWx1ZSk7XG5cblx0XHRcdFx0XHRpZiAoaW5kZXggPCBvbGRfaW5kZXgpIHtcblx0XHRcdFx0XHRcdC8vIG1vdmluZyBiYWNrLlxuXHRcdFx0XHRcdFx0Ly8gZGljdF9pbmRleGVzW11cblx0XHRcdFx0XHRcdGRpY3RfaW5kZXhlc1thcnJbaW5kZXhdXSA9IGluZGV4O1xuXHRcdFx0XHRcdFx0Ly8gdGhlIGluZGV4IG9iamVjdCBvZiB0aGUgb25lIGl0XG5cblx0XHRcdFx0XHRcdC8vIGZvciAodmFyIGMgPSBpbmRleCwgbCA9IGFyci5sZW5ndGg7IGMgPCBsOyBjKyspIHtcblx0XHRcdFx0XHRcdGZvciAoIHZhciBjID0gaW5kZXggKyAxOyBjIDw9IG9sZF9pbmRleDsgYysrKSB7XG5cdFx0XHRcdFx0XHRcdGRpY3RfaW5kZXhlc1thcnJbY11dKys7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChpbmRleCA+IG9sZF9pbmRleCkge1xuXHRcdFx0XHRcdFx0ZGljdF9pbmRleGVzW2FycltpbmRleF1dID0gaW5kZXg7XG5cdFx0XHRcdFx0XHRmb3IgKCB2YXIgYyA9IG9sZF9pbmRleDsgYyA8IGluZGV4OyBjKyspIHtcblx0XHRcdFx0XHRcdFx0ZGljdF9pbmRleGVzW2FycltjXV0tLTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cdFx0XHQvLyBmb3IgdGVzdGluZ1xuXG5cdFx0XHR0aGlzLl9pbmRleF9zY2FuID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGZvciAoIHZhciBjID0gMCwgbCA9IGFyci5sZW5ndGg7IGMgPCBsOyBjKyspIHtcblx0XHRcdFx0XHRjb25zb2xlLmxvZygnYyAnICsgYyArICcgYXJyW2NdICcgKyBhcnJbY10gKyAnIGlkeCAnXG5cdFx0XHRcdFx0XHRcdCsgZGljdF9pbmRleGVzW2FycltjXV0pO1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXG5cdFx0ICAgIC8qKlxuICAgICAgICAgICAgKiBSZXR1cm5zIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGxpc3Q6IGFsbCB0aGUgc3RyaW5nIHZhbHVlcyBzZXBhcmF0ZWQgYnkgc3BhY2UuXG4gICAgICAgICAgICAqIEBmdW5jXG4gICAgICAgICAgICAqIEBhbGlhcyB0b1N0cmluZ1xuICAgICAgICAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvcmUvanNndWktZGF0YS1zdHJ1Y3R1cmVzLk9yZGVyZWRfU3RyaW5nX0xpc3RcbiAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAqL1xuXHRcdFx0dGhpcy50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0dmFyIHJlcyA9IGFyci5qb2luKCcgJyk7XG5cdFx0XHRcdHJldHVybiByZXM7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMudG9TdHJpbmcuc3RyaW5naWZ5ID0gdHJ1ZTtcblxuXHRcdCAgICAvKipcbiAgICAgICAgICAgICogU2V0cyB0aGUgdmFsdWVzIGluIHRoZSBsaXN0LlxuICAgICAgICAgICAgKiBAZnVuY1xuICAgICAgICAgICAgKiBAYWxpYXMgc2V0XG4gICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZXMgLSBzcGFjZS1zZXBhcmF0ZWQgbGlzdCBvZiB2YWx1ZXNcbiAgICAgICAgICAgICogQG1lbWJlcm9mIG1vZHVsZTpjb3JlL2pzZ3VpLWRhdGEtc3RydWN0dXJlcy5PcmRlcmVkX1N0cmluZ19MaXN0XG4gICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAgKi9cblx0XHRcdHRoaXMuc2V0ID0gZnAoZnVuY3Rpb24gKGEsIHNpZykge1xuXHRcdFx0XHRpZiAoc2lnID09ICdbc10nKSB7XG5cdFx0XHRcdFx0YXJyID0gYVswXS5zcGxpdCgnICcpO1xuXHRcdFx0XHRcdC8vIGNvbnNvbGUubG9nKCdhcnIgJyArIGpzZ3VpLnN0cmluZ2lmeShhcnIpKTtcblx0XHRcdFx0XHRyZWluZGV4X2RpY3RfaW5kZXhlcygpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gaWYgKHNpZyA9PSAnW3NdJykge1xuXHRcdFx0Ly8gdGhpcy5zZXQoYVswXSk7XG5cdFx0XHQvLyB9XG5cblx0XHRcdHZhciBhID0gYXJndW1lbnRzO1xuXHRcdFx0aWYgKGEubGVuZ3RoID09IDEpIHtcblx0XHRcdFx0dmFyIHNwZWMgPSBhWzBdO1xuXHRcdFx0XHRpZiAodG9mKHNwZWMpID09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdFx0Ly8gY29uc29sZS5sb2coJ3NldHRpbmcnKTtcblx0XHRcdFx0XHR0aGlzLnNldChzcGVjKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0fVxuXHR9KTtcblxuXHRcblx0XG5cdHZhciBEYXRhX1N0cnVjdHVyZXMgPSB7XG5cdFx0J0RvdWJseV9MaW5rZWRfTGlzdCc6IERvdWJseV9MaW5rZWRfTGlzdCxcblx0XHQnQl9QbHVzX1RyZWUnOiBCX1BsdXNfVHJlZSxcblx0XHQnU29ydGVkX0tWUyc6IFNvcnRlZF9LVlMsXG5cdFx0J09yZGVyZWRfS1ZTJzogT3JkZXJlZF9LVlMsXG5cdFx0J09yZGVyZWRfU3RyaW5nX0xpc3QnOiBPcmRlcmVkX1N0cmluZ19MaXN0XG5cdFx0Ly8nU29ydGVkX0tWU19DdXJzb3InOiBTb3J0ZWRfS1ZTX0N1cnNvclxuXHR9XG5cdFxuXG5cdC8vIHZhciBqc2d1aSA9IHt9O1xuXHQvLyBhbGVydCgncmV0dXJuaW5nIGpzZ3VpIGZyb20ganNndWktbGFuZycpO1xuXHQvL3JldHVybiBqc2d1aTtcblx0XG5cdC8vIG1heWJlIHNob3VsZCBtaXggdGhlIGRhdGEgc3RydWN0dXJlcyBpbnRvIGpzZ3VpLlxuXHQvLyAgVGhlc2UgZGF0YSBzdHJ1Y3R1cmVzIGFyZSBsaWtlbHkgdG8gYmUgbmVjZXNzYXJ5IGZvciB2YXJpb3VzIHRoaW5nc1xuXHRcblx0XG5cdFxuXHRcblx0XG5cdC8vcmV0dXJuIERhdGFfU3RydWN0dXJlcztcbiAgICBtb2R1bGUuZXhwb3J0cyA9IERhdGFfU3RydWN0dXJlcztcbi8vfSk7IiwiLy8gVGhpcyBpcyByZXN1bHRpbmcgaW4gc21hbGxlciBjb2RlIGluIG90aGVyIHBhcnRzIG9mIHRoZSBmcmFtZXdvcmsuXG4vLyAgVGhpcyBzZWN0aW9uIGlzIGdldHRpbmcgcXVpdGUgYmlnIChhZ2Fpbilcbi8vICBTdGlsbCBuZWVkIHRvIG1ha2UgdXNlIG9mIHRoZSBCKyBmcmVlIGZvciBvcmRlcmVkIGluZGV4aW5nLlxuXG4vLyBNb3Zpbmcgc29tZSBjb2RlIHRvIGpzZ3VpLWxhbmctZXNzZW50aWFsc1xuLy8gIFdpbGwgYmUgcHVibGlzaGluZyBhIDAuNCB2ZXJzaW9uIG9mIHRoYXQgYmVmb3JlIHNvIGxvbmc/XG4vLyAgIE1heWJlIHdpdGggbW9yZSBleHBsYW5hdGlvbj9cblxuLy8gSXQgbWF5IGJlIHdvcnRoIHB1Ymxpc2hpbmcgdGhpcywgYW5kIGEgZGlzY3Vzc2lvbiBmb3J1bSBhYm91dCBpdCBvbiBteSBvd24gd2ViIGZvcnVtLlxuLy8gIFBlcmhhcHMgdGhhdCBjb3VsZCBjb21lIGxhdGVyLCBidXQganNndWktbGFuZy1lc3NlbnRpYWxzIG1heSBiZSBhIGdvb2Qgc3RlcC4gQ291bGQgY2FsbCBpdCB2ZXJzaW9uIDAuMzUuXG4vLyAgIENvdWxkIGhhdmUgYSBmZXcgZXhhbXBsZXNcbi8vICAgV291bGQgYmUgYSB1c2VmdWwgdG9vbGtpdCBJIGNvdWxkIHVzZSB3aGlsZSB3b3JraW5nIGVsc2V3aGVyZS5cblxuLy8gIEkgdGhpbmsgdGhhdCB3ZWIgc2l0ZSB3b3VsZCBiZSBsaWdodGVuaW5nIGZhc3QsIGFuZCBpbXByZXNzIHBlb3BsZSB3aXRoIGl0cyBzcGVlZCBjb21wYXJlZCB0byBvdGhlciB3ZWIgcGxhdGZvcm1zIHRoYXQgdGhleSBhcmUgdXNlZCB0b1xuLy8gICAodGhvdWdoIEZhY2Vib29rIGlzIE9LKVxuXG4vLyBUaGlzIGlzIGdvaW5nIHRvIGJlIHVzaW5nIGRhdGFfdHlwZXMgYXMgd2VsbC5cbi8vIFdpbGwgYWxzbyBoYXZlIGEgc3lzdGVtIG9mIHJlcXVpcmVtZW50cy5cbi8vICBUaGF0IGNvdWxkIG1lYW4gdGhleSBuZWVkIHRvIGJlIGJvdGggdGhlIHJpZ2h0IGRhdGEgdHlwZSwgYXMgd2VsbCBhcyBoYXZpbmcgc29tZSBvdGhlciBzcGVjaWZpZWQgcHJvcGVydGllcy5cblxuLypcbmlmICh0eXBlb2YgZGVmaW5lICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIGRlZmluZSA9IHJlcXVpcmUoJ2FtZGVmaW5lJykobW9kdWxlKTtcbn1cblxuZGVmaW5lKFtcIi4vanNndWktbGFuZy11dGlsXCIsIFwiLi9lbmhhbmNlZC1kYXRhLW9iamVjdFwiXSwgZnVuY3Rpb24oanNndWksIEVuaGFuY2VkX0RhdGFfT2JqZWN0KSB7XG5cbiAgICAqL1xudmFyIGpzZ3VpID0gcmVxdWlyZSgnLi9qc2d1aS1sYW5nLXV0aWwnKTtcbnZhciBFbmhhbmNlZF9EYXRhX09iamVjdCA9IHJlcXVpcmUoJy4vZW5oYW5jZWQtZGF0YS1vYmplY3QnKTtcblx0XG5cdC8vIFdpbGwgdXNlIGRhdGEgc3RydWN0dXJlcy5cblx0Ly8gIE5vdCBzdXJlIGFib3V0IHVzaW5nIGFsbCBvZiB0aGVtIGhlcmUuXG5cdFxuXHQvLyBBIG1peC1pbiBzeXN0ZW0gb2YgZW5oYW5jaW5nIHRoZSBkYXRhIHN0cnVjdHVyZXMgbWF5IHdvcmsgYmVzdC5cblx0Ly8gIEl0IGRvZXMgbm90IHN0YXJ0IHdpdGggQisgdHJlZSwgYnV0IHRoYXQgZ2V0cyBicm91Z2h0IGluP1xuXHRcblx0Ly8gSG93ZXZlciwgaGF2aW5nIEIrIGFzIHBhcnQgb2YgaXQgY291bGQgd29yayBxdWl0ZSBuaWNlbHkuXG5cdHZhciB0b2YgPSBqc2d1aS50b2Y7XG5cdHZhciBDb2xsZWN0aW9uID0ganNndWkuQ29sbGVjdGlvbjtcblx0dmFyIERhdGFfVmFsdWUgPSBqc2d1aS5EYXRhX1ZhbHVlO1xuXG5cdGpzZ3VpLkVuaGFuY2VkX0RhdGFfT2JqZWN0ID0gRW5oYW5jZWRfRGF0YV9PYmplY3Q7XG5cblx0Ly8gTm90IHN1cmUgYWJvdXQgdGhpcyBmb3IgdGhlIG1vbWVudC5cblx0Ly8gIFF1aXRlIGEgbG90IGlzIGdvaW5nIGluIGxhbmctdXRpbC5cblx0Ly9qc2d1aS5tYXBfZGF0YV90eXBlX2RhdGFfb2JqZWN0X2NvbnN0cnVjdG9ycyA9IEVuaGFuY2VkX0RhdGFfT2JqZWN0Lm1hcF9kYXRhX3R5cGVfZGF0YV9vYmplY3RfY29uc3RydWN0b3JzO1xuXG5cdGpzZ3VpLk1pbmlfQ29udGV4dCA9IEVuaGFuY2VkX0RhdGFfT2JqZWN0Lk1pbmlfQ29udGV4dDtcblxuXHQvLyBNYXliZSBjYW4gZ2l2ZSBhIGNvbnRleHQgYXMgd2VsbD9cblxuXHR2YXIgZnJvbU9iamVjdCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0dmFyIHRWYWx1ZSA9IHRvZih2YWx1ZSk7XG5cdFx0aWYgKHRWYWx1ZSA9PSAnYXJyYXknKSB7XG5cdFx0XHR2YXIgY29sbFJlcyA9IG5ldyBDb2xsZWN0aW9uKCk7XG5cblx0XHRcdGZvciAodmFyIGMgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBjIDwgbDsgYysrKSB7XG5cdFx0XHRcdGNvbGxSZXMucHVzaChmcm9tT2JqZWN0KHZhbHVlW2NdKSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gY29sbFJlcztcblxuXHRcdH1cblx0XHRpZiAodFZhbHVlID09ICdvYmplY3QnKSB7XG5cdFx0XHR2YXIgZWRvUmVzID0gbmV3IEVuaGFuY2VkX0RhdGFfT2JqZWN0KCk7XG5cdFx0XHRmb3IgKGkgaW4gdmFsdWUpIHtcblx0XHRcdFx0ZWRvUmVzLnNldChpLCBmcm9tT2JqZWN0KHZhbHVlW2ldKSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZWRvUmVzO1xuXHRcdH1cblx0XHRpZiAodFZhbHVlID09ICdzdHJpbmcnKSB7XG5cdFx0XHR2YXIgZHZSZXMgPSBuZXcgRGF0YV9WYWx1ZSh7J3ZhbHVlJzogdmFsdWV9KTtcblx0XHRcdHJldHVybiBkdlJlcztcblx0XHR9XG5cdFx0aWYgKHRWYWx1ZSA9PSAnbnVtYmVyJykge1xuXHRcdFx0dmFyIGR2UmVzID0gbmV3IERhdGFfVmFsdWUoeyd2YWx1ZSc6IHZhbHVlfSk7XG5cdFx0XHRyZXR1cm4gZHZSZXM7XG5cdFx0fVxuXG5cdH1cblxuXHRqc2d1aS5mcm9tT2JqZWN0ID0gZnJvbU9iamVjdDtcblx0XG4gICAgLy9FbmhhbmNlZF9EYXRhX09iamVjdC5wcm90b3R5cGUuX2dldF9pbnB1dF9wcm9jZXNzb3JzID0gZnVuY3Rpb24oKSB7XG4gICAgLy9cdHJldHVybiBqc2d1aS5pbnB1dF9wcm9jZXNzb3JzO1xuICAgIC8vfVxuICAgIG1vZHVsZS5leHBvcnRzID0ganNndWk7XG5cdC8vcmV0dXJuIGpzZ3VpO1xuXG4vL30pOyIsIlxyXG5cclxuICAgLyoqXHJcbiAgICAqIGxhbmcgZXNzZW50aWFscyBtb2R1bGUuXHJcbiAgICAqIEBtb2R1bGUgY29yZS9qc2d1aS1sYW5nLWVzc2VudGlhbHNcclxuICAgICogQHZlcnNpb24gMC40LjRcclxuICAgICovXHJcblxyXG4vKiBDaGFuZ2Vsb2c6XHJcblxyXG5cdDAuNC40XHJcblx0LS0tLS1cclxuXHRSZW1vdmVkIGV4Y2VzcyBjb21tZW50cywgaW5sY3VkaW5nIHVudXNlZCBjb21tZW50ZWQtb3V0IGNvZGVcclxuXHJcblx0MC40LjNcclxuXHQtLS0tLVxyXG5cdEFkZGVkIGNvbW1lbnQgYWJvdXQgY2hhbmdpbmcgYXJyX2xpa2VfdG9fYXJyXHJcblxyXG5cdDAuNC4yXHJcblx0LS0tLS1cclxuXHJcblx0UGVyZm9ybWFuY2UgaW1wcm92ZW1lbnRzLCBiYXNlZCBvbiBwcm9maWxpbmdcclxuXHRpc0FycmF5IHVzZXMgQXJyYXkuaXNBcnJheSBpZiBhdmFpbGFibGVcclxuXHJcblxyXG4qL1xyXG5cclxuLypcclxuaWYgKHR5cGVvZiBkZWZpbmUgIT09ICdmdW5jdGlvbicpIHtcclxuICAgIHZhciBkZWZpbmUgPSByZXF1aXJlKCdhbWRlZmluZScpKG1vZHVsZSk7XHJcbn1cclxuKi9cclxuXHJcbmlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgLy9leHBvcnRzLmZvbyA9IHt9O1xyXG4gICAgdmFyIFN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xyXG59IGVsc2Uge1xyXG4gICAgLy93aW5kb3cuZm9vID0ge307XHJcbn1cclxuXHJcblxyXG4vLyBuZWVkcyB0byB1c2Ugbm9kZS5qcydzIHN0cmVhbSBmb3IgdGhlIG1vbWVudC5cclxuLy8gV2lsbCBtYWtlIGEgbmV3IGpzZ3VpLW5vZGUtbGFuZy1lc3NlbnRpYWxzIHZlcnNpb24gYmVjYXVzZSBpdCdzIGdvdCBub2RlLXNwZWNpZmljICYgZGVwZW5kYW50IGNvZGUgbm93LlxyXG5cclxuLy9kZWZpbmUoWydTdHJlYW0nXSxcclxuLy9mdW5jdGlvbiAoU3RyZWFtKSB7XHJcblxyXG5cclxuLy9kZWZpbmUoZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgIC8vICAgICAgICAgICAgICAgICAgICAgIENsYXNzXHJcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuICAgIC8vIHNlZW1zIGJhc2VkIG9uIGh0dHA6Ly9lam9obi5vcmcvYmxvZy9zaW1wbGUtamF2YXNjcmlwdC1pbmhlcml0YW5jZS9cclxuXHJcbiAgICAvKipcclxuICAgICogQmFzZSBjbGFzcyBsaWtlIEpvaG4gUmVzaWcncyBcIlNpbXBsZSBKYXZhU2NyaXB0IEluaGVyaXRhbmNlXCIgdGVobmlxdWUuXHJcbiAgICAqXHJcbiAgICAqIEluIGFkZGl0aW9uLCB3aGVuIHRoZSBpbmhlcml0ZWQgY2xhc3MgY29udGFpbnMgYSBwcm9wZXJ0eSB0aGF0IG5hbWUgc3RhcnRzIGZyb20gJyMnLFxyXG4gICAgKiB0aGVuIHRoZSBwcm9wZXJ0eSBhZGRzIHRvIHRoZSBjbGFzcyB3aXRob3V0ICcjJywgYW5kIHRoZSBwcm9wZXJ0eSB2YWx1ZSBpcyB0aGUgYmFzZSBjbGFzcyBwcm9wZXJ0eSB2YWx1ZSxcclxuICAgICogYnV0IHRoZSBiYXNlIGNsYXNzIHByb3BlcnR5IG5hbWUgdXNlZCBpcyB0aGUgcmVzdCBvZiB0aGUgaW5pdGlhbCBwcm9wZXJ0eSBuYW1lIChhZnRlciB0aGUgJyMnKS5cclxuICAgICogQHNlZSBbSm9obiBSZXNpZydzIFwiU2ltcGxlIEphdmFTY3JpcHQgSW5oZXJpdGFuY2VcIl17QGxpbmsgaHR0cDovL2Vqb2huLm9yZy9ibG9nL3NpbXBsZS1qYXZhc2NyaXB0LWluaGVyaXRhbmNlL31cclxuICAgICogQG5hbWUgQ2xhc3NcclxuICAgICogQG1lbWJlclxyXG4gICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvcmUvanNndWktbGFuZy1lc3NlbnRpYWxzXHJcbiAgICAqL1xyXG5cclxuXHJcblx0dmFyIGluaXRpYWxpemluZyA9IGZhbHNlLCBmblRlc3QgPSAveHl6Ly50ZXN0KGZ1bmN0aW9uKCkgeyB4eXo7IH0pID8gL1xcYl9zdXBlclxcYi8gOiAvLiovO1xyXG5cdHZhciBDbGFzcyA9IGZ1bmN0aW9uKCkge1xyXG5cdH07XHJcblxyXG5cdC8vIG5vdCBzbyBzdXJlIG9mIHRoZSB1dGlsaXR5IG9mIG5hbWVzcGNFeHRlbnNpb24sIHByb3BzVG9NZXJnZVxyXG5cdENsYXNzLmV4dGVuZCA9IGZ1bmN0aW9uKHByb3ApIHtcclxuXHRcdHZhciBfc3VwZXIgPSB0aGlzLnByb3RvdHlwZTtcclxuXHRcdGluaXRpYWxpemluZyA9IHRydWU7XHJcblx0XHR2YXIgcHJvdG90eXBlID0gbmV3IHRoaXMoKTtcclxuXHRcdGluaXRpYWxpemluZyA9IGZhbHNlO1xyXG5cdFx0Zm9yICh2YXIgbmFtZSBpbiBwcm9wKSB7XHJcblx0XHRcdGlmIChuYW1lLmNoYXJBdCgwKSA9PT0gJyMnKSB7XHJcblx0XHRcdFx0cHJvdG90eXBlW25hbWUuc3Vic3RyaW5nKDEpXSA9IHByb3RvdHlwZVtwcm9wW25hbWVdXTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRwcm90b3R5cGVbbmFtZV0gPSB0eXBlb2YgcHJvcFtuYW1lXSA9PT0gJ2Z1bmN0aW9uJ1xyXG5cdFx0XHRcdFx0XHQmJiB0eXBlb2YgX3N1cGVyW25hbWVdID09PSAnZnVuY3Rpb24nXHJcblx0XHRcdFx0XHRcdCYmIGZuVGVzdC50ZXN0KHByb3BbbmFtZV0pID9cclxuXHRcdFx0XHQvLyBoYWQgc29tZSBkaWZmaWN1bHR5IHVzaW5nIGZwKCkgd2l0aCAnaW5pdCcgZnVuY3Rpb25zLiBjb3VsZFxyXG5cdFx0XHRcdC8vIGl0IGhhdmUgdG8gZG8gd2l0aCBmdW5jdGlvbiBuYW1lcz9cclxuXHJcblx0XHRcdFx0KGZ1bmN0aW9uKG5hbWUsIGZuKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHRcdHZhciB0bXAgPSB0aGlzLl9zdXBlcjtcclxuXHRcdFx0XHRcdFx0dGhpcy5fc3VwZXIgPSBfc3VwZXJbbmFtZV07XHJcblx0XHRcdFx0XHRcdHZhciByZXMgPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG5cdFx0XHRcdFx0XHR0aGlzLl9zdXBlciA9IHRtcDtcclxuXHRcdFx0XHRcdFx0cmV0dXJuIHJlcztcclxuXHRcdFx0XHRcdH07XHJcblx0XHRcdFx0fSkobmFtZSwgcHJvcFtuYW1lXSkgOiBwcm9wW25hbWVdO1xyXG5cdFx0XHR9O1xyXG5cdFx0fTtcclxuXHRcdGZ1bmN0aW9uIENsYXNzKCkge1xyXG5cdFx0XHQvL2NvbnNvbGUubG9nKCdpbml0aWFsaXppbmcgJyArIGluaXRpYWxpemluZyk7XHJcblx0XHRcdC8vY29uc29sZS5sb2coJyEhdGhpcy5pbml0ICcgKyAhIXRoaXMuaW5pdCk7XHJcblx0XHRcdGlmICghaW5pdGlhbGl6aW5nICYmIHRoaXMuaW5pdCkge1xyXG5cdFx0XHRcdHRoaXMuaW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG5cdFx0XHRcdC8vaWYgKHRoaXMucG9zdF9pbml0KSB7XHJcblx0XHRcdFx0Ly9cdHRoaXMucG9zdF9pbml0KCk7XHJcblx0XHRcdFx0Ly99XHJcblx0XHRcdH1cclxuXHRcdH07XHJcblx0XHRDbGFzcy5wcm90b3R5cGUgPSBwcm90b3R5cGU7XHJcblx0XHRDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDbGFzcztcclxuXHRcdC8vQ2xhc3MuY29uc3RydWN0b3IgPSBDbGFzcztcclxuXHRcdENsYXNzLmV4dGVuZCA9IGFyZ3VtZW50cy5jYWxsZWU7XHJcblx0XHQvL0NsYXNzLl9zdXBlcmNsYXNzID0gX3N1cGVyO1xyXG5cclxuXHRcdENsYXNzLl9zdXBlcmNsYXNzID0gdGhpcztcclxuXHJcblx0XHRyZXR1cm4gQ2xhc3M7XHJcblx0fTtcclxuXHJcblxyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgIC8vICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uc1xyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBCcmVhayBpdGVyYXRpb24gY2FsbGJhY2sgZnVuY3Rpb24uXHJcbiAgICAqIEBleGFtcGxlXHJcbiAgICAqIGpzZ3VpLmVhY2goWzEsIDIsIDMsIDQsIDVdLCBmdW5jdGlvbihpbmRleCwgZWxlbWVudCwgc3RvcCl7XHJcbiAgICAqICAgIGlmIChlbGVtZW50ID4gMykgc3RvcCgpO1xyXG4gICAgKiB9KTtcclxuICAgICpcclxuICAgICoganNndWkuZWFjKFsxLCAyLCAzLCA0LCA1XSwgZnVuY3Rpb24oZWxlbWVudCwgaW5kZXgsIHN0b3Ape1xyXG4gICAgKiAgICBpZiAoZWxlbWVudCA+IDMpIHN0b3AoKTtcclxuICAgICogfSk7XHJcbiAgICAqXHJcbiAgICAqIEBjYWxsYmFjayBtb2R1bGU6Y29yZS9qc2d1aS1sYW5nLWVzc2VudGlhbHMuc3RvcEl0ZXJhdGlvbkNhbGxiYWNrXHJcbiAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBBcnJheSBpdGVyYXRvciBjYWxsYmFjayBmdW5jdGlvbi5cclxuICAgICpcclxuICAgICogQGNhbGxiYWNrIG1vZHVsZTpjb3JlL2pzZ3VpLWxhbmctZXNzZW50aWFscy5hcnJheUl0ZXJhdG9yQ2FsbGJhY2tcclxuICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XHJcbiAgICAqIEBwYXJhbSB7Kn0gZWxlbWVudFxyXG4gICAgKiBAcGFyYW0ge21vZHVsZTpjb3JlL2pzZ3VpLWxhbmctZXNzZW50aWFscy5zdG9wSXRlcmF0aW9uQ2FsbGJhY2t9IHN0b3BcclxuICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIE9iamVjdCBpdGVyYXRvciBjYWxsYmFjayBmdW5jdGlvbi5cclxuICAgICpcclxuICAgICogQGNhbGxiYWNrIG1vZHVsZTpjb3JlL2pzZ3VpLWxhbmctZXNzZW50aWFscy5vYmplY3RJdGVyYXRvckNhbGxiYWNrXHJcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcclxuICAgICogQHBhcmFtIHsqfSB2YWx1ZVxyXG4gICAgKiBAcGFyYW0ge21vZHVsZTpjb3JlL2pzZ3VpLWxhbmctZXNzZW50aWFscy5zdG9wSXRlcmF0aW9uQ2FsbGJhY2t9IHN0b3BcclxuICAgICovXHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBJdGVyYXRlcyBvdmVyIGEgY29sbGVjdGlvbiBjYWxsaW5nIHRoZSBjb2xsZWN0aW9uLmVhY2goZm4sIGNvbnRleHQpIG1ldGhvZC5cclxuICAgICpcclxuICAgICogQG5hbWUgZWFjaFxyXG4gICAgKiBAZnVuY1xyXG4gICAgKiBAcGFyYW0ge0NvbGxlY3Rpb259IGNvbGxlY3Rpb24gLSBjb2xsZWN0aW9uIG9mIGVsZW1lbnRzXHJcbiAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuIC0gaXRlcmF0b3IgZnVuY3Rpb25cclxuICAgICogQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0XSAtIGNvbnRleHQgb2JqZWN0XHJcbiAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29yZS9qc2d1aS1sYW5nLWVzc2VudGlhbHNcclxuICAgICogQGV4YW1wbGVcclxuICAgICpcclxuICAgICogLy8gVE9ETy4uLi4uLi4uLi4uLi4uXHJcbiAgICAqXHJcbiAgICAqL1xyXG5cclxuXHJcbiAgICAvKipcclxuICAgICogSXRlcmF0ZXMgb3ZlciB0aGUgYXJyYXkgZWxlbWVudHMuIFRoZSBpdGVyYXRvciBmdW5jdGlvbiBjYWxscyBmb3IgZWFjaCBlbGVtZW50OiBmbihpbmRleCwgZWxlbWVudCwgc3RvcCk6XHJcbiAgICAqIC0gaW5kZXg6IHRoZSBlbGVtZW50IGluZGV4XHJcbiAgICAqIC0gZWxlbWVudDogdGhlIGVsZW1lbnQgdmFsdWVcclxuICAgICogLSBzdG9wOiBjYWxsIHRoaXMgZnVuY3Rpb24gdG8gcHJldmVudCBmdXJ0aGVyIGl0ZXJhdGlvbnNcclxuICAgICpcclxuICAgICogVGhlIGl0ZXJhdG9yIGZ1bmN0aW9uIGlzIGJvdW5kIHRvIHRoZSBjb250ZXh0IG9iamVjdCwgaWYgcGFzc2VkLlxyXG4gICAgKlxyXG4gICAgKiBAbmFtZSBlYWNoXHJcbiAgICAqIEBmdW5jXHJcbiAgICAqIEBwYXJhbSB7QXJyYXl9IGFyciAtIGFycmF5IG9mIGVsZW1lbnRzXHJcbiAgICAqIEBwYXJhbSB7bW9kdWxlOmNvcmUvanNndWktbGFuZy1lc3NlbnRpYWxzLmFycmF5SXRlcmF0b3JDYWxsYmFja30gZm4gLSBpdGVyYXRvciBmdW5jdGlvblxyXG4gICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbnRleHRdIC0gY29udGV4dCBvYmplY3RcclxuICAgICogQG1lbWJlcm9mIG1vZHVsZTpjb3JlL2pzZ3VpLWxhbmctZXNzZW50aWFsc1xyXG4gICAgKiBAZXhhbXBsZVxyXG4gICAgKlxyXG4gICAgKiBqc2d1aS5lYWNoKFsxLCAyLCAzLCA0LCA1XSwgZnVuY3Rpb24oaW5kZXgsIGVsZW1lbnQsIHN0b3Ape1xyXG4gICAgKiAgICBjb25zb2xlLmxvZyhpbmRleCArIFwiOlwiICsgZWxlbWVudCk7ICAvLyAwOjEgMToyIDI6MyAzOjQgNDo1XHJcbiAgICAqICAgIGlmIChpbmRleCA+IDEwMDApIHN0b3AoKTtcclxuICAgICogfSk7XHJcbiAgICAqXHJcbiAgICAqL1xyXG5cclxuXHJcbiAgICAvKipcclxuICAgICogSXRlcmF0ZXMgb3ZlciB0aGUgb2JqZWN0IHByb3BlcnRpZXMuIFRoZSBpdGVyYXRvciBmdW5jdGlvbiBjYWxscyBmb3IgZWFjaCBlbGVtZW50OiBmbihrZXksIHZhbHVlLCBzdG9wKTpcclxuICAgICogLSBrZXk6IHRoZSBwcm9wZXJ0eSBrZXlcclxuICAgICogLSB2YWx1ZTogdGhlIHByb3BlcnR5IHZhbHVlXHJcbiAgICAqIC0gc3RvcDogY2FsbCB0aGlzIGZ1bmN0aW9uIHRvIHByZXZlbnQgZnVydGhlciBpdGVyYXRpb25zXHJcbiAgICAqXHJcbiAgICAqIFRoZSBpdGVyYXRvciBmdW5jdGlvbiBpcyBib3VuZCB0byB0aGUgY29udGV4dCBvYmplY3QsIGlmIHBhc3NlZC5cclxuICAgICpcclxuICAgICogQG5hbWUgZWFjaFxyXG4gICAgKiBAZnVuY1xyXG4gICAgKiBAcGFyYW0ge09iamVjdH0gb2JqIC0gb2JqZWN0XHJcbiAgICAqIEBwYXJhbSB7bW9kdWxlOmNvcmUvanNndWktbGFuZy1lc3NlbnRpYWxzLm9iamVjdEl0ZXJhdG9yQ2FsbGJhY2t9IGZuIC0gaXRlcmF0b3IgZnVuY3Rpb25cclxuICAgICogQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0XSAtIGNvbnRleHQgb2JqZWN0XHJcbiAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29yZS9qc2d1aS1sYW5nLWVzc2VudGlhbHNcclxuICAgICogQGV4YW1wbGVcclxuICAgICpcclxuICAgICoganNndWkuZWFjaCh7YTogMSwgYjogMn0sIGZ1bmN0aW9uKGtleSwgdmFsdWUsIHN0b3Ape1xyXG4gICAgKiAgICBpZiAoa2V5ID09IFwic2VjcmV0S2V5XCIpe1xyXG4gICAgKiAgICAgIHN0b3AoKTtcclxuICAgICogICAgICByZXR1cm47XHJcbiAgICAqICAgIH1cclxuICAgICogICAgY29uc29sZS5sb2coa2V5ICsgXCI6XCIgKyB2YWx1ZSk7ICAvLyBhOjEgIGI6MlxyXG4gICAgKiB9KTtcclxuICAgICpcclxuICAgICovXHJcblx0Ly8gbmV3IGFkZGl0aW9uIHdpdGggdGhlIGxvb3AgYmVpbmcgc3RvcHBhYmxlIHVzaW5nIGEgZnVuY3Rpb24gY2FsbC4gMTgvMDYvMjAxMlxyXG5cdHZhciBlYWNoID0gZnVuY3Rpb24oY29sbGVjdGlvbiwgZm4sIGNvbnRleHQpIHtcclxuXHRcdC8vIGVhY2ggdGhhdCBwdXRzIHRoZSByZXN1bHRzIGluIGFuIGFycmF5IG9yIGRpY3QuXHJcblx0XHRpZiAoY29sbGVjdGlvbikge1xyXG5cclxuXHRcdFx0aWYgKGNvbGxlY3Rpb24uX190eXBlID09ICdjb2xsZWN0aW9uJykge1xyXG5cdFx0XHRcdHJldHVybiBjb2xsZWN0aW9uLmVhY2goZm4sIGNvbnRleHQpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBjb3VsZCBoYXZlIGEgYnJlYWsgZnVuY3Rpb24gdGhhdCBzdG9wcyB0aGUgbG9vcCBmcm9tIGNvbnRpbnVpbmcuXHJcblx0XHRcdC8vICB0aGF0IHdvdWxkIGJlIHVzZWZ1bCBhcyBhIHRoaXJkIHBhcmFtZXRlciB0aGF0IGNhbiBnZXQgY2FsbGVkLlxyXG5cdFx0XHQvLyAgc3RvcCgpIGZ1bmN0aW9uXHJcblx0XHRcdHZhciBjdHUgPSB0cnVlO1xyXG5cdFx0XHR2YXIgc3RvcCA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdGN0dSA9IGZhbHNlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoaXNfYXJyYXkoY29sbGVjdGlvbikpIHtcclxuXHRcdFx0ICAgIHZhciByZXMgPSBbXSwgcmVzX2l0ZW07XHJcblx0XHRcdFx0Zm9yICh2YXIgYyA9IDAsIGwgPSBjb2xsZWN0aW9uLmxlbmd0aDsgYyA8IGw7IGMrKykge1xyXG5cdFx0XHRcdFx0cmVzX2l0ZW07XHJcblx0XHRcdFx0XHRpZiAoY3R1ID09IGZhbHNlKSBicmVhaztcclxuXHJcblx0XHRcdFx0XHRpZiAoY29udGV4dCkge1xyXG5cdFx0XHRcdFx0XHRyZXNfaXRlbSA9IGZuLmNhbGwoY29udGV4dCwgYywgY29sbGVjdGlvbltjXSwgc3RvcCk7XHJcblxyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0cmVzX2l0ZW0gPSBmbihjLCBjb2xsZWN0aW9uW2NdLCBzdG9wKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHJlcy5wdXNoKHJlc19pdGVtKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0cmV0dXJuIHJlcztcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR2YXIgbmFtZSwgcmVzID0ge307XHJcblx0XHRcdFx0Zm9yIChuYW1lIGluIGNvbGxlY3Rpb24pIHtcclxuXHRcdFx0XHRcdGlmIChjdHUgPT0gZmFsc2UpIGJyZWFrO1xyXG5cdFx0XHRcdFx0aWYgKGNvbnRleHQpIHtcclxuXHRcdFx0XHRcdCAgICByZXNbbmFtZV0gPSBmbi5jYWxsKGNvbnRleHQsIG5hbWUsIGNvbGxlY3Rpb25bbmFtZV0sIHN0b3ApO1xyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0cmVzW25hbWVdID0gZm4obmFtZSwgY29sbGVjdGlvbltuYW1lXSwgc3RvcCk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHJldHVybiByZXM7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcbiAgICAvKipcclxuICAgICogQXJyYXkgaXRlcmF0b3IgY2FsbGJhY2sgZnVuY3Rpb24uXHJcbiAgICAqXHJcbiAgICAqIEBjYWxsYmFjayBtb2R1bGU6Y29yZS9qc2d1aS1sYW5nLWVzc2VudGlhbHMuYXJyYXlJdGVyYXRvckNhbGxiYWNrLWVhY1xyXG4gICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcclxuICAgICogQHBhcmFtIHsqfSBlbGVtZW50XHJcbiAgICAqIEBwYXJhbSB7bW9kdWxlOmNvcmUvanNndWktbGFuZy1lc3NlbnRpYWxzLnN0b3BJdGVyYXRpb25DYWxsYmFja30gc3RvcFxyXG4gICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICogT2JqZWN0IGl0ZXJhdG9yIGNhbGxiYWNrIGZ1bmN0aW9uLlxyXG4gICAgKlxyXG4gICAgKiBAY2FsbGJhY2sgbW9kdWxlOmNvcmUvanNndWktbGFuZy1lc3NlbnRpYWxzLm9iamVjdEl0ZXJhdG9yQ2FsbGJhY2stZWFjXHJcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcclxuICAgICogQHBhcmFtIHsqfSB2YWx1ZVxyXG4gICAgKiBAcGFyYW0ge21vZHVsZTpjb3JlL2pzZ3VpLWxhbmctZXNzZW50aWFscy5zdG9wSXRlcmF0aW9uQ2FsbGJhY2t9IHN0b3BcclxuICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEl0ZXJhdGVzIG92ZXIgYSBjb2xsZWN0aW9uIGNhbGxpbmcgdGhlIGNvbGxlY3Rpb24uZWFjaChmbiwgY29udGV4dCkgbWV0aG9kLlxyXG4gICAgKlxyXG4gICAgKiA8bWFyaz5tYXliZSBjb2xsZWN0aW9uLmVhY2goKSBtdXN0IGJlIGNoYW5nZWQgdG8gY29sbGVjdGlvbi5lYWMoKT88L21hcms+XHJcbiAgICAqXHJcbiAgICAqIEBuYW1lIGVhY1xyXG4gICAgKiBAZnVuY1xyXG4gICAgKiBAcGFyYW0ge0NvbGxlY3Rpb259IGNvbGxlY3Rpb24gLSBjb2xsZWN0aW9uIG9mIGVsZW1lbnRzXHJcbiAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuIC0gaXRlcmF0b3IgZnVuY3Rpb25cclxuICAgICogQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0XSAtIGNvbnRleHQgb2JqZWN0XHJcbiAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29yZS9qc2d1aS1sYW5nLWVzc2VudGlhbHNcclxuICAgICogQGV4YW1wbGVcclxuICAgICpcclxuICAgICogLy8gVE9ETy4uLi4uLi5cclxuICAgICpcclxuICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEl0ZXJhdGVzIG92ZXIgYW4gYXJyYXksIGp1c3QgbGlrZSB0aGUgW2VhY2goKV17QGxpbmsgbW9kdWxlOmNvcmUvanNndWktbGFuZy1lc3NlbnRpYWxzLmVhY2h9IGZ1bmN0aW9uLCBidXQgdGhlIGl0ZXJhdG9yIGZ1bmN0aW9uIHBhcmFtZXRlcnMgb3JkZXIgaXMgY2hhbmdlZDo8YnI+XHJcbiAgICAqIGBmbihlbGVtZW50LCBpbmRleCwgc3RvcClgIGluc3RlYWQgb2YgYGZuKGluZGV4LCBlbGVtZW50LCBzdG9wKWBcclxuICAgICpcclxuICAgICogQmV0dGVyIGVhY2ggZnVuY3Rpb24sIGZpcnN0IHBhcmFtIG9mIGNhbGxiYWNrIGlzIG9iaiwgMm5kIGlzIGluZGV4LiBXaWxsIHJlcGxhY2UgYWxsIGVhY2ggZnVuY3Rpb25zIHdpdGggdGhpcyB2ZXJzaW9uIHRoZW4gY2hhbmdlIHRoZSBuYW1lIHRvIGVhY2guXHJcblx0KiAgVXNlZnVsIGZvciBuZXcgY29kZS5cclxuICAgICpcclxuICAgICogQG5hbWUgZWFjXHJcbiAgICAqIEBmdW5jXHJcbiAgICAqIEBwYXJhbSB7QXJyYXl9IGFyciAtIGFycmF5IG9mIGVsZW1lbnRzXHJcbiAgICAqIEBwYXJhbSB7bW9kdWxlOmNvcmUvanNndWktbGFuZy1lc3NlbnRpYWxzLmFycmF5SXRlcmF0b3JDYWxsYmFjay1lYWN9IGZuIC0gaXRlcmF0b3IgZnVuY3Rpb25cclxuICAgICogQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0XSAtIGNvbnRleHQgb2JqZWN0XHJcbiAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29yZS9qc2d1aS1sYW5nLWVzc2VudGlhbHNcclxuICAgICogQGV4YW1wbGVcclxuICAgICpcclxuICAgICoganNndWkuZWFjaChbMSwgMiwgMywgNCwgNV0sIGZ1bmN0aW9uKGVsZW1lbnQsIGluZGV4LCBzdG9wKXtcclxuICAgICogICAgY29uc29sZS5sb2coaW5kZXggKyBcIjpcIiArIGVsZW1lbnQpOyAgLy8gMDoxIDE6MiAyOjMgMzo0IDQ6NVxyXG4gICAgKiAgICBpZiAoaW5kZXggPiAxMDAwKSBzdG9wKCk7XHJcbiAgICAqIH0pO1xyXG4gICAgKlxyXG4gICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICogSXRlcmF0ZXMgb3ZlciB0aGUgb2JqZWN0IHByb3BlcnRpZXMsIGp1c3QgbGlrZSB0aGUgW2VhY2goKV17QGxpbmsgbW9kdWxlOmNvcmUvanNndWktbGFuZy1lc3NlbnRpYWxzLmVhY2h9IGZ1bmN0aW9uLCBidXQgdGhlIGl0ZXJhdG9yIGZ1bmN0aW9uIHBhcmFtZXRlcnMgb3JkZXIgaXMgY2hhbmdlZDo8YnIgLz5cclxuICAgICogYGZuKHZhbHVlLCBrZXksIHN0b3ApYCBpbnN0ZWFkIG9mIGBmbihrZXksIHZhbHVlLCBzdG9wKWBcclxuICAgICpcclxuICAgICogQmV0dGVyIGVhY2ggZnVuY3Rpb24sIGZpcnN0IHBhcmFtIG9mIGNhbGxiYWNrIGlzIG9iaiwgMm5kIGlzIGluZGV4LiBXaWxsIHJlcGxhY2UgYWxsIGVhY2ggZnVuY3Rpb25zIHdpdGggdGhpcyB2ZXJzaW9uIHRoZW4gY2hhbmdlIHRoZSBuYW1lIHRvIGVhY2guXHJcblx0KiAgVXNlZnVsIGZvciBuZXcgY29kZS5cclxuICAgICpcclxuICAgICogQG5hbWUgZWFjXHJcbiAgICAqIEBmdW5jXHJcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmogLSBvYmplY3RcclxuICAgICogQHBhcmFtIHttb2R1bGU6Y29yZS9qc2d1aS1sYW5nLWVzc2VudGlhbHMub2JqZWN0SXRlcmF0b3JDYWxsYmFjay1lYWN9IGZuIC0gaXRlcmF0b3IgZnVuY3Rpb25cclxuICAgICogQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0XSAtIGNvbnRleHQgb2JqZWN0XHJcbiAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29yZS9qc2d1aS1sYW5nLWVzc2VudGlhbHNcclxuICAgICogQGV4YW1wbGVcclxuICAgICpcclxuICAgICoganNndWkuZWFjKHthOiAxLCBiOiAyfSwgZnVuY3Rpb24odmFsdWUsIGtleSwgc3RvcCl7XHJcbiAgICAqICAgIGlmIChrZXkgPT0gXCJzZWNyZXRLZXlcIil7XHJcbiAgICAqICAgICAgc3RvcCgpO1xyXG4gICAgKiAgICAgIHJldHVybjtcclxuICAgICogICAgfVxyXG4gICAgKiAgICBjb25zb2xlLmxvZyhrZXkgKyBcIjpcIiArIHZhbHVlKTsgIC8vIGE6MSAgYjoyXHJcbiAgICAqIH0pO1xyXG4gICAgKlxyXG4gICAgKi9cclxuXHR2YXIgZWFjID0gZnVuY3Rpb24gKGNvbGxlY3Rpb24sIGZuLCBjb250ZXh0KSB7XHJcblx0XHQvLyBlYWNoIHRoYXQgcHV0cyB0aGUgcmVzdWx0cyBpbiBhbiBhcnJheSBvciBkaWN0LlxyXG5cdFx0aWYgKGNvbGxlY3Rpb24pIHtcclxuXHJcblx0XHRcdGlmIChjb2xsZWN0aW9uLl9fdHlwZSA9PSAnY29sbGVjdGlvbicpIHtcclxuXHRcdFx0XHRyZXR1cm4gY29sbGVjdGlvbi5lYWMoZm4sIGNvbnRleHQpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBjb3VsZCBoYXZlIGEgYnJlYWsgZnVuY3Rpb24gdGhhdCBzdG9wcyB0aGUgbG9vcCBmcm9tIGNvbnRpbnVpbmcuXHJcblx0XHRcdC8vICB0aGF0IHdvdWxkIGJlIHVzZWZ1bCBhcyBhIHRoaXJkIHBhcmFtZXRlciB0aGF0IGNhbiBnZXQgY2FsbGVkLlxyXG5cdFx0XHQvLyAgc3RvcCgpIGZ1bmN0aW9uXHJcblx0XHRcdHZhciBjdHUgPSB0cnVlO1xyXG5cdFx0XHR2YXIgc3RvcCA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdGN0dSA9IGZhbHNlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoaXNfYXJyYXkoY29sbGVjdGlvbikpIHtcclxuXHRcdFx0XHR2YXIgcmVzID0gW10sIHJlc19pdGVtO1xyXG5cdFx0XHRcdGZvciAodmFyIGMgPSAwLCBsID0gY29sbGVjdGlvbi5sZW5ndGg7IGMgPCBsOyBjKyspIHtcclxuXHRcdFx0XHRcdHJlc19pdGVtO1xyXG5cdFx0XHRcdFx0aWYgKGN0dSA9PSBmYWxzZSkgYnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0aWYgKGNvbnRleHQpIHtcclxuXHRcdFx0XHRcdFx0cmVzX2l0ZW0gPSBmbi5jYWxsKGNvbnRleHQsIGNvbGxlY3Rpb25bY10sIGMsIHN0b3ApO1xyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdHJlc19pdGVtID0gZm4oY29sbGVjdGlvbltjXSwgYywgc3RvcCk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRyZXMucHVzaChyZXNfaXRlbSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHJldHVybiByZXM7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dmFyIG5hbWUsIHJlcyA9IHt9O1xyXG5cdFx0XHRcdGZvciAobmFtZSBpbiBjb2xsZWN0aW9uKSB7XHJcblx0XHRcdFx0XHRpZiAoY3R1ID09IGZhbHNlKSBicmVhaztcclxuXHRcdFx0XHRcdGlmIChjb250ZXh0KSB7XHJcblx0XHRcdFx0XHRcdHJlc1tuYW1lXSA9IGZuLmNhbGwoY29udGV4dCwgY29sbGVjdGlvbltuYW1lXSwgbmFtZSwgc3RvcCk7XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRyZXNbbmFtZV0gPSBmbihjb2xsZWN0aW9uW25hbWVdLCBuYW1lLCBzdG9wKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0cmV0dXJuIHJlcztcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cclxuXHJcblx0dmFyIGpxX2NsYXNzMnR5cGUgPSB7fTtcclxuXHR2YXIganFfdHlwZSA9IGZ1bmN0aW9uIChvYmopIHtcclxuXHQgICAgLy9yZXR1cm4gb2JqID09IG51bGwgPyBTdHJpbmcob2JqKSA6IGpxX2NsYXNzMnR5cGVbdG9TdHJpbmcuY2FsbChvYmopXSB8fCBcIm9iamVjdFwiO1xyXG5cdCAgICBpZiAob2JqID09IG51bGwpIHJldHVybiBTdHJpbmcob2JqKTtcclxuXHQgICAgdmFyIHMgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKTtcclxuXHQgICAgcmV0dXJuIGpxX2NsYXNzMnR5cGVbc10gfHwgXCJvYmplY3RcIjtcclxuXHR9O1xyXG5cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBwYXNzZWQgYG9iamAgaXMgYW4gYEFycmF5YC4gRGVsZWdhdGVzIHRvIHRoZSBuYXRpdmUgYEFycmF5LmlzQXJyYXkoKWAgZnVuY3Rpb24gaWYgaXQgZXhpc3RzLlxyXG4gICAgKiBAZnVuY1xyXG4gICAgKiBAcGFyYW0ge09iamVjdH0gb2JqIC0gb2JqZWN0IHRvIGNoZWNrXHJcbiAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29yZS9qc2d1aS1sYW5nLWVzc2VudGlhbHNcclxuICAgICovXHJcblx0dmFyIGlzX2FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAob2JqKSB7XHJcblx0ICAgICAgICByZXR1cm4ganFfdHlwZShvYmopID09PSBcImFycmF5XCI7XHJcblx0fTtcclxuXHJcbiAgICAvKipcclxuICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHBhc3NlZCBgb2JqYCBpcyBhIERPTSBub2RlLiBVc2VzIHRoZSBkdWNrIHR5cGluZy5cclxuICAgICogQGZ1bmNcclxuICAgICogQHBhcmFtIHtPYmplY3R9IG9iaiAtIG9iamVjdCB0byBjaGVja1xyXG4gICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvcmUvanNndWktbGFuZy1lc3NlbnRpYWxzXHJcbiAgICAqL1xyXG4gICAgdmFyIGlzX2RvbV9ub2RlID0gZnVuY3Rpb24gaXNEb21Ob2RlKG9iaikge1xyXG5cdFx0cmV0dXJuICghIW9iaiAmJiB0eXBlb2Ygb2JqLm5vZGVUeXBlICE9ICd1bmRlZmluZWQnICYmIHR5cGVvZiBvYmouY2hpbGROb2RlcyAhPSAndW5kZWZpbmVkJyk7XHJcblx0fTtcclxuXHJcblxyXG4gICAganFfY2xhc3MydHlwZVtcIltvYmplY3QgQm9vbGVhbl1cIl0gPSBcImJvb2xlYW5cIjtcclxuICAgIGpxX2NsYXNzMnR5cGVbXCJbb2JqZWN0IE51bWJlcl1cIl0gPSBcIm51bWJlclwiO1xyXG4gICAganFfY2xhc3MydHlwZVtcIltvYmplY3QgU3RyaW5nXVwiXSA9IFwic3RyaW5nXCI7XHJcbiAgICBqcV9jbGFzczJ0eXBlW1wiW29iamVjdCBGdW5jdGlvbl1cIl0gPSBcImZ1bmN0aW9uXCI7XHJcbiAgICBqcV9jbGFzczJ0eXBlW1wiW29iamVjdCBBcnJheV1cIl0gPSBcImFycmF5XCI7XHJcbiAgICBqcV9jbGFzczJ0eXBlW1wiW29iamVjdCBEYXRlXVwiXSA9IFwiZGF0ZVwiO1xyXG4gICAganFfY2xhc3MydHlwZVtcIltvYmplY3QgUmVnRXhwXVwiXSA9IFwicmVnZXhwXCI7XHJcbiAgICBqcV9jbGFzczJ0eXBlW1wiW29iamVjdCBPYmplY3RdXCJdID0gXCJvYmplY3RcIjtcclxuXHJcbiAgICAvKiBlYWNoKCkgY2FsbHMgaXNBcnJheSgpLCBpc0FycmF5KCkgY2FsbHMganFfdHlwZSgpLCBqcV90eXBlKCkgdXNlcyBqcV9jbGFzczJ0eXBlW10gaW4gdHVyblxyXG4gICAgZWFjaChcIkJvb2xlYW4gTnVtYmVyIFN0cmluZyBGdW5jdGlvbiBBcnJheSBEYXRlIFJlZ0V4cCBPYmplY3RcIi5zcGxpdChcIiBcIiksXHJcblx0XHRmdW5jdGlvbihpLCBuYW1lKSB7XHJcblx0XHRcdGlmICh0eXBlb2YobmFtZSkgPT0gJ3N0cmluZycpIHtcclxuXHRcdCAgICAgICAganFfY2xhc3MydHlwZVtcIltvYmplY3QgXCIgKyBuYW1lICsgXCJdXCJdID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xyXG5cdFx0ICAgIH1cclxuXHRcdH0pOyovXHJcblxyXG5cdC8qXHJcblx0ICogdmFyIGpxX3R5cGUgPSBmdW5jdGlvbiggb2JqICkgeyByZXR1cm4gb2JqID09IG51bGwgPyBTdHJpbmcob2JqKTpcclxuXHQgKiBqcV9jbGFzczJ0eXBlW3RvU3RyaW5nLmNhbGwob2JqKV0gfHwgXCJvYmplY3RcIjsgfTtcclxuXHQgKi9cclxuXHJcblx0dmFyIGpxX2lzRnVuY3Rpb24gPSBmdW5jdGlvbihvYmopIHtcclxuXHRcdHJldHVybiBqcV90eXBlKG9iaikgPT09IFwiZnVuY3Rpb25cIjtcclxuXHR9O1xyXG5cclxuXHR2YXIganFfaXNXaW5kb3cgPSBmdW5jdGlvbihvYmopIHtcclxuXHRcdHJldHVybiBvYmogJiYgdHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIiAmJiBcInNldEludGVydmFsXCIgaW4gb2JqO1xyXG5cdH07XHJcblxyXG5cdHZhciBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xyXG5cclxuXHR2YXIganFfaXNQbGFpbk9iamVjdCA9IGZ1bmN0aW9uKG9iaikge1xyXG5cdFx0Ly8gTXVzdCBiZSBhbiBPYmplY3QuXHJcblx0XHQvLyBCZWNhdXNlIG9mIElFLCB3ZSBhbHNvIGhhdmUgdG8gY2hlY2sgdGhlIHByZXNlbmNlIG9mIHRoZSBjb25zdHJ1Y3RvclxyXG5cdFx0Ly8gcHJvcGVydHkuXHJcblx0XHQvLyBNYWtlIHN1cmUgdGhhdCBET00gbm9kZXMgYW5kIHdpbmRvdyBvYmplY3RzIGRvbid0IHBhc3MgdGhyb3VnaCwgYXNcclxuXHRcdC8vIHdlbGxcclxuXHRcdGlmICghb2JqIHx8IGpxX3R5cGUob2JqKSAhPT0gXCJvYmplY3RcIiB8fCBvYmoubm9kZVR5cGVcclxuXHRcdFx0XHR8fCBqcV9pc1dpbmRvdyhvYmopKSB7XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBOb3Qgb3duIGNvbnN0cnVjdG9yIHByb3BlcnR5IG11c3QgYmUgT2JqZWN0XHJcblx0XHRpZiAob2JqLmNvbnN0cnVjdG9yICYmICFoYXNPd24uY2FsbChvYmosIFwiY29uc3RydWN0b3JcIilcclxuXHRcdFx0XHQmJiAhaGFzT3duLmNhbGwob2JqLmNvbnN0cnVjdG9yLnByb3RvdHlwZSwgXCJpc1Byb3RvdHlwZU9mXCIpKSB7XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHRcdC8vIE93biBwcm9wZXJ0aWVzIGFyZSBlbnVtZXJhdGVkIGZpcnN0bHksIHNvIHRvIHNwZWVkIHVwLFxyXG5cdFx0Ly8gaWYgbGFzdCBvbmUgaXMgb3duLCB0aGVuIGFsbCBwcm9wZXJ0aWVzIGFyZSBvd24uXHJcblxyXG5cdFx0dmFyIGtleTtcclxuXHRcdGZvciAoa2V5IGluIG9iaikge1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBrZXkgPT09IHVuZGVmaW5lZCB8fCBoYXNPd24uY2FsbChvYmosIGtleSk7XHJcblx0fTtcclxuXHJcblx0Ly8galF1ZXJ5IEV4dGVuZFxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBNZXJnZSB0aGUgY29udGVudHMgb2YgdHdvIG9yIG1vcmUgb2JqZWN0cyB0b2dldGhlciBpbnRvIHRoZSBmaXJzdCBvYmplY3QuIFJldHVybnMgdGhlIHVwZGF0ZWQgb2JqZWN0LlxyXG4gICAgKiBJZiBvbmx5IG9uZSBwYXJhbWV0ZXIgaXMgcGFzc2VkLCB0aGUgZXh0ZW5kcyBgdGhpc2AuXHJcbiAgICAqIEBmdW5jXHJcbiAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2RlZXBdIC0gaWYgdHJ1ZSwgcGVyZm9ybXMgcmVjdXJzaXZlIGRlZXAgY29weS4gaWYgZmFsc2Ugb3Igb21pdHRlZCwgcGVyZm9ybXMgc2ltcGxlIHJlZmVyZW5jZSBjb3B5LlxyXG4gICAgKiBAcGFyYW0geyhvYmplY3R8YXJyYXkpfSBbdGFyZ2V0XSAtIHRhcmdldCBvYmplY3Q7IGlmIG9taXR0ZWQgdGhlbiBgdGhpc2AgaXMgdXNlZC5cclxuICAgICogQHBhcmFtIHsuLi4ob2JqZWN0fGFycmF5KX0gZXh0ZW5kZXIgLSBvYmplY3QocykgdG8gYWRkIHRoZSBjb250ZW50XHJcbiAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29yZS9qc2d1aS1sYW5nLWVzc2VudGlhbHNcclxuICAgICogQGV4YW1wbGVcclxuICAgICogICBqcV9leHRlbmQoe2E6MX0sIHtiOjJ9KSAgPT0+IHthOjEsIGI6Mn1cclxuICAgICogICBqcV9leHRlbmQoWzEsMiwzXSwgWzQsNV0pICA9PT4gWzQsNSwzXVxyXG4gICAgKlxyXG4gICAgKiAgIHZhciBleHQgPSB7c3ViMjp7cHJvcDI6Mn19O1xyXG4gICAgKiAgIHZhciByZXN1bHQxID0ganFfZXh0ZW5kKHRydWUsIHt9LCBleHQpICA9PT4ge3N1YjI6e3Byb3AyOjJ9fVxyXG4gICAgKiAgIHZhciByZXN1bHQyID0ganFfZXh0ZW5kKGZhbHNlLCB7fSwgZXh0KSAgPT0+IHtzdWIyOntwcm9wMjoyfX1cclxuICAgICogICBleHQuc3ViMi5wcm9wMiA9IDIwOyAgPT0+IChyZXN1bHQxLnN1YjIucHJvcDIgPT0gMikgJiAocmVzdWx0Mi5zdWIyLnByb3AyID09IDIwKVxyXG4gICAgKi9cclxuXHR2YXIganFfZXh0ZW5kID0gZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgb3B0aW9ucywgbmFtZSwgc3JjLCBjb3B5LCBjb3B5aXNfYXJyYXksIGNsb25lLCB0YXJnZXQgPSBhcmd1bWVudHNbMF1cclxuXHRcdFx0XHR8fCB7fSwgaSA9IDEsIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsIGRlZXAgPSBmYWxzZTtcclxuXHJcblx0XHQvLyBIYW5kbGUgYSBkZWVwIGNvcHkgc2l0dWF0aW9uXHJcblx0XHRpZiAodHlwZW9mIHRhcmdldCA9PT0gXCJib29sZWFuXCIpIHtcclxuXHRcdFx0ZGVlcCA9IHRhcmdldDtcclxuXHRcdFx0dGFyZ2V0ID0gYXJndW1lbnRzWzFdIHx8IHt9O1xyXG5cdFx0XHQvLyBza2lwIHRoZSBib29sZWFuIGFuZCB0aGUgdGFyZ2V0XHJcblx0XHRcdGkgPSAyO1xyXG5cdFx0fVxyXG5cdFx0Ly8gSGFuZGxlIGNhc2Ugd2hlbiB0YXJnZXQgaXMgYSBzdHJpbmcgb3Igc29tZXRoaW5nIChwb3NzaWJsZSBpbiBkZWVwXHJcblx0XHQvLyBjb3B5KVxyXG5cdFx0aWYgKHR5cGVvZiB0YXJnZXQgIT09IFwib2JqZWN0XCIgJiYgIWpxX2lzRnVuY3Rpb24odGFyZ2V0KSkge1xyXG5cdFx0XHR0YXJnZXQgPSB7fTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyAoZXh0ZW5kIChqUXVlcnkpIGl0c2VsZiBpZiBvbmx5IG9uZSBhcmd1bWVudCBpcyBwYXNzZWQpIG5vIGxvbmdlciBpblxyXG5cdFx0Ly8galF1ZXJ5XHJcblx0XHRpZiAobGVuZ3RoID09PSBpKSB7XHJcblx0XHRcdHRhcmdldCA9IHRoaXM7XHJcblx0XHRcdC0taTtcclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdC8vIE9ubHkgZGVhbCB3aXRoIG5vbi1udWxsL3VuZGVmaW5lZCB2YWx1ZXNcclxuXHRcdFx0aWYgKChvcHRpb25zID0gYXJndW1lbnRzW2ldKSAhPSBudWxsKSB7XHJcblx0XHRcdFx0Ly8gRXh0ZW5kIHRoZSBiYXNlIG9iamVjdFxyXG5cclxuXHRcdFx0XHQvLyBub3BlLi4uIG5lZWQgdG8gZ28gdGhyb3VnaCBhbGwgaXRlbXMgaW4gdGhlIGFycmF5IGlmIGl0cyBhblxyXG5cdFx0XHRcdC8vIGFycmF5LCBjb3B5aW5nIHVuZGVmaW5lZCBhcyBuZWVkZWQuXHJcblxyXG5cdFx0XHRcdGlmIChpc19hcnJheShvcHRpb25zKSkge1xyXG5cclxuXHRcdFx0XHRcdC8vIGNvdWxkIG1heWJlIHVzZSBlYWNoIGhlcmUgYW55d2F5LlxyXG5cdFx0XHRcdFx0Ly8gYnV0IGEgZGlyZWN0IGZ1bmN0aW9uIG1heSBiZSBmYXN0ZXIuXHJcblxyXG5cdFx0XHRcdFx0Zm9yICggdmFyIG5hbWUgPSAwLCBsID0gb3B0aW9ucy5sZW5ndGg7IG5hbWUgPCBsOyBuYW1lKyspIHtcclxuXHRcdFx0XHRcdFx0c3JjID0gdGFyZ2V0W25hbWVdO1xyXG5cdFx0XHRcdFx0XHRjb3B5ID0gb3B0aW9uc1tuYW1lXTtcclxuXHJcblx0XHRcdFx0XHRcdC8vIFByZXZlbnQgbmV2ZXItZW5kaW5nIGxvb3BcclxuXHRcdFx0XHRcdFx0aWYgKHRhcmdldCA9PT0gY29weSkge1xyXG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHQvLyBSZWN1cnNlIGlmIHdlJ3JlIG1lcmdpbmcgcGxhaW4gb2JqZWN0cyBvciBhcnJheXNcclxuXHRcdFx0XHRcdFx0aWYgKGRlZXBcclxuXHRcdFx0XHRcdFx0XHRcdCYmIGNvcHlcclxuXHRcdFx0XHRcdFx0XHRcdCYmIChqcV9pc1BsYWluT2JqZWN0KGNvcHkpIHx8IChjb3B5aXNfYXJyYXkgPSBpc19hcnJheShjb3B5KSkpKSB7XHJcblx0XHRcdFx0XHRcdFx0aWYgKGNvcHlpc19hcnJheSkge1xyXG5cdFx0XHRcdFx0XHRcdFx0Y29weWlzX2FycmF5ID0gZmFsc2U7XHJcblx0XHRcdFx0XHRcdFx0XHRjbG9uZSA9IHNyYyAmJiBpc19hcnJheShzcmMpID8gc3JjIDogW107XHJcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0XHRcdGNsb25lID0gc3JjICYmIGpxX2lzUGxhaW5PYmplY3Qoc3JjKSA/IHNyYyA6IHt9O1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHQvLyBOZXZlciBtb3ZlIG9yaWdpbmFsIG9iamVjdHMsIGNsb25lIHRoZW1cclxuXHRcdFx0XHRcdFx0XHR0YXJnZXRbbmFtZV0gPSBqcV9leHRlbmQoZGVlcCwgY2xvbmUsIGNvcHkpO1xyXG5cdFx0XHRcdFx0XHRcdC8vIERvbid0IGJyaW5nIGluIHVuZGVmaW5lZCB2YWx1ZXM/Pz9cclxuXHRcdFx0XHRcdFx0fSAvLyBlbHNlIGlmICggY29weSAhPT0gdW5kZWZpbmVkICkge1xyXG5cdFx0XHRcdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRcdFx0XHR0YXJnZXRbbmFtZV0gPSBjb3B5O1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRmb3IgKG5hbWUgaW4gb3B0aW9ucykge1xyXG5cclxuXHRcdFx0XHRcdFx0Ly8gY29uc29sZS5sb2coJ25hbWUgJyArIG5hbWUpO1xyXG5cclxuXHRcdFx0XHRcdFx0c3JjID0gdGFyZ2V0W25hbWVdO1xyXG5cdFx0XHRcdFx0XHRjb3B5ID0gb3B0aW9uc1tuYW1lXTtcclxuXHJcblx0XHRcdFx0XHRcdC8vIFByZXZlbnQgbmV2ZXItZW5kaW5nIGxvb3BcclxuXHRcdFx0XHRcdFx0aWYgKHRhcmdldCA9PT0gY29weSkge1xyXG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHQvLyBSZWN1cnNlIGlmIHdlJ3JlIG1lcmdpbmcgcGxhaW4gb2JqZWN0cyBvciBhcnJheXNcclxuXHRcdFx0XHRcdFx0aWYgKGRlZXBcclxuXHRcdFx0XHRcdFx0XHRcdCYmIGNvcHlcclxuXHRcdFx0XHRcdFx0XHRcdCYmIChqcV9pc1BsYWluT2JqZWN0KGNvcHkpIHx8IChjb3B5aXNfYXJyYXkgPSBpc19hcnJheShjb3B5KSkpKSB7XHJcblx0XHRcdFx0XHRcdFx0aWYgKGNvcHlpc19hcnJheSkge1xyXG5cdFx0XHRcdFx0XHRcdFx0Y29weWlzX2FycmF5ID0gZmFsc2U7XHJcblx0XHRcdFx0XHRcdFx0XHRjbG9uZSA9IHNyYyAmJiBpc19hcnJheShzcmMpID8gc3JjIDogW107XHJcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0XHRcdGNsb25lID0gc3JjICYmIGpxX2lzUGxhaW5PYmplY3Qoc3JjKSA/IHNyYyA6IHt9O1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHQvLyBOZXZlciBtb3ZlIG9yaWdpbmFsIG9iamVjdHMsIGNsb25lIHRoZW1cclxuXHRcdFx0XHRcdFx0XHR0YXJnZXRbbmFtZV0gPSBqcV9leHRlbmQoZGVlcCwgY2xvbmUsIGNvcHkpO1xyXG5cdFx0XHRcdFx0XHRcdC8vIERvbid0IGJyaW5nIGluIHVuZGVmaW5lZCB2YWx1ZXNcclxuXHRcdFx0XHRcdFx0fSBlbHNlIGlmIChjb3B5ICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0XHRcdFx0XHR0YXJnZXRbbmFtZV0gPSBjb3B5O1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cdFx0XHQvLyBjb25zb2xlLmxvZygnYXJndW1lbnRzW2ldICcgKyBzdHJpbmdpZnkoYXJndW1lbnRzW2ldKSk7XHJcblx0XHRcdC8vIGNvbnNvbGUubG9nKCdvcHRpb25zICcgKyBzdHJpbmdpZnkob3B0aW9ucykpO1xyXG5cdFx0fVxyXG5cdFx0Ly8gUmV0dXJuIHRoZSBtb2RpZmllZCBvYmplY3RcclxuXHRcdC8vIGNvbnNvbGUubG9nKCd0YXJnZXQgJyArIHN0cmluZ2lmeSh0YXJnZXQpKTtcclxuXHRcdHJldHVybiB0YXJnZXQ7XHJcblx0fTtcclxuXHJcbiAgICAvKipcclxuICAgICogQWxpYXMgdG8gdGhlIFtqcV9leHRlbmQoKV17QGxpbmsgbW9kdWxlOmNvcmUvanNndWktbGFuZy1lc3NlbnRpYWxzLmpxX2V4dGVuZH0gZnVuY3Rpb24uXHJcbiAgICAqIEBmdW5jXHJcbiAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29yZS9qc2d1aS1sYW5nLWVzc2VudGlhbHNcclxuICAgICovXHJcbiAgICB2YXIgZXh0ZW5kID0ganFfZXh0ZW5kO1xyXG5cclxuXHQvKlxyXG5cdHZhciB4X2Nsb25lcyA9IGZ1bmN0aW9uKG9iaiwgeCkge1xyXG5cclxuXHR9O1xyXG5cdCovXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFJldHVybnMgYSB0cnV0aCBtYXAgY3JlYXRlZCBmcm9tIHRoZSBnaXZlbiBhcnJheS5cclxuICAgICpcclxuICAgICogVGhlIHRydXRoIG1hcCBpcyBhbiBvYmplY3QgY29udGFpbmluZyBrZXkvdmFsdWUgcGFpcnM7IHRoZSBrZXlzIGFyZSB0aGUgYXJyYXkgZWxlbWVudHMsIHRoZSB2YWx1ZXMgYXJlIGFsbCB0cnVlLlxyXG4gICAgKiBAZXhhbXBsZSBnZXRfdHJ1dGhfbWFwX2Zyb21fYXJyKFtcImFcIiwgXCJiXCIsIFwiY1wiXSkgPT0+IHsgYTogdHJ1ZSwgYjogdHJ1ZSwgYzogdHJ1ZX1cclxuICAgICogQGZ1bmNcclxuICAgICogQHBhcmFtIHtBcnJheX0gYXJyIC0gc291cmNlIGFycmF5XHJcbiAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29yZS9qc2d1aS1sYW5nLWVzc2VudGlhbHNcclxuICAgICovXHJcblx0dmFyIGdldF90cnV0aF9tYXBfZnJvbV9hcnIgPSBmdW5jdGlvbihhcnIpIHtcclxuXHRcdHZhciByZXMgPSB7fTtcclxuXHRcdGVhY2goYXJyLCBmdW5jdGlvbihpLCB2KSB7XHJcblx0XHRcdHJlc1t2XSA9IHRydWU7XHJcblx0XHR9KTtcclxuXHRcdHJldHVybiByZXM7XHJcblx0fTtcclxuXHJcbiAgICAvKipcclxuICAgICogUmV0dXJucyBhIG1hcCBjcmVhdGVkIGZyb20gdGhlIGdpdmVuIGFycmF5LlxyXG4gICAgKlxyXG4gICAgKiBUaGUgbWFwIGlzIGFuIG9iamVjdCBjb250YWluaW5nIGtleS92YWx1ZSBwYWlyczsgdGhlIGtleXMgYXJlIHRoZSBhcnJheSBlbGVtZW50cywgdGhlIHZhbHVlcyBhcmUgdGhlIGFycmF5IGluZGV4ZXMuXHJcbiAgICAqIEBleGFtcGxlIGdldF9tYXBfZnJvbV9hcnIoW1wiYVwiLCBcImJcIiwgXCJjXCJdKSA9PT4geyBhOiAwLCBiOiAxLCBjOiAyfVxyXG4gICAgKiBAZnVuY1xyXG4gICAgKiBAcGFyYW0ge0FycmF5fSBhcnIgLSBzb3VyY2UgYXJyYXlcclxuICAgICogQG1lbWJlcm9mIG1vZHVsZTpjb3JlL2pzZ3VpLWxhbmctZXNzZW50aWFsc1xyXG4gICAgKi9cclxuXHQvLyBub3QgYSB0cnV0aCBtYXAgYmVjYXVzZSAwID09IGZhbHNlLiBDb3VsZCB1c2UgdGhpcyBidXQgZG8gZGlmZmVyZW50XHJcblx0Ly8gY2hlY2ssIGxpa2UgaXNfZGVmaW5lZC5cclxuXHR2YXIgZ2V0X21hcF9mcm9tX2FyciA9IGZ1bmN0aW9uKGFycikge1xyXG5cdFx0dmFyIHJlcyA9IHt9O1xyXG5cdFx0Zm9yICh2YXIgYyA9IDAsIGwgPSBhcnIubGVuZ3RoOyBjIDwgbDsgYysrKSB7XHJcblx0XHRcdHJlc1thcnJbY11dID0gYztcclxuXHRcdH1cclxuXHRcdC8vZWFjaChhcnIsIGZ1bmN0aW9uKGksIHYpIHtcclxuXHRcdC8vXHRyZXNbdl0gPSBpO1xyXG5cdFx0Ly99KTtcclxuXHRcdHJldHVybiByZXM7XHJcblx0fVxyXG5cclxuXHQvL3ZhciBhcnJTbGljZUNhbGwgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbDtcclxuXHJcbiAgICAvKipcclxuICAgICogUmV0dXJucyBhbiBhcnJheSBjcmVhdGVkIGZyb20gdGhlIGdpdmVuIFwiYXJyYXktbGlrZVwiIG9iamVjdCAoZS5nLiBgYXJndW1lbnRzYCkuXHJcbiAgICAqIEBmdW5jXHJcbiAgICAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBhcnJfbGlrZSAtIHRoZSBhcnJheS1saWtlIG9iamVjdFxyXG4gICAgKiBAZXhhbXBsZVxyXG4gICAgKiBmdW5jdGlvbiBleGFtcGxlKCl7XHJcbiAgICAqICAgIHZhciBhcmd1bWVudHNfYXJyYXkgPSBhcnJfbGlrZV90b19hcnIoYXJndW1lbnRzKTtcclxuICAgICogICAgY29uc29sZS5sb2coYXJndW1lbnRzX2FycmF5KTtcclxuICAgICogfVxyXG4gICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvcmUvanNndWktbGFuZy1lc3NlbnRpYWxzXHJcbiAgICAqL1xyXG5cdHZhciBhcnJfbGlrZV90b19hcnIgPSBmdW5jdGlvbihhcnJfbGlrZSkge1xyXG5cdFx0Ly8gbGlrZSBhbiBhcmd1bWVudHMgbGlzdFxyXG5cdFx0Ly8gaXMgdGhpcyB3b3JraW5nIGluIFNhZmFyaT9cclxuXHJcblx0XHQvL3ZhciByZXMgPSBbXTtcclxuXHRcdC8vcmV0dXJuIGFyclNsaWNlQ2FsbChhcnJfbGlrZSwgMCk7XHJcblxyXG5cclxuXHRcdC8vcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZShhcnJfbGlrZSk7XHJcblx0XHQvLyBNYXkgaGF2ZSBiZXR0ZXIgd2F5IG9mIGRvaW5nIHRoaXMuXHJcblxyXG5cclxuXHJcblx0XHR2YXIgcmVzID0gbmV3IEFycmF5KGFycl9saWtlLmxlbmd0aCk7XHJcblxyXG5cclxuXHRcdC8vIFRoaXMgd2FzIG5vdCB3b3JraW5nIGluIFNhZmFyaSEgV29ya2VkIGluIENocm9tZS4gUHJvYmFibHlcclxuXHRcdC8vIChtaXM/KXJlY29nbmlzZWQgaXQgYXMgYW4gb2JqZWN0LlxyXG5cdFx0Ly8gZWFjaChhcnJfbGlrZSwgZnVuY3Rpb24oaSwgdikge1xyXG5cdFx0Ly8gcmVzLnB1c2godik7XHJcblx0XHQvLyB9KTtcclxuXHJcblx0XHRmb3IgKHZhciBjID0gMCwgbCA9IGFycl9saWtlLmxlbmd0aDsgYyA8IGw7IGMrKykge1xyXG5cdFx0XHQvL3Jlcy5wdXNoKGFycl9saWtlW2NdKTtcclxuXHRcdFx0cmVzW2NdID0gYXJyX2xpa2VbY107XHJcblx0XHR9O1xyXG5cdFx0cmV0dXJuIHJlcztcclxuXHR9O1xyXG5cclxuXHJcblxyXG5cdC8vIENvdWxkIGRvIGJldHRlci4uLiBjb3VsZCBjaGVjayBhY3R1YWwgaW5zdGFuY2VvZlxyXG5cdC8vICBCdXQgYSBtb3JlIGFkdmFuY2VkIGpzZ3VpIGxldmVsIGNvdWxkIGRvIHRoaXMgY2hlY2ssIGFuZCBoYXZlIGl0cyBvd24gdG9mIGZ1bmN0aW9uLlxyXG5cdC8vICBUaGF0IHdvdWxkIGJlIGpzZ3VpLWxhbmctaHRtbCBoYXMgdGhlIGNoZWNrIGZvciBpcyBjb250cm9sLlxyXG5cclxuICAgIC8qKlxyXG4gICAgKiA8bWFyaz5kZXNjcmlwdGlvbi4uLjwvbWFyaz5cclxuICAgICogQGZ1bmNcclxuICAgICogQG1lbWJlcm9mIG1vZHVsZTpjb3JlL2pzZ3VpLWxhbmctZXNzZW50aWFsc1xyXG4gICAgKi9cclxuXHR2YXIgaXNfY3RybCA9IGZ1bmN0aW9uKG9iaikge1xyXG5cdFx0cmV0dXJuICh0eXBlb2Ygb2JqICE9ICd1bmRlZmluZWQnICYmIG9iaiAhPSBudWxsICYmIGlzX2RlZmluZWQob2JqLl8pICYmIGlzX2RlZmluZWQob2JqLl9fdHlwZV9uYW1lKSk7XHJcblx0fTtcclxuXHJcblxyXG4gICAgLy8gQWxzbyBhIGJpdCBvZiBub2RlLmpzIHNwZWNpZmljIGNvZGUuXHJcbiAgICAvLyAgTWF5IG1ha2Ugbm9kZSB2ZXJzaW9uIG9mIGpzZ3VpLWxhbmctZXNzZW50aWFscywganNndWktbm9kZS1sYW5nLWVzc2VudGlhbHMuXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFJldHVybnMgdGhlIHR5cGUgb2YgdGhlIGdpdmVuIG9iamVjdCBhcyBhIHN0cmluZy4gSWYgdGhlIHQxIHBhcmFtZXRlciBpcyBwYXNzZWQsIHRoZW4gcmV0dXJucyB0MSBmb3IgYWxsIHRoZSB0MSB2YWx1ZXMgZXhjZXB0aW5nICdvYmplY3QnIG9uZS5cclxuICAgICogUG9zc2libGUgcmVzdWx0cyBhcmU6XHJcbiAgICAqIC0gXCJudW1iZXJcIlxyXG4gICAgKiAtIFwic3RyaW5nXCJcclxuICAgICogLSBcImZ1bmN0aW9uXCJcclxuICAgICogLSBcImJvb2xlYW5cIlxyXG4gICAgKiAtIFwib2JqZWN0XCJcclxuICAgICogLSBcInVuZGVmaW5lZFwiXHJcbiAgICAqIC0gXCJudWxsXCJcclxuICAgICogLSA8bWFyaz5vYmouX190eXBlPC9tYXJrPlxyXG4gICAgKiAtIFwiZGF0ZVwiXHJcbiAgICAqIC0gXCJhcnJheVwiXHJcbiAgICAqIC0gXCJjb250cm9sXCJcclxuICAgICogLSBcInJlZ2V4XCIgKG9iaiBpbnN0YW5jZW9mIFJlZ0V4cClcclxuICAgICogLSBcImJ1ZmZlclwiIChvYmogaW5zdGFuY2VvZiBCdWZmZXIpXHJcbiAgICAqIC0gXCJyZWFkYWJsZV9zdHJlYW1cIiAob2JqIGluc3RhbmNlb2YgU3RyZWFtLlJlYWRhYmxlKVxyXG4gICAgKiAtIFwid3JpdGFibGVfc3RyZWFtXCIgKG9iaiBpbnN0YW5jZW9mIFN0cmVhbS5Xcml0YWJsZSlcclxuICAgICogQGZ1bmNcclxuICAgICogQHBhcmFtIHsqfSBvYmogLSBvYmplY3QgdG8gaW5zcGVjdCB0eXBlXHJcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBbdDFdIC0gdHlwZSB0byByZXR1cm4gKD8pXHJcbiAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29yZS9qc2d1aS1sYW5nLWVzc2VudGlhbHNcclxuICAgICogQGV4YW1wbGVcclxuICAgICogdG9mKDEpID09PiBcIm51bWJlclwiXHJcbiAgICAqIHRvZihbXSkgPT0+IFwiYXJyYXlcIlxyXG4gICAgKiB0b2YoMSwgXCJteVR5cGVcIikgPT0+IFwibXlUeXBlXCJcclxuICAgICogdG9mKDEsIFwib2JqZWN0XCIpID09PiBcIm9iamVjdFwiXHJcbiAgICAqIHRvZihbXSwgXCJvYmplY3RcIikgPT0+IFwiYXJyYXlcIlxyXG4gICAgKi9cclxuXHQvLyBtYXkgY2hhbmdlIHRvIHRoZSBqcV90eXBlIGNvZGUuXHJcblx0dmFyIHRvZiA9IGZ1bmN0aW9uKG9iaiwgdDEpIHtcclxuXHRcdHZhciByZXMgPSB0MSB8fCB0eXBlb2Ygb2JqO1xyXG5cclxuXHRcdGlmIChyZXMgPT09ICdudW1iZXInIHx8IHJlcyA9PT0gJ3N0cmluZycgfHwgcmVzID09PSAnZnVuY3Rpb24nIHx8IHJlcyA9PT0gJ2Jvb2xlYW4nKSB7XHJcblx0XHQgICAgcmV0dXJuIHJlcztcclxuXHRcdH1cclxuXHJcblxyXG5cdFx0aWYgKHJlcyA9PT0gJ29iamVjdCcpIHtcclxuXHJcblx0XHRcdGlmICh0eXBlb2Ygb2JqICE9PSAndW5kZWZpbmVkJykge1xyXG5cclxuXHRcdFx0XHRpZiAob2JqID09PSBudWxsKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gJ251bGwnO1xyXG5cdFx0XHRcdH1cclxuXHJcblxyXG5cclxuXHRcdFx0XHQvL2NvbnNvbGUubG9nKCd0eXBlb2Ygb2JqICcgKyB0eXBlb2Ygb2JqKTtcclxuXHRcdFx0XHQvL2NvbnNvbGUubG9nKCdvYmogPT09IG51bGwgJyArIChvYmogPT09IG51bGwpKTtcclxuXHJcblx0XHRcdFx0aWYgKG9iai5fX3R5cGUpIHtcclxuXHRcdFx0XHRcdHJldHVybiBvYmouX190eXBlO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgaWYgKGlzX2N0cmwob2JqKSkge1xyXG4gICAgICAgICAgICAgIC8vcmV0dXJuIHJlcztcclxuICAgICAgICAgICAgICByZXR1cm4gJ2NvbnRyb2wnO1xyXG4gICAgICAgICAgfVxyXG5cclxuXHRcdFx0XHRcdC8vIElubGluZSBhcnJheSB0ZXN0LCBlYXJsaWVyIG9uP1xyXG5cclxuXHRcdFx0XHRcdGlmIChvYmogaW5zdGFuY2VvZiBEYXRlKSB7XHJcblx0XHRcdFx0XHRcdHJldHVybiAnZGF0ZSc7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cclxuXHRcdFx0XHRcdGlmIChpc19hcnJheShvYmopKSB7XHJcblx0XHRcdFx0ICAgICAgICAvL3JlcyA9ICdhcnJheSc7XHJcblx0XHRcdFx0ICAgICAgICAvL3JldHVybiByZXM7XHJcblx0XHRcdFx0ICAgICAgICByZXR1cm4gJ2FycmF5JztcclxuXHRcdFx0XHQgICAgfSBlbHNlIHtcclxuXHJcblx0XHRcdFx0ICAgICAgICBpZiAob2JqIGluc3RhbmNlb2YgUmVnRXhwKSByZXMgPSAncmVnZXgnO1xyXG5cclxuXHRcdFx0XHQgICAgICAgIC8vIEZvciBydW5uaW5nIGluc2lkZSBOb2RlLlxyXG5cdFx0XHRcdCAgICAgICAgLy9jb25zb2xlLmxvZygndHdpbiAnICsgdHlwZW9mIHdpbmRvdyk7XHJcblx0XHRcdFx0ICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuXHRcdFx0XHQgICAgICAgIFx0Ly9jb25zb2xlLmxvZygnb2JqLmxlbmd0aCAnICsgb2JqLmxlbmd0aCk7XHJcblx0XHRcdFx0ICAgICAgICBcdGlmIChvYmogaW5zdGFuY2VvZiBCdWZmZXIpIHJlcyA9ICdidWZmZXInO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRpZiAob2JqIGluc3RhbmNlb2YgU3RyZWFtLlJlYWRhYmxlKSByZXMgPSAncmVhZGFibGVfc3RyZWFtJztcclxuXHRcdFx0XHRcdFx0XHRpZiAob2JqIGluc3RhbmNlb2YgU3RyZWFtLldyaXRhYmxlKSByZXMgPSAnd3JpdGFibGVfc3RyZWFtJztcclxuXHRcdFx0XHQgICAgICAgIH1cclxuXHJcblxyXG5cdFx0XHRcdCAgICB9XHJcblx0XHRcdFx0ICAgIC8vY29uc29sZS5sb2coJ3JlcyAnICsgcmVzKTtcclxuXHRcdFx0XHRcdHJldHVybiByZXM7XHJcblxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRyZXR1cm4gJ3VuZGVmaW5lZCc7XHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHJlcztcclxuXHR9O1xyXG5cclxuXHQvLyBCdWcgZm9yIGEgdGVzdCBjYXNlIC0gY2hlY2tpbmcgaWYgYSBmdW5jdGlvbiBpcyBhbiBpbnN0YW5jZU9mIHN0cmVhbS5cclxuXHJcbiAgICAvKipcclxuICAgICogUmV0dXJucyBhbiBhcnJheSBjb250YWluaW5nIHR5cGUgc3RyaW5ncyBmb3IgdGhlIHBhc3NlZCBhcnJheSBlbGVtZW50cy4gVGhlIHR5cGUgc3RyaW5ncyBhcmUgbWFkZSB1c2luZyB0aGUgW3RvZigpXXtAbGluayBtb2R1bGU6Y29yZS9qc2d1aS1sYW5nLWVzc2VudGlhbHMudG9mfSBmdW5jdGlvbi5cclxuICAgICogQGZ1bmNcclxuICAgICogQHBhcmFtIHtBcnJheX0gYXJyIC0gc291cmNlIGFycmF5XHJcbiAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29yZS9qc2d1aS1sYW5nLWVzc2VudGlhbHNcclxuICAgICogQGV4YW1wbGVcclxuICAgICogYXRvZihbMSwgXCJcIiwgbnVsbF0pID09PiBbXCJudW1iZXJcIiwgXCJzdHJpbmdcIiwgXCJudWxsXCJdXHJcbiAgICAqL1xyXG5cdHZhciBhdG9mID0gZnVuY3Rpb24oYXJyKSB7XHJcblxyXG5cdFx0dmFyIHJlcyA9IG5ldyBBcnJheShhcnIubGVuZ3RoKTtcclxuXHRcdC8vZWFjaChhcnIsIGZ1bmN0aW9uKGksIHYpIHtcclxuXHRcdC8vXHRyZXMucHVzaCh0b2YodikpO1xyXG5cdFx0Ly99KTtcclxuXHRcdGZvciAodmFyIGMgPSAwLCBsID0gYXJyLmxlbmd0aDsgYyA8IGw7IGMrKykge1xyXG5cdFx0XHQvL3Jlcy5wdXNoKHRvZihhcnJbY10pKTtcclxuXHRcdFx0cmVzW2NdID0gdG9mKGFycltjXSk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHJlcztcclxuXHR9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHZhbHVlIGlzIGRlZmluZWQgKGUuZy4gbm90IGVxdWFscyB0byB1bmRlZmluZWQpXHJcbiAgICAqIEBmdW5jXHJcbiAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgLSB2YWx1ZSB0byBjaGVja1xyXG4gICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvcmUvanNndWktbGFuZy1lc3NlbnRpYWxzXHJcbiAgICAqIEBleGFtcGxlXHJcbiAgICAqIGlzX2RlZmluZWQoTWF0aC5QSSkgPT0+IHRydWVcclxuICAgICogaXNfZGVmaW5lZChNYXRoLlBJX1BJX1BJKSA9PT4gZmFsc2VcclxuICAgICovXHJcblx0dmFyIGlzX2RlZmluZWQgPSBmdW5jdGlvbih2YWx1ZSkge1xyXG5cdFx0Ly8gdG9mIG9yIHR5cGVvZlxyXG5cclxuXHRcdHJldHVybiB0eXBlb2YgKHZhbHVlKSAhPSAndW5kZWZpbmVkJztcclxuXHR9LCBpc2RlZiA9IGlzX2RlZmluZWQ7XHJcblxyXG5cdHZhciBpc19kYXRhX29iamVjdCA9IGZ1bmN0aW9uKG9iaikge1xyXG5cclxuXHRcdGlmKG9iaikge1xyXG5cdFx0XHRpZiAob2JqLl9fdHlwZSA9PSAnZGF0YV9vYmplY3QnKSByZXR1cm4gdHJ1ZTtcclxuXHRcdFx0aWYgKG9iai5fX3R5cGUgPT0gJ2NvbGxlY3Rpb24nKSByZXR1cm4gdHJ1ZTtcclxuXHRcdH1cclxuXHJcblx0XHQvL3RoaXMuX190eXBlID0gJ2NvbGxlY3Rpb24nXHJcblxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cclxuXHR9XHJcblxyXG5cdC8vIHdpbGwgdGVzdCBmb3IgY29udHJvbCB1c2luZyBzaW1pbGFyIG1lYW5zIGFzIHdlbGwuXHJcblxyXG5cdHZhciBpc19jb2xsZWN0aW9uID0gZnVuY3Rpb24ob2JqKSB7XHJcblx0XHQvL2lmIChvYmouX190eXBlID09ICdkYXRhX29iamVjdCcpIHJldHVybiB0cnVlO1xyXG5cclxuXHRcdGlmIChvYmopIHtcclxuXHRcdFx0aWYgKG9iai5fX3R5cGUgPT0gJ2NvbGxlY3Rpb24nKSByZXR1cm4gdHJ1ZTtcclxuXHRcdH1cclxuXHJcblxyXG5cdFx0Ly90aGlzLl9fdHlwZSA9ICdjb2xsZWN0aW9uJ1xyXG5cclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHJcblx0fVxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBPdXRwdXR0aW5nIGEgc3RyaW5nIGluIGEgY29udmVuaWVudCBmb3JtYXQgLSBjdXJyZW50bHkgSlNPTi5cclxuICAgICogQGZ1bmNcclxuICAgICogQHBhcmFtIHsqfSBvYmogLSB2YWx1ZSB0byBjb252ZXJ0XHJcbiAgICAqIEBwYXJhbSB7Ym9vbH0gW2luY2x1ZGVGdW5jdGlvbnNdIC0gaWYgdHJ1ZSwgdGhlbiBpbmNsdWRlIGZ1bmN0aW9ucyB0byB0aGUgcmVzdWx0XHJcbiAgICAqIEBwYXJhbSB7YXJyYXkoc3RyaW5nKX0gW2V4Y2x1ZGluZ1Byb3BzXSAtIGV4Y2x1ZGUgdGhlIGxpc3RlZCBvYmplY3QgcHJvcGVydGllcyBmcm9tIHRoZSByZXN1bHRcclxuICAgICogQG1lbWJlcm9mIG1vZHVsZTpjb3JlL2pzZ3VpLWxhbmctZXNzZW50aWFsc1xyXG4gICAgKiBAZXhhbXBsZVxyXG4gICAgKiBzdHJpbmdpZnkoMSkgPT0+ICcxJ1xyXG4gICAgKiBzdHJpbmdpZnkoXCIxXCIpID09PiAnXCIxXCInXHJcbiAgICAqIHN0cmluZ2lmeShbMSwgXCJhXCIsIG51bGxdKSA9PT4gJ1sxLCBcImFcIiwgbnVsbF0nXHJcbiAgICAqIHN0cmluZ2lmeSh7cDE6MSwgcDI6XCJhXCIsIHAzOm51bGx9KSA9PT4gJ3tcInAxXCI6IDEsIFwicDJcIjogXCJhXCIsIFwicDNcIjogbnVsbH0nXHJcbiAgICAqL1xyXG5cdHZhciBzdHJpbmdpZnkgPSBmdW5jdGlvbihvYmosIGluY2x1ZGVGdW5jdGlvbnMsIGV4Y2x1ZGluZ1Byb3BzKSB7XHJcblxyXG5cdFx0dmFyIF9zdHJpbmdpZnkgPSBmdW5jdGlvbihvYmosIGluY2x1ZGVGdW5jdGlvbnMsIGNhbGxlck9iakl0ZW0pIHtcclxuXHJcblx0XHRcdC8vX3N0cmluZ2lmeShhLCBiLCB7IHByZXY6IGNhbGxlck9iakl0ZW0sIG9iajogb2JqIH0pO1xyXG5cclxuXHRcdFx0dmFyIGlzQ2lyY3VsYXJSZWZlcmVuY2UgPSBmdW5jdGlvbihvYmosIGNhbGxlck9iakl0ZW0pe1xyXG5cdFx0XHRcdHdoaWxlKGNhbGxlck9iakl0ZW0pe1xyXG5cdFx0XHRcdFx0aWYgKGNhbGxlck9iakl0ZW0ub2JqID09PSBvYmopIHJldHVybiB0cnVlO1xyXG5cdFx0XHRcdFx0Y2FsbGVyT2JqSXRlbSA9IGNhbGxlck9iakl0ZW0ucHJldjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHR9O1xyXG5cclxuXHRcdFx0aWYgKGlzQ2lyY3VsYXJSZWZlcmVuY2Uob2JqLCBjYWxsZXJPYmpJdGVtKSkgcmV0dXJuIFwiKENpcmN1bGFyUmVmKVwiO1xyXG5cclxuXHRcdFx0Ly8gTGlrZWx5IG9wdGltaXphdGlvbjogdXNlIGFycmF5IHRvIGJ1aWxkIHRoZSBzdHJpbmcsIHRoZW4gam9pbiBpdCBmb3JcclxuXHRcdFx0Ly8gdGhlIHJlc3VsdC5cclxuXHRcdFx0Ly8gTm93IHVwZGF0ZWQuXHJcblx0XHRcdC8vIENvdWxkIHByb2JhYmx5IHVzZSBwb2x5bW9ycGhpc20gaGVyZSBhbmQgc2F2ZSBzcGFjZVxyXG5cclxuXHRcdFx0Ly8gRGVzaWduZWQgZm9yIHN0cmluZ2lmeWluZyBzcGVjcyBpbmNsdWRpbmcgZnVuY3Rpb25zIGluIG1pbmQuXHJcblxyXG5cdFx0XHQvLyBDb3VsZCB1c2UgdG9mIGFzIHdlbGwuLi4gSSB0aGluayB0aGF0IHdvdWxkIG1ha2UgYSBsb3Qgb2Ygc2Vuc2UuXHJcblxyXG5cdFx0XHR2YXIgdCA9IHR5cGVvZiBvYmosIHJlcyA9IFtdO1xyXG5cclxuXHRcdFx0Ly8gdG8gc3RyaW5naWZ5IGEgY29sbGVjdGlvbj9cclxuXHJcblx0XHRcdGlmIChvYmogPT09IFN0cmluZykge1xyXG5cdFx0XHRcdHJldHVybiAnSlNfU3RyaW5nJztcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKHQgPT0gJ29iamVjdCcpIHtcclxuXHRcdFx0XHQvLyB3aWxsIGJlIHRlc3RpbmcgaXQgdG8gc2VlIGlmIGl0IGlzIGEgRGF0YV9PYmplY3RcclxuXHRcdFx0XHQvLyAgYW5kIHRoZW4gaWYgaXQgaXMgYSBDb2xsZWN0aW9uXHJcblxyXG5cclxuXHRcdFx0XHRpZiAob2JqICYmIGlzX2RlZmluZWQob2JqLnN0cmluZ2lmeSkpIHtcclxuXHRcdFx0XHRcdHJldHVybiBvYmouc3RyaW5naWZ5KCk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHR2YXIgaWEgPSBpc19hcnJheShvYmopO1xyXG5cdFx0XHRcdFx0aWYgKGlhKSB7XHJcblx0XHRcdFx0XHRcdC8vIHJlcyA9IHJlcyArICdbJztcclxuXHRcdFx0XHRcdFx0cmVzLnB1c2goJ1snKTtcclxuXHRcdFx0XHRcdFx0dmFyIGZpcnN0ID0gdHJ1ZTtcclxuXHRcdFx0XHRcdFx0Zm9yICggdmFyIGMgPSAwOyBjIDwgb2JqLmxlbmd0aDsgYysrKSB7XHJcblx0XHRcdFx0XHRcdFx0Ly8gaWYgKCFmaXJzdCkgcmVzID0gcmVzICsgJywgJztcclxuXHRcdFx0XHRcdFx0XHRpZiAoIWZpcnN0KVxyXG5cdFx0XHRcdFx0XHRcdFx0cmVzLnB1c2goJywgJyk7XHJcblx0XHRcdFx0XHRcdFx0Ly8gcmVzID0gcmVzICsgc3RyaW5naWZ5KG9ialtjXSk7XHJcblx0XHRcdFx0XHRcdFx0Ly9yZXMucHVzaChfc3RyaW5naWZ5KG9ialtjXSwgdW5kZWZpbmVkLCB7IHByZXY6IGNhbGxlck9iakl0ZW0sIG9iajogb2JqIH0pKTtcclxuXHRcdFx0XHRcdFx0XHRyZXMucHVzaChfc3RyaW5naWZ5KG9ialtjXSwgaW5jbHVkZUZ1bmN0aW9ucywgeyBwcmV2OiBjYWxsZXJPYmpJdGVtLCBvYmo6IG9iaiB9KSk7XHJcblx0XHRcdFx0XHRcdFx0Zmlyc3QgPSBmYWxzZTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHQ7XHJcblx0XHRcdFx0XHRcdC8vIHJlcyA9IHJlcyArICddJztcclxuXHRcdFx0XHRcdFx0cmVzLnB1c2goJ10nKTtcclxuXHRcdFx0XHRcdH0gZWxzZSBpZiAob2JqID09IG51bGwpIHtcclxuXHRcdFx0XHRcdFx0cmVzID0gWyAnbnVsbCcgXTtcclxuXHRcdFx0XHRcdFx0Ly8gZG9uJ3QgZG8gdGhpcyBpc19jb250cm9sIHRlc3QuXHJcblx0XHRcdFx0XHQvL30gZWxzZSBpZiAoaXNfY3RybChvYmopKSB7XHJcblx0XHRcdFx0XHRcdC8vIHJlcyA9IHJlcyArICd7XCJjdHJsXCI6IFwiJyArIG9iai5pZCgpICsgJ1wifSc7XHJcblx0XHRcdFx0XHQvL1x0cmVzLnB1c2goJ3tcImN0cmxcIjogXCInICsgb2JqLmlkKCkgKyAnXCJ9Jyk7XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHQvLyBjb25zb2xlLmxvZygnb2JqICcgKyBvYmopO1xyXG5cclxuXHRcdFx0XHRcdFx0Ly8gYSB3YXkgb2YgY2hlY2tpbmcgZm9yIGEgbm9uLW5hdGl2ZSB0b1N0cmluZz9cclxuXHRcdFx0XHRcdFx0aWYgKGlzX2RlZmluZWQob2JqLnRvU3RyaW5nKSAmJiBvYmoudG9TdHJpbmcuc3RyaW5naWZ5ID09PSB0cnVlKSB7XHJcblx0XHRcdFx0XHRcdFx0cmVzLnB1c2goJ1wiJyArIG9iai50b1N0cmluZygpICsgJ1wiJyk7XHJcblx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdCAgICB2YXIgcHJvcElzUHJpbnRhYmxlID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XHJcblx0XHRcdFx0XHRcdCAgICAgICAgaWYgKCFpbmNsdWRlRnVuY3Rpb25zICYmIHRvZih2YWx1ZSkgPT09ICdmdW5jdGlvbicpIHJldHVybiBmYWxzZTtcclxuXHRcdFx0XHRcdFx0ICAgICAgICAvL1xyXG5cdFx0XHRcdFx0XHQgICAgICAgIGlmIChleGNsdWRpbmdQcm9wcykge1xyXG5cdFx0XHRcdFx0XHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4Y2x1ZGluZ1Byb3BzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0XHRcdCAgICAgICAgICAgICAgICBpZiAobmFtZSA9PSBleGNsdWRpbmdQcm9wc1tpXSkgcmV0dXJuIGZhbHNlO1xyXG5cdFx0XHRcdFx0XHQgICAgICAgICAgICB9XHJcblx0XHRcdFx0XHRcdCAgICAgICAgfVxyXG5cdFx0XHRcdFx0XHQgICAgICAgIC8vXHJcblx0XHRcdFx0XHRcdCAgICAgICAgcmV0dXJuIHRydWU7XHJcblx0XHRcdFx0XHRcdCAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9cclxuXHRcdFx0XHRcdFx0XHR2YXIgZmlyc3QgPSB0cnVlO1xyXG5cdFx0XHRcdFx0XHRcdC8vIHJlcyA9IHJlcyArICd7JztcclxuXHRcdFx0XHRcdFx0XHRyZXMucHVzaCgneycpO1xyXG5cdFx0XHRcdFx0XHRcdGVhY2gob2JqLCBmdW5jdGlvbihpLCB2KSB7XHJcblx0XHRcdFx0XHRcdFx0XHQvL2NvbnNvbGUubG9nKHRvZih2KSk7XHJcblx0XHRcdFx0XHRcdFx0XHQvL1xyXG5cdFx0XHRcdFx0XHRcdFx0Ly92YXIgcHJvcElzUHJpbnRhYmxlID0gdHJ1ZTtcclxuXHRcdFx0XHRcdFx0XHRcdC8vaWYgKHByb3BJc1ByaW50YWJsZSAmJiAhaW5jbHVkZUZ1bmN0aW9ucyAmJiB0b2YodikgPT09ICdmdW5jdGlvbicpIHByb3BJc1ByaW50YWJsZSA9IGZhbHNlO1xyXG5cdFx0XHRcdFx0XHRcdFx0Ly9pZiAocHJvcElzUHJpbnRhYmxlICYmIGV4Y2x1ZGluZ1Byb3BzICYmIGV4Y2x1ZGluZ1Byb3BzLmluZGV4T2YoaSk+PTApIHByb3BJc1ByaW50YWJsZSA9IGZhbHNlO1xyXG5cdFx0XHRcdFx0XHRcdFx0Ly9cclxuXHRcdFx0XHRcdFx0XHRcdC8qaWYgKGluY2x1ZGVGdW5jdGlvbnMgIT09IGZhbHNlXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0JiYgdG9mKHYpICE9PSAnZnVuY3Rpb24nKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGlmICghZmlyc3QpIHJlcyA9IHJlcyArICcsICc7XHJcblx0XHRcdFx0XHRcdFx0XHRcdGlmICghZmlyc3QpXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzLnB1c2goJywgJyk7XHJcblx0XHRcdFx0XHRcdFx0XHRcdC8vIHJlcyA9IHJlcyArICdcIicgKyBpICsgJ1wiOiAnICtcclxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gc3RyaW5naWZ5KHYpO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRyZXMucHVzaCgnXCInICsgaSArICdcIjogJyArIF9zdHJpbmdpZnkodiwgdW5kZWZpbmVkLCB7IHByZXY6IGNhbGxlck9iakl0ZW0sIG9iajogb2JqIH0pKTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0Zmlyc3QgPSBmYWxzZTtcclxuXHRcdFx0XHRcdFx0XHRcdH0qL1xyXG5cdFx0XHRcdFx0XHRcdFx0Ly9cclxuXHRcdFx0XHRcdFx0XHQgICAgaWYgKHByb3BJc1ByaW50YWJsZShpLCB2KSkge1xyXG5cdFx0XHRcdFx0XHRcdCAgICAgICAgaWYgKCFmaXJzdCkgcmVzLnB1c2goJywgJyk7XHJcblx0XHRcdFx0XHRcdFx0ICAgICAgICAvL3Jlcy5wdXNoKCdcIicgKyBpICsgJ1wiOiAnICsgX3N0cmluZ2lmeSh2LCB1bmRlZmluZWQsIHsgcHJldjogY2FsbGVyT2JqSXRlbSwgb2JqOiBvYmogfSkpO1xyXG5cdFx0XHRcdFx0XHRcdCAgICAgICAgcmVzLnB1c2goJ1wiJyArIGkgKyAnXCI6ICcgKyBfc3RyaW5naWZ5KHYsIGluY2x1ZGVGdW5jdGlvbnMsIHsgcHJldjogY2FsbGVyT2JqSXRlbSwgb2JqOiBvYmogfSkpO1xyXG5cdFx0XHRcdFx0XHRcdCAgICAgICAgZmlyc3QgPSBmYWxzZTtcclxuXHRcdFx0XHRcdFx0XHQgICAgfVxyXG5cdFx0XHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdFx0XHRcdC8vIHJlcyA9IHJlcyArICd9JztcclxuXHRcdFx0XHRcdFx0XHRyZXMucHVzaCgnfScpO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9O1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKHQgPT0gJ3N0cmluZycpIHtcclxuXHRcdFx0XHQvLyBFc2NhcGUgY2hhcmFjdGVycyBpbiBKU09OIHN0cmluZz9cclxuXHRcdFx0XHQvLyByZXMgPSAnXCInICsgb2JqICsgJ1wiJztcclxuXHRcdFx0XHRyZXMucHVzaCgnXCInICsgb2JqICsgJ1wiJyk7XHJcblx0XHRcdH0gZWxzZSBpZiAodCA9PSAndW5kZWZpbmVkJykge1xyXG5cdFx0XHRcdHJlcyA9IFsgJ3VuZGVmaW5lZCcgXTtcclxuXHRcdFx0fSBlbHNlIGlmICh0ID09ICdmdW5jdGlvbicpIHtcclxuXHRcdFx0XHQvL2lmIChpbmNsdWRlRnVuY3Rpb25zICE9PSBmYWxzZSkge1xyXG5cdFx0XHRcdGlmICghIWluY2x1ZGVGdW5jdGlvbnMpIHtcclxuXHRcdFx0XHRcdHJlcyA9IFtvYmoudG9TdHJpbmcoKV07XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHJlcyA9IFtvYmoudG9TdHJpbmcoKV07XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIHJlcy5qb2luKCcnKTtcclxuXHRcdH07IC8vIHZhciBfc3RyaW5naWZ5ID1cclxuXHJcblx0XHRyZXR1cm4gX3N0cmluZ2lmeShvYmosIGluY2x1ZGVGdW5jdGlvbnMpO1xyXG5cdH07XHJcblxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICogUmV0dXJucyBhIHR5cGUgc2lnbmF0dXJlIGZvciB0aGUgZ2l2ZW4gdmFsdWUuXHJcbiAgICAqIFBvc3NpYmxlIHJlc3VsdHMgYXJlOlxyXG4gICAgKiAtIFwic1wiIChzdHJpbmcpXHJcbiAgICAqIC0gXCJuXCIgKG51bWJlcilcclxuICAgICogLSBcImJcIiAoYm9vbGVhbilcclxuICAgICogLSBcImZcIiAoZnVuY3Rpb24pXHJcbiAgICAqIC0gXCJhXCIgKGFycmF5KVxyXG4gICAgKiAtIFwib1wiIChvYmplY3QpXHJcbiAgICAqIC0gXCJ1XCIgKHVuZGVmaW5lZClcclxuICAgICogLSBcIiFcIiAobnVsbClcclxuICAgICogLSBcImNcIiAoY29udHJvbClcclxuICAgICogLSBcInJcIiAoUmVnRXgpXHJcbiAgICAqIC0gXCJCXCIgKEJ1ZmZlcilcclxuICAgICogLSBcIlJcIiAocmVhZGFibGVfc3RyZWFtKVxyXG4gICAgKiAtIFwiV1wiICh3cml0YWJsZV9zdHJlYW0pXHJcbiAgICAqIC0gXCJYXCIgKGNvbGxlY3Rpb25faW5kZXgpXHJcbiAgICAqIC0gXCJEXCIgKGRhdGFfb2JqZWN0KVxyXG4gICAgKiAtIFwifkRcIiAoYWJzdHJhY3QgZGF0YV9vYmplY3QpXHJcbiAgICAqIC0gXCJWXCIgKGRhdGFfdmFsdWUpXHJcbiAgICAqIC0gXCJ+VlwiIChhYnN0cmFjdCBkYXRhX3ZhbHVlKVxyXG4gICAgKiAtIFwiQ1wiIChjb2xsZWN0aW9uKVxyXG4gICAgKiAtIFwifkNcIiAoYWJzdHJhY3QgY29sbGVjdGlvbilcclxuICAgICogQGZ1bmNcclxuICAgICogQHBhcmFtIHsqfSBpIC0gdmFsdWUgdG8gZ2V0IHRoZSB0eXBlIHNpZ25hdHVyZVxyXG4gICAgKiBAcGFyYW0geyp9IFthcnJfZGVwdGhdIC0gYXJyYXkgbmVzdGluZyBkZXB0aCB0byBpbmNsdWRlIHRoZSBhcnJheSBlbGVtZW50IHNpZ25hdHVyZXNcclxuICAgICogQG1lbWJlcm9mIG1vZHVsZTpjb3JlL2pzZ3VpLWxhbmctZXNzZW50aWFsc1xyXG4gICAgKiBAZXhhbXBsZVxyXG4gICAgKiBnZXRfaXRlbV9zaWcoMSkgPT0+ICduJ1xyXG4gICAgKiBnZXRfaXRlbV9zaWcoXCIxXCIpID09PiAncydcclxuICAgICogZ2V0X2l0ZW1fc2lnKFsxLCAyXSkgPT0+ICdhJ1xyXG4gICAgKiBnZXRfaXRlbV9zaWcoWzEsIDJdLCAxKSA9PT4gJ1tuLG5dJ1xyXG4gICAgKi9cclxuXHJcbiAgdmFyIGdldF9hX3NpZyA9IGZ1bmN0aW9uKGEpIHtcclxuICAgIC8vIEZvciBhcmd1bWVudHNcclxuICAgIC8vIFN0cmluZyBidWlsZGluZyBvcHRpbWl6ZWQgZm9yIG5ld2VyIEpTP1xyXG5cclxuICAgIHZhciBjID0gMCwgbCA9IGEubGVuZ3RoO1xyXG4gICAgdmFyIHJlcyA9ICdbJztcclxuICAgIHZhciBmaXJzdCA9IHRydWU7XHJcbiAgICBmb3IgKGMgPSAwOyBjIDwgbDsgYysrKSB7XHJcbiAgICAgIGlmICghZmlyc3QpIHtcclxuICAgICAgICByZXMgPSByZXMgKyAnLCc7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZmlyc3QgPSBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgICByZXMgPSByZXMgKyBnZXRfaXRlbV9zaWcoYVtjXSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmVzID0gcmVzICsgJ10nO1xyXG4gICAgcmV0dXJuIHJlcztcclxuXHJcbiAgfVxyXG5cclxuXHJcblx0dmFyIGdldF9pdGVtX3NpZyA9IGZ1bmN0aW9uKGksIGFycl9kZXB0aCkge1xyXG5cclxuXHQgICAgLy8gYW4gb3B0aW9uIGFib3V0IGhvdyBmYXIgaW50byB0aGUgYXJyYXkgdG8gbG9vay5cclxuXHJcblxyXG5cclxuXHRcdC8vIGFsc28gd2FudCB0byBiZSBhYmxlIHRvIGRvIHBvbHltb3JwaGljIHJlYXJyYW5nZW1lbnRzLlxyXG5cdFx0Ly8gdGhlc2Ugd2lsbCBuZWVkIHRvIGJlIHNwZWNpZmllZCBzbyB0aGV5IGdldCByZWFycmFuZ2VkIGFzIHJlcXVpcmVkLlxyXG5cdFx0Ly8gd2lsbCBjaGVjayBmb3Igc29tZSBzaWduYXR1cmVzIGFuZCByZWFycmFuZ2UgdGhlIGFyZ3VtZW50cywgYW5kXHJcblx0XHQvLyByZXR1cm4gdGhhdCBhcnJheS4gV2lsbCBiZSB1c2VmdWwgYWxsIG92ZXIgdGhlIHBsYWNlIGluIHRoZSBsaWJyYXJ5LlxyXG5cclxuXHRcdC8vIHYyID0gW2ksIGldLCB2MyA9IFtpLCBpLCBpXVxyXG5cdFx0Ly8gb3IgZXZlbiBpMiA9IFtpLCBpXT8gbWF5YmUgbm90IGZvciB0aGUgbW9tZW50LCBwbGVudHkgb2ZcclxuXHRcdC8vIHNpbXBsaWZpY2F0aW9uIGFscmVhZHksIGNvdWxkIG1heWJlIGV4cHJlc3MgdGhpbmdzIGxpa2UgdGhhdCBhdCBzb21lXHJcblx0XHQvLyBzdGFnZS5cclxuXHJcblx0XHQvLyByZWFycmFuZ2VtZW50IC0gJ1tpLCBpXSwgcycgPC0gJ3MsIFtpLCBpXSdcclxuXHRcdC8vIGlmIHNlY29uZCBhcnJhbmdlbWVudCwgb3V0cHV0IHRoZSBpdGVtcyBpbiB0aGUgb3JkZXIgZ2l2ZW4uXHJcblx0XHQvLyB0aGF0IHNlZW1zIHRvIHJlcXVpcmUgcGFyc2luZyB0aGVzZSBzaWduYXR1cmUgc3RyaW5ncy5cclxuXHJcblx0XHQvLyByZXR1cm5zIHRoZSBwb2x5bW9ycGhpYyBzaWduYXR1cmUuXHJcblx0XHQvLyBzYW1lIGZvciBlYWNoIGl0ZW0gaW4gdGhlIGFycmF5LlxyXG5cclxuXHRcdC8vIHdpbGwgZ2V0IHRoZSBwb2x5IHNpZ25hdHVyZSBmb3IgZWFjaCBpdGVtIGluIHRoZSBhcnJheT9cclxuXHRcdC8vIGlzIGl0IGFuIGFycmF5P1xyXG5cclxuXHJcblx0XHR2YXIgcmVzO1xyXG5cdFx0dmFyIHQxID0gdHlwZW9mIGk7XHJcblxyXG5cdFx0Ly8gY291bGQgcG9zc2libHkgaGF2ZSB0d28gZnVuY3Rpb25zIC0gb25lIHRoYXQgd2lsbCBiZSB2ZXJ5IGZhc3QsIGFuZCBhIG1vcmUgZHluYW1pYywgc2xvd2VyIG9uZS5cclxuXHJcblxyXG5cclxuXHRcdGlmICh0MSA9PT0gJ3N0cmluZycpIHtcclxuXHRcdFx0cmVzID0gJ3MnO1xyXG5cdFx0fSBlbHNlIGlmICh0MSA9PT0gJ251bWJlcicpIHtcclxuXHRcdFx0cmVzID0gJ24nO1xyXG5cdFx0fSBlbHNlIGlmICh0MSA9PT0gJ2Jvb2xlYW4nKSB7XHJcblx0XHRcdHJlcyA9ICdiJztcclxuXHRcdH0gZWxzZSBpZiAodDEgPT09ICdmdW5jdGlvbicpIHtcclxuXHRcdFx0cmVzID0gJ2YnO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dmFyIHQgPSB0b2YoaSwgdDEpO1xyXG5cclxuXHRcdFx0Ly9pZiAoaSA9PT0gMCkge1xyXG5cdFx0XHRcdC8vY29uc29sZS5sb2coJ2kgJyArIGkpO1xyXG5cdFx0XHRcdC8vY29uc29sZS5sb2coJ3QgJyArIHQpO1xyXG5cdFx0XHQvL31cclxuXHJcbiAgICAgIC8vIEJ1dCB3aXRoIGFycmF5LWxpa2U/XHJcblxyXG5cclxuXHJcblx0XHRcdC8vY29uc29sZS5sb2coJ2kgJyArIGkpO1xyXG5cdFx0XHQvL2NvbnNvbGUubG9nKCd0ICcgKyB0KTtcclxuXHJcblx0XHRcdC8vIGxpa2VseSB0byB1c2UgYSBtYXAgZm9yIHRoaXMgbG9naWMgaW5zdGVhZC5cclxuXHRcdFx0Ly8gY29uc29sZS5sb2coJ3QgJyArIHQpO1xyXG5cdFx0XHRpZiAodCA9PT0gJ2FycmF5Jykge1xyXG5cclxuXHRcdFx0ICAgIC8vIGxvb2sgaW50byBpdCB3aXRoIG9uZSBuZXN0ZWQgbGV2ZWwuLi5cclxuXHRcdFx0ICAgIGlmIChhcnJfZGVwdGgpIHtcclxuXHRcdFx0ICAgICAgICByZXMgPSAnWydcclxuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgYyA9IDAsIGwgPSBpLmxlbmd0aDsgYyA8IGw7IGMrKykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGMgPiAwKSByZXMgPSByZXMgKyAnLCc7XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXMgPSByZXMgKyBnZXRfaXRlbV9zaWcoaVtjXSwgYXJyX2RlcHRoIC0gMSk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgcmVzID0gcmVzICsgJ10nO1xyXG5cdFx0XHQgICAgfSBlbHNlIHtcclxuXHRcdFx0ICAgICAgICByZXMgPSAnYSc7XHJcblx0XHRcdCAgICB9XHJcblx0XHRcdCAgICAvL2NvbnNvbGUubG9nKCdyZXMqICcgKyByZXMpO1xyXG5cclxuXHRcdFx0XHQvLyByZXR1cm4gcmVzO1xyXG5cdFx0XHQvL30gZWxzZSBpZiAodCA9PSAnc3RyaW5nJykge1xyXG5cdFx0XHRcdC8vIGlzIGl0IGEgc3RyaW5nIHRoYXQgcGFyc2VzIHRvIGFuIGludGVnZXI/XHJcblx0XHRcdFx0Ly8gcGFyc2VzIHRvIGEgZGVjaW1hbCBudW1iZXJcclxuXHRcdFx0XHQvLyBwYXJzZXMgdG8gYW4gcmdiIHZhbHVlXHJcblx0XHRcdFx0Ly8gcGFyc2VzIHRvIGhleCB2YWx1ZVxyXG5cdFx0XHRcdC8vIHZhcmlvdXMgc3RyaW5nIHJlZ2V4cyB1c2VkIChvcHRpb25hbGx5KSwgY2FuIHNheSB3aGF0IHdlIGFyZVxyXG5cdFx0XHRcdC8vIGxvb2tpbmcgZm9yIChmb3IgdmFyaW91cyBwYXJhbWV0ZXJzKS5cclxuXHRcdFx0XHQvLyBtYXkgd2FudCBhIHF1aWNrIGJhc2ljIHBvbHkuXHJcblxyXG5cdFx0XHQvL1x0cmVzID0gJ3MnO1xyXG5cdFx0XHQvL30gZWxzZSBpZiAodCA9PSAnYm9vbGVhbicpIHtcclxuXHRcdFx0Ly9cdHJlcyA9ICdiJztcclxuXHRcdFx0Ly99IGVsc2UgaWYgKHQgPT0gJ2Z1bmN0aW9uJykge1xyXG5cdFx0XHQvL1x0cmVzID0gJ2YnO1xyXG4gICAgfSBlbHNlIGlmICh0ID09PSAnY29udHJvbCcpIHtcclxuXHRcdFx0XHRyZXMgPSAnYyc7XHJcblx0XHRcdH0gZWxzZSBpZiAodCA9PT0gJ2RhdGUnKSB7XHJcblx0XHRcdFx0cmVzID0gJ2QnO1xyXG5cdFx0XHR9IGVsc2UgaWYgKHQgPT09ICdyZWdleCcpIHtcclxuXHRcdFx0XHRyZXMgPSAncic7XHJcblx0XHRcdH0gZWxzZSBpZiAodCA9PT0gJ2J1ZmZlcicpIHsgLy8gbWF5IHJlbW92ZSBmb3Igbm9uIG5vZGUuanMuXHJcblx0XHRcdFx0cmVzID0gJ0InO1xyXG5cdFx0XHQvL30gZWxzZSBpZiAodCA9PSAnc3RyZWFtJykgeyAvLyBtYXkgcmVtb3ZlIGZvciBub24gbm9kZS5qcy5cclxuXHRcdFx0Ly9cdHJlcyA9ICdTJztcclxuXHJcblx0XHRcdC8vIFdpbGwgYWxzbyBpbmNvcnBvcmF0ZSBkdWJwbGV4IGFuZCB0cmFuc2Zvcm1hdGlvbiBzdHJlYW1zLlxyXG5cclxuICAgIH0gZWxzZSBpZiAodCA9PT0gJ3JlYWRhYmxlX3N0cmVhbScpIHsgLy8gbWF5IHJlbW92ZSBmb3Igbm9uIG5vZGUuanMuXHJcblx0XHRcdFx0cmVzID0gJ1InO1xyXG5cdFx0XHR9IGVsc2UgaWYgKHQgPT09ICd3cml0YWJsZV9zdHJlYW0nKSB7IC8vIG1heSByZW1vdmUgZm9yIG5vbiBub2RlLmpzLlxyXG5cdFx0XHRcdHJlcyA9ICdXJztcclxuXHRcdFx0Ly99IGVsc2UgaWYgKHQgPT0gJ251bWJlcicpIHtcclxuXHRcdFx0XHQvLyBpcyBpdCBhbiBpbnRlZ2VyP1xyXG5cdFx0XHRcdC8vIGlzIGl0IGEgZGVjaW1hbD9cclxuXHJcblx0XHRcdFx0Ly8gYXJlIHdlIGNoZWNraW5nIGZvciB0aG9zZSBhbnl3YXk/IG1heWJlIG5vdCBieSBkZWZhdWx0LlxyXG5cclxuXHRcdFx0Ly9cdHJlcyA9ICduJztcclxuICAgIH0gZWxzZSBpZiAodCA9PT0gJ29iamVjdCcpIHtcclxuXHJcblx0XHRcdFx0Ly8gbm90IHN1cmUgYWJvdXQgc2hvd2luZyBhbGwgdGhlIGRldGFpbHMgb2YgdGhlIG9iamVjdC5cclxuXHJcblx0XHRcdFx0cmVzID0gJ28nO1xyXG5cdFx0XHR9IGVsc2UgaWYgKHQgPT09ICd1bmRlZmluZWQnKSB7XHJcblx0XHRcdFx0cmVzID0gJ3UnO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRpZiAodCA9PSAnY29sbGVjdGlvbl9pbmRleCcpIHtcclxuXHRcdFx0XHRcdHJldHVybiAnWCc7XHJcblx0XHRcdFx0fSBlbHNlIGlmICh0ID09PSAnZGF0YV9vYmplY3QnKSB7XHJcblx0XHRcdFx0XHRpZiAoaS5fYWJzdHJhY3QpIHtcclxuXHRcdFx0XHRcdFx0cmVzID0gJ35EJztcclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdHJlcyA9ICdEJztcclxuXHRcdFx0XHRcdH1cclxuXHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRpZiAodCA9PT0gJ2RhdGFfdmFsdWUnKSB7XHJcblx0XHRcdFx0XHRcdGlmIChpLl9hYnN0cmFjdCkge1xyXG5cdFx0XHRcdFx0XHRcdHJlcyA9ICd+Vic7XHJcblx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdFx0cmVzID0gJ1YnO1xyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSBpZiAodCA9PT0gJ251bGwnKSB7XHJcblx0XHRcdFx0XHRcdHJlcyA9ICchJztcclxuXHRcdFx0XHRcdH0gZWxzZSBpZiAodCA9PT0gJ2NvbGxlY3Rpb24nKSB7XHJcblx0XHRcdFx0XHRcdGlmIChpLl9hYnN0cmFjdCkge1xyXG5cdFx0XHRcdFx0XHRcdHJlcyA9ICd+Qyc7XHJcblx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdFx0cmVzID0gJ0MnO1xyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblxyXG5cdFx0XHRcdFx0XHQvL2NvbnNvbGUubG9nKCd0ICcgKyB0KTtcclxuXHRcdFx0XHRcdFx0dGhyb3cgJ1VuZXhwZWN0ZWQgb2JqZWN0IHR5cGUgJyArIHQ7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvLyBNYXkgaGF2ZSBkZWNpbWFsIHR5cGUgYXMgd2VsbD9cclxuXHJcblx0XHRcdFx0Ly8gZCBmb3IgdGhlIG1vbWVudD9cclxuXHRcdFx0XHQvLyAgTWF5IHdhbnQgZGVjaW1hbCBudW1iZXJzIHRvbz9cclxuXHRcdFx0XHQvLyAgRCBpcyBiZXR0ZXIgZm9yIERhdGFfT2JqZWN0LlxyXG5cclxuXHRcdFx0XHQvLyBjIGZvciBDb250cm9sXHJcblx0XHRcdFx0Ly8gQyBmb3IgQ29sbGVjdGlvblxyXG5cclxuXHRcdFx0XHQvLyBDb3VsZCBzYXkgRGF0YV9PYmplY3QgaXMgRFxyXG5cdFx0XHRcdC8vIENvbGxlY3Rpb24gaXMgQz9cclxuXHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiByZXM7XHJcblxyXG5cdH07XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBSZW1vdmVzIHRoZSBsZWFkaW5nIGFuZCB0cmFpbGluZyBzcXVhcmUgYnJhY2tldHMgZnJvbSB0aGUgc2lnbmF0dXJlLCBpZiB0aGUgYnJhY2tldHMgYXJlIHByZXNlbnRlZC5cclxuICAgICogQGZ1bmNcclxuICAgICogQHBhcmFtIHtzdHJpbmd9IHNpZyAtIHRoZSBzaWduYXR1cmVcclxuICAgICogQG1lbWJlcm9mIG1vZHVsZTpjb3JlL2pzZ3VpLWxhbmctZXNzZW50aWFsc1xyXG4gICAgKiBAZXhhbXBsZVxyXG4gICAgKiB0cmltX3NpZ19icmFja2V0cyhcIltuXVwiKSA9PT4gXCJuXCJcclxuICAgICogdHJpbV9zaWdfYnJhY2tldHMoXCJuXCIpID09PiBcIm5cIlxyXG4gICAgKi9cclxuXHR2YXIgdHJpbV9zaWdfYnJhY2tldHMgPSBmdW5jdGlvbihzaWcpIHtcclxuXHQgICAgaWYgKHRvZihzaWcpID09PSAnc3RyaW5nJykge1xyXG5cdCAgICAgICAgaWYgKHNpZy5jaGFyQXQoMCkgPT0gJ1snICYmIHNpZy5jaGFyQXQoc2lnLmxlbmd0aCAtIDEpID09ICddJykge1xyXG5cdFx0XHRcdHJldHVybiBzaWcuc3Vic3RyaW5nKDEsIHNpZy5sZW5ndGggLSAxKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRyZXR1cm4gc2lnO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fTtcclxuXHJcbiAgICAvKipcclxuICAgICogUmV0dXJucyBhbiBhcnJheSB3aXRob3V0IHRoZSB0cmFpbGluZyB1bmRlZmluZWQgdmFsdWVzLCBtYWRlIGZyb20gdGhlIGFycmF5LWxpa2Ugc291cmNlLlxyXG4gICAgKiBAZnVuY1xyXG4gICAgKiBAcGFyYW0ge2FycmF5LWxpa2V9IGFycl9saWtlIC0gdGhlIHNvdXJjZVxyXG4gICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvcmUvanNndWktbGFuZy1lc3NlbnRpYWxzXHJcbiAgICAqIEBleGFtcGxlXHJcbiAgICAqIGFycl90cmltX3VuZGVmaW5lZChbdW5kZWZpbmVkLCAxLCB1bmRlZmluZWRdKSA9PT4gW3VuZGVmaW5lZCwgMV1cclxuICAgICovXHJcblx0dmFyIGFycl90cmltX3VuZGVmaW5lZCA9IGZ1bmN0aW9uKGFycl9saWtlKSB7XHJcblx0XHR2YXIgcmVzID0gW107XHJcblx0XHR2YXIgbGFzdF9kZWZpbmVkID0gLTE7XHJcblx0XHR2YXIgdCwgdjtcclxuXHRcdGZvciAodmFyIGMgPSAwLCBsID0gYXJyX2xpa2UubGVuZ3RoOyBjIDwgbDsgYysrKSB7XHJcblx0XHRcdHYgPSBhcnJfbGlrZVtjXTtcclxuXHRcdFx0dCA9IHRvZih2KTtcclxuXHRcdFx0aWYgKHQgPT0gJ3VuZGVmaW5lZCcpIHtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0bGFzdF9kZWZpbmVkID0gYztcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAodmFyIGMgPSAwLCBsID0gYXJyX2xpa2UubGVuZ3RoOyBjIDwgbDsgYysrKSB7XHJcblx0XHRcdGlmIChjIDw9IGxhc3RfZGVmaW5lZCkge1xyXG5cdFx0XHRcdHJlcy5wdXNoKGFycl9saWtlW2NdKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHJlcztcclxuXHR9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBIZWxwcyB0byBjcmVhdGUgYSBwb2x5bW9ycGhpYyB2ZXJzaW9uIG9mIHRoZSBwYXNzZWQgZnVuY3Rpb24uIFRoZSBmdW5jdGlvbiB3aWxsIGdldCAyIHBhcmFtZXRlcnM6IGBhYCBhbmQgYHNpZ2AuXHJcbiAgICAqIEFycmF5IGBhYCB3aWxsIGNvbnRhaW5zIHRoZSBhY3R1YWwgcGFyYW1ldGVycywgYGEubGAgcHJvcGVydHkgd2lsbCBjb250YWlucyB0aGUgcGFyYW1ldGVycyBjb3VudC5cclxuICAgICogVGhlIGBzaWdgIHBhcmFtZXRlciB3aWxsIGNvbnRhaW5zIHRoZSBwYXJhbWV0ZXIgdHlwZXMgYXJyYXkgc2lnbmF0dXJlLiBUaGUgZnVuY3Rpb24gd2lsbCB1c2UgdGhlc2UgcGFyYW1ldGVyc1xyXG4gICAgKiB0byBzZWxlY3QgYSByZXF1aXJlZCBwb2x5bW9ycGhpYyBjb2RlIGJyYW5jaCB0byBleGVjdXRlLlxyXG4gICAgKiBAZnVuY1xyXG4gICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSAtIG5vdCB1c2VkXHJcbiAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuIC0gdGhlIGZ1bmN0aW9uXHJcbiAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29yZS9qc2d1aS1sYW5nLWVzc2VudGlhbHNcclxuICAgICogQGV4YW1wbGVcclxuICAgICogdmFyIG15RnVuYyA9IGZ1bmN0aW9uYWxfcG9seW1vcnBoaXNtKGZ1bmN0aW9uKGEsIHNpZyl7XHJcbiAgICAqICAgIHJldHVybiBzdHJpbmdpZnkoYSkgKyBcIjogXCIgKyBzaWc7XHJcbiAgICAqIH0pO1xyXG4gICAgKlxyXG4gICAgKiBteUZ1bmMoMSwgXCJhXCIsIFtudWxsXSkgID09PiAgJ1sxLCBcImFcIiwgW251bGxdXTogW24scyxhXSdcclxuICAgICpcclxuICAgICovXHJcblx0dmFyIGZ1bmN0aW9uYWxfcG9seW1vcnBoaXNtID0gZnVuY3Rpb24ob3B0aW9ucywgZm4pIHtcclxuXHRcdHZhciBhMCA9IGFyZ3VtZW50cztcclxuXHRcdGlmIChhMC5sZW5ndGggPT09IDEpIHtcclxuXHRcdFx0Zm4gPSBhMFswXTtcclxuXHRcdFx0b3B0aW9ucyA9IG51bGw7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly9pcyB0aGVyZSBhIHRoaXM/XHJcblxyXG5cdFx0Ly92YXIgdGhhdCA9IHRoaXM7XHJcblx0XHQvL3ZhciBfc3VwZXIgPSB0aGF0Ll9zdXBlcjtcclxuXHJcblx0XHQvLyBub3QgaGF2aW5nIGFjY2VzcyB0byB0aGlzIGhlcmVcclxuXHRcdHZhciBhcnJfc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XHJcblx0XHR2YXIgYXJyLCBzaWcsIGEyLCBsLCBhO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbigpIHtcclxuXHJcblx0XHRcdC8vdGhhdCA9IHRoaXM7XHJcblxyXG5cdFx0XHQvLyBub3Qgc3VyZSB3ZSB3YW50IHN1cGVyIGhlcmU/XHJcblx0XHRcdC8vICBXZSBoYXJkbHkgZXZlciB1c2UgdGhpcywgaXQgd291bGQgc2xvdyB0aGluZ3MgZG93bi5cclxuXHRcdFx0Ly92YXIgX3N1cGVyID0gdGhhdC5fc3VwZXI7XHJcblxyXG5cdFx0XHRhID0gYXJndW1lbnRzO1xyXG5cdFx0XHQvLyBhbmQgaWYgdGhlcmUgaXMgYW4gYXJyYXkgb2YgYXJndW1lbnRzIGdpdmVuLi4uIGdpdmUgYXMgb25lXHJcblx0XHRcdC8vIGFyZ3VtZW50LlxyXG5cdFx0XHRsID0gYS5sZW5ndGg7XHJcblxyXG5cdFx0XHRpZiAobCA9PT0gMSkge1xyXG5cdFx0XHRcdHNpZyA9IGdldF9pdGVtX3NpZyhbYVswXV0sIDEpO1xyXG5cdFx0XHRcdC8vY29uc29sZS5sb2coJ2ZwIHNpZywgYS5sID09IDEgJyArIHNpZyk7XHJcblx0XHRcdFx0Ly8gYSAnbCcgcHJvcGVydHkgZ2l2ZW4gdG8gYXJyYXkgZ2l2ZW5cclxuXHRcdFx0XHRhMiA9IFthWzBdXTtcclxuXHRcdFx0XHRhMi5sID0gMTtcclxuXHRcdFx0XHQvL3JldHVybiBmbi5jYWxsKHRoYXQsIGEyLCBzaWcsIF9zdXBlcik7XHJcblx0XHRcdFx0cmV0dXJuIGZuLmNhbGwodGhpcywgYTIsIHNpZyk7XHJcblx0XHRcdH0gZWxzZSBpZiAobCA+IDEpIHtcclxuXHRcdFx0XHQvL3ZhciBhcnIgPSBhcnJfbGlrZV90b19hcnIoYSk7XHJcblx0XHRcdFx0Ly92YXIgYXJyID0gYXJyX3NsaWNlLmNhbGwoYSwgMCk7XHJcblx0XHRcdFx0Ly9cclxuXHRcdFx0XHRhcnIgPSBhcnJfdHJpbV91bmRlZmluZWQoYXJyX3NsaWNlLmNhbGwoYSwgMCkpO1xyXG5cclxuXHRcdFx0XHQvL2FyciA9IGFycl90cmltX3VuZGVmaW5lZChhcnIpO1xyXG5cdFx0XHRcdC8vdmFyIHNpZyA9IGdldF9pdGVtX3NpZyhhcnIsIDEpO1xyXG5cdFx0XHRcdHNpZyA9IGdldF9pdGVtX3NpZyhhcnIsIDEpO1xyXG5cdFx0XHRcdC8vYXJyLmwgPSBsO1xyXG5cdFx0XHRcdGFyci5sID0gYXJyLmxlbmd0aDtcclxuXHRcdFx0ICAgIC8vY29uc29sZS5sb2coJ2Fyci5sICcgKyBhcnIubCk7XHJcblx0XHRcdFx0Ly9yZXR1cm4gZm4uY2FsbCh0aGF0LCBhcnIsIHNpZywgX3N1cGVyKTtcclxuXHRcdFx0XHRyZXR1cm4gZm4uY2FsbCh0aGlzLCBhcnIsIHNpZyk7XHJcblx0XHRcdH0gZWxzZSBpZiAoYS5sZW5ndGggPT09IDApIHtcclxuXHRcdFx0XHRhcnIgPSBuZXcgQXJyYXkoMCk7XHJcblx0XHRcdFx0YXJyLmwgPSAwO1xyXG5cdFx0XHRcdC8vcmV0dXJuIGZuLmNhbGwodGhhdCwgYXJyLCAnW10nLCBfc3VwZXIpO1xyXG5cdFx0XHRcdHJldHVybiBmbi5jYWxsKHRoaXMsIGFyciwgJ1tdJyk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBBIHNob3J0Y3V0IGZvciB0aGUgW2Z1bmN0aW9uYWxfcG9seW1vcnBoaXNtKClde0BsaW5rIG1vZHVsZTpjb3JlL2pzZ3VpLWxhbmctZXNzZW50aWFscy5mdW5jdGlvbmFsX3BvbHltb3JwaGlzbX0gZnVuY3Rpb24uXHJcbiAgICAqIEBmdW5jXHJcbiAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29yZS9qc2d1aS1sYW5nLWVzc2VudGlhbHNcclxuICAgICovXHJcbiAgICB2YXIgZnAgPSBmdW5jdGlvbmFsX3BvbHltb3JwaGlzbTtcclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFJldHVybnMgYW4gYXJyYXkgY29udGFpbmluZyBba2V5LCB2YWx1ZV0gYXJyYXlzIG9mIHRoZSBwYXNzZWQgb2JqZWN0IHByb3BlcnRpZXMuPGJyIC8+XHJcbiAgICAqXHJcbiAgICAqIEBuYW1lIGFycmF5aWZ5XHJcbiAgICAqIEBmdW5jXHJcbiAgICAqIEBwYXJhbSB7b2JqZWN0fSBvYmogLSBhcnJheWlmaW5nIG9iamVjdFxyXG4gICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvcmUvanNndWktbGFuZy1lc3NlbnRpYWxzXHJcbiAgICAqXHJcbiAgICAqIEBleGFtcGxlXHJcbiAgICAqXHJcbiAgICAqIGFycmF5aWZ5KHthOiAxLCBiOiAyfSkgID09PiBbW1wiYVwiLCAxXSwgW1wiYlwiLCAyXV1cclxuICAgICpcclxuICAgICovXHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBSZXR1cm5zIGFuIGFycmF5aWZpZWQgdmVyc2lvbiBvZiB0aGUgZnVuY3Rpb24uIFRoZSBhcnJheWlmaWVkIHZlcnNpb24gYWNjZXB0cyBhbiBhcnJheSBvZiB2YWx1ZXMgaW5zdGVhZCBvZiBzaW5nbGUgdmFsdWUgZm9yIHNvbWUgcGFyYW1ldGVyLlxyXG4gICAgKiBGb3IgZXhhbXBsZTogYGZ1bmMoYSwgYikgPT0+IGFycmF5aWZpZWRfZnVuYyhbYV0sIGIpYFxyXG4gICAgKiBUaGUgb3JpZ2luYWwgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgc2V2ZXJhbCB0aW1lcywgb25lIHRpbWUgZm9yIGVhY2ggdmFsdWUgZnJvbSB0aGUgYXJyYXkuIFRoZSByZXN1bHQgb2YgdGhlIGFycmF5aWZpZWQgZnVuY3Rpb25cclxuICAgICogd2lsbCBiZSBhbiBhcnJheSBjb250YWluaW5nIHRoZSBvcmlnaW5hbCBmdW5jdGlvbiByZXR1cm4gdmFsdWVzLlxyXG4gICAgKlxyXG4gICAgKiBCeSBkZWZhdWx0IGl0IGFycmF5aWZpZXMgdGhlIGZpcnN0IHBhcmFtZXRlci4gWW91IGNhbiBzcGVjaWZ5IHRoZSBhcnJheWlmeWluZyBwYXJhbWV0ZXIgaW5kZXggYXMgdGhlIGZpcnN0IGFyZ3VtZW50IG9mIHRoZSBhcnJheWlmeSgpIGZ1bmN0aW9uOiA8YnIgLz5cclxuICAgICogYGFycmF5aWZ5KGZ1bmMpICA9PT4gIGFycmF5aWZpZWRfZnVuYyhbYV0sIGIsIGMsIGQsIC4uLilgIDxiciAvPlxyXG4gICAgKiBgYXJyYXlpZnkoMiwgZnVuYykgID09PiAgYXJyYXlpZmllZF9mdW5jKGEsIGIsIFtjXSwgZCwgLi4uKWBcclxuICAgICpcclxuICAgICogWW91IGNhbiBhcnJheWlmeSBhbiBhc3luYyBmdW5jdGlvbiBhcyB3ZWxsLiBJZiB0aGUgdmVyeSBsYXN0IGFyZ3VtZW50IHBhc3NlZCB0byB0aGUgYXJyYXlpZmllZCB2ZXJzaW9uIGlzIGZ1bmN0aW9uLCB0aGVuIHRoaXMgY2FzZSBpcyBjb25zaWRlcmVkXHJcbiAgICAqIGFzIGFzeW5jIGZ1bmN0aW9uIGNhbGwuIFRoZSBsYXN0IHBhcmFtZXRlciBpcyBjb25zaWRlcmVkIGFzIGEgY2FsbGJhY2sgZnVuY3Rpb24gcmVjZWl2aW5nIHRoZSBhc3luYyBhcnJheSBwcm9jZXNzaW5nIGZpbmFsIHJlc3VsdC4gVGhlIGNhbGxiYWNrXHJcbiAgICAqIGZvcm1hdCBpcyBgY2FsbGJhY2soZXJyb3IsIHJlc3VsdClgLCB3aGVyZSBgZXJyb3JgIGlzIGFuIGVycm9yIG9iamVjdCBvciBudWxsLCBhbmQgYHJlc3VsdGAgaXMgdGhlIHJlc3VsdCBhcnJheS5cclxuICAgICpcclxuICAgICogVGhlIG9yaWdpbmFsIGFzeW5jIGZ1bmN0aW9uIG11c3QgY2FsbCBhIGNhbGxiYWNrIGZ1bmN0aW9uIGluIHR1cm4uIFRoZSBjYWxsYmFjayBmdW5jdGlvbiBpcyBwYXNzZWQgYXMgYSBsYXN0IGFyZ3VtZW50IHRvIHRoZSBhc3luYyBmdW5jdGlvblxyXG4gICAgKiBjYWxsLCBmb2xsb3dpbmcgdGhlIHVzdWFsIFtjYWxsX211bHRpcGxlX2NhbGxiYWNrX2Z1bmN0aW9ucygpXXtAbGluayBtb2R1bGU6Y29yZS9qc2d1aS1sYW5nLWVzc2VudGlhbHMuY2FsbF9tdWx0aXBsZV9jYWxsYmFja19mdW5jdGlvbnN9IHJ1bGVzLlxyXG4gICAgKlxyXG4gICAgKiBAZnVuY1xyXG4gICAgKiBAcGFyYW0ge251bWJlcn0gW3BhcmFtX2luZGV4ID0gMF0gLSBhcnJheWlmaW5nIHBhcmFtZXRlciBpbmRleFxyXG4gICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmbiAtIGFycmF5aWZpbmcgZnVuY3Rpb25cclxuICAgICogQG1lbWJlcm9mIG1vZHVsZTpjb3JlL2pzZ3VpLWxhbmctZXNzZW50aWFsc1xyXG4gICAgKlxyXG4gICAgKiBAZXhhbXBsZVxyXG4gICAgKlxyXG4gICAgKiAvLyAtLS0tLS0tIGFycmF5aWZpbmcgYSBmdW5jdGlvbjogLS0tLS0tLVxyXG4gICAgKlxyXG4gICAgKiB2YXIgbXVsdGlwbHkgPSBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgKiAgICAgcmV0dXJuIGEgKiBiO1xyXG4gICAgKiB9O1xyXG4gICAgKlxyXG4gICAgKiAvLyBtdWx0aXBseShbYV0sIGIpOlxyXG4gICAgKlxyXG4gICAgKiB2YXIgYXJyYXlpZmllZF9tdWx0aXBseSA9IGpzZ3VpLmFycmF5aWZ5KG11bHRpcGx5KTtcclxuICAgICpcclxuICAgICogY29uc29sZS5sb2coYXJyYXlpZmllZF9tdWx0aXBseShbMSwgNSwgMTBdLCAyKSk7ICAvLyBbMiwgMTAsIDIwXSk7XHJcbiAgICAqXHJcbiAgICAqIC8vIG11bHRpcGx5KGEsIFtiXSk6XHJcbiAgICAqXHJcbiAgICAqIHZhciBhcnJheWlmaWVkX211bHRpcGx5MiA9IGpzZ3VpLmFycmF5aWZ5KDEsIG11bHRpcGx5KTtcclxuICAgICpcclxuICAgICogY29uc29sZS5sb2coYXJyYXlpZmllZF9tdWx0aXBseTIoMTAsIFsxLCA1LCAxMF0pKTsgLy8gWzEwLCA1MCwgMTAwXSk7XHJcbiAgICAqXHJcbiAgICAqXHJcbiAgICAqIC8vIC0tLS0tLS0gYXJyYXlpZmluZyBhbiBhc3luYyBmdW5jdGlvbjogLS0tLS0tLVxyXG4gICAgKlxyXG4gICAgKiB2YXIgYXN5bmNNdWx0aXBseSA9IGZ1bmN0aW9uIChhLCBiLCBjYikge1xyXG4gICAgKiAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IGNiKG51bGwsIGEgKiBiKTsgfSwgMTAwMCk7XHJcbiAgICAqIH07XHJcbiAgICAqXHJcbiAgICAqIHZhciBhcnJheWlmaWVkX2FzeW5jTXVsdGlwbHkgPSBqc2d1aS5hcnJheWlmeShhc3luY011bHRpcGx5KTsgLy8gYXN5bmNNdWx0aXBseShbYV0sIGIsIGNiKVxyXG4gICAgKlxyXG4gICAgKiB2YXIgY2FsbGJhY2sgPSBmdW5jdGlvbiAoZXJyb3IsIHJlc3VsdCkge1xyXG4gICAgKiAgICAgY29uc29sZS5sb2coZXJyb3IpOyAgLy8gbnVsbFxyXG4gICAgKiAgICAgY29uc29sZS5sb2cocmVzdWx0KTsgLy8gWzIsIDEwLCAyMF0pO1xyXG4gICAgKiAgICAgZG9uZSgpO1xyXG4gICAgKiB9O1xyXG4gICAgKlxyXG4gICAgKiBhcnJheWlmaWVkX2FzeW5jTXVsdGlwbHkoWzEsIDUsIDEwXSwgMiwgY2FsbGJhY2spO1xyXG4gICAgKlxyXG4gICAgKi9cclxuXHR2YXIgYXJyYXlpZnkgPSBmcChmdW5jdGlvbihhLCBzaWcpIHtcclxuICAgICAgICAvLyBidXQgd2hlbiB0aGUgZnVuY3Rpb24gaGFzIGl0J3MgbGFzdCBwYXJhbWV0ZXIgYXMgYSBmdW5jdGlvbi4uLlxyXG4gICAgICAgIC8vICBjYW4gd2UgYXNzdW1lIGl0IGlzIGEgY2FsbGJhY2s/XHJcbiAgICAgICAgLy8gd2hlbiBnaXZlbiBhIHdob2xlIGJ1bmNoIG9mIHN0cmluZ3MgKG9yIG51bWJlcnMpIHRoZXNlIGNhbiBiZSB1c2VkIHRvIG1ha2UgYSBtYXAgZm9yIHRoZSByZXN1bHRzLlxyXG4gICAgICAgIC8vICBpZSBmb3IgbG9hZF9maWxlIGNvdWxkIGdpdmUgYSBidW5jaCBvZiBzdHJpbmcgZmlsZXMsIGl0IGxvYWRzIHRoZW0sIGNhbiBwcm92aWRlIHRoZSByZXN1bHRzIGFzIG9uZSBvYmplY3QuXHJcbiAgICAgICAgLy8gbWF5IGFsc28gd2FudCB0byBzcGVjaWZ5IGlmIGZ1bmN0aW9ucyBnZXQgY2FsbGVkIGluIHBhcmFsbGVsLCBhbmQgdGhlIGxpbWl0IHRvIGhvdyBtYW55IGdldCBjYWxsZWQgYXQgb25jZS5cclxuICAgICAgICAvLyB0aGlzIGNvdWxkIHRha2Ugb3B0aW9ucyBpbiB0aGUgc2lnbmF0dXJlIC0gYmUgYWJsZSB0byByZXR1cm4gYSByZXN1bHRzIG1hcC5cclxuXHRcdC8vIFdoYXQgYWJvdXQgYXJyYXlpZnlpbmcgYSBtYXAgcmF0aGVyIHRoYW4gYSBmdW5jdGlvbj9cclxuXHRcdC8vIFR1cm5zIGl0IGludG8gbmFtZS92YWx1ZSBwYWlycy4gRWFzaWVyIHRvIHByb2Nlc3Mgd2l0aCBlYWNoIG9yXHJcblx0XHQvLyBtZWFzdXJlIHRoZSBsZW5ndGggb2YuXHJcblxyXG5cdFx0Ly8gd2hhdCBhYm91dCBhIHBmIGZ1bmN0aW9uIHRoYXQgcHJvdmlkZXMgYW4gJ2EnIG1hcC5cclxuXHRcdC8vIGhhcyB3aGF0ZXZlciBwcm9wZXJ0aWVzIGhhdmUgYmVlbiBwcm92aWRlZCBhbmQgYXNrZWQgZm9yLlxyXG5cdFx0dmFyIHBhcmFtX2luZGV4LCBudW1fcGFyYWxsZWwgPSAxLCBkZWxheSA9IDAsIGZuO1xyXG5cdFx0Ly8gKHBhcmFtX2luZGV4LCBmbilcclxuXHRcdHZhciByZXM7XHJcblx0XHR2YXIgcHJvY2Vzc19hc19mbiA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0ICAgIC8vY29uc29sZS5sb2coJ3Byb2Nlc3NfYXNfZm4nKTtcclxuXHRcdFx0cmVzID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0Ly8gY291bGQgdXNlIHBmIGhlcmU/IGJ1dCBtYXliZSBub3RcclxuXHRcdFx0XHQvL2NvbnNvbGUubG9nKCdhcmd1bWVudHMubGVuZ3RoICcgKyBhcmd1bWVudHMubGVuZ3RoKTtcclxuXHRcdFx0XHQvL2NvbnNvbGUubG9nKCdhcmd1bWVudHMgJyArIHN0cmluZ2lmeShhcmd1bWVudHMpKTtcclxuXHRcdFx0XHR2YXIgYSA9IGFycl9saWtlX3RvX2Fycihhcmd1bWVudHMpLCB0cyA9IGF0b2YoYSksIHQgPSB0aGlzO1xyXG5cdFx0XHQgICAgLy9jb25zb2xlLmxvZygnYSAnICsgc3RyaW5naWZ5KGEpKTtcclxuICAgICAgICAgICAgICAgIHZhciBsYXN0X2FyZyA9IGFbYS5sZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2xhc3RfYXJnICcgKyBsYXN0X2FyZyk7XHJcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdhLmxlbmd0aCAnICsgYS5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRvZihsYXN0X2FyZykgPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGl0IHNlZW1zIGxpa2UgYSBjYWxsYmFjayBmdW5jdGlvbi5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gd2lsbCBkbyBjYWxsYmFjayByZXN1bHQgY29tcGlsYXRpb24uXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3RzW3BhcmFtX2luZGV4XSAnICsgdHNbcGFyYW1faW5kZXhdKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXJhbV9pbmRleCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHNbcGFyYW1faW5kZXhdID09ICdhcnJheScpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdmFyIHJlcyA9IFtdLCBhMiA9IGEuc2xpY2UoMSk7IC8vIGRvbid0IHRoaW5rIHRoaXMgbWFrZXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYSBjb3B5IG9mIHRoZSBhcnJheS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlcyA9IFtdOyAvLyBkb24ndCB0aGluayB0aGlzIG1ha2VzIGEgY29weSBvZiB0aGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFycmF5LlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnZm4gJyArIGZuKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJ1dCB3ZSBjYW4gbWFrZSB0aGlzIHByb2Nlc3MgYSBmdW5jdGlvbiB3aXRoIGEgY2FsbGJhY2suXHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZucyA9IFtdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWFjaChhW3BhcmFtX2luZGV4XSwgZnVuY3Rpb24oaSwgdikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5ld19wYXJhbXMgPSBhLnNsaWNlKDAsIGEubGVuZ3RoIC0gMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdfcGFyYW1zW3BhcmFtX2luZGV4XSA9IHY7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgcmVzdCBvZiB0aGUgcGFyYW1ldGVycyBhcyBub3JtYWxcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb250ZXh0LCBmdW5jdGlvbiwgcGFyYW1zXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbnMucHVzaChbdCwgZm4sIG5ld19wYXJhbXNdKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3ZhciByZXN1bHQgPSBmbi5hcHBseSh0LCBuZXdfcGFyYW1zKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdyZXN1bHQgJyArIHN0cmluZ2lmeShyZXN1bHQpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vcmVzLnB1c2gocmVzdWx0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vcmV0dXJuIHJlcztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhbGxfbXVsdGkgbm90IHdvcmtpbmcgcmlnaHQ/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2RlbGF5JywgZGVsYXkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3Rocm93ICdzdG9wJztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxfbXVsdGlwbGVfY2FsbGJhY2tfZnVuY3Rpb25zKGZucywgbnVtX3BhcmFsbGVsLCBkZWxheSwgZnVuY3Rpb24oZXJyLCByZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3JlcyAnICsgc3RyaW5naWZ5KHJlcykpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBnZXQgYmFjayB0aGUgcmVzdWx0cyBvZiB0aGUgbXVsdGlwbGUgY2FsbGJhY2sgZnVuY3Rpb25zLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICBsZXQncyBwdXQgdGhlbSBpbiBvbmUgYXJyYXkuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1heWJlIG1ha2UgcmVzdWx0IGFycmF5IGNvbmNhdCBvcHRpb25hbC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgbGlrZWx5IHRvIGJlIG5lZWRlZC5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29uY2F0IGFsbCBvZiB0aGUgYXJyYXlzIGluIHRoZSByZXN1bHRzLlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEgPSBhLmNvbmNhdC5hcHBseShhLCByZXMpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2FsbGJhY2sgPSBsYXN0X2FyZztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdsYXN0X2FyZyAnICsgbGFzdF9hcmcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIGEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmbi5hcHBseSh0LCBhKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHQvL2NvbnNvbGUubG9nKCdub3QgY2IgZm4nKTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0Ly9jb25zb2xlLmxvZygnYXJndW1lbnRzJywgYXJndW1lbnRzKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXJhbV9pbmRleCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHNbcGFyYW1faW5kZXhdID09ICdhcnJheScpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdmFyIHJlcyA9IFtdLCBhMiA9IGEuc2xpY2UoMSk7IC8vIGRvbid0IHRoaW5rIHRoaXMgbWFrZXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYSBjb3B5IG9mIHRoZSBhcnJheS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlcyA9IFtdOyAvLyBkb24ndCB0aGluayB0aGlzIG1ha2VzIGEgY29weSBvZiB0aGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFycmF5LlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnZm4gJyArIGZuKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYnV0IHdlIGNhbiBtYWtlIHRoaXMgcHJvY2VzcyBhIGZ1bmN0aW9uIHdpdGggYSBjYWxsYmFjay5cclxuXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGZvciAodmFyIGMgPSAwLCBsID0gYVtwYXJhbV9pbmRleF0ubGVuZ3RoOyBjIDwgbDsgYysrKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdCAgICAvL2FbcGFyYW1faW5kZXhdID0gYVtwYXJhbV9pbmRleF1bY107XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdCAgICBhW3BhcmFtX2luZGV4XSA9IGFyZ3VtZW50c1twYXJhbV9pbmRleF1bY107XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dmFyIHJlc3VsdCA9IGZuLmFwcGx5KHQsIGEpO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGNvbnNvbGUubG9nKCdyZXN1bHQgJyArIHN0cmluZ2lmeShyZXN1bHQpKTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXMucHVzaChyZXN1bHQpO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlYWNoKGFbcGFyYW1faW5kZXhdLCBmdW5jdGlvbihpLCB2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3ZhciBuZXdfcGFyYW1zID0gYTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFbcGFyYW1faW5kZXhdID0gdjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSByZXN0IG9mIHRoZSBwYXJhbWV0ZXJzIGFzIG5vcm1hbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGZuLmFwcGx5KHQsIGEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ3Jlc3VsdCAnICsgc3RyaW5naWZ5KHJlc3VsdCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2gocmVzdWx0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdCovXHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkodCwgYSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nKCdhLmxlbmd0aCAnICsgYS5sZW5ndGgpO1xyXG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nKCdhICcgKyBzdHJpbmdpZnkoYSkpO1xyXG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nKCdwYXJhbV9pbmRleCAnICsgcGFyYW1faW5kZXgpO1xyXG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nKCd0cyAnICsgc3RyaW5naWZ5KHRzKSk7XHJcbiAgICAgICAgICAgICAgICAvLyBidXQgaWYgdGhlIGxhc3QgZnVuY3Rpb24gdGhlcmUgaXMgYSBmdW5jdGlvbi4uLiBpdCBtYXkgYmUgYmVzdCB0byBjb21waWxlIHRoZSByZXN1bHRzIGludG8gb25lIG9iamVjdC5cclxuXHRcdFx0fTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoc2lnID09ICdbb10nKSB7XHJcblx0XHRcdHZhciByZXMgPSBbXTtcclxuXHRcdFx0ZWFjaChhWzBdLCBmdW5jdGlvbihpLCB2KSB7XHJcblx0XHRcdFx0cmVzLnB1c2goW2ksIHZdKTtcclxuXHRcdFx0fSk7XHJcblx0XHR9IGVsc2UgaWYgKHNpZyA9PSAnW2ZdJykge1xyXG5cdFx0XHRwYXJhbV9pbmRleCA9IDAsIGZuID0gYVswXTtcclxuXHRcdFx0cHJvY2Vzc19hc19mbigpO1xyXG5cdFx0fSBlbHNlIGlmIChzaWcgPT0gJ1tuLGZdJykge1xyXG5cdFx0ICAgIHBhcmFtX2luZGV4ID0gYVswXSwgZm4gPSBhWzFdO1xyXG5cdFx0XHRwcm9jZXNzX2FzX2ZuKCk7XHJcblx0XHR9IGVsc2UgaWYgKHNpZyA9PSAnW24sbixmXScpIHtcclxuICAgICAgICAgICAgcGFyYW1faW5kZXggPSBhWzBdLCBudW1fcGFyYWxsZWwgPSBhWzFdLCBmbiA9IGFbMl07XHJcbiAgICAgICAgICAgIHByb2Nlc3NfYXNfZm4oKTtcclxuICAgICAgICB9IGVsc2UgaWYgKHNpZyA9PSAnW24sbixuLGZdJykge1xyXG4gICAgICAgICAgICBwYXJhbV9pbmRleCA9IGFbMF0sIG51bV9wYXJhbGxlbCA9IGFbMV0sIGRlbGF5ID0gYVsyXSwgZm4gPSBhWzNdO1xyXG4gICAgICAgICAgICBwcm9jZXNzX2FzX2ZuKCk7XHJcbiAgICAgICAgfVxyXG5cclxuXHRcdC8vIG1heWJlIGRvbmUgd2l0aCBwZiBmb3IgZ2V0dGluZyBmdW5jdGlvbiBzaWduYXR1cmUuXHJcblx0XHQvLyBjb25zb2xlLmxvZygndXNpbmcgYXJyYXlpZnknKTtcclxuXHRcdC8vIGlmICh0eXBlb2YgcGFyYW1faW5kZXggPT0gJ3VuZGVmaW5lZCcpIHBhcmFtX2luZGV4ID0gMDtcclxuXHJcblx0XHRyZXR1cm4gcmVzO1xyXG5cdH0pO1xyXG5cclxuXHJcbiAgICAvKipcclxuICAgICogUmV0dXJucyBhbiBvYmplY3QgY29udGFpbmluZyBrZXlzIGFuZCB2YWx1ZXMgZnJvbSB0aGUgW2tleSwgdmFsdWVdIHBhaXJzIG9mIHRoZSBhcnJheS5cclxuICAgICpcclxuICAgICogQG5hbWUgbWFwaWZ5XHJcbiAgICAqIEBmdW5jXHJcbiAgICAqIEBwYXJhbSB7YXJyYXl9IGFyciAtIG1hcGlmeWluZyBhcnJheVxyXG4gICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvcmUvanNndWktbGFuZy1lc3NlbnRpYWxzXHJcbiAgICAqXHJcbiAgICAqIEBleGFtcGxlXHJcbiAgICAqXHJcbiAgICAqIG1hcGlmeShbW1wibmFtZVwiLCBcIkpvaG5cIl0sIFtcImFnZVwiLCAyMl1dKSAgPT0+IHsgbmFtZTogXCJKb2huXCIsIGFnZTogMjIgfVxyXG4gICAgKlxyXG4gICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICogVGhlIGFycmF5IGlzIGFuIG9iamVjdHMgYXJyYXkuIFRoZSBtYXBpZnkoKSBmdW5jdGlvbiBnYXRoZXJzIHZhbHVlcyBvZiB0aGUgKGJ5X3Byb3BlcnR5X25hbWUpIHByb3BlcnRpZXMuIFRoZSB2YWx1ZXMgd2lsbCBiZSBrZXlzIChwcm9wZXJ0eSBuYW1lcykgb2YgdGhlXHJcbiAgICAqIHJldHVybmluZyBvYmplY3QuIFRoZSB2YWx1ZXMgb2YgdGhlIHJldHVybmluZyBvYmplY3Qgd2lsbCBiZSB0aGUgb2JqZWN0cyBpdHNlbGYuXHJcbiAgICAqXHJcbiAgICAqIEBuYW1lIG1hcGlmeVxyXG4gICAgKiBAZnVuY1xyXG4gICAgKiBAcGFyYW0ge2FycmF5fSBhcnIgLSBtYXBpZnlpbmcgYXJyYXlcclxuICAgICogQHBhcmFtIHtzdHJpbmd9IGJ5X3Byb3BlcnR5X25hbWUgLSBtYXBwaW5nIHByb3BlcnR5IG5hbWVcclxuICAgICogQG1lbWJlcm9mIG1vZHVsZTpjb3JlL2pzZ3VpLWxhbmctZXNzZW50aWFsc1xyXG4gICAgKlxyXG4gICAgKiBAZXhhbXBsZVxyXG4gICAgKlxyXG4gICAgKiB2YXIgb2JqX2FyciA9IFt7IG5hbWU6IFwiTGFycnlcIiwgYWdlOiAyMSB9LCB7IG5hbWU6IFwiSm9oblwiLCBhZ2U6IDIyIH1dO1xyXG4gICAgKlxyXG4gICAgKiBtYXBpZnkob2JqX2FyciwgXCJuYW1lXCIpICA9PT4geyBMYXJyeTogeyBuYW1lOiBcIkxhcnJ5XCIsIGFnZTogMjEgfSwgSm9objogeyBuYW1lOiBcIkpvaG5cIiwgYWdlOiAyMiB9IH1cclxuICAgICpcclxuICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFJldHVybnMgYW4gbWFwaWZpZWQgdmVyc2lvbiBvZiB0aGUgZnVuY3Rpb24uIFRoZSBvcmdpbmFsIGZ1bmN0aW9uIHJlY2VpdmVzIDIgcGFyYW1ldGVyczoga2V5IGFuZCB2YWx1ZS4gVGhlIG1hcGlmaWVkIHZlcnNpb24gcmVjZWl2ZXMgYW4gb2JqZWN0LCBhbmRcclxuICAgICogY2FsbHMgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uIGZvciBlYWNoIGtleS92YWx1ZSBwYWlyIG9mIHRoZSBvYmplY3QuXHJcbiAgICAqXHJcbiAgICAqIFlvdSBjYW4gbWFwaWZ5IGFuIGFzeW5jIGZ1bmN0aW9uIGFzIHdlbGwuIElmIHlvdSBwYXNzIGEgZnVuY3Rpb24gYXMgdGhlIHNlY29uZCBwYXJhbWV0ZXIgdG8gdGhlIG1hcGlmaWVkIHZlcnNpb24gY2FsbCwgdGhlbiB0aGlzIGNhc2UgaXMgY29uc2lkZXJlZFxyXG4gICAgKiBhcyBhc3luYyBmdW5jdGlvbiBjYWxsLiBUaGUgc2Vjb25kIHBhcmFtZXRlciBpcyBjb25zaWRlcmVkIGFzIGEgY2FsbGJhY2sgZnVuY3Rpb24gcmVjZWl2aW5nIHRoZSBhc3luYyBvYmplY3QgcHJvY2Vzc2luZyBmaW5hbCByZXN1bHQuIFRoZSBjYWxsYmFja1xyXG4gICAgKiBmb3JtYXQgaXMgYGNhbGxiYWNrKGVycm9yLCByZXN1bHQpYCwgd2hlcmUgYGVycm9yYCBpcyBhbiBlcnJvciBvYmplY3Qgb3IgbnVsbCwgYW5kIGByZXN1bHRgIGlzIHRoZSByZXN1bHQgYXJyYXkuXHJcbiAgICAqXHJcbiAgICAqIFRoZSBvcmlnaW5hbCBhc3luYyBmdW5jdGlvbiBtdXN0IGNhbGwgYSBjYWxsYmFjayBmdW5jdGlvbiBpbiB0dXJuLiBUaGUgY2FsbGJhY2sgZnVuY3Rpb24gaXMgcGFzc2VkIGFzIGEgbGFzdCBhcmd1bWVudCB0byB0aGUgYXN5bmMgZnVuY3Rpb25cclxuICAgICogY2FsbCwgZm9sbG93aW5nIHRoZSB1c3VhbCBbY2FsbF9tdWx0aXBsZV9jYWxsYmFja19mdW5jdGlvbnMoKV17QGxpbmsgbW9kdWxlOmNvcmUvanNndWktbGFuZy1lc3NlbnRpYWxzLmNhbGxfbXVsdGlwbGVfY2FsbGJhY2tfZnVuY3Rpb25zfSBydWxlcy5cclxuICAgICpcclxuICAgICogU28sIHRoZSBtYXBpZmllZCBmdW5jdGlvbiBwYXJhbWV0ZXJzIGFyZSAob2JqZWN0KSBvciAob2JqZWN0LCBmdW5jdGlvbikuIFlvdSBjYW4gY2FsbCB0aGUgbWFwaWZpZWQgZnVuY3Rpb24gd2l0aCBvdGhlciBwYXJhbWV0ZXJzIHR5cGUsIGJ1dCBpblxyXG4gICAgKiB0aGlzIGNhc2UgaXQgd2lsbCBqdXN0IGNhbGwgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uIChpZiB0aGUgcGFyYW1ldGVycyBudW1iZXIgPj0gMikuXHJcbiAgICAqXHJcbiAgICAqIEBmdW5jXHJcbiAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuIC0gbWFwaWZ5aW5nIGZ1bmN0aW9uXHJcbiAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29yZS9qc2d1aS1sYW5nLWVzc2VudGlhbHNcclxuICAgICpcclxuICAgICogQGV4YW1wbGVcclxuICAgICpcclxuICAgICogdmFyIGtleXMgPSBbXTtcclxuICAgICogdmFyIHZhbHVlcyA9IFtdO1xyXG4gICAgKlxyXG4gICAgKiB2YXIgYWRkS2V5VmFsdWUgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xyXG4gICAgKiAgICAga2V5cy5wdXNoKGtleSk7XHJcbiAgICAqICAgICB2YWx1ZXMucHVzaCh2YWx1ZSk7XHJcbiAgICAqIH07XHJcbiAgICAqXHJcbiAgICAqIHZhciBtYXBpZmllZF9hZGRLZXlWYWx1ZSA9IGpzZ3VpLm1hcGlmeShhZGRLZXlWYWx1ZSk7XHJcbiAgICAqXHJcbiAgICAqIG1hcGlmaWVkX2FkZEtleVZhbHVlKHsgYTogMSwgYjogMiwgbmFtZTogXCJKb2huXCIgfSk7XHJcbiAgICAqXHJcbiAgICAqIGNvbnNvbGUubG9nKGtleXMpOyAvLyBbXCJhXCIsIFwiYlwiLCBcIm5hbWVcIl1cclxuICAgICogY29uc29sZS5sb2codmFsdWVzKTsgLy8gWzEsIDIsIFwiSm9oblwiXVxyXG4gICAgKlxyXG4gICAgKlxyXG4gICAgKiAvLyAtLS0tLS0tIG1hcGlmeSBhbiBhc3luYyBmdW5jdGlvbjogLS0tLS0tLVxyXG4gICAgKlxyXG4gICAgKlxyXG4gICAgKiB2YXIga2V5cyA9IFtdO1xyXG4gICAgKiB2YXIgdmFsdWVzID0gW107XHJcbiAgICAqXHJcbiAgICAqIHZhciBhc3luY0FkZEtleVZhbHVlID0gZnVuY3Rpb24gKGtleSwgdmFsdWUsIGNiKSB7XHJcbiAgICAqICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICogICAgICAgICBrZXlzLnB1c2goa2V5KTtcclxuICAgICogICAgICAgICB2YWx1ZXMucHVzaCh2YWx1ZSk7XHJcbiAgICAqICAgICAgICAgY2IobnVsbCwga2V5ICsgXCI9XCIgKyB2YWx1ZSk7XHJcbiAgICAqICAgICB9LCAxMDAwKTtcclxuICAgICogfTtcclxuICAgICpcclxuICAgICogdmFyIGNhbGxiYWNrID0gZnVuY3Rpb24gKGVycm9yLCByZXN1bHQpIHtcclxuICAgICogICAgIGNvbnNvbGUubG9nKHJlc3VsdCk7IC8vIFtcImE9MVwiLCBcImI9MlwiLCBcIm5hbWU9Sm9oblwiXVxyXG4gICAgKiAgICAgLy9cclxuICAgICogICAgIGNvbnNvbGUubG9nKGtleXMpOyAgIC8vIFtcImFcIiwgXCJiXCIsIFwibmFtZVwiXVxyXG4gICAgKiAgICAgY29uc29sZS5sb2codmFsdWVzKTsgLy8gWzEsIDIsIFwiSm9oblwiXVxyXG4gICAgKiB9O1xyXG4gICAgKlxyXG4gICAgKiB2YXIgbWFwaWZpZWRfYXN5bmNBZGRLZXlWYWx1ZSA9IGpzZ3VpLm1hcGlmeShhc3luY0FkZEtleVZhbHVlKTtcclxuICAgICpcclxuICAgICogbWFwaWZpZWRfYXN5bmNBZGRLZXlWYWx1ZSh7IGE6IDEsIGI6IDIsIG5hbWU6IFwiSm9oblwiIH0sIGNhbGxiYWNrKTtcclxuICAgICpcclxuICAgICpcclxuICAgICogLy8gLS0tLS0tLSBjYWxsIHRoZSBvcmlnaW5hbCBmdW5jdGlvbjogLS0tLS0tLVxyXG4gICAgKlxyXG4gICAgKiB2YXIgZnVuYyA9IGZ1bmN0aW9uIChhLCBiLCBjKSB7XHJcbiAgICAqICAgICBjb25zb2xlLmxvZyhhICsgXCIgXCIgKyBiICsgXCIgXCIgKyBjKTsgIC8vIDEgNSAxMFxyXG4gICAgKiB9O1xyXG4gICAgKlxyXG4gICAgKiB2YXIgbWFwaWZpZWRfZnVuYyA9IGpzZ3VpLm1hcGlmeShmdW5jKTtcclxuICAgICpcclxuICAgICogbWFwaWZpZWRfZnVuYygxLCA1LCAxMCk7XHJcbiAgICAqXHJcbiAgICAqXHJcbiAgICAqL1xyXG4gICAgLy8gdGhhdCB0YXJnZXQgZnVuY3Rpb24gY291bGQgdGFrZSBhIGNhbGxiYWNrKGVyciwgcmVzKSBwYXJhbWV0ZXIuXHJcbiAgICAvLyAgdGhhdCBtZWFucywgd2hlbiBjYWxsaW5nIHRoZSBmdW5jdGlvbiwgaWYgdGhlIGxhc3QgZnVuY3Rpb24gaXMgYSBjYWxsYmFjaywgd2UgY2FuIGFjdCBkaWZmZXJlbnRseS5cclxuXHR2YXIgbWFwaWZ5ID0gZnVuY3Rpb24odGFyZ2V0KSB7XHJcblx0XHR2YXIgdHQgPSB0b2YodGFyZ2V0KTtcclxuXHRcdGlmICh0dCA9PSAnZnVuY3Rpb24nKSB7XHJcblx0XHRcdHZhciByZXMgPSBmcChmdW5jdGlvbihhLCBzaWcpIHtcclxuXHRcdFx0XHR2YXIgdGhhdCA9IHRoaXM7XHJcblx0XHRcdFx0Ly9jb25zb2xlLmxvZygnbWFwaWZpZWQgZm4gc2lnICcgKyBzaWcpO1xyXG5cdFx0XHRcdGlmIChzaWcgPT0gJ1tvXScpIHtcclxuXHRcdFx0XHRcdHZhciBtYXAgPSBhWzBdO1xyXG5cdFx0XHRcdFx0ZWFjaChtYXAsIGZ1bmN0aW9uKGksIHYpIHtcclxuXHRcdFx0XHRcdCAgICAvL2ZuLmNhbGwodGhhdCwgaSwgdik7XHJcblx0XHRcdFx0XHQgICAgdGFyZ2V0LmNhbGwodGhhdCwgaSwgdik7XHJcblx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHR9IGVsc2UgaWYgKHNpZyA9PSAnW28sZl0nKSB7XHJcblx0XHRcdFx0ICAgIHZhciBtYXAgPSBhWzBdO1xyXG5cdFx0XHRcdCAgICAvLyBjYWxsX211bHRpIG9uIHRoZSBmdW5jdGlvbiwgdXNpbmcgdGhlIGl0ZW1zIGluIHRoZSBtYXAsIGNhbGxpbmcgd2l0aCAxIHBhcmFtICgrY2FsbGJhY2spLlxyXG5cdFx0XHRcdCAgICB2YXIgY2FsbGJhY2sgPSBhWzFdO1xyXG5cdFx0XHRcdCAgICB2YXIgZm5zID0gW107XHJcblx0XHRcdFx0ICAgIGVhY2gobWFwLCBmdW5jdGlvbihpLCB2KSB7XHJcblx0XHRcdFx0ICAgICAgICBmbnMucHVzaChbdGFyZ2V0LCBbaSwgdl1dKTtcclxuXHRcdFx0XHQgICAgfSk7XHJcblx0XHRcdFx0ICAgIGNhbGxfbXVsdGkoZm5zLCBmdW5jdGlvbihlcnJfbXVsdGksIHJlc19tdWx0aSkge1xyXG5cdFx0XHRcdCAgICAgICAgaWYgKGVycl9tdWx0aSkge1xyXG5cdFx0XHRcdCAgICAgICAgICAgIGNhbGxiYWNrKGVycl9tdWx0aSk7XHJcblx0XHRcdFx0ICAgICAgICB9IGVsc2Uge1xyXG5cdFx0XHRcdCAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHJlc19tdWx0aSk7XHJcblx0XHRcdFx0ICAgICAgICB9XHJcblx0XHRcdFx0ICAgIH0pO1xyXG5cclxuXHRcdFx0XHR9IGVsc2UgaWYgKGEubGVuZ3RoID49IDIpIHtcclxuXHRcdFx0XHQgICAgLy8gYXBwbHlpbmcgdGhlIHRhcmdldCBmdW5jdGlvbiB3aXRoIGEgY2FsbGJhY2suLi5cclxuXHJcblx0XHRcdFx0ICAgIC8vdmFyIGxhc3RfYXJnID0gYVthLmxlbmd0aCAtIDFdO1xyXG5cclxuXHRcdFx0XHRcdC8vIGNvdWxkIHRha2UgZnVuY3Rpb25zLCBidXQgbm90IGRlYWxpbmcgd2l0aCBvYmplY3RzIG1heSBiZVxyXG5cdFx0XHRcdFx0Ly8gdHJpY2t5P1xyXG5cdFx0XHRcdFx0Ly8gb3IganVzdCBpZiB0aGVyZSBhcmUgdHdvIHBhcmFtcyBpdHMgZmluZS5cclxuXHRcdFx0XHRcdHRhcmdldC5hcHBseSh0aGlzLCBhKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cdFx0XHRyZXR1cm4gcmVzO1xyXG5cdFx0fSBlbHNlIGlmICh0dCA9PSAnYXJyYXknKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBJZiBpdCdzIGFuIGFycmF5IG9mIHN0cmluZ3MsIHdhbnQgdG8gbWFrZSBhIHRydXRoIG1hcCBmcm9tIGl0LlxyXG5cclxuICAgICAgICAgICAgLy8gSSB0aGluayBjaGVjayB0byBzZWUgaWYgaXQncyBhbiBhcnJheSBvZiBzdHJpbmdzIHdvdWxkIGhlbHAuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHRcdFx0Ly8gYSBidW5jaCBvZiBpdGVtcywgaXRlbXMgY291bGQgaGF2ZSBuYW1lXHJcblxyXG5cdFx0XHQvLyBjb3VsZCBqdXN0IGJlIGdpdmVuIGFuIGFycmF5IHRvIG1hcGlmeS5cclxuXHJcblx0XHRcdHZhciByZXMgPSB7fTtcclxuXHJcblx0XHRcdGlmIChhcmd1bWVudHMubGVuZ3RoID09IDEpIHtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoaXNfYXJyX29mX3N0cnModGFyZ2V0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVhY2godGFyZ2V0LCBmdW5jdGlvbihpLCB2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc1t2XSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGVhY2godGFyZ2V0LCBmdW5jdGlvbihpLCB2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc1t2WzBdXSA9IHZbMV07XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuXHRcdFx0XHQvLyBkZWFsaW5nIHdpdGggW25hbWUsIHZhbHVlXSBwYWlyc1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR2YXIgYnlfcHJvcGVydHlfbmFtZSA9IGFyZ3VtZW50c1sxXTtcclxuXHRcdFx0XHRlYWNoKHRhcmdldCwgZnVuY3Rpb24oaSwgdikge1xyXG5cdFx0XHRcdFx0cmVzW3ZbYnlfcHJvcGVydHlfbmFtZV1dID0gdjtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHJlcztcclxuXHJcblx0XHR9XHJcblx0XHQvLyB3ZSBtYXkgYmUgZ2l2ZW4gYSBmdW5jdGlvbixcclxuXHRcdC8vIHdlIG1heSBiZSBnaXZlbiBhbiBhcnJheS5cclxuXHJcblx0XHQvLyBiZWVuIGdpdmVuIGEgbWFwIC8gb2JqZWN0XHJcblxyXG5cdH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGUgZ2l2ZW4gdmFsdWUuIFRoZSByZXN1bHQgZGVwZW5kcyBvZiB0aGUgaW5wdXQgdmFsdWUgdHlwZTpcclxuICAgICogLSBhcnJheTogYW4gYXJyYXkgY29udGFpbmluZyBjbG9uZXMgb2YgdGhlIGlucHV0IGFycmF5IGVsZW1lbnRzXHJcbiAgICAqIC0gdW5kZWZpbmVkOiB1bmRlZmluZWRcclxuICAgICogLSBzdHJpbmc6IHNhbWUgc3RyaW5nXHJcbiAgICAqIC0gbnVtYmVyOiBzYW1lIG51bWJlclxyXG4gICAgKiAtIGZ1bmN0aW9uOiBzYW1lIGZ1bmN0aW9uIHJlZmVyZW5jZVxyXG4gICAgKiAtIGJvb2xlYW46IHNhbWUgYm9vbGVhbiB2YWx1ZVxyXG4gICAgKiAtIG51bGw6IG51bGxcclxuICAgICogLSBvdGhlciAob2JqZWN0KTogZGVlcCBjb3B5IG9mIHRoZSBvYmplY3RcclxuICAgICpcclxuICAgICogSWYgdGhlIHNlY29uZCBwYXJhbWV0ZXIgaXMgcGFzc2VkLCB0aGVuIHJldHVybnMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgcmVxdWVzdGVkIG51bWJlciBvZiB0aGUgY2xvbmVzLlxyXG4gICAgKiBAZnVuY1xyXG4gICAgKiBAcGFyYW0geyp9IG9iaiAtIHNvdXJjZSB2YWx1ZVxyXG4gICAgKiBAcGFyYW0ge251bWJlcn0gW2NvdW50XSAtIG51bWJlciBvZiB0aGUgb3V0cHV0IHZhbHVlc1xyXG4gICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvcmUvanNndWktbGFuZy1lc3NlbnRpYWxzXHJcbiAgICAqIEBleGFtcGxlXHJcbiAgICAqICBjbG9uZSgxKSA9PT4gMVxyXG4gICAgKlxyXG4gICAgKiAgY2xvbmUoXCJhYmNcIikgPT0+IFwiYWJjXCJcclxuICAgICogIGNsb25lKFwiYWJjXCIsIDMpID09PiBbXCJhYmNcIiwgXCJhYmNcIiwgXCJhYmNcIl1cclxuICAgICpcclxuICAgICogIGNsb25lKFsxLCB1bmRlZmluZWRdKSA9PT4gWzEsIHVuZGVmaW5lZF1cclxuICAgICpcclxuICAgICogIGNsb25lKHthOiAxLCBiOntjOjJ9fSkgPT0+IHthOiAxLCBiOntjOjJ9fVxyXG4gICAgKlxyXG4gICAgKi9cclxuXHQvLyBoYWQgeF9jbG9uZXMgZm9sZGVkIGludG8gaXRcclxuXHR2YXIgY2xvbmUgPSBmcChmdW5jdGlvbihhLCBzaWcpIHtcclxuXHRcdHZhciBvYmogPSBhWzBdO1xyXG5cdFx0aWYgKGEubCA9PSAxKSB7XHJcblxyXG5cclxuXHRcdFx0dmFyIHQgPSB0b2Yob2JqKTtcclxuXHRcdFx0aWYgKHQgPT0gJ2FycmF5Jykge1xyXG5cclxuXHRcdFx0XHQvLyBzbGljZSByZW1vdmVzIHVuZGVmaW5lZCBpdGVtc1xyXG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nKCdjbG9uZSBvYmogJyArIHN0cmluZ2lmeShvYmopKTtcclxuXHRcdFx0XHQvLyBjb25zb2xlLmxvZygnb2JqLmxlbmd0aCAnICsgb2JqLmxlbmd0aCk7XHJcblxyXG5cdFx0XHRcdHZhciByZXMgPSBbXTtcclxuXHJcblxyXG5cdFx0XHRcdGVhYyhvYmosIGZ1bmN0aW9uKHYpIHtcclxuXHRcdFx0XHRcdC8vY29uc29sZS5sb2coJ2kgJyArIGkpO1xyXG5cdFx0XHRcdFx0cmVzLnB1c2goY2xvbmUodikpO1xyXG5cdFx0XHRcdH0pO1xyXG5cclxuXHJcblxyXG5cclxuXHRcdFx0XHRyZXR1cm4gcmVzO1xyXG5cclxuXHRcdFx0XHQvL3JldHVybiBvYmouc2xpY2UoKTtcclxuXHJcblx0XHRcdFx0Ly8gZGVlcCBjbG9uZS4uLj9cclxuXHJcblx0XHRcdH0gZWxzZSBpZiAodCA9PSAndW5kZWZpbmVkJykge1xyXG5cdFx0XHRcdHJldHVybiB1bmRlZmluZWQ7XHJcblx0XHRcdH0gZWxzZSBpZiAodCA9PSAnc3RyaW5nJykge1xyXG5cdFx0XHQgICAgcmV0dXJuIG9iajtcclxuXHRcdFx0fSBlbHNlIGlmICh0ID09ICdudW1iZXInKSB7XHJcblx0XHRcdCAgICByZXR1cm4gb2JqO1xyXG5cdFx0XHR9IGVsc2UgaWYgKHQgPT0gJ2Z1bmN0aW9uJykge1xyXG5cdFx0XHQgICAgcmV0dXJuIG9iajtcclxuXHRcdFx0fSBlbHNlIGlmICh0ID09ICdib29sZWFuJykge1xyXG5cdFx0XHQgICAgcmV0dXJuIG9iajtcclxuXHRcdFx0fSBlbHNlIGlmICh0ID09ICdudWxsJykge1xyXG5cdFx0XHQgICAgcmV0dXJuIG9iajtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0Ly8gZXh0ZW5kIG5vdCBjbG9uaW5nIHRoZSB1bmRlZmluZWQgdmFsdWVzIGluIHRoZSBhcnJheSBwcm9wZXJseSxcclxuXHRcdFx0XHQvLyBkb24ndCB3YW50IHRoZW0gdHJpbW1lZC5cclxuXHJcblx0XHRcdFx0cmV0dXJuIGV4dGVuZCh0cnVlLCB7fSwgb2JqKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSBpZiAoYS5sID09IDIgJiYgdG9mKGFbMV0pID09ICdudW1iZXInKSB7XHJcblx0XHRcdHZhciByZXMgPSBbXTtcclxuXHRcdFx0Zm9yICggdmFyIGMgPSAwOyBjIDwgYVsxXTsgYysrKSB7XHJcblx0XHRcdFx0cmVzLnB1c2goY2xvbmUob2JqKSk7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIHJlcztcclxuXHJcblx0XHR9XHJcblxyXG5cclxuXHR9KTtcclxuXHJcbiAgICAvKipcclxuICAgICogUmV0dXJucyB0cnVlIGlmIGFsbCB0aGUgcGFzc2VkIGFyZ3VtZW50cyBhcmUgZXF1YWxzLiBQZXJmb3JtcyBhIFwiZGVlcCBlcXVhbHNcIiBmb3Igb2JqZWN0cyBhbmQgYXJyYXlzLlxyXG4gICAgKlxyXG4gICAgKiBJZiBvbmUgYXJyYXkgYXJnaW1lbnQgcGFzc2VkLCB0aGVuIHJldHVybnMgdHJ1ZSBpZiBhbGwgdGhlIGFycmF5IGVsZW1lbnRzIGFyZSBlcXVhbHMuXHJcbiAgICAqXHJcbiAgICAqIElmIG9uZSBvdGhlciAobm9uLWFycmF5KSBhcmd1bWVudCBwYXNzZWQsIHJldHVybnMgdHJ1ZS5cclxuICAgICpcclxuICAgICogSWYgbm8gYXJndW1lbnRzIHBhc3NlZCwgcmV0dXJucyBudWxsLlxyXG4gICAgKlxyXG4gICAgKiBAZnVuY1xyXG4gICAgKiBAcGFyYW0gey4uLip9IG9iaiAtIHZhbHVlcyB0byBjb21wYXJlLlxyXG4gICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvcmUvanNndWktbGFuZy1lc3NlbnRpYWxzXHJcbiAgICAqIEBleGFtcGxlXHJcbiAgICAqXHJcbiAgICAqIGFyZV9lcXVhbCgxLCAxLCAxKSA9PiB0cnVlXHJcbiAgICAqIGFyZV9lcXVhbCgxLCAyLCAxKSA9PiBmYWxzZVxyXG4gICAgKlxyXG4gICAgKiBhcmVfZXF1YWwoWzEsIDEsIDFdKSA9PiB0cnVlXHJcbiAgICAqIGFyZV9lcXVhbChbMSwgMiwgMV0pID0+IGZhbHNlXHJcbiAgICAqXHJcbiAgICAqIGFyZV9lcXVhbChbMSwgeyBiMTogXCIyXCIsIGIyOiAyIH0sIDNdLCBbMSwgeyBiMTogXCIyXCIsIGIyOiAyIH0sIDNdKSA9PiB0cnVlXHJcbiAgICAqIGFyZV9lcXVhbChbMSwgeyBiMTogXCIyXCIsIGIyOiAyIH0sIDNdLCBbMSwgeyBiMTogMiwgYjI6IDIgfSwgM10pID0+IGZhbHNlXHJcbiAgICAqXHJcbiAgICAqL1xyXG5cdHZhciBhcmVfZXF1YWwgPSBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBhID0gYXJndW1lbnRzO1xyXG5cdFx0aWYgKGEubGVuZ3RoID09IDApXHJcblx0XHRcdHJldHVybiBudWxsO1xyXG5cdFx0aWYgKGEubGVuZ3RoID09IDEpIHtcclxuXHRcdFx0dmFyIHQgPSBqc2d1aS50b2YoYVswXSk7XHJcblx0XHRcdGlmICh0ID09ICdhcnJheScgJiYgYVswXS5sZW5ndGggPiAxKSB7XHJcblx0XHRcdFx0Zm9yICggdmFyIGMgPSAxLCBsID0gYVswXS5sZW5ndGg7IGMgPCBsOyBjKyspIHtcclxuXHRcdFx0XHRcdGlmICghanNndWkuYXJlX2VxdWFsKGFbMF1bMF0sIGFbMF1bY10pKVxyXG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRpZiAoYS5sZW5ndGggPT0gMikge1xyXG5cdFx0XHR2YXIgdHMgPSBqc2d1aS5hdG9mKGEpO1xyXG5cdFx0XHRpZiAodHNbMF0gIT0gdHNbMV0pXHJcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHR2YXIgdCA9IHRzWzBdO1xyXG5cdFx0XHRpZiAodCA9PSAnc3RyaW5nJyB8fCB0ID09ICdudW1iZXInKVxyXG5cdFx0XHRcdHJldHVybiBhWzBdID09IGFbMV07XHJcblx0XHRcdGlmICh0ID09ICdhcnJheScpIHtcclxuXHRcdFx0XHRpZiAoYVswXS5sZW5ndGggIT0gYVsxXS5sZW5ndGgpXHJcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdFx0Zm9yICggdmFyIGMgPSAwLCBsID0gYVswXS5sZW5ndGg7IGMgPCBsOyBjKyspIHtcclxuXHRcdFx0XHRcdGlmICghanNndWkuYXJlX2VxdWFsKGFbMF1bY10sIGFbMV1bY10pKVxyXG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdDtcclxuXHRcdFx0fSBlbHNlIGlmICh0eXBlb2YgYVswXSA9PSAnb2JqZWN0Jykge1xyXG5cdFx0XHQgICAgLy8gZ2V0IHRoZSBkaWN0IG9mIGtleXMgZm9yIGJvdGgsIGNvbXBhcmUgdGhlIGxlbmd0aHMsIChjb21wYXJlXHJcblx0XHRcdCAgICAvLyB0aGUga2V5cyksIGdldCBtZXJnZWQga2V5IG1hcFxyXG5cdFx0XHQgICAgdmFyIG1lcmdlZF9rZXlfdHJ1dGhfbWFwID0ge307XHJcblx0XHRcdCAgICB2YXIgYzEgPSAwO1xyXG5cdFx0XHQgICAgZWFjaChhWzBdLCBmdW5jdGlvbiAoaSwgdikge1xyXG5cdFx0XHQgICAgICAgIG1lcmdlZF9rZXlfdHJ1dGhfbWFwW2ldID0gdHJ1ZTtcclxuXHRcdFx0ICAgICAgICBjMSsrO1xyXG5cdFx0XHQgICAgfSk7XHJcblx0XHRcdCAgICB2YXIgYzIgPSAwO1xyXG5cdFx0XHQgICAgZWFjaChhWzFdLCBmdW5jdGlvbiAoaSwgdikge1xyXG5cdFx0XHQgICAgICAgIG1lcmdlZF9rZXlfdHJ1dGhfbWFwW2ldID0gdHJ1ZTtcclxuXHRcdFx0ICAgICAgICBjMisrO1xyXG5cdFx0XHQgICAgfSk7XHJcblx0XHRcdCAgICBpZiAoYzEgIT0gYzIpXHJcblx0XHRcdCAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG5cdFx0XHQgICAgdmFyIG9iamVjdHNfYXJlX2VxdWFsID0gdHJ1ZTtcclxuXHRcdFx0ICAgIGVhY2gobWVyZ2VkX2tleV90cnV0aF9tYXAsIGZ1bmN0aW9uIChpLCB2KSB7XHJcblx0XHRcdCAgICAgICAgaWYgKCFqc2d1aS5hcmVfZXF1YWwoYVswXVtpXSwgYVsxXVtpXSkpIHtcclxuXHRcdFx0ICAgICAgICAgICAgb2JqZWN0c19hcmVfZXF1YWwgPSBmYWxzZTtcclxuXHRcdFx0ICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHRcdFx0ICAgIH0pO1xyXG5cdFx0XHQgICAgcmV0dXJuIG9iamVjdHNfYXJlX2VxdWFsO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHQgICAgcmV0dXJuIGFbMF0gPT0gYVsxXTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0aWYgKGEubGVuZ3RoID4gMikge1xyXG5cdFx0XHR2YXIgdHMgPSBqc2d1aS5hdG9mKGEpO1xyXG5cdFx0XHRpZiAoIWpzZ3VpLmFyZV9lcXVhbCh0cykpXHJcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHR2YXIgbyA9IGFbMF07XHJcblx0XHRcdGZvciAoIHZhciBjID0gMSwgbCA9IGEubGVuZ3RoOyBjIDwgbDsgYysrKSB7XHJcblx0XHRcdFx0aWYgKGFbY10gIT09IG8pXHJcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdH1cclxuXHRcdH07XHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9O1xyXG5cclxuXHJcbiAgICAvKipcclxuICAgICogQXNzaWducyBwcm9wZXJ0eSB2YWx1ZXMgZnJvbSBtYXAgdG8gb2JqLlxyXG4gICAgKiBAZnVuY1xyXG4gICAgKiBAcGFyYW0ge29iamVjdH0gb2JqIC0gdGFyZ2V0IG9iamVjdFxyXG4gICAgKiBAcGFyYW0ge29iamVjdH0gbWFwIC0gc291cmNlIGtleS92YWx1ZSBvYmplY3RcclxuICAgICogQHJldHVybnMgdW5kZWZpbmVkXHJcbiAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29yZS9qc2d1aS1sYW5nLWVzc2VudGlhbHNcclxuICAgICogQGV4YW1wbGVcclxuICAgICpcclxuICAgICogIHZhciBvYmoxID0ge307XHJcbiAgICAqICBqc2d1aS5zZXRfdmFscyhvYmoxLCB7IGE6IDEsIGI6IDJ9KTsgIC8vIG9iajEgPT0geyBhOiAxLCBiOiAyIH1cclxuICAgICpcclxuICAgICogIHZhciBvYmoyID0geyBhOiAxLCBiOiAyfTtcclxuICAgICogIGpzZ3VpLnNldF92YWxzKG9iajIsIHsgYjogMjAwLCBjOiAzMDB9KTsgIC8vIG9iajIgPT0geyBhOiAxLCBiOiAyMDAsIGM6IDMwMCB9XHJcbiAgICAqXHJcbiAgICAqL1xyXG5cdHZhciBzZXRfdmFscyA9IGZ1bmN0aW9uKG9iaiwgbWFwKSB7XHJcblx0XHRlYWNoKG1hcCwgZnVuY3Rpb24oaSwgdikge1xyXG5cdFx0XHRvYmpbaV0gPSB2O1xyXG5cdFx0fSk7XHJcblx0fTtcclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEFzc2lnbnMgYSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgb2JqZWN0IHVzaW5nIGEgcXVhbGlmaWVkIChkb3R0ZWQpIHByb3BlcnR5IG5hbWUuIE5lc3RlZCBzdWItb2JqZWN0cyBhcmUgY3JlYXRlZCBpZiBuZWVkZWQuXHJcbiAgICAqXHJcbiAgICAqIGlmIHRoZSBvYmplY3QgY29udGFpbnMgYW4gaW50ZXJuYWwgb2JqZWN0IG5hbWVkIFwiX1wiLCB0aGVuIGFzc2lnbnMgdGhlIGludGVybmFsIG9iamVjdCBwcm9wZXJ0eS5cclxuICAgICpcclxuICAgICogQGZ1bmNcclxuICAgICogQHBhcmFtIHtvYmplY3R9IG9iaiAtIHRhcmdldCBvYmplY3RcclxuICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BfbmFtZSAtIHByb3BlcnR5IG5hbWVcclxuICAgICogQHBhcmFtIHsqfSBwcm9wX3ZhbHVlIC0gcHJvcGVydHkgdmFsdWVcclxuICAgICogQHJldHVybnMgcHJvcGVydHkgdmFsdWVcclxuICAgICogQG1lbWJlcm9mIG1vZHVsZTpjb3JlL2pzZ3VpLWxhbmctZXNzZW50aWFsc1xyXG4gICAgKiBAZXhhbXBsZVxyXG4gICAgKlxyXG4gICAgKiAgLy8gb2JqZWN0IGl0c2VsZjpcclxuICAgICpcclxuICAgICogIHZhciBvYmoxID0ge307XHJcbiAgICAqICBqc2d1aS5sbF9zZXQob2JqMSwgXCJhXCIsIDEpOyAgLy8gb2JqMSA9PSB7IGE6IDEgfVxyXG4gICAgKlxyXG4gICAgKiAgdmFyIG9iajIgPSB7fTtcclxuICAgICogIGpzZ3VpLmxsX3NldChvYmoyLCBcImEuYi5jXCIsIDEpOyAgLy8gb2JqMiA9PSB7IGE6IHsgYjogeyBjOiAxIH0gfSB9XHJcbiAgICAqXHJcbiAgICAqICB2YXIgb2JqMyA9IHsgYTogeyBiOiB7IGM6IDEgfSB9O1xyXG4gICAgKiAganNndWkubGxfc2V0KG9iajMsIFwiYS5iLmNcIiwgMTAwKTsgIC8vIG9iajMgPT0geyBhOiB7IGI6IHsgYzogMTAwIH0gfSB9XHJcbiAgICAqXHJcbiAgICAqICAvLyBpbnRlcm5hbCBvYmplY3Q6XHJcbiAgICAqXHJcbiAgICAqICB2YXIgb2JqNCA9IHsgXzoge30sIGE6IDEwMCB9O1xyXG4gICAgKiAganNndWkubGxfc2V0KG9iajQsIFwiYVwiLCAxKTsgIC8vIG9iajQgPT0geyBfOiB7IGE6IDEgfSwgYTogMTAwIH1cclxuICAgICovXHJcblx0dmFyIGxsX3NldCA9IGZ1bmN0aW9uKG9iaiwgcHJvcF9uYW1lLCBwcm9wX3ZhbHVlKSB7XHJcblx0XHQvLyBub3Qgc2V0dGluZyBzdWItcHJvcGVydGllcyBzcGVjaWZpY2FsbHkuIHN1Yi1wcm9wZXJ0aWVzIGFyZVxyXG5cdFx0Ly8gcHJvcGVydGllcyBvZiBhIGtpbmRcclxuXHRcdC8vIGhvd2V2ZXIgd2lsbCBub3QgdXNlIGxsX3NldCBpbmFwcHJvcHJpYXRlbHkgZWcgYm9yZGVyLndpZHRoIHdvcmtzXHJcblx0XHQvLyBkaWZmZXJlbnRseVxyXG5cclxuXHRcdHZhciBhcnIgPSBwcm9wX25hbWUuc3BsaXQoJy4nKTtcclxuXHRcdC8vY29uc29sZS5sb2coJ2FyciAnICsgYXJyKTtcclxuXHRcdHZhciBjID0gMCwgbCA9IGFyci5sZW5ndGg7XHJcblx0XHR2YXIgaSA9IG9iai5fIHx8IG9iaiwgcztcclxuXHJcblx0XHR3aGlsZSAoYyA8IGwpIHtcclxuXHRcdFx0cyA9IGFycltjXTtcclxuXHRcdFx0Ly9jb25zb2xlLmxvZygncyAnICsgcyk7XHJcblx0XHRcdGlmICh0eXBlb2YgaVtzXSA9PSAndW5kZWZpbmVkJykge1xyXG5cdFx0XHRcdGlmIChjIC0gbCA9PSAtMSkge1xyXG5cdFx0XHRcdFx0Ly8gY29uc29sZS5sb2coJ2RlZmF1bHRfdmFsdWUgJyArIGRlZmF1bHRfdmFsdWUpO1xyXG5cdFx0XHRcdFx0aVtzXSA9IHByb3BfdmFsdWU7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdGlbc10gPSB7fTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0aWYgKGMgLSBsID09IC0xKSB7XHJcblx0XHRcdFx0XHQvLyBjb25zb2xlLmxvZygnZGVmYXVsdF92YWx1ZSAnICsgZGVmYXVsdF92YWx1ZSk7XHJcblx0XHRcdFx0XHRpW3NdID0gcHJvcF92YWx1ZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0aSA9IGlbc107XHJcblx0XHRcdGMrKztcclxuXHRcdH07XHJcblx0XHRyZXR1cm4gcHJvcF92YWx1ZTtcclxuXHR9O1xyXG5cclxuXHQvKlxyXG5cdHZhciBsbF9nZXRfaW5uZXIgPSBmdW5jdGlvbihhMCwgYTEpIHtcclxuXHRcdHZhciBpID0gYTAuXyB8fCBhMDtcclxuXHRcdHZhciBhcnIgPSBhMS5zcGxpdCgnLicpO1xyXG5cclxuXHRcdC8vIHNob3dzIGhvdyBtdWNoIHRoZSBsbCBmdW5jdGlvbnMgZ2V0IHVzZWQgd2hlbiB0aGV5IGdldCBsb2dnZWQhXHJcblxyXG5cdFx0Ly9jb25zb2xlLmxvZygnbGxfZ2V0IGFyciAnICsgYXJyKTtcclxuXHRcdHZhciBjID0gMCwgbCA9IGFyci5sZW5ndGgsIHM7XHJcblxyXG5cdFx0d2hpbGUgKGMgPCBsKSB7XHJcblx0XHRcdHMgPSBhcnJbY107XHJcblx0XHRcdC8vY29uc29sZS5sb2coJ3MgJyArIHMpO1xyXG5cdFx0XHQvL2NvbnNvbGUubG9nKCd0eXBlb2YgaVtzXSAnICsgdHlwZW9mIGlbc10pO1xyXG5cdFx0XHQvL2NvbnNvbGUubG9nKCdjICcgKyBjKTtcclxuXHRcdFx0Ly9jb25zb2xlLmxvZygnbCAnICsgbCk7XHJcblx0XHRcdGlmICh0eXBlb2YgaVtzXSA9PSAndW5kZWZpbmVkJykge1xyXG5cdFx0XHRcdGlmIChjIC0gbCA9PSAtMSkge1xyXG5cdFx0XHRcdFx0Ly8gY29uc29sZS5sb2coJ2RlZmF1bHRfdmFsdWUgJyArIGRlZmF1bHRfdmFsdWUpO1xyXG5cdFx0XHRcdFx0Ly8gY29uc29sZS5sb2coaVtzXSk7XHJcblx0XHRcdFx0XHQvL2lbc10gPSBhWzJdO1xyXG5cdFx0XHRcdFx0Ly9yZXR1cm4gaVtzXTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0Ly8gaVtzXSA9IHt9O1xyXG5cdFx0XHRcdFx0dGhyb3cgJ29iamVjdCAnICsgcyArICcgbm90IGZvdW5kJztcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0aWYgKGMgLSBsID09IC0xKSB7XHJcblx0XHRcdFx0XHQvLyBjb25zb2xlLmxvZygnZGVmYXVsdF92YWx1ZSAnICsgZGVmYXVsdF92YWx1ZSk7XHJcblx0XHRcdFx0XHQvLyBjb25zb2xlLmxvZyhpW3NdKTtcclxuXHRcdFx0XHRcdC8vIGlbc10gPSBhWzJdO1xyXG5cdFx0XHRcdFx0cmV0dXJuIGlbc107XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdGkgPSBpW3NdO1xyXG5cdFx0XHRjKys7XHJcblx0XHR9XHJcblx0fVxyXG5cdCovXHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBSZXR1cm5zIGEgcHJvcGVydHkgdmFsdWUgb2YgdGhlIG9iamVjdCB1c2luZyBhIHF1YWxpZmllZCAoZG90dGVkKSBwcm9wZXJ0eSBuYW1lLlxyXG4gICAgKlxyXG4gICAgKiBSZXR1cm5zIGB1bmRlZmluZWRgIGlmIHRoZSBwcm9wZXJ0eSBkb2VzIG5vdCBleGlzdHMuXHJcbiAgICAqXHJcbiAgICAqIFRocm93bnMgYW4gZXhjZXB0aW9uIGlmIGFuIGlubmVyIG9iamVjdCBjb250YWluaW5nIHRoZSBwcm9wZXJ0eSBkb2VzIG5vdCBleGlzdHMuXHJcbiAgICAqXHJcbiAgICAqIGlmIHRoZSBvYmplY3QgY29udGFpbnMgYW4gaW50ZXJuYWwgb2JqZWN0IG5hbWVkIFwiX1wiLCB0aGVuIHJldHVybiB0aGUgdmFsdWUgb2YgdGhlIGludGVybmFsIG9iamVjdCBwcm9wZXJ0eS5cclxuICAgICpcclxuICAgICogQWxsb3dzIHRvIHBhc3MgXCIuXCIgKGRvdCkgYXMgdGhlIGBwcm9wX25hbWVgIHBhcmFtZXRlciByZXR1cm5pbmcgYSB2YWx1ZSBvZiB0aGUgJy4nIHByb3BlcnR5IGZvciB0aGUgb2JqZWN0IG9yIGludGVybmFsIFwiX1wiIG9iamVjdCAoaWYgdGhlIHZhbHVlIGV4aXN0cykuXHJcbiAgICAqXHJcbiAgICAqIEBmdW5jXHJcbiAgICAqIEBwYXJhbSB7b2JqZWN0fSBvYmogLSBvYmplY3RcclxuICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BfbmFtZSAtIHByb3BlcnR5IG5hbWVcclxuICAgICogQHJldHVybnMgcHJvcGVydHkgdmFsdWVcclxuICAgICogQG1lbWJlcm9mIG1vZHVsZTpjb3JlL2pzZ3VpLWxhbmctZXNzZW50aWFsc1xyXG4gICAgKiBAZXhhbXBsZVxyXG4gICAgKlxyXG4gICAgKiAgLy8gb2JqZWN0IGl0c2VsZjpcclxuICAgICpcclxuICAgICogIGpzZ3VpLmxsX2dldCh7fSwgXCJhXCIpOyAgPT0+IHVuZGVmaW5lZFxyXG4gICAgKiAganNndWkubGxfZ2V0KHsgYTogMSB9LCBcImFcIik7ICA9PT4gMVxyXG4gICAgKiAganNndWkubGxfZ2V0KHsgJy4nOiAxIH0sIFwiLlwiKTsgID09PiAxXHJcbiAgICAqXHJcbiAgICAqICBqc2d1aS5sbF9nZXQoeyBhOiB7IGI6IHsgYzogMSB9IH0gfSwgXCJhLmIuY1wiKTsgID09PiAxXHJcbiAgICAqICBqc2d1aS5sbF9nZXQoeyBhOiB7IGI6IHsgfSB9IH0sIFwiYS5iLmNcIik7ICA9PT4gdW5kZWZpbmVkXHJcbiAgICAqICBqc2d1aS5sbF9nZXQoeyBhOiB7IH0gfSwgXCJhLmIuY1wiKTsgID09PiBleGNlcHRpb25cclxuICAgICogIGpzZ3VpLmxsX2dldCh7IH0sIFwiYS5iLmNcIik7ICA9PT4gZXhjZXB0aW9uXHJcbiAgICAqXHJcbiAgICAqICAvLyBpbnRlcm5hbCBvYmplY3Q6XHJcbiAgICAqXHJcbiAgICAqICBqc2d1aS5sbF9nZXQoeyBfIDogeyAnLic6IDEgfSB9LCBcIi5cIik7ICA9PT4gMVxyXG4gICAgKiAganNndWkubGxfZ2V0KHsgXyA6IHsgYTogeyBiOiB7IGM6IDEgfSB9IH0gfSwgXCJhLmIuY1wiKTsgID09PiAxXHJcbiAgICAqICBqc2d1aS5sbF9nZXQoeyBfIDogeyAnLic6IDEgfSB9LCBcImEuYi5jXCIpOyAgPT0+IGV4Y2VwdGlvblxyXG4gICAgKlxyXG4gICAgKi9cclxuXHR2YXIgbGxfZ2V0ID0gZnVuY3Rpb24oYTAsIGExKSB7XHJcblxyXG5cdFx0aWYgKGEwICYmIGExKSB7XHJcblx0XHRcdHZhciBpID0gYTAuXyB8fCBhMDtcclxuXHJcblx0XHRcdGlmIChhMSA9PSAnLicpIHtcclxuXHRcdFx0XHQvLyhmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdGlmICh0eXBlb2YgaVsnLiddID09ICd1bmRlZmluZWQnKSB7XHJcblx0XHRcdFx0XHRcdC8vdGhyb3cgJ29iamVjdCAnICsgcyArICcgbm90IGZvdW5kJztcclxuXHRcdFx0XHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdHJldHVybiBpWycuJ107XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0Ly99KSgpO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0Ly9yZXR1cm4gbGxfZ2V0X2lubmVyKGEwLCBhMSk7XHJcblxyXG5cclxuXHRcdFx0XHR2YXIgYXJyID0gYTEuc3BsaXQoJy4nKTtcclxuXHJcblx0XHRcdFx0Ly8gc2hvd3MgaG93IG11Y2ggdGhlIGxsIGZ1bmN0aW9ucyBnZXQgdXNlZCB3aGVuIHRoZXkgZ2V0IGxvZ2dlZCFcclxuXHJcblx0XHRcdFx0Ly9jb25zb2xlLmxvZygnbGxfZ2V0IGFyciAnICsgYXJyKTtcclxuXHRcdFx0XHR2YXIgYyA9IDAsIGwgPSBhcnIubGVuZ3RoLCBzO1xyXG5cclxuXHRcdFx0XHR3aGlsZSAoYyA8IGwpIHtcclxuXHRcdFx0XHRcdHMgPSBhcnJbY107XHJcblx0XHRcdFx0XHQvL2NvbnNvbGUubG9nKCdzICcgKyBzKTtcclxuXHRcdFx0XHRcdC8vY29uc29sZS5sb2coJ3R5cGVvZiBpW3NdICcgKyB0eXBlb2YgaVtzXSk7XHJcblx0XHRcdFx0XHQvL2NvbnNvbGUubG9nKCdjICcgKyBjKTtcclxuXHRcdFx0XHRcdC8vY29uc29sZS5sb2coJ2wgJyArIGwpO1xyXG5cdFx0XHRcdFx0aWYgKHR5cGVvZiBpW3NdID09ICd1bmRlZmluZWQnKSB7XHJcblx0XHRcdFx0XHRcdGlmIChjIC0gbCA9PSAtMSkge1xyXG5cdFx0XHRcdFx0XHRcdC8vIGNvbnNvbGUubG9nKCdkZWZhdWx0X3ZhbHVlICcgKyBkZWZhdWx0X3ZhbHVlKTtcclxuXHRcdFx0XHRcdFx0XHQvLyBjb25zb2xlLmxvZyhpW3NdKTtcclxuXHRcdFx0XHRcdFx0XHQvL2lbc10gPSBhWzJdO1xyXG5cdFx0XHRcdFx0XHRcdC8vcmV0dXJuIGlbc107XHJcblx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdFx0Ly8gaVtzXSA9IHt9O1xyXG5cdFx0XHRcdFx0XHRcdHRocm93ICdvYmplY3QgJyArIHMgKyAnIG5vdCBmb3VuZCc7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdGlmIChjIC0gbCA9PSAtMSkge1xyXG5cdFx0XHRcdFx0XHRcdC8vIGNvbnNvbGUubG9nKCdkZWZhdWx0X3ZhbHVlICcgKyBkZWZhdWx0X3ZhbHVlKTtcclxuXHRcdFx0XHRcdFx0XHQvLyBjb25zb2xlLmxvZyhpW3NdKTtcclxuXHRcdFx0XHRcdFx0XHQvLyBpW3NdID0gYVsyXTtcclxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gaVtzXTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aSA9IGlbc107XHJcblx0XHRcdFx0XHRjKys7XHJcblx0XHRcdFx0fVxyXG5cclxuXHJcblxyXG5cdFx0XHR9XHJcblx0XHRcdC8vIHJldHVybiBpO1xyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cclxuXHQvKlxyXG5cdHZhciBsbF9nZXQgPSBmcChmdW5jdGlvbihhLCBzaWcpIHtcclxuXHJcblx0XHRpZiAoYS5sID09IDIpIHtcclxuXHRcdFx0dmFyIGkgPSBhWzBdLl8gfHwgYVswXTtcclxuXHJcblx0XHRcdGlmIChhWzFdID09ICcuJykge1xyXG5cdFx0XHRcdGlmICh0eXBlb2YgaVsnLiddID09ICd1bmRlZmluZWQnKSB7XHJcblx0XHRcdFx0XHQvL3Rocm93ICdvYmplY3QgJyArIHMgKyAnIG5vdCBmb3VuZCc7XHJcblx0XHRcdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gaVsnLiddO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR2YXIgYXJyID0gYVsxXS5zcGxpdCgnLicpO1xyXG5cclxuXHRcdFx0XHQvLyBzaG93cyBob3cgbXVjaCB0aGUgbGwgZnVuY3Rpb25zIGdldCB1c2VkIHdoZW4gdGhleSBnZXQgbG9nZ2VkIVxyXG5cclxuXHRcdFx0XHQvL2NvbnNvbGUubG9nKCdsbF9nZXQgYXJyICcgKyBhcnIpO1xyXG5cdFx0XHRcdHZhciBjID0gMCwgbCA9IGFyci5sZW5ndGg7XHJcblxyXG5cclxuXHRcdFx0XHR3aGlsZSAoYyA8IGwpIHtcclxuXHRcdFx0XHRcdHZhciBzID0gYXJyW2NdO1xyXG5cdFx0XHRcdFx0Ly9jb25zb2xlLmxvZygncyAnICsgcyk7XHJcblx0XHRcdFx0XHQvL2NvbnNvbGUubG9nKCd0eXBlb2YgaVtzXSAnICsgdHlwZW9mIGlbc10pO1xyXG5cdFx0XHRcdFx0Ly9jb25zb2xlLmxvZygnYyAnICsgYyk7XHJcblx0XHRcdFx0XHQvL2NvbnNvbGUubG9nKCdsICcgKyBsKTtcclxuXHRcdFx0XHRcdGlmICh0eXBlb2YgaVtzXSA9PSAndW5kZWZpbmVkJykge1xyXG5cdFx0XHRcdFx0XHRpZiAoYyAtIGwgPT0gLTEpIHtcclxuXHRcdFx0XHRcdFx0XHQvLyBjb25zb2xlLmxvZygnZGVmYXVsdF92YWx1ZSAnICsgZGVmYXVsdF92YWx1ZSk7XHJcblx0XHRcdFx0XHRcdFx0Ly8gY29uc29sZS5sb2coaVtzXSk7XHJcblx0XHRcdFx0XHRcdFx0Ly9pW3NdID0gYVsyXTtcclxuXHRcdFx0XHRcdFx0XHQvL3JldHVybiBpW3NdO1xyXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRcdC8vIGlbc10gPSB7fTtcclxuXHRcdFx0XHRcdFx0XHR0aHJvdyAnb2JqZWN0ICcgKyBzICsgJyBub3QgZm91bmQnO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRpZiAoYyAtIGwgPT0gLTEpIHtcclxuXHRcdFx0XHRcdFx0XHQvLyBjb25zb2xlLmxvZygnZGVmYXVsdF92YWx1ZSAnICsgZGVmYXVsdF92YWx1ZSk7XHJcblx0XHRcdFx0XHRcdFx0Ly8gY29uc29sZS5sb2coaVtzXSk7XHJcblx0XHRcdFx0XHRcdFx0Ly8gaVtzXSA9IGFbMl07XHJcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGlbc107XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGkgPSBpW3NdO1xyXG5cdFx0XHRcdFx0YysrO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHQvLyByZXR1cm4gaTtcclxuXHRcdH1cclxuXHR9KTtcclxuXHQqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBSZXR1cm5zIHRydWUgb25seSBpZiB0aGUgcGFzc2VkIHZhbHVlIGlzIGEgYm9vbGVhbiB0cnVlLlxyXG4gICAgKiBAcGFyYW0geyp9IHZhbHVlIC0gdmFsdWUgdG8gY2hlY2tcclxuICAgICogQGZ1bmNcclxuICAgICogQG1lbWJlcm9mIG1vZHVsZTpjb3JlL2pzZ3VpLWxhbmctZXNzZW50aWFsc1xyXG4gICAgKiBAZXhhbXBsZVxyXG4gICAgKlxyXG4gICAgKiAganNndWkudHJ1dGgodHJ1ZSkgID09PiB0cnVlXHJcbiAgICAqICBqc2d1aS50cnV0aCgxKSAgPT0+IGZhbHNlXHJcbiAgICAqXHJcbiAgICAqXHJcbiAgICAqXHJcbiAgICAqL1xyXG5cdHZhciB0cnV0aCA9IGZ1bmN0aW9uKHZhbHVlKSB7XHJcblx0XHRyZXR1cm4gdmFsdWUgPT09IHRydWU7XHJcblx0fTtcclxuXHJcbiAgICAvKipcclxuICAgICogSXRlcmF0ZXMgb3ZlciBhbmNlc3RvciBjbGFzc2VzIGhpZXJhcmNoeSBjYWxsaW5nIHRoZSBjYWxsYmFjayBmdW5jdGlvbiBmb3IgZWFjaCBjbGFzcyBpbiB0aGUgaW5oZXJpdGFuY2UgdHJlZS4gU3RhcnRzIGZyb20gdGhlIHBhc3NlZCBjbGFzcywgZW5kcyBvbiBqc2d1aS5DbGFzcy5cclxuICAgICpcclxuICAgICogVGhlIGl0ZXJhdGlvbiBjYW4gYmUgYnJva2VuIGNhbGxpbmcgdGhlIGBzdG9wKClgIGZ1bmN0aW9uICh0aGUgY2FsbGJhY2sgc2Vjb25kIHBhcmFtZXRlcikuXHJcbiAgICAqXHJcbiAgICAqIEBmdW5jXHJcbiAgICAqIEBwYXJhbSB7anNndWkuQ2xhc3N9IG9iaiAtIGNsYXNzIHRvIHN0YXJ0IHRoZSBpdGVyYXRpb25cclxuICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgLSBjYWxsYmFjayBmdW5jdGlvbiAob2JqLCBzdG9wKS5cclxuICAgICogQG1lbWJlcm9mIG1vZHVsZTpjb3JlL2pzZ3VpLWxhbmctZXNzZW50aWFsc1xyXG4gICAgKiBAZXhhbXBsZVxyXG4gICAgKlxyXG5cdCogIHZhciBDbGFzcyA9IGpzZ3VpLkNsYXNzO1xyXG5cdCogIHZhciBQZXJzb24gPSBDbGFzcy5leHRlbmQoe30pO1xyXG5cdCogIHZhciBOaW5qYSA9IFBlcnNvbi5leHRlbmQoe30pO1xyXG4gICAgKlxyXG5cdCogIHZhciBjbGFzc2VzID0gW107XHJcbiAgICAqXHJcblx0KiAgdmFyIGNhbGxiYWNrID0gZnVuY3Rpb24gKF9jbGFzcywgc3RvcCkge1xyXG5cdCogICAgY2xhc3Nlcy5wdXNoKF9jbGFzcyk7XHJcblx0KiAgfTtcclxuXHQqXHJcblx0KiAganNndWkuaXRlcmF0ZV9hbmNlc3Rvcl9jbGFzc2VzKE5pbmphLCBjYWxsYmFjayk7ICAvLyBjbGFzc2VzID09IFtOaW5qYSwgUGVyc29uLCBDbGFzc11cclxuICAgICpcclxuICAgICovXHJcblx0dmFyIGl0ZXJhdGVfYW5jZXN0b3JfY2xhc3NlcyA9IGZ1bmN0aW9uKG9iaiwgY2FsbGJhY2spIHtcclxuXHJcblx0XHQvKlxyXG5cdFx0aWYgKG9iai5jb25zdHJ1Y3RvciAmISBvYmouX3N1cGVyY2xhc3MpIHtcclxuXHRcdFx0aXRlcmF0ZV9hbmNlc3Rvcl9jbGFzc2VzKG9iai5jb25zdHJ1Y3RvciwgY2FsbGJhY2spXHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRjYWxsYmFjayhvYmopO1xyXG5cdFx0XHRpZiAob2JqLl9zdXBlcmNsYXNzKSB7XHJcblx0XHRcdFx0aXRlcmF0ZV9hbmNlc3Rvcl9jbGFzc2VzKG9iai5fc3VwZXJjbGFzcywgY2FsbGJhY2spO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cdFx0Ki9cclxuXHJcblx0XHR2YXIgY3R1ID0gdHJ1ZTtcclxuXHJcblx0XHR2YXIgc3RvcCA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRjdHUgPSBmYWxzZTtcclxuXHRcdH1cclxuXHJcblx0XHRjYWxsYmFjayhvYmosIHN0b3ApO1xyXG5cdFx0aWYgKG9iai5fc3VwZXJjbGFzcyAmJiBjdHUpIHtcclxuXHRcdFx0aXRlcmF0ZV9hbmNlc3Rvcl9jbGFzc2VzKG9iai5fc3VwZXJjbGFzcywgY2FsbGJhY2spO1xyXG5cdFx0fVxyXG5cclxuXHJcblx0fVxyXG5cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBwYXNzZWQgb2JqZWN0IGlzIGFuIGFycmF5IGNvbnRhaW5pbmcgdmFsdWVzIG9mIHRoZSBzcGVjaWZpZWQgdHlwZSBvbmx5LlxyXG4gICAgKiBAcGFyYW0geyp9IG9iaiAtIG9iamVjdCB0byBjaGVja1xyXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZV9uYW1lIC0gZXN0aW1hdGVkIHR5cGUgbmFtZVxyXG4gICAgKiBAZnVuY1xyXG4gICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvcmUvanNndWktbGFuZy1lc3NlbnRpYWxzXHJcbiAgICAqIEBleGFtcGxlXHJcbiAgICAqXHJcbiAgICAqICBqc2d1aS5pc19hcnJfb2ZfdChcIjFcIiwgXCJzdHJpbmdcIikgID09PiAgZmFsc2VcclxuICAgICpcclxuICAgICogIGpzZ3VpLmlzX2Fycl9vZl90KFtdLCBcInN0cmluZ1wiKSAgPT0+ICB0cnVlXHJcbiAgICAqXHJcbiAgICAqICBqc2d1aS5pc19hcnJfb2ZfdChbXCIxXCIsIFwiMlwiLCBcIjNcIl0sIFwic3RyaW5nXCIpICA9PT4gIHRydWVcclxuICAgICpcclxuICAgICogIGpzZ3VpLmlzX2Fycl9vZl90KFtcIjFcIiwgMiwgXCIzXCJdLCBcInN0cmluZ1wiKSAgPT0+ICBmYWxzZVxyXG4gICAgKlxyXG4gICAgKi9cclxuXHR2YXIgaXNfYXJyX29mX3QgPSBmdW5jdGlvbihvYmosIHR5cGVfbmFtZSkge1xyXG5cdFx0dmFyIHQgPSB0b2Yob2JqKSwgdHY7XHJcblx0XHRpZiAodCA9PSAnYXJyYXknKSB7XHJcblx0XHRcdHZhciByZXMgPSB0cnVlO1xyXG5cclxuXHRcdFx0ZWFjaChvYmosIGZ1bmN0aW9uKGksIHYpIHtcclxuXHRcdFx0XHQvL2NvbnNvbGUubG9nKCcyKSB2ICcgKyBzdHJpbmdpZnkodikpO1xyXG5cdFx0XHRcdHR2ID0gdG9mKHYpO1xyXG5cdFx0XHRcdC8vY29uc29sZS5sb2coJ3R2ICcgKyB0dik7XHJcblx0XHRcdFx0Ly9jb25zb2xlLmxvZygndHlwZV9uYW1lICcgKyB0eXBlX25hbWUpO1xyXG5cdFx0XHRcdGlmICh0diAhPSB0eXBlX25hbWUpIHJlcyA9IGZhbHNlO1xyXG5cdFx0XHR9KTtcclxuXHRcdFx0cmV0dXJuIHJlcztcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcGFzc2VkIG9iamVjdCBpcyBhbiBhcnJheSBjb250YWluaW5nIGFycmF5cyBpbiB0dXJuLlxyXG4gICAgKiBAcGFyYW0geyp9IG9iaiAtIG9iamVjdCB0byBjaGVja1xyXG4gICAgKiBAZnVuY1xyXG4gICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvcmUvanNndWktbGFuZy1lc3NlbnRpYWxzXHJcbiAgICAqIEBleGFtcGxlXHJcbiAgICAqXHJcbiAgICAqICBqc2d1aS5pc19hcnJfb2ZfYXJycyhbXSkgID09PiAgdHJ1ZVxyXG4gICAgKlxyXG4gICAgKiAganNndWkuaXNfYXJyX29mX2FycnMoW1wiMVwiLCBcIjJcIiwgXCIzXCJdKSAgPT0+ICBmYWxzZVxyXG4gICAgKlxyXG4gICAgKiAganNndWkuaXNfYXJyX29mX2FycnMoW1tdLCBbMSwgXCIyXCJdXSkgID09PiAgdHJ1ZVxyXG4gICAgKlxyXG4gICAgKi9cclxuXHR2YXIgaXNfYXJyX29mX2FycnMgPSBmdW5jdGlvbihvYmopIHtcclxuXHRcdHJldHVybiBpc19hcnJfb2ZfdChvYmosICdhcnJheScpO1xyXG5cdH1cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBwYXNzZWQgb2JqZWN0IGlzIGFuIGFycmF5IGNvbnRhaW5pbmcgc3RyaW5ncyBvbmx5LlxyXG4gICAgKiBAcGFyYW0geyp9IG9iaiAtIG9iamVjdCB0byBjaGVja1xyXG4gICAgKiBAZnVuY1xyXG4gICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvcmUvanNndWktbGFuZy1lc3NlbnRpYWxzXHJcbiAgICAqIEBleGFtcGxlXHJcbiAgICAqXHJcbiAgICAqICBqc2d1aS5pc19hcnJfb2Zfc3RycyhcIjFcIikgID09PiAgZmFsc2VcclxuICAgICpcclxuICAgICogIGpzZ3VpLmlzX2Fycl9vZl9zdHJzKFtdKSAgPT0+ICB0cnVlXHJcbiAgICAqXHJcbiAgICAqICBqc2d1aS5pc19hcnJfb2Zfc3RycyhbXCIxXCIsIFwiMlwiLCBcIjNcIl0pICA9PT4gIHRydWVcclxuICAgICpcclxuICAgICogIGpzZ3VpLmlzX2Fycl9vZl9zdHJzKFtcIjFcIiwgMiwgXCIzXCJdKSAgPT0+ICBmYWxzZVxyXG4gICAgKlxyXG4gICAgKi9cclxuXHR2YXIgaXNfYXJyX29mX3N0cnMgPSBmdW5jdGlvbihvYmopIHtcclxuXHRcdC8vY29uc29sZS5sb2coJ29iaiAnICsgc3RyaW5naWZ5KG9iaikpO1xyXG5cdFx0cmV0dXJuIGlzX2Fycl9vZl90KG9iaiwgJ3N0cmluZycpO1xyXG5cdH1cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIDxtYXJrPmRlc2NyaXB0aW9uLi4uIFRPRE88L21hcms+XHJcbiAgICAqIEBtZW1iZXJcclxuICAgICogQG1lbWJlcm9mIG1vZHVsZTpjb3JlL2pzZ3VpLWxhbmctZXNzZW50aWFsc1xyXG4gICAgKi9cclxuXHR2YXIgaW5wdXRfcHJvY2Vzc29ycyA9IHt9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiA8bWFyaz5kZXNjcmlwdGlvbi4uLiBUT0RPPC9tYXJrPlxyXG4gICAgKiBAbWVtYmVyXHJcbiAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29yZS9qc2d1aS1sYW5nLWVzc2VudGlhbHNcclxuICAgICovXHJcblx0dmFyIG91dHB1dF9wcm9jZXNzb3JzID0ge307XHJcblxyXG5cdC8vIGZvciBkYXRhIHR5cGVzLi4uXHJcblx0Ly8gIGRvbid0IGxvb2sgdXAgdGhlIGRhdGEgdHlwZXMgZGlyZWN0bHkgZm9yIHRoZSBtb21lbnQuXHJcblx0Ly8gIHRoZXkgYXJlIGNvbXBvc2VkIG9mIGlucHV0IHByb2Nlc3NvcnMsIHZhbGlkYXRpb24gYW5kIG91dHB1dCBwcm9jZXNzb3JzLlxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICogPG1hcms+UmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHBhc3NlZCBvYmplY3QgaGFzIGEgcHJvdG90eXBlICh0eXBpY2FsbHkgdGhlIG9iamVjdCBpcyBhIGZ1bmN0aW9uKS48L21hcms+XHJcbiAgICAqIEBmdW5jXHJcbiAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuIC0gb2JqZWN0IHRvIGNoZWNrXHJcbiAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29yZS9qc2d1aS1sYW5nLWVzc2VudGlhbHNcclxuICAgICogQGV4YW1wbGVcclxuICAgICpcclxuICAgICogIGpzZ3VpLmlzX2NvbnN0cnVjdG9yX2ZuKE9iamVjdCkgID09PiAgdHJ1ZVxyXG4gICAgKiAganNndWkuaXNfY29uc3RydWN0b3JfZm4obmV3IE9iamVjdCgpKSAgPT0+ICBmYWxzZVxyXG4gICAgKlxyXG4gICAgKiAganNndWkuaXNfY29uc3RydWN0b3JfZm4oc2V0SW50ZXJ2YWwpICA9PT4gIHRydWVcclxuICAgICpcclxuICAgICovXHJcblx0dmFyIGlzX2NvbnN0cnVjdG9yX2ZuID0gZnVuY3Rpb24oZm4pIHtcclxuXHRcdHJldHVybiBpc19kZWZpbmVkKGZuLnByb3RvdHlwZSk7XHJcblx0fVxyXG5cclxuXHJcblx0Ly92YXIgb3V0cHV0X3Byb2Nlc3NvcnMgPSB7fTtcclxuXHJcblx0Ly8gUG9zc2libHkgdmFsaWRhdG9ycyBoZXJlIHRvby5cclxuXHQvLyAgVGhleSBtYXkgd2VsbCBnZXQgdXNlZCBmb3IgZGF0YSBzdHJ1Y3R1cmVzIHRoYXQgZGVhbCB3aXRoIHRoZXNlIGRhdGEgdHlwZXMuIFRoZSB0eXBlZCBjb25zdHJhaW50cyBjb3VsZCBtYWtlIHVzZSBvZiB0aGVtICh0aGUgYmFzaXMgdGhhdCBpcyBzZXQgaW4gZXNzZW50aWFscylcclxuXHQvLyAgd2hpbGUgYWRkaW5nIHRvIHRoZW0uIFBlcmhhcHMgYSAnY29yZScgaW50ZXJtZWRpYXRlIGxheWVyIHdpbGwgYmUgdGhlcmUgZXh0ZW5kaW5nIGVzc2VudGlhbHMgd2l0aCBzb21lIG9mIHRoZSBkYXRhIHR5cGVzIHRoYXQgYXJlIHRvIGJlIHVzZWQgdGhyb3VnaG91dCB0aGUgc3lzdGVtLlxyXG5cclxuXHQvLyBNYXkgZmluZCB0aGF0IHRoZSBmdW5jdGlvbmFsaXR5IGZvciAnbmVzdGVkJyBnZXRzIG1vdmVkIG91dCBmcm9tIHRoYXQgY29kZSBmaWxlLiBOb3Qgc28gc3VyZSBhYm91dCB1c2luZyB0aGUgRGF0YV9UeXBlX0luc3RhbmNlLi4uXHJcblx0Ly8gIGl0IGNvdWxkIGJlIHVzZWZ1bCwgYnV0IG5vdCByZWFsbHkgdXNlZnVsIG9uIHRoZSBsZXZlbCBvZiB3aGF0IHRoZSB1c2VyIHdhbnRzIHRoZSBzeXN0ZW0gdG8gZG8uXHJcblx0Ly8gIFdhbnQgdG8gZ2V0IHRoZSBEYXRhX09iamVjdCBhbmQgQ29sbGVjdGlvbnMgc3lzdGVtIHdvcmtpbmcgaW4gc29tZSBtb3JlIGdlbmVyaWMgdGVzdHMsIGFsc28gd2FudCB0byBleHBsb3JlIHNvbWUgb2YgdGhlIG1vcmUgY29tcGxpY2F0ZWQgZGF0YSBzdHJ1Y3R1cmVzXHJcblx0Ly8gIHRoYXQgd2lsbCBiZSB1c2VkIGZvciBIVE1MLiBUaGUgaWRlYSBpcyB0aGF0IHRoZSBIVE1MIHNlY3Rpb24gd2lsbCBub3QgbmVlZCBzbyBtdWNoIGNvZGUgYmVjYXVzZSBpdCBpcyBtYWtpbmcgdXNlIG9mIHNvbWUgbW9yZSBnZW5lcmFsbHkgZGVmaW5lZCB0aGluZ3MuXHJcblxyXG5cdC8vIERlZmluaW5nIGFuIGVsZW1lbnQncyBzdHlsZSBhdHRyaWJ1dGVzLi4uIHdpbGwgdXNlIGEgRGF0YV9PYmplY3Qgc3lzdGVtIGludGVybmFsbHkgdGhhdCBpcyBjdXN0b21pemVkIHRvIHJlZm9ybWF0IGRhdGEuXHJcblx0Ly8gIFRoYXQgc2VlbXMgbGlrZSBhIGZhaXJseSBiaWcgZ29hbCwgd2FudCB0byBnZXQgdGhlc2UgdGhpbmdzIHdvcmtpbmcgb24gYSBzaW1wbGVyIGxldmVsIGFuZCBpbiBjb2xsZWN0aW9ucy5cclxuXHQvLyAgV2lsbCB1c2Ugc29tZSBraW5kIG9mIHBvbHltb3JwaGljIHJlYXJyYW5nZW1lbnQgdG8gcmVhcnJhbmdlIHdoZXJlIHN1aXRhYmxlLlxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBFeGVjdXRlcyBzZXZlcmFsIHRhc2tzIG9uZSBieSBvbmUgKGRlZmF1bHQpIG9yIHNpbXVsdGFuZW91c2x5ICh1cCB0byBzcGVjaWZpZWQgYW1vdW50IG9mIHRhc2tzIGF0IHRoZSBzYW1lIHRpbWUpLlxyXG4gICAgKlxyXG4gICAgKiBFYWNoIHRhc2sgY2FuIGJlIGEgZnVuY3Rpb24sIG9yIGFuIGFycmF5IGluLiBUaGUgZm9sbG93aW5nIHRhc2sgZm9ybWF0cyBhcmUgc3VwcG9ydGVkOlxyXG4gICAgKiAtIGZuXHJcbiAgICAqIC0gW2NvbnRleHQsIGZuXVxyXG4gICAgKiAtIFtmbiwgcGFyYW1zXVxyXG4gICAgKiAtIFtmbiwgcGFyYW1zLCBmbl9jYWxsYmFja11cclxuICAgICogLSBbY29udGV4dCwgZm4sIHBhcmFtc11cclxuICAgICogLSBbY29udGV4dCwgZm4sIHBhcmFtcywgZm5fY2FsbGJhY2tdXHJcbiAgICAqXHJcbiAgICAqIFRoZSB0YXNrIHBhcnRzIG1lYW46XHJcbiAgICAqIC0gY29udGV4dDogZXhlY3V0aW9uIGNvbnRleHQgKFwidGhpc1wiIHZhbHVlKVxyXG4gICAgKiAtIGZuIC0gdGFzayBmdW5jdGlvblxyXG4gICAgKiAtIHBhcmFtcyAtIHRhc2sgZnVuY3Rpb24gcGFyYW1ldGVycyBhcnJheVxyXG4gICAgKiAtIGZuX2NhbGxiYWNrIC0gY2FsbGJhY2sgZnVuY3Rpb24gY2FsbGluZyB3aGVuIHRoZSB0YXNrIGlzIGNvbXBsZXRlZDogZm5fY2FsbGJhY2sobnVsbCwgcmVzdWx0KSwgd2hlcmUgXCJyZXN1bHRcIiBpcyB0aGUgdGFzayBmdW5jdGlvbiByZXN1bHRcclxuICAgICpcclxuICAgICogVGhlIHRhc2sgZnVuY3Rpb24gbXVzdCBjYWxsIGEgcHJlZGVmaW5lZCBjYWxsYmFjayBmdW5jdGlvbi4gVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGlzIHBhc3NlZCBhcyB0aGUgbGFzdCBwYXJhbWV0ZXIgdG8gdGhlIHRhc2sgZnVuY3Rpb24uXHJcbiAgICAqIFRoZSBjYWxsYmFjayBmdW5jdGlvbiBsb29rcyBhcyBmb2xsb3dzOiBjYWxsYmFjayhlcnJvciwgcmVzdWx0KVxyXG4gICAgKiAtIGVycm9yOiBhbiBlcnJvciBvYmplY3Qgb3IgbnVsbFxyXG4gICAgKiAtIHJlc3VsdDogdGhlIHRhc2sgcmVzdWx0XHJcbiAgICAqXHJcbiAgICAqIFRoZSBcIm1haW5cIiBjYWxsYmFjayAocGFzc2VkIHRvIHRoZSBjYWxsX211bHRpcGxlX2NhbGxiYWNrX2Z1bmN0aW9ucygpIGNhbGwpIGxvb2tzIGFzIGZvbGxvd3M6XHJcbiAgICAqIGNhbGxiYWNrKGVycm9yLCByZXN1bHQpLCB3aGVyZSBcInJlc3VsdFwiIGlzIGFsbCB0aGUgdGFza3MgcmVzdWx0IGFycmF5LlxyXG4gICAgKlxyXG4gICAgKiBAZXhhbXBsZVxyXG4gICAgKiB2YXIgdGFza3MgPSBbXTtcclxuICAgICpcclxuICAgICogdmFyIHRhc2sxID0gZnVuY3Rpb24oYXJnMSwgYXJnMiwgY2IpIHtcclxuICAgICogICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IGNiKG51bGwsIChhcmcxICogYXJnMikpOyB9LCAxMDAwKTsgLy8gbXVsdGlwbHkgYXJnMSAqIGFyZzJcclxuICAgICogfTtcclxuICAgICpcclxuICAgICogdGFza3MucHVzaChbdGFzazEsIFsxMCwgMl1dKTsgICAvLyBtdWx0aXBseSAxMCAqIDJcclxuICAgICpcclxuICAgICogY2FsbF9tdWx0aXBsZV9jYWxsYmFja19mdW5jdGlvbnModGFza3MsIGZ1bmN0aW9uKGVycm9yLCByZXN1bHQpIHtcclxuICAgICogICAgY29uc29sZS5sb2coXCJBbGwgdGhlIHRhc2tzIGFyZSBkb25lLiBUaGUgZmlyc3QgdGFzayByZXN1bHQgaXMgXCIgKyByZXN1bHRbMF0pO1xyXG4gICAgKiB9KTtcclxuICAgICpcclxuICAgICpcclxuICAgICogQGZ1bmNcclxuICAgICogQHBhcmFtIHthcnJheX0gdGFza3MgLSB0YXNrcyBhcnJheVxyXG4gICAgKiBAcGFyYW0ge251bWJlcn0gW251bV9wYXJhbGxlbCA9IDFdIC0gbWF4aW11bSBhbW91bnQgb2YgdGFza3MgcnVubmluZyBzaW11bHRhbmVvdXNseVxyXG4gICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayAtIGNhbGxiYWNrIGZ1bmN0aW9uIGNhbGxlZCB3aGVuIGFsbCB0aGUgdGFza3MgYXJlIGNvbXBsZXRlZFxyXG4gICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXR1cm5fcGFyYW1zID0gZmFsc2VdIC0gaW5jbHVkZSB0aGUgdGFzayBwYXJhbWV0ZXJzIHRvIHRoZSB0YXNrIHJlc3VsdFxyXG4gICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvcmUvanNndWktbGFuZy1lc3NlbnRpYWxzXHJcbiAgICAqL1xyXG5cdHZhciBjYWxsX211bHRpcGxlX2NhbGxiYWNrX2Z1bmN0aW9ucyA9IGZwKGZ1bmN0aW9uKGEsIHNpZykge1xyXG5cdFx0Ly8gd2lsbCBsb29rIGF0IHRoZSBzaWduYXR1cmUgYW5kIGNob29zZSB3aGF0IHRvIGRvLlxyXG5cdFx0Ly9pZiAoc2lnID09IClcclxuXHRcdC8vIG5lZWQgdG8gYmUgY2hlY2tpbmcgaWYgdGhlIGl0ZW0gaXMgYW4gYXJyYXkgLSBuaWNlIHRvIGhhdmUgYSBkaWZmZXJlbnQgd2F5IG9mIGRvaW5nIHRoYXQgd2l0aCBmcC5cclxuXHJcblx0XHQvLyBhbmQgd2FudCB0byBsb29rIG91dCBmb3IgYSBudW1iZXIgaW4gdGhlcmUuXHJcblx0XHQvLyAgd2FudCBpdCB0byBjYWxsIG11bHRpcGxlIGZ1bmN0aW9ucywgYnV0IGhhdmUgdGhlbSBydW5uaW5nIGluIHBhcmFsbGVsIHRvby5cclxuXHRcdC8vICBsaWtlIHRoZSBhc3luYyBsaWJyYXJ5LCBidXQgYWxzbyBhY2NlcHRpbmcgcGFyYW1ldGVycy5cclxuXHJcblx0XHQvLyBhcnJfZnVuY3Rpb25zX3BhcmFtc19wYWlycywgY2FsbGJhY2tcclxuXHRcdHZhciBhcnJfZnVuY3Rpb25zX3BhcmFtc19wYWlycywgY2FsbGJhY2ssIHJldHVybl9wYXJhbXMgPSBmYWxzZTtcclxuICAgICAgICB2YXIgZGVsYXk7XHJcblxyXG5cdFx0Ly9jb25zb2xlLmxvZygnYS5sICcgKyBhLmwpO1xyXG5cdFx0Ly9jb25zb2xlLmxvZygnJyk7XHJcblx0XHQvL2NvbnNvbGUubG9nKCcnKTtcclxuXHRcdC8vY29uc29sZS5sb2coJ2NhbGxfbXVsdGkgc2lnICcgKyBzaWcpO1xyXG5cclxuICAgICAgICAvLyB3aGF0IGFib3V0IG51bV9wYXJhbGxlbCBiZWluZyB6ZXJvIHRvIGRvIHRoZW0gYWxsIGluIHBhcmFsbGVsP1xyXG4gICAgICAgIC8vICBtYXliZSB0cnkganVzdCBhIHZlcnkgaGlnaCBudW1iZXIgYXQgdGhlIG1vbWVudC5cclxuXHJcblxyXG5cclxuXHRcdHZhciBudW1fcGFyYWxsZWwgPSAxO1xyXG5cdFx0Ly9jb25zb2xlLmxvZygnYS5sJywgYS5sKTtcclxuXHRcdGlmIChhLmwgPT0gMikge1xyXG5cdFx0XHRhcnJfZnVuY3Rpb25zX3BhcmFtc19wYWlycyA9IGFbMF07XHJcblx0XHRcdC8vY29uc29sZS5sb2coJ2Fycl9mdW5jdGlvbnNfcGFyYW1zX3BhaXJzJywgYXJyX2Z1bmN0aW9uc19wYXJhbXNfcGFpcnMpO1xyXG5cdFx0XHRjYWxsYmFjayA9IGFbMV07XHJcblx0XHRcdC8vY29uc29sZS5sb2coJ2NhbGxiYWNrJywgY2FsbGJhY2spO1xyXG5cdFx0fVxyXG5cdFx0aWYgKGEubCA9PSAzKSB7XHJcblx0XHQgICAgLy8gbG9vayBhdCB0aGUgc2lnXHJcblx0XHQgICAgLy8gYXJyLCBudW0sIGZuIC0gbnVtYmVyIGlzIHRoZSBudW1iZXIgb2YgcGFyYWxsZWwgdG8gZG8gYXQgb25jZS5cclxuXHRcdCAgICAvLyByZXR1cm5fcGFyYW1zIGlzIGEgYm9vbGVhbj9cclxuXHJcblx0XHQgICAgLy8gd2FudCBhIHNpZ25hdHVyZSB0aGF0IGp1c3QgdHJlYXRzIGFuIGFycmF5IGFzIGE/XHJcblx0XHQgICAgLy8gIG1heSBtYWtlIG1vcmUgc2Vuc2UgZm9yIHRoZXNlIGZ1bmN0aW9uIHNpZ25hdHVyZXMuXHJcblx0XHQgICAgLy8gICBhdCBsZWFzdCBmb3IgdGhlIGZpcnN0IHN0YWdlLi4uIGNvdWxkIGxvb2sgaW4gbW9yZSBkZXRhaWwgYXQgdGhlIGFycmF5LlxyXG5cdFx0ICAgIC8vICAgbm90IHVzaW5nIHRoZSBtb3JlIGNvbXBsaWNhdGVkIHNpZ25hdHVyZXMgcmlnaHQgbm93LiBjb3VsZCBjaGFuZ2UgdG8gYSBkaWZmZXJlbnQgc2lnIG1ldGhvZCB3aGVuIG5lZWRlZCwgb3IgdXNlIGRpZmZlcmVudCBzaWcgb3IgZnAgb3B0aW9ucy5cclxuXHJcblx0XHQgICAgLy9jb25zb2xlLmxvZygnc2lnICcgKyBzaWcpO1xyXG5cclxuXHRcdCAgICBpZiAoc2lnID09ICdbYSxuLGZdJykge1xyXG5cdFx0ICAgICAgICBhcnJfZnVuY3Rpb25zX3BhcmFtc19wYWlycyA9IGFbMF07XHJcblx0XHQgICAgICAgIG51bV9wYXJhbGxlbCA9IGFbMV07XHJcblx0XHQgICAgICAgIGNhbGxiYWNrID0gYVsyXTtcclxuXHRcdCAgICB9XHJcbiAgICAgICAgICAgIGlmIChzaWcgPT0gJ1tuLGEsZl0nKSB7XHJcbiAgICAgICAgICAgICAgICBhcnJfZnVuY3Rpb25zX3BhcmFtc19wYWlycyA9IGFbMV07XHJcbiAgICAgICAgICAgICAgICBudW1fcGFyYWxsZWwgPSBhWzBdO1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBhWzJdO1xyXG4gICAgICAgICAgICB9XHJcblx0XHQgICAgaWYgKHNpZyA9PSAnW2EsZixiXScpIHtcclxuXHRcdCAgICAgICAgYXJyX2Z1bmN0aW9uc19wYXJhbXNfcGFpcnMgPSBhWzBdO1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBhWzFdO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuX3BhcmFtcyA9IGFbMl07XHJcblx0XHQgICAgfVxyXG5cclxuXHJcblx0XHR9XHJcbiAgICAgICAgaWYgKGEubCA9PSA0KSB7XHJcbiAgICAgICAgICAgIC8vIGxvb2sgYXQgdGhlIHNpZ1xyXG4gICAgICAgICAgICAvLyBhcnIsIG51bSwgZm4gLSBudW1iZXIgaXMgdGhlIG51bWJlciBvZiBwYXJhbGxlbCB0byBkbyBhdCBvbmNlLlxyXG4gICAgICAgICAgICAvLyByZXR1cm5fcGFyYW1zIGlzIGEgYm9vbGVhbj9cclxuXHJcbiAgICAgICAgICAgIC8vIHdhbnQgYSBzaWduYXR1cmUgdGhhdCBqdXN0IHRyZWF0cyBhbiBhcnJheSBhcyBhP1xyXG4gICAgICAgICAgICAvLyAgbWF5IG1ha2UgbW9yZSBzZW5zZSBmb3IgdGhlc2UgZnVuY3Rpb24gc2lnbmF0dXJlcy5cclxuICAgICAgICAgICAgLy8gICBhdCBsZWFzdCBmb3IgdGhlIGZpcnN0IHN0YWdlLi4uIGNvdWxkIGxvb2sgaW4gbW9yZSBkZXRhaWwgYXQgdGhlIGFycmF5LlxyXG4gICAgICAgICAgICAvLyAgIG5vdCB1c2luZyB0aGUgbW9yZSBjb21wbGljYXRlZCBzaWduYXR1cmVzIHJpZ2h0IG5vdy4gY291bGQgY2hhbmdlIHRvIGEgZGlmZmVyZW50IHNpZyBtZXRob2Qgd2hlbiBuZWVkZWQsIG9yIHVzZSBkaWZmZXJlbnQgc2lnIG9yIGZwIG9wdGlvbnMuXHJcblxyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdzaWcgJyArIHNpZyk7XHJcblxyXG4gICAgICAgICAgICBpZiAoc2lnID09ICdbYSxuLG4sZl0nKSB7XHJcbiAgICAgICAgICAgICAgICBhcnJfZnVuY3Rpb25zX3BhcmFtc19wYWlycyA9IGFbMF07XHJcbiAgICAgICAgICAgICAgICBudW1fcGFyYWxsZWwgPSBhWzFdO1xyXG4gICAgICAgICAgICAgICAgZGVsYXkgPSBhWzJdO1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBhWzNdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChzaWcgPT0gJ1tuLG4sYSxmXScpIHtcclxuICAgICAgICAgICAgICAgIGFycl9mdW5jdGlvbnNfcGFyYW1zX3BhaXJzID0gYVsyXTtcclxuICAgICAgICAgICAgICAgIG51bV9wYXJhbGxlbCA9IGFbMF07XHJcbiAgICAgICAgICAgICAgICBkZWxheSA9IGFbMV07XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IGFbM107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy9pZiAoc2lnID09ICdbYSxmLGJdJykge1xyXG4gICAgICAgICAgICAvLyAgICBhcnJfZnVuY3Rpb25zX3BhcmFtc19wYWlycyA9IGFbMF07XHJcbiAgICAgICAgICAgIC8vICAgIGNhbGxiYWNrID0gYVsxXTtcclxuICAgICAgICAgICAgLy8gICAgcmV0dXJuX3BhcmFtcyA9IGFbMl07XHJcbiAgICAgICAgICAgIC8vfVxyXG5cclxuICAgICAgICB9XHJcblxyXG5cclxuXHJcblx0XHQvLyBhbHNvIHdhbnQgdGhlIGNvbnRleHQuXHJcblxyXG5cdFx0dmFyIHJlcyA9IFtdO1xyXG5cclxuXHRcdHZhciBsID0gYXJyX2Z1bmN0aW9uc19wYXJhbXNfcGFpcnMubGVuZ3RoO1xyXG5cdFx0dmFyIGMgPSAwO1xyXG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xyXG5cclxuXHRcdHZhciBjb3VudF91bmZpbmlzaGVkID0gbDtcclxuXHJcblx0XHQvLyB0aGUgbnVtYmVyIG9mIHByb2Nlc3NlcyBnb2luZ1xyXG5cclxuXHRcdC8vIHRoZSBtYXhpbXVtIG51bWJlciBvZiBwcm9jZXNzZXMgYWxsb3dlZC5cclxuICAgICAgICAvLyAgbnVtX3BhcmFsbGVsXHJcblxyXG4gICAgICAgIHZhciBudW1fY3VycmVudGx5X2V4ZWN1dGluZyA9IDA7XHJcblxyXG5cdFx0dmFyIHByb2Nlc3MgPSBmdW5jdGlvbihkZWxheSkge1xyXG4gICAgICAgICAgICBudW1fY3VycmVudGx5X2V4ZWN1dGluZysrO1xyXG4gICAgICAgICAgICB2YXIgbWFpbiA9IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIHRoZXkgbWF5IG5vdCBiZSBwYWlycywgdGhleSBjb3VsZCBiZSBhIHRyaXBsZSB3aXRoIGEgY2FsbGJhY2suXHJcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdudW1fY3VycmVudGx5X2V4ZWN1dGluZyAnICsgbnVtX2N1cnJlbnRseV9leGVjdXRpbmcpO1xyXG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnbnVtX3BhcmFsbGVsJywgbnVtX3BhcmFsbGVsKTtcclxuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2MgJyArIGMpO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBwYWlyID0gYXJyX2Z1bmN0aW9uc19wYXJhbXNfcGFpcnNbY107XHJcbiAgICAgICAgICAgICAgICAvLyBtYXliZSB0aGVyZSB3b24ndCBiZSBhIHBhaXIuXHJcbiAgICAgICAgICAgICAgICAvLyAgc2hvdWxkIHRyeSB0byBwcmV2ZW50IHRoaXMgc2l0dWF0aW9uLlxyXG5cclxuXHJcblxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdwYWlyJywgcGFpcik7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gb2JqZWN0IChjb250ZXh0IC8gY2FsbGVyKSwgZnVuY3Rpb24sIHBhcmFtc1xyXG4gICAgICAgICAgICAgICAgLy8gb2JqZWN0IChjb250ZXh0IC8gY2FsbGVyKSwgZnVuY3Rpb24sIHBhcmFtcywgZm5fY2FsbGJhY2tcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgY29udGV4dDtcclxuICAgICAgICAgICAgICAgIHZhciBmbiwgcGFyYW1zLCBmbl9jYWxsYmFjaztcclxuICAgICAgICAgICAgICAgIC8vIGZ1bmN0aW9uLCBhcnJheVxyXG4gICAgICAgICAgICAgICAgLy8gY29udGV4dFxyXG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygncGFpci5sZW5ndGggJyArIHBhaXIubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgIHZhciBwYWlyX3NpZyA9IGdldF9pdGVtX3NpZyhwYWlyKTtcclxuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3BhaXJfc2lnICcgKyBwYWlyX3NpZyk7XHJcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKGpzZ3VpLmF0b2YocGFpcikpO1xyXG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygncGFpci5sZW5ndGggJyArIHBhaXIubGVuZ3RoKTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgdF9wYWlyID0gdG9mKHBhaXIpO1xyXG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygndF9wYWlyJywgdF9wYWlyKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAodF9wYWlyID09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgICAgICBmbiA9IHBhaXI7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zID0gW107XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhaXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhaXIubGVuZ3RoID09IDEpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYWlyLmxlbmd0aCA9PSAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBbY29udGV4dCwgZm5dXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBbZm4sIHBhcmFtc11cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2lmICh0b2YocGFpclswXSkgPT0gJ2Z1bmN0aW9uJyAmJiB0b2YocGFpclsxXSkgPT0gJ2FycmF5JyAmJiBwYWlyLmxlbmd0aCA9PSAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1x0Zm4gPSBwYWlyWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9cdHBhcmFtcyA9IHBhaXJbMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL31cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vID8sIGZ1bmN0aW9uXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRvZihwYWlyWzFdKSA9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dCA9IHBhaXJbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm4gPSBwYWlyWzFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbiA9IHBhaXJbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zID0gcGFpclsxXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZnVuY3Rpb24sIGFycmF5LCBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFpci5sZW5ndGggPT0gMykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gW2ZuLCBwYXJhbXMsIGZuX2NhbGxiYWNrXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gW2NvbnRleHQsIGZuLCBwYXJhbXNdXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRvZihwYWlyWzBdKSA9PSAnZnVuY3Rpb24nICYmIHRvZihwYWlyWzFdKSA9PSAnYXJyYXknICYmIHRvZihwYWlyWzJdKSA9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm4gPSBwYWlyWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcyA9IHBhaXJbMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm5fY2FsbGJhY2sgPSBwYWlyWzJdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb2JqZWN0IC8gZGF0YV9vYmplY3Q/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyA/LCBmdW5jdGlvbiwgYXJyYXlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0b2YocGFpclsxXSkgPT0gJ2Z1bmN0aW9uJyAmJiB0b2YocGFpclsyXSkgPT0gJ2FycmF5Jykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2hhcyBjb250ZXh0Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dCA9IHBhaXJbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm4gPSBwYWlyWzFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcyA9IHBhaXJbMl07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1heSBub3QgYmUgYSBmbl9jYWxsYmFjayBpbiB0aGlzIGNhc2UuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYWlyLmxlbmd0aCA9PSA0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBbY29udGV4dCwgZm4sIHBhcmFtcywgZm5fY2FsbGJhY2tdXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29udGV4dCwgZnVuY3Rpb24gYmVpbmcgY2FsbGVkLCBwYXJhbXMsIGNiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0ID0gcGFpclswXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZuID0gcGFpclsxXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcyA9IHBhaXJbMl07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbl9jYWxsYmFjayA9IHBhaXJbM107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdtaXNzaW5nIHBhaXInKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBGb3Igc29tZSByZWFzb24gdGhlIHBhaXIgY2FuIGJlIHVuZGVmaW5lZC5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgZG9uJ3QgaGF2ZSBhIHBhaXIgb2YgdGhlbS5cclxuICAgICAgICAgICAgICAgICAgICAvLyAgSGF2ZSB3ZSBjYWxsZWQgd2l0aCB0aGUgd3JvbmcgZGF0YT9cclxuICAgICAgICAgICAgICAgICAgICAvLyAgIERvIGEgY2FsbGJhY2ssIHJlc3VsdCBpcyBmYWxzZS5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG5cclxuICAgICAgICAgICAgICAgIHZhciBpID0gYztcclxuICAgICAgICAgICAgICAgIC8vIG5vdCBzdXJlIGl0IGtlZXBzIHRoaXMgc2FtZSB2YWx1ZSBvZiBpLlxyXG4gICAgICAgICAgICAgICAgLy8gIGNhbiB0cnkgc29tZSB0ZXN0cyBvbiB0aGlzLlxyXG5cclxuICAgICAgICAgICAgICAgIGMrKztcclxuICAgICAgICAgICAgICAgIC8vdGhyb3cgJ3N0b3AnO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBjYiA9IGZ1bmN0aW9uKGVyciwgcmVzMikge1xyXG4gICAgICAgICAgICAgICAgICAgIG51bV9jdXJyZW50bHlfZXhlY3V0aW5nLS07XHJcbiAgICAgICAgICAgICAgICAgICAgY291bnRfdW5maW5pc2hlZC0tO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2NiIG51bV9jdXJyZW50bHlfZXhlY3V0aW5nICcgKyBudW1fY3VycmVudGx5X2V4ZWN1dGluZyArICcsIGMgJyArIGMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0YWNrID0gbmV3IEVycm9yKCkuc3RhY2s7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coc3RhY2spO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnaSAnICsgaSArICcsIHJlczIgJyArIHJlczIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmV0dXJuX3BhcmFtcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnY2FsbF9tdWx0aSBpbm5lciBjYiByZXR1cm5fcGFyYW1zICcgKyBzdHJpbmdpZnkocmV0dXJuX3BhcmFtcykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy90aHJvdyAnc3RvcCc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdwYXJhbXMgJyArIHBhcmFtcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNbaV0gPSBbcGFyYW1zLCByZXMyXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc1tpXSA9IHJlczI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygncGFpci5sZW5ndGggJyArIHBhaXIubGVuZ3RoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmbl9jYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm5fY2FsbGJhY2sobnVsbCwgcmVzMik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLypcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFpci5sZW5ndGggPT0gMykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgZm5fY2FsbGJhY2sobnVsbCwgcmVzMik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFpci5sZW5ndGggPT0gNCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgZm5fY2FsbGJhY2sobnVsbCwgcmVzMik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdjJywgYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2wnLCBsKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjIDwgbCkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9ubHkgcHJvY2VzcyBpZiB0aGUgbnVtIGV4ZWN1dGluZyBpcyBsZXNzIHRoYW4gdGhlIG1heCBudW0gdG8gZXhlY3V0ZS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG90aGVyd2lzZSB0aGUgcHJvY2VzcyB3aWxsIGJlIGRvbmUgd2hlbiBhIGNhbGxhYmNrIGlzIHByb2R1Y2VkIGZyb20gdGhlIGZ1bmN0aW9uLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnbnVtX2N1cnJlbnRseV9leGVjdXRpbmcnLCBudW1fY3VycmVudGx5X2V4ZWN1dGluZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobnVtX2N1cnJlbnRseV9leGVjdXRpbmcgPCBudW1fcGFyYWxsZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9jZXNzKGRlbGF5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnY291bnRfdW5maW5pc2hlZCcsIGNvdW50X3VuZmluaXNoZWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvdW50X3VuZmluaXNoZWQgPD0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHJlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLy8gQ2xvbmUgdGhlIHBhcmFtcz9cclxuICAgICAgICAgICAgICAgIC8vICBSZWFsbHkgbm90IHN1cmUgYWJvdXQgdGhhdC5cclxuICAgICAgICAgICAgICAgIHZhciBhcnJfdG9fY2FsbCA9IGNsb25lKHBhcmFtcykgfHwgW107XHJcbiAgICAgICAgICAgICAgICAvL3ZhciBhcnJfdG9fY2FsbCA9IChwYXJhbXMpIHx8IFtdO1xyXG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygncGFyYW1zJywgcGFyYW1zKTtcclxuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2Fycl90b19jYWxsJywgYXJyX3RvX2NhbGwpO1xyXG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygncGFyYW1zICcgKyBwYXJhbXMpO1xyXG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnZm4gJyArIGZuKTtcclxuICAgICAgICAgICAgICAgIGFycl90b19jYWxsLnB1c2goY2IpO1xyXG4gICAgICAgICAgICAgICAgLy8gYnV0IGlmIHRoZSBmdW5jdGlvbiBkb2VzIG5vdCBoYXZlIGEgY2FsbGJhY2s/XHJcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdjb250ZXh0ICcgKyBjb250ZXh0KTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoZm4pIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY29udGV4dCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmbi5hcHBseShjb250ZXh0LCBhcnJfdG9fY2FsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm4uYXBwbHkodGhhdCwgYXJyX3RvX2NhbGwpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9jYihudWxsLCB1bmRlZmluZWQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJzIpIGRlbGF5JywgZGVsYXkpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGFycl9mdW5jdGlvbnNfcGFyYW1zX3BhaXJzW2NdKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGVsYXkpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KG1haW4sIGRlbGF5KTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWFpbigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblx0XHR9XHJcblx0XHQvL2NvbnNvbGUubG9nKCcqKiBhcnJfZnVuY3Rpb25zX3BhcmFtc19wYWlycy5sZW5ndGggJyArIGFycl9mdW5jdGlvbnNfcGFyYW1zX3BhaXJzLmxlbmd0aCk7XHJcblx0XHRpZiAoYXJyX2Z1bmN0aW9uc19wYXJhbXNfcGFpcnMubGVuZ3RoID4gMCkge1xyXG5cdFx0ICAgIHdoaWxlICgoYyA8IGwpICAmJiAobnVtX2N1cnJlbnRseV9leGVjdXRpbmcgPCBudW1fcGFyYWxsZWwpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGVsYXkpIHtcclxuICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdzdG8nKTtcclxuICAgICAgICAgICAgICAgICAgICAvL3NldFRpbWVvdXQocHJvY2VzcywgZGVsYXkgKiBjKTtcclxuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzKGRlbGF5ICogYyk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3MoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHRcdCAgICB9XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0ICAgIGlmIChjYWxsYmFjaykge1xyXG5cdFx0ICAgICAgICAvL2NhbGxiYWNrKG51bGwsIG51bGwpO1xyXG4gICAgICAgICAgICB9XHJcblx0XHR9XHJcblx0fSk7XHJcblx0dmFyIG11bHRpID0gY2FsbF9tdWx0aXBsZV9jYWxsYmFja19mdW5jdGlvbnM7XHJcbiAgICAvKipcclxuICAgICogQWxpYXMgdG8gdGhlIFtjYWxsX211bHRpcGxlX2NhbGxiYWNrX2Z1bmN0aW9ucygpXXtAbGluayBtb2R1bGU6Y29yZS9qc2d1aS1sYW5nLWVzc2VudGlhbHMuY2FsbF9tdWx0aXBsZV9jYWxsYmFja19mdW5jdGlvbnN9IGZ1bmN0aW9uLlxyXG4gICAgKiBAZnVuY1xyXG4gICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvcmUvanNndWktbGFuZy1lc3NlbnRpYWxzXHJcbiAgICAqL1xyXG4gICAgdmFyIGNhbGxfbXVsdGkgPSBjYWxsX211bHRpcGxlX2NhbGxiYWNrX2Z1bmN0aW9ucztcclxuICAgIC8qKlxyXG4gICAgKiBSZXR1cm5zIGEgW2NhbGxfbXVsdGlwbGVfY2FsbGJhY2tfZnVuY3Rpb25zKClde0BsaW5rIG1vZHVsZTpjb3JlL2pzZ3VpLWxhbmctZXNzZW50aWFscy5jYWxsX211bHRpcGxlX2NhbGxiYWNrX2Z1bmN0aW9uc30gaGVscGVyIG9iamVjdC4gVGhlIG9iamVjdCBpcyBhbiBhcnJheSB3aXRoIGBnbygpYCBtZXRob2QgYWRkZWQuXHJcbiAgICAqIFlvdSBjYW4gYWRkIHRoZSBbY2FsbF9tdWx0aXBsZV9jYWxsYmFja19mdW5jdGlvbnMoKV17QGxpbmsgbW9kdWxlOmNvcmUvanNndWktbGFuZy1lc3NlbnRpYWxzLmNhbGxfbXVsdGlwbGVfY2FsbGJhY2tfZnVuY3Rpb25zfSB0YXNrcyB0byB0aGUgYXJyYXksIHRoZW4gY2FsbCB0aGUgZ28oKSBtZXRob2QgcGFzc2luZyB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXHJcbiAgICAqIEBmdW5jXHJcbiAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29yZS9qc2d1aS1sYW5nLWVzc2VudGlhbHNcclxuICAgICogQGV4YW1wbGVcclxuICAgICpcclxuXHQqICAgdmFyIHRhc2tQbHVzID0gZnVuY3Rpb24gKGEsIGIsIGNiKSB7IGNiKG51bGwsIGEgKyBiKTsgfTtcclxuXHQqICAgdmFyIHRhc2tNaW51cyA9IGZ1bmN0aW9uIChhLCBiLCBjYikgeyBjYihudWxsLCBhIC0gYik7IH07XHJcbiAgICAqXHJcblx0KiAgIHZhciBmbnMgPSBqc2d1aS5GbnMoKTtcclxuICAgICpcclxuXHQqICAgZm5zLnB1c2goW3Rhc2tQbHVzLCBbMSwgMl1dKTtcclxuXHQqICAgZm5zLnB1c2goW3Rhc2tQbHVzLCBbMywgNF1dKTtcclxuXHQqICAgZm5zLnB1c2goW3Rhc2tNaW51cywgWzEsIDJdXSk7XHJcblx0KiAgIGZucy5wdXNoKFt0YXNrUGx1cywgWzEwLCAxMl1dKTtcclxuICAgICpcclxuXHQqICAgZm5zLmdvKGZ1bmN0aW9uIChlcnJvciwgcmVzdWx0KSB7XHJcblx0KiAgICAgICBjb25zb2xlLmxvZyhyZXN1bHQpOyAgLy8gIFszLCA3LCAtMSwgMjJdXHJcblx0KiAgIH0pO1xyXG4gICAgKlxyXG4gICAgKi9cclxuXHR2YXIgRm5zID0gZnVuY3Rpb24oKSB7XHJcblx0ICAgIHZhciBmbnMgPSBbXTtcclxuXHQgICAgZm5zLmdvID0gZnVuY3Rpb24ocGFyYWxsZWwsIGRlbGF5LCBjYWxsYmFjaykge1xyXG5cclxuICAgICAgICAgICAgLy8gU2hvdWxkIGhhdmUgYmV0dGVyIHBhcmFtIGNoZWNraW5nIGhlcmUuXHJcblxyXG5cclxuXHJcblxyXG4gICAgICAgICAgICAvL2lmICghY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgLy8gICAgY2FsbF9tdWx0aShmbnMsIHBhcmFsbGVsKTtcclxuICAgICAgICAgICAgLy99IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyAgICBjYWxsX211bHRpKHBhcmFsbGVsLCBmbnMsIGNhbGxiYWNrKTtcclxuICAgICAgICAgICAgLy99XHJcblxyXG4gICAgICAgICAgICB2YXIgYSA9IGFyZ3VtZW50cztcclxuICAgICAgICAgICAgdmFyIGFsID0gYS5sZW5ndGg7XHJcblxyXG5cclxuXHJcbiAgICAgICAgICAgIC8vIE5vLCB3ZSBtYXkgZ2l2ZSB0aGUgbnVtYmVyIGluIHBhcmFsbGVsLCBhbG9uZ3NpZGUgYSBjYWxsYmFjay5cclxuXHJcbiAgICAgICAgICAgIC8vIGNhbGwgY2FzZXM6XHJcblx0ICAgICAgICAvLyAoY2FsbGJhY2spXHJcblx0ICAgICAgICAvLyAocGFyYWxsZWwsIGNhbGxiYWNrKVxyXG5cdCAgICAgICAgLy8gKHBhcmFsbGVsLCBkZWxheSwgY2FsbGJhY2spXHJcblxyXG4gICAgICAgICAgICBpZiAoYWwgPT0gMSkge1xyXG4gICAgICAgICAgICAgICAgY2FsbF9tdWx0aShmbnMsIHBhcmFsbGVsKTsgLy8gbWVhbmluZyBjYWxsX211bHRpKGZucywgY2FsbGJhY2spO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChhbCA9PSAyKSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsX211bHRpKHBhcmFsbGVsLCBmbnMsIGRlbGF5KTsgLy8gbWVhbmluZyBjYWxsX211bHRpKHBhcmFsbGVsLCBmbnMsIGNhbGxiYWNrKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoYWwgPT0gMykge1xyXG4gICAgICAgICAgICAgICAgY2FsbF9tdWx0aShwYXJhbGxlbCwgZGVsYXksIGZucywgY2FsbGJhY2spO1xyXG4gICAgICAgICAgICB9XHJcblxyXG5cclxuXHJcblxyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBmbnM7XHJcblx0fVxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBSZXR1cm5zIGEgbmFtZSBvZiB0aGUgcGFzc2VkIG5hdGl2ZSBjb25zdHJ1Y3RvciBmdW5jdGlvbi4gUG9zc2libGUgcmV0dXJuIHZhbHVlcyBhcmU6XHJcbiAgICAqIC0gXCJTdHJpbmdcIlxyXG4gICAgKiAtIFwiTnVtYmVyXCJcclxuICAgICogLSBcIkJvb2xlYW5cIlxyXG4gICAgKiAtIFwiQXJyYXlcIlxyXG4gICAgKiAtIFwiT2JqZWN0XCJcclxuICAgICogLSB1bmRlZmluZWQgKGZvciBhbGwgb3RoZXIgYXJndW1lbnRzKVxyXG4gICAgKlxyXG4gICAgKiBAZnVuY1xyXG4gICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvcmUvanNndWktbGFuZy1lc3NlbnRpYWxzXHJcbiAgICAqIEBleGFtcGxlXHJcbiAgICAqXHJcbiAgICAqIGpzZ3VpLm5hdGl2ZV9jb25zdHJ1Y3Rvcl90b2YoU3RyaW5nKSAgPT0+ICBcIlN0cmluZ1wiXHJcbiAgICAqXHJcbiAgICAqIGpzZ3VpLm5hdGl2ZV9jb25zdHJ1Y3Rvcl90b2YoRGF0ZSkgID09PiAgdW5kZWZpbmVkXHJcbiAgICAqXHJcbiAgICAqL1xyXG5cdHZhciBuYXRpdmVfY29uc3RydWN0b3JfdG9mID0gZnVuY3Rpb24odmFsdWUpIHtcclxuXHRcdGlmICh2YWx1ZSA9PT0gU3RyaW5nKSB7XHJcblx0XHRcdHJldHVybiAnU3RyaW5nJztcclxuXHRcdH1cclxuXHRcdGlmICh2YWx1ZSA9PT0gTnVtYmVyKSB7XHJcblx0XHRcdHJldHVybiAnTnVtYmVyJztcclxuXHRcdH1cclxuXHRcdGlmICh2YWx1ZSA9PT0gQm9vbGVhbikge1xyXG5cdFx0XHRyZXR1cm4gJ0Jvb2xlYW4nO1xyXG5cdFx0fVxyXG5cdFx0aWYgKHZhbHVlID09PSBBcnJheSkge1xyXG5cdFx0XHRyZXR1cm4gJ0FycmF5JztcclxuXHRcdH1cclxuXHRcdGlmICh2YWx1ZSA9PT0gT2JqZWN0KSB7XHJcblx0XHRcdHJldHVybiAnT2JqZWN0JztcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8vdmFyIHN0b3JhZ2VfY2xvc3VyZVxyXG5cclxuXHQvLyBqc2d1aS5nZXQgYW5kIGpzZ3VpLnNldFxyXG5cdC8vICBzbyBKU0dVSSBpdHNlbGYgd291bGQgaGF2ZSBzb21lIHByb3BlcnRpZXMgd2l0aGluIGEgY2xvc3VyZS5cclxuXHQvLyAgTm90IHN1cmUgaWYgdGhhdCB3b3VsZCBhbGxvdyBzb21lIGtpbmQgb2YgZ2xvYmFsIHZhcmlhYmxlcyAoYWdhaW4pLlxyXG5cdHZhciBzdG9yYWdlX21hcCA9IHt9O1xyXG5cclxuXHJcbiAgICAvKipcclxuICAgICogR2V0cyB2YWx1ZSBmcm9tIHRoZSBtb2R1bGUncyBpbnRlcm5hbCBrZXkvdmFsdWUgc3RvcmFnZS5cclxuICAgICogQGZ1bmNcclxuICAgICogQHBhcmFtIHtzdHJpbmd8Kn0ga2V5IC0gdGhlIHZhbHVlIGtleVxyXG4gICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvcmUvanNndWktbGFuZy1lc3NlbnRpYWxzXHJcbiAgICAqIEBleGFtcGxlXHJcbiAgICAqXHJcbiAgICAqIGpzZ3VpLnNldChcImFcIiwgMSk7XHJcbiAgICAqIGpzZ3VpLnNldCgxMDAsIDIpO1xyXG4gICAgKlxyXG4gICAgKlxyXG4gICAgKiBqc2d1aS5nZXQoXCJhXCIpICA9PT4gIDFcclxuICAgICoganNndWkuZ2V0KDEwMCkgID09PiAgMlxyXG4gICAgKlxyXG4gICAgKi9cclxuXHR2YXIgZ2V0ID0gZnVuY3Rpb24oa2V5KSB7XHJcblx0XHRyZXR1cm4gc3RvcmFnZV9tYXBba2V5XTtcclxuXHR9XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFNldHMgdmFsdWUgZm9yIHRoZSBtb2R1bGUncyBpbnRlcm5hbCBrZXkvdmFsdWUgc3RvcmFnZS5cclxuICAgICogQGZ1bmNcclxuICAgICogQHBhcmFtIHtzdHJpbmd8Kn0ga2V5IC0gdGhlIHZhbHVlIGtleVxyXG4gICAgKiBAcGFyYW0geyp9IHZhbHVlIC0gdGhlIHZhbHVlXHJcbiAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29yZS9qc2d1aS1sYW5nLWVzc2VudGlhbHNcclxuICAgICogQGV4YW1wbGVcclxuICAgICpcclxuICAgICoganNndWkuc2V0KFwiYVwiLCAxKTtcclxuICAgICoganNndWkuc2V0KDEwMCwgMik7XHJcbiAgICAqXHJcbiAgICAqXHJcbiAgICAqIGpzZ3VpLmdldChcImFcIikgID09PiAgMVxyXG4gICAgKiBqc2d1aS5nZXQoMTAwKSAgPT0+ICAyXHJcbiAgICAqXHJcbiAgICAqL1xyXG5cdHZhciBzZXQgPSBmdW5jdGlvbihrZXksIHZhbHVlKSB7XHJcblx0XHRzdG9yYWdlX21hcFtrZXldID0gdmFsdWU7XHJcblx0fVxyXG5cclxuXHJcbiAgICB2YXIgc2lnX21hdGNoID0gZnVuY3Rpb24oc2lnMSwgc2lnMikge1xyXG4gICAgICAgIC8vIERvZXMgc2lnMiBtYXRjaCBzaWcxXHJcblxyXG4gICAgICAgIC8vIFdlIGdvIHRocm91Z2ggc2lnMSwgY2hlY2tpbmcgaXRlbSBieSBpdGVtLlxyXG5cclxuICAgICAgICAvLyBTaWdzIGhhdmUgdG8gYmUgdGhlIHNhbWUgbGVuZ3RoIEkgdGhpbms/XHJcblxyXG4gICAgICAgIC8vIEkgdGhpbmsganVzdCBjaGVjayBmbGF0IHNpZ3M/XHJcbiAgICAgICAgLy8gIE9yIHdlIGNvdWxkIGRvIHRoaXMgcmVjdXJzaXZlbHkgYW55d2F5LlxyXG5cclxuICAgICAgICB2YXIgc2lnMV9pbm5lciA9IHNpZzEuc3Vic3RyKDEsIHNpZzEubGVuZ3RoIC0gMik7XHJcbiAgICAgICAgLy9jb25zb2xlLmxvZygnc2lnMV9pbm5lcicsIHNpZzFfaW5uZXIpO1xyXG5cclxuICAgICAgICB2YXIgc2lnMl9pbm5lciA9IHNpZzIuc3Vic3RyKDEsIHNpZzIubGVuZ3RoIC0gMik7XHJcbiAgICAgICAgLy9jb25zb2xlLmxvZygnc2lnMl9pbm5lcicsIHNpZzJfaW5uZXIpO1xyXG5cclxuICAgICAgICBpZiAoc2lnMV9pbm5lci5pbmRleE9mKCdbJykgPiAtMSB8fCBzaWcxX2lubmVyLmluZGV4T2YoJ10nKSA+IC0xIHx8IHNpZzJfaW5uZXIuaW5kZXhPZignWycpID4gLTEgfHwgc2lnMl9pbm5lci5pbmRleE9mKCddJykgPiAtMSkge1xyXG4gICAgICAgICAgICB0aHJvdyAnc2lnX21hdGNoIG9ubHkgc3VwcG9ydHMgZmxhdCBzaWduYXR1cmVzLic7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgc2lnMV9wYXJ0cyA9IHNpZzFfaW5uZXIuc3BsaXQoJywnKTtcclxuICAgICAgICAvL3ZhciBzaWcyX3BhcnRzID0gc2lnMV9pbm5lci5zcGxpdCgnLCcpO1xyXG4gICAgICAgIHZhciBzaWcyX3BhcnRzID0gc2lnMl9pbm5lci5zcGxpdCgnLCcpO1xyXG5cclxuICAgICAgICB2YXIgcmVzID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgaWYgKHNpZzFfcGFydHMubGVuZ3RoID09IHNpZzJfcGFydHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHZhciBjID0gMCwgbCA9IHNpZzFfcGFydHMubGVuZ3RoLCBpMSwgaTI7XHJcbiAgICAgICAgICAgIHdoaWxlIChyZXMgJiYgYyA8IGwpIHtcclxuICAgICAgICAgICAgICAgIGkxID0gc2lnMV9wYXJ0c1tjXTtcclxuICAgICAgICAgICAgICAgIGkyID0gc2lnMl9wYXJ0c1tjXTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoaTEgPT09IGkyKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaTEgIT09ICc/Jykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXMgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgYysrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXM7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy90aHJvdyAnc3RvcCc7XHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbiAgICB9XHJcblxyXG5cclxuXHQvKlxyXG5cclxuXHQoZnVuY3Rpb24oKSB7XHJcblxyXG5cclxuXHR9KSgpO1xyXG5cclxuXHQqL1xyXG5cdC8vIHdpbGwgcHV0IGZ1bmN0aW9ucyBpbnRvIHRoZSBqc2d1aSBvYmplY3QuXHJcblxyXG5cdC8vIHdpdGggdGhlIGZ1bmN0aW9ucyBsaXN0ZWQgbGlrZSB0aGlzIGl0IHdpbGwgYmUgZWFzaWVyIHRvIGRvY3VtZW50IHRoZW0uXHJcblxyXG5cdHZhciBqc2d1aSA9IHtcclxuXHRcdCdDbGFzcycgOiBDbGFzcyxcclxuXHRcdCdlYWNoJyA6IGVhY2gsXHJcblx0XHQnZWFjJzogZWFjLFxyXG5cdFx0J2lzX2FycmF5JyA6IGlzX2FycmF5LFxyXG5cdFx0J2lzX2RvbV9ub2RlJyA6IGlzX2RvbV9ub2RlLFxyXG5cdFx0J2lzX2N0cmwnIDogaXNfY3RybCxcclxuXHRcdCdleHRlbmQnIDogZXh0ZW5kLFxyXG5cdFx0J2Nsb25lJyA6IGNsb25lLFxyXG5cdFx0Ly8neF9jbG9uZXMnIDogeF9jbG9uZXMsXHJcblx0XHQnZ2V0X3RydXRoX21hcF9mcm9tX2FycicgOiBnZXRfdHJ1dGhfbWFwX2Zyb21fYXJyLFxyXG5cdFx0J2Fycl90cmltX3VuZGVmaW5lZCc6IGFycl90cmltX3VuZGVmaW5lZCxcclxuXHRcdCdnZXRfbWFwX2Zyb21fYXJyJyA6IGdldF9tYXBfZnJvbV9hcnIsXHJcblx0XHQnYXJyX2xpa2VfdG9fYXJyJyA6IGFycl9saWtlX3RvX2FycixcclxuXHRcdCd0b2YnIDogdG9mLFxyXG5cdFx0J2F0b2YnIDogYXRvZixcclxuXHRcdCdpc19kZWZpbmVkJyA6IGlzX2RlZmluZWQsXHJcblx0XHQnc3RyaW5naWZ5JyA6IHN0cmluZ2lmeSxcclxuXHRcdCdmdW5jdGlvbmFsX3BvbHltb3JwaGlzbScgOiBmdW5jdGlvbmFsX3BvbHltb3JwaGlzbSxcclxuXHRcdCdmcCcgOiBmcCxcclxuXHRcdCdhcnJheWlmeScgOiBhcnJheWlmeSxcclxuXHRcdCdtYXBpZnknIDogbWFwaWZ5LFxyXG5cdFx0J2FyZV9lcXVhbCcgOiBhcmVfZXF1YWwsXHJcbiAgICAnZ2V0X2Ffc2lnJzogZ2V0X2Ffc2lnLFxyXG5cdFx0J2dldF9pdGVtX3NpZycgOiBnZXRfaXRlbV9zaWcsXHJcblx0XHQnc2V0X3ZhbHMnOiBzZXRfdmFscyxcclxuXHRcdCd0cnV0aCc6IHRydXRoLFxyXG5cdFx0J3RyaW1fc2lnX2JyYWNrZXRzJyA6IHRyaW1fc2lnX2JyYWNrZXRzLFxyXG5cdFx0J2xsX3NldCc6IGxsX3NldCxcclxuXHRcdCdsbF9nZXQnOiBsbF9nZXQsXHJcblx0XHQnaXRlcmF0ZV9hbmNlc3Rvcl9jbGFzc2VzJzogaXRlcmF0ZV9hbmNlc3Rvcl9jbGFzc2VzLFxyXG5cdFx0J2lzX2NvbnN0cnVjdG9yX2ZuJzogaXNfY29uc3RydWN0b3JfZm4sXHJcblx0XHQnaXNfYXJyX29mX3QnOiBpc19hcnJfb2ZfdCxcclxuXHRcdCdpc19hcnJfb2ZfYXJycyc6IGlzX2Fycl9vZl9hcnJzLFxyXG5cdFx0J2lzX2Fycl9vZl9zdHJzJzogaXNfYXJyX29mX3N0cnMsXHJcblx0XHQnaW5wdXRfcHJvY2Vzc29ycyc6IGlucHV0X3Byb2Nlc3NvcnMsXHJcblx0XHQnb3V0cHV0X3Byb2Nlc3NvcnMnOiBvdXRwdXRfcHJvY2Vzc29ycyxcclxuXHRcdCdjYWxsX211bHRpcGxlX2NhbGxiYWNrX2Z1bmN0aW9ucyc6IGNhbGxfbXVsdGlwbGVfY2FsbGJhY2tfZnVuY3Rpb25zLFxyXG5cdFx0J2NhbGxfbXVsdGknOiBjYWxsX211bHRpLFxyXG5cdFx0J211bHRpJzogY2FsbF9tdWx0aSxcclxuXHRcdCduYXRpdmVfY29uc3RydWN0b3JfdG9mJzogbmF0aXZlX2NvbnN0cnVjdG9yX3RvZixcclxuXHRcdCdGbnMnOiBGbnMsXHJcblx0XHQnZ2V0JzogZ2V0LFxyXG5cdFx0J3NldCc6IHNldCxcclxuICAgICAgICAnc2lnX21hdGNoJzogc2lnX21hdGNoXHJcblx0fTtcclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIGRlc2NyaXB0aW9uLi4uXHJcbiAgICAqIEBhbGlhcyBkYXRhX3R5cGVzX2luZm9cclxuICAgICogQG1lbWJlclxyXG4gICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvcmUvanNndWktbGFuZy1lc3NlbnRpYWxzXHJcbiAgICAqL1xyXG5cdC8vIE1heWJlIHRoaXMgd2lsbCBiZSBtb3ZlZCB0byBhbiBpbnRlcm1lZGlhdGUgbGF5ZXIuXHJcblx0anNndWkuZGF0YV90eXBlc19pbmZvID0ganNndWkuZGF0YV90eXBlc19pbmZvIHx8IHt9O1xyXG5cclxuXHJcblxyXG5cclxuXHQvLyBhbmQgdGhlIGxvY2FsIHZhcmlhYmxlIHNob3J0Y3V0cyB0aGF0IGdvIGF0IHRoZSBiZWdpbm5pbmc6XHJcblxyXG5cdC8qXHJcblxyXG5cdCB2YXIgaiA9IGpzZ3VpO1xyXG5cdCB2YXIgQ2xhc3MgPSBqLkNsYXNzO1xyXG5cdCB2YXIgZWFjaCA9IGouZWFjaDtcclxuXHQgdmFyIGlzX2FycmF5ID0gai5pc19hcnJheTtcclxuXHQgdmFyIGlzX2RvbV9ub2RlID0gai5pc19kb21fbm9kZTtcclxuXHQgdmFyIGlzX2N0cmwgPSBqLmlzX2N0cmw7XHJcblx0IHZhciBleHRlbmQgPSBqLmV4dGVuZDtcclxuXHQgdmFyIHhfY2xvbmVzID0gai54X2Nsb25lcztcclxuXHQgdmFyIGdldF90cnV0aF9tYXBfZnJvbV9hcnIgPSBqLmdldF90cnV0aF9tYXBfZnJvbV9hcnI7XHJcblx0IHZhciBnZXRfbWFwX2Zyb21fYXJyID0gai5nZXRfbWFwX2Zyb21fYXJyO1xyXG5cdCB2YXIgYXJyX2xpa2VfdG9fYXJyID0gai5hcnJfbGlrZV90b19hcnI7XHJcblx0IHZhciB0b2YgPSBqLnRvZjtcclxuXHQgdmFyIGlzX2RlZmluZWQgPSBqLmlzX2RlZmluZWQ7XHJcblx0IHZhciBzdHJpbmdpZnkgPSBqLnN0cmluZ2lmeTtcclxuXHQgdmFyIGZ1bmN0aW9uYWxfcG9seW1vcnBoaXNtID0gai5mdW5jdGlvbmFsX3BvbHltb3JwaGlzbTtcclxuXHQgdmFyIGZwID0gai5mcDtcclxuXHQgdmFyIGFycmF5aWZ5ID0gai5hcnJheWlmeTtcclxuXHQgdmFyIG1hcGlmeSA9IGoubWFwaWZ5O1xyXG5cdCB2YXIgYXJlX2VxdWFsID0gai5hcmVfZXF1YWw7XHJcblx0IHZhciBnZXRfaXRlbV9zaWcgPSBqLmdldF9pdGVtX3NpZztcclxuXHQgdmFyIHNldF92YWxzID0gai5zZXRfdmFscztcclxuXHQgdmFyIHRydXRoID0gai50cnV0aDtcclxuXHQgdmFyIHRyaW1fc2lnX2JyYWNrZXRzID0gai50cmltX3NpZ19icmFja2V0cztcclxuXHQgdmFyIGxsX3NldCA9IGoubGxfc2V0O1xyXG5cdCB2YXIgbGxfZ2V0ID0gai5sbF9nZXQ7XHJcblx0IHZhciBpc19jb25zdHJ1Y3Rvcl9mbiA9IGouaXNfY29uc3RydWN0b3JfZm47XHJcblx0IHZhciBpc19hcnJfb2ZfYXJycyA9IGouaXNfYXJyX29mX2FycnM7XHJcblx0IHZhciBpc19hcnJfb2Zfc3RycyA9IGouaXNfYXJyX29mX3N0cnM7XHJcblx0IHZhciBpc19hcnJfb2ZfdCA9IGouaXNfYXJyX29mX3Q7XHJcblx0ICovXHJcblxyXG5cclxuXHQvLyB2YXIganNndWkgPSB7fTtcclxuXHQvLyBhbGVydCgncmV0dXJuaW5nIGpzZ3VpIGZyb20ganNndWktbGFuZycpO1xyXG5cdC8vcmV0dXJuIGpzZ3VpO1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBqc2d1aTtcclxuLy99KTtcclxuIiwiLy8gVGhpcyBpcyByZXN1bHRpbmcgaW4gc21hbGxlciBjb2RlIGluIG90aGVyIHBhcnRzIG9mIHRoZSBmcmFtZXdvcmsuXG4vLyAgVGhpcyBzZWN0aW9uIGlzIGdldHRpbmcgcXVpdGUgYmlnIChhZ2Fpbilcbi8vICBTdGlsbCBuZWVkIHRvIG1ha2UgdXNlIG9mIHRoZSBCKyBmcmVlIGZvciBvcmRlcmVkIGluZGV4aW5nLlxuXG4vLyBNb3Zpbmcgc29tZSBjb2RlIHRvIGpzZ3VpLWxhbmctZXNzZW50aWFsc1xuLy8gIFdpbGwgYmUgcHVibGlzaGluZyBhIDAuNCB2ZXJzaW9uIG9mIHRoYXQgYmVmb3JlIHNvIGxvbmc/XG4vLyAgIE1heWJlIHdpdGggbW9yZSBleHBsYW5hdGlvbj9cblxuLy8gSXQgbWF5IGJlIHdvcnRoIHB1Ymxpc2hpbmcgdGhpcywgYW5kIGEgZGlzY3Vzc2lvbiBmb3J1bSBhYm91dCBpdCBvbiBteSBvd24gd2ViIGZvcnVtLlxuLy8gIFBlcmhhcHMgdGhhdCBjb3VsZCBjb21lIGxhdGVyLCBidXQganNndWktbGFuZy1lc3NlbnRpYWxzIG1heSBiZSBhIGdvb2Qgc3RlcC4gQ291bGQgY2FsbCBpdCB2ZXJzaW9uIDAuMzUuXG4vLyAgIENvdWxkIGhhdmUgYSBmZXcgZXhhbXBsZXNcbi8vICAgV291bGQgYmUgYSB1c2VmdWwgdG9vbGtpdCBJIGNvdWxkIHVzZSB3aGlsZSB3b3JraW5nIGVsc2V3aGVyZS5cblxuLy8gIEkgdGhpbmsgdGhhdCB3ZWIgc2l0ZSB3b3VsZCBiZSBsaWdodGVuaW5nIGZhc3QsIGFuZCBpbXByZXNzIHBlb3BsZSB3aXRoIGl0cyBzcGVlZCBjb21wYXJlZCB0byBvdGhlciB3ZWIgcGxhdGZvcm1zIHRoYXQgdGhleSBhcmUgdXNlZCB0b1xuLy8gICAodGhvdWdoIEZhY2Vib29rIGlzIE9LKVxuXG4vLyBUaGlzIGlzIGdvaW5nIHRvIGJlIHVzaW5nIGRhdGFfdHlwZXMgYXMgd2VsbC5cbi8vIFdpbGwgYWxzbyBoYXZlIGEgc3lzdGVtIG9mIHJlcXVpcmVtZW50cy5cbi8vICBUaGF0IGNvdWxkIG1lYW4gdGhleSBuZWVkIHRvIGJlIGJvdGggdGhlIHJpZ2h0IGRhdGEgdHlwZSwgYXMgd2VsbCBhcyBoYXZpbmcgc29tZSBvdGhlciBzcGVjaWZpZWQgcHJvcGVydGllcy5cbi8qXG5pZiAodHlwZW9mIGRlZmluZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBkZWZpbmUgPSByZXF1aXJlKCdhbWRlZmluZScpKG1vZHVsZSk7XG59XG5cblxuZGVmaW5lKFtcIi4vanNndWktbGFuZy1lc3NlbnRpYWxzXCIsIFwiLi9qc2d1aS1kYXRhLXN0cnVjdHVyZXNcIiwgXCIuL2RhdGEtb2JqZWN0XCIsIFwiLi9jb2xsZWN0aW9uXCJdLFxuXHRmdW5jdGlvbihqc2d1aSwgRGF0YV9TdHJ1Y3R1cmVzLCBEYXRhX09iamVjdCwgQ29sbGVjdGlvbikge1xuXHQqL1xuICAgIHZhciBqc2d1aSA9IHJlcXVpcmUoJy4vanNndWktbGFuZy1lc3NlbnRpYWxzJyk7XG52YXIgRGF0YV9TdHJ1Y3R1cmVzID0gcmVxdWlyZSgnLi9qc2d1aS1kYXRhLXN0cnVjdHVyZXMnKTtcbnZhciBEYXRhX1ZhbHVlID0gcmVxdWlyZSgnLi9kYXRhLXZhbHVlJyk7XG52YXIgRXZlbnRlZF9DbGFzcyA9IHJlcXVpcmUoJy4vZXZlbnRlZC1jbGFzcycpO1xudmFyIERhdGFfT2JqZWN0ID0gcmVxdWlyZSgnLi9kYXRhLW9iamVjdCcpO1xudmFyIENvbGxlY3Rpb24gPSByZXF1aXJlKCcuL2NvbGxlY3Rpb24nKTtcblxuXHQvLyBXaWxsIHVzZSBkYXRhIHN0cnVjdHVyZXMuXG5cdC8vICBOb3Qgc3VyZSBhYm91dCB1c2luZyBhbGwgb2YgdGhlbSBoZXJlLlxuXG5cdC8vIEEgbWl4LWluIHN5c3RlbSBvZiBlbmhhbmNpbmcgdGhlIGRhdGEgc3RydWN0dXJlcyBtYXkgd29yayBiZXN0LlxuXHQvLyAgSXQgZG9lcyBub3Qgc3RhcnQgd2l0aCBCKyB0cmVlLCBidXQgdGhhdCBnZXRzIGJyb3VnaHQgaW4/XG5cblx0Ly8gSG93ZXZlciwgaGF2aW5nIEIrIGFzIHBhcnQgb2YgaXQgY291bGQgd29yayBxdWl0ZSBuaWNlbHkuXG5cblxuIHZhciBqID0ganNndWk7XG4gdmFyIENsYXNzID0gai5DbGFzcztcbiB2YXIgZWFjaCA9IGouZWFjaDtcbiB2YXIgaXNfYXJyYXkgPSBqLmlzX2FycmF5O1xuIHZhciBpc19kb21fbm9kZSA9IGouaXNfZG9tX25vZGU7XG4gdmFyIGlzX2N0cmwgPSBqLmlzX2N0cmw7XG4gdmFyIGV4dGVuZCA9IGouZXh0ZW5kO1xuIHZhciB4X2Nsb25lcyA9IGoueF9jbG9uZXM7XG4gdmFyIGdldF90cnV0aF9tYXBfZnJvbV9hcnIgPSBqLmdldF90cnV0aF9tYXBfZnJvbV9hcnI7XG4gdmFyIGdldF9tYXBfZnJvbV9hcnIgPSBqLmdldF9tYXBfZnJvbV9hcnI7XG4gdmFyIGFycl9saWtlX3RvX2FyciA9IGouYXJyX2xpa2VfdG9fYXJyO1xuIHZhciB0b2YgPSBqLnRvZjtcbiB2YXIgYXRvZiA9IGouYXRvZjtcbiB2YXIgaXNfZGVmaW5lZCA9IGouaXNfZGVmaW5lZDtcbiB2YXIgc3RyaW5naWZ5ID0gai5zdHJpbmdpZnk7XG4gdmFyIGZ1bmN0aW9uYWxfcG9seW1vcnBoaXNtID0gai5mdW5jdGlvbmFsX3BvbHltb3JwaGlzbTtcbiB2YXIgZnAgPSBqLmZwO1xuIHZhciBhcnJheWlmeSA9IGouYXJyYXlpZnk7XG4gdmFyIG1hcGlmeSA9IGoubWFwaWZ5O1xuIHZhciBhcmVfZXF1YWwgPSBqLmFyZV9lcXVhbDtcbiB2YXIgZ2V0X2l0ZW1fc2lnID0gai5nZXRfaXRlbV9zaWc7XG4gdmFyIHNldF92YWxzID0gai5zZXRfdmFscztcbiB2YXIgdHJ1dGggPSBqLnRydXRoO1xuIHZhciB0cmltX3NpZ19icmFja2V0cyA9IGoudHJpbV9zaWdfYnJhY2tldHM7XG5cbmpzZ3VpLkRhdGFfT2JqZWN0ID0gRGF0YV9PYmplY3Q7XG5qc2d1aS5Db2xsZWN0aW9uID0gQ29sbGVjdGlvbjtcblxuanNndWkuRGF0YV9WYWx1ZSA9IERhdGFfVmFsdWU7XG5qc2d1aS5FdmVudGVkX0NsYXNzID0gRXZlbnRlZF9DbGFzcztcblxuLy92YXIgQl9QbHVzX1RyZWUgPSBEYXRhX1N0cnVjdHVyZXMuQl9QbHVzX1RyZWU7XG52YXIgU29ydGVkX0tWUyA9IERhdGFfU3RydWN0dXJlcy5Tb3J0ZWRfS1ZTO1xuXG52YXIgdmVjdG9yaWZ5ID0gZnVuY3Rpb24obl9mbikge1xuICAgIC8vIENyZWF0ZXMgYSBuZXcgcG9seW1vcnBoaWMgZnVuY3Rpb24gYXJvdW5kIHRoZSBvcmlnaW5hbCBvbmUuXG5cbiAgICB2YXIgZm5fcmVzID0gZnAoZnVuY3Rpb24oYSwgc2lnKSB7XG4gICAgICAgIC8vY29uc29sZS5sb2coJ3ZlY3RvcmlmaWVkIHNpZyAnICsgc2lnKTtcbiAgICAgICAgaWYgKGEubCA+IDIpIHtcbiAgICAgICAgICAgIHZhciByZXMgPSBhWzBdO1xuICAgICAgICAgICAgZm9yICggdmFyIGMgPSAxLCBsID0gYS5sOyBjIDwgbDsgYysrKSB7XG4gICAgICAgICAgICAgICAgcmVzID0gZm5fcmVzKHJlcywgYVtjXSk7XG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ3JlcyAnICsgcmVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoc2lnID09ICdbbixuXScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbl9mbihhWzBdLCBhWzFdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gd2lsbCBuZWVkIGdvIHRocm91Z2ggdGhlIGZpcnN0IGFycmF5LCBhbmQgdGhlIDJuZC4uLiBidXRcbiAgICAgICAgICAgICAgICAvLyB3aWxsIG5lZWQgdG8gY29tcGFyZSB0aGVtLlxuICAgICAgICAgICAgICAgIHZhciBhdHMgPSBhdG9mKGEpO1xuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2F0cyAnICsgc3RyaW5naWZ5KGF0cykpO1xuICAgICAgICAgICAgICAgIGlmIChhdHNbMF0gPT0gJ2FycmF5Jykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXRzWzFdID09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzID0gW10sIG4gPSBhWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWFjaChhWzBdLCBmdW5jdGlvbihpLCB2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2goZm5fcmVzKHYsIG4pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoYXRzWzFdID09ICdhcnJheScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhdHNbMF0ubGVuZ3RoICE9IGF0c1sxXS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyAndmVjdG9yIGFycmF5IGxlbmd0aHMgbWlzbWF0Y2gnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzID0gW10sIGFycjIgPSBhWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVhY2goYVswXSwgZnVuY3Rpb24oaSwgdikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXMucHVzaChmbl9yZXModiwgYXJyMltpXSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZm5fcmVzO1xufTtcblxudmFyIG5fYWRkID0gZnVuY3Rpb24objEsIG4yKSB7XG4gICAgcmV0dXJuIG4xICsgbjI7XG59LCBuX3N1YnRyYWN0ID0gZnVuY3Rpb24objEsIG4yKSB7XG4gICAgcmV0dXJuIG4xIC0gbjI7XG59LCBuX211bHRpcGx5ID0gZnVuY3Rpb24objEsIG4yKSB7XG4gICAgcmV0dXJuIG4xICogbjI7XG59LCBuX2RpdmlkZSA9IGZ1bmN0aW9uKG4xLCBuMikge1xuICAgIHJldHVybiBuMSAvIG4yO1xufTtcblxudmFyIHZfYWRkID0gdmVjdG9yaWZ5KG5fYWRkKSwgdl9zdWJ0cmFjdCA9IHZlY3RvcmlmeShuX3N1YnRyYWN0KTtcblxuLy8gdGhlc2UgYXJlIG5vdCB0aGUgc3RhbmRhcmQsIGVzdGFibGlzaGVkIHZlY3RvciBvciBtYXRyaXggb3BlcmF0aW9ucy4gVGhleVxuLy8gY2FuIGJlIHVzZWQgZm9yIHNjYWxpbmcgb2YgYXJyYXlzIG9mIHZlY3RvcnMuXG52YXIgdl9tdWx0aXBseSA9IHZlY3RvcmlmeShuX211bHRpcGx5KSwgdl9kaXZpZGUgPSB2ZWN0b3JpZnkobl9kaXZpZGUpO1xuXG52YXIgdmVjdG9yX21hZ25pdHVkZSA9IGZ1bmN0aW9uKHZlY3Rvcikge1xuICAgIC8vIG1heSBjYWxjdWxhdGUgbWFnbml0dWRlcyBvZiBsYXJnZXIgZGltZW5zaW9uIHZlY3RvcnMgdG9vLlxuICAgIC8vIGFsZXJ0KHRvZih2ZWN0b3JbMF0pKTtcbiAgICAvLyBhbGVydCh2ZWN0b3JbMF0gXiAyKTtcblxuICAgIHZhciByZXMgPSBNYXRoLnNxcnQoKE1hdGgucG93KHZlY3RvclswXSwgMikpICsgKE1hdGgucG93KHZlY3RvclsxXSwgMikpKTtcbiAgICByZXR1cm4gcmVzO1xuXG59O1xuXG52YXIgZGlzdGFuY2VfYmV0d2Vlbl9wb2ludHMgPSBmdW5jdGlvbihwb2ludHMpIHtcbiAgICB2YXIgb2Zmc2V0ID0gdl9zdWJ0cmFjdChwb2ludHNbMV0sIHBvaW50c1swXSk7XG4gICAgY29uc29sZS5sb2coJ29mZnNldCAnICsgc3RyaW5naWZ5KG9mZnNldCkpO1xuICAgIHJldHVybiB2ZWN0b3JfbWFnbml0dWRlKG9mZnNldCk7XG59XG5cbi8vIERvZXMgdGhpcyBoYXZlIGEgZ2VuZXJhbCB1c2U/XG52YXIgcmVtb3ZlX3NpZ19mcm9tX2Fycl9zaGVsbCA9IGZ1bmN0aW9uKHNpZykge1xuICAgIC8vIGZpcnN0IGFuZCBsYXN0IGNoYXJhY3RlcnM/XG4gICAgLy8gdXNlIHJlZ2V4IHRoZW4gcmVnZXggdG8gZXh0cmFjdCB0aGUgbWlkZGxlP1xuXG4gICAgaWYgKHNpZ1swXSA9PSAnWycgJiYgc2lnW3NpZy5sZW5ndGggLSAxXSA9PSAnXScpIHtcbiAgICAgICAgcmV0dXJuIHNpZy5zdWJzdHJpbmcoMSwgc2lnLmxlbmd0aCAtIDEpO1xuICAgIH1cbiAgICByZXR1cm4gc2lnO1xuICAgIC8vIGJ1dCBhbHNvIGRvIHRoaXMgdG8gdGhlIGFyZ3VtZW50cz9cbn07XG5cbnZhciBleGVjdXRlX29uX2VhY2hfc2ltcGxlID0gZnVuY3Rpb24oaXRlbXMsIGZuKSB7XG4gICAgLy8gY3VycmVudGx5IG5vIGFyZ3VtZW50cyBwcm92aWRlZCwgdGhlcmUgbWF5IGJlIGluIHRoZSBmdXR1cmUgLyBmdXR1cmVcbiAgICAvLyB2ZXJzaW9uc1xuICAgIHZhciByZXMgPSBbXSwgdGhhdCA9IHRoaXM7XG4gICAgZWFjaChpdGVtcywgZnVuY3Rpb24oaSwgdikge1xuICAgICAgICByZXMucHVzaChmbi5jYWxsKHRoYXQsIHYpKTsgLy8gZnVuY3Rpb24gY2FsbGVkIHdpdGggaXRlbSBhcyBpdHMgb25seVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcGFyYW1ldGVyLlxuICAgIH0pO1xuICAgIHJldHVybiByZXM7XG59O1xuXG52YXIgZmlsdGVyX21hcF9ieV9yZWdleCA9IGZ1bmN0aW9uKG1hcCwgcmVnZXgpIHtcbiAgICB2YXIgcmVzID0ge307XG4gICAgZWFjaChtYXAsIGZ1bmN0aW9uKGksIHYpIHtcbiAgICAgICAgLy8gaWYgKHJlZ2V4Lm1hdGNoKGkpKSB7XG4gICAgICAgIGlmIChpLm1hdGNoKHJlZ2V4KSkge1xuICAgICAgICAgICAgcmVzW2ldID0gdjtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXM7XG59XG5cbi8vIE1heSBiZSByZXBsYWNlZCBieSBhIG1vcmUgdmVyaXN0aWxlIHJlcGxhY2VtZW50IHN5c3RlbSwgaWUgaW5wdXQgdHJhbnNmb3JtYXRpb24gYW5kIHBhcnNpbmcgaW4gc2NoZW1hcy5cbnZhciBucHggPSBhcnJheWlmeShmdW5jdGlvbih2YWx1ZSkge1xuICAgIC8vIGRvbid0IHRoaW5rIHdlIGNhbiB1c2UgYXJyYXlpZnk/XG5cbiAgICAvLyBnb29kIGNhbmRpZGF0ZSBmb3IgcGY/IGJ1dCBob3cgaXQgZGVhbHMgd2l0aCBhcnJheSB0cmVlcy4uLlxuICAgIC8vIGNvdWxkIGhhdmUgYW5vdGhlciBvbmUsIGxpa2Ugc2Ygb3Igc3BmIHRoYXQgaXMgc2ltcGxlciBpbiB0ZXJtcyBvZlxuICAgIC8vIHRyZWF0aW5nIGFuIGFycmF5IGluIHRoZSBzaWduYXR1cmUgYXMganVzdCBvbmUgYXJyYXk/XG5cbiAgICB2YXIgcmVzLCBhID0gYXJndW1lbnRzLCB0ID0gdG9mKGFbMF0pO1xuXG4gICAgLy8gZm4gc2lncz8/PyBwZXJmb3JtYW5jZT9cblxuICAgIGlmICh0ID09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJlcyA9IGFbMF07XG4gICAgfSBlbHNlIGlmICh0ID09ICdudW1iZXInKSB7XG4gICAgICAgIHJlcyA9IGFbMF0gKyAncHgnO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufSk7XG5cbnZhciBub19weCA9IGFycmF5aWZ5KGZwKGZ1bmN0aW9uKGEsIHNpZykge1xuICAgIC8vIG5vX3B4IC0gcmVtb3ZlcyB0aGUgJ3B4JyBpZiBpdCBlbmRzIHdpdGggcHhcbiAgICAvLyBHZW5lcmFsbHkgcmV0dXJucyBhIG51bWJlci5cbiAgICAvLyB2YWx1ZVxuICAgIHZhciByZSA9IC9weCQvLCByZXM7XG4gICAgaWYgKHNpZyA9PSAnW3NdJyAmJiByZS50ZXN0KGFbMF0pKSB7XG4gICAgICAgIHJlcyA9IHBhcnNlSW50KGFbMF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJlcyA9IGFbMF07XG4gICAgfVxuICAgIDtcbiAgICByZXR1cm4gcmVzO1xufSkpO1xuXG52YXIgYXJyX2x0cmIgPSBbICdsZWZ0JywgJ3RvcCcsICdyaWdodCcsICdib3R0b20nIF07XG5cbnZhciBzdHJfYXJyX21hcGlmeSA9IGZ1bmN0aW9uKGZuKSB7XG4gICAgdmFyIHJlcyA9IGZwKGZ1bmN0aW9uKGEsIHNpZykge1xuICAgICAgICBpZiAoYS5sID09IDEpIHtcbiAgICAgICAgICAgIGlmIChzaWcgPT0gJ1tzXScpIHtcbiAgICAgICAgICAgICAgICB2YXIgc19wbiA9IGFbMF0uc3BsaXQoJyAnKTtcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnc19wbiAnICsgc19wbi5sZW5ndGgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHNfcG4ubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzLmNhbGwodGhpcywgc19wbik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZuLmNhbGwodGhpcywgYVswXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodG9mKGFbMF0pID09ICdhcnJheScpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzMiA9IHt9LCB0aGF0ID0gdGhpcztcblxuICAgICAgICAgICAgICAgIGVhY2goYVswXSwgZnVuY3Rpb24oaSwgdikge1xuICAgICAgICAgICAgICAgICAgICByZXMyW3ZdID0gZm4uY2FsbCh0aGF0LCB2KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXM7XG59O1xuXG4vLyBMb3dlciBsZXZlbCBmdW5jdGlvbnNcbi8vIEZvciB0aGUgbW9tZW50IG5vdCBleHBvc2VkXG5cbi8vIFRoZXNlIHR3byBkbyBkZWFsIHdpdGggbmVzdGVkIGRhdGEuLi4gYnV0IHRoZSBwdXJwb3NlIG9mIHRoZSBuZXN0ZWRcbi8vIG1vZHVsZSBpcyB0byBwdXQgdGhlIGNvbXBsaWNhdGVkIG5lc3RlZCBzdHVmZiB0aGVyZS5cbi8vIFRoaXMgb25lIGxvb2tzIHF1aXRlIHVzZWZ1bCBhbmQgaXQgaXMgbGltaXRlZCBpbiB3aGF0IGl0IGRvZXMsIGVhc3kgdG9cbi8vIHVuZGVyc3RhbmQuIEtlZXAgaGVyZS5cblxuXG52YXIgYXJyX2hleF9jaGFycyA9IFsgJzAnLCAnMScsICcyJywgJzMnLCAnNCcsICc1JywgJzYnLCAnNycsICc4JywgJzknLFxuICAgICAgICAnQScsICdCJywgJ0MnLCAnRCcsICdFJywgJ0YnIF07XG52YXIgZGljdF9oZXhfdG9fYmluID0ge1xuICAgICcwJyA6IDAsXG4gICAgJzEnIDogMSxcbiAgICAnMicgOiAyLFxuICAgICczJyA6IDMsXG4gICAgJzQnIDogNCxcbiAgICAnNScgOiA1LFxuICAgICc2JyA6IDYsXG4gICAgJzcnIDogNyxcbiAgICAnOCcgOiA4LFxuICAgICc5JyA6IDksXG4gICAgJ0EnIDogMTAsXG4gICAgJ0InIDogMTEsXG4gICAgJ0MnIDogMTIsXG4gICAgJ0QnIDogMTMsXG4gICAgJ0UnIDogMTQsXG4gICAgJ0YnIDogMTVcbn07XG52YXIgc3RyX2hleF90b19pbnQgPSBmdW5jdGlvbihzdHJfaGV4KSB7XG4gICAgc3RyX2hleCA9IHN0cl9oZXgudG9VcHBlckNhc2UoKTtcbiAgICB2YXIgaSA9IHN0cl9oZXgubGVuZ3RoOyAvLyBvciAxMFxuICAgIHZhciByZXMgPSAwLCBleHAgPSAxO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgdmFyIGlfcGFydCA9IGRpY3RfaGV4X3RvX2JpbltzdHJfaGV4LmNoYXJBdChpKV07XG4gICAgICAgIHZhciBpcDIgPSBpX3BhcnQgKiBleHA7XG4gICAgICAgIHJlcyA9IHJlcyArIGlwMjtcbiAgICAgICAgZXhwID0gZXhwICogMTY7XG4gICAgICAgIC8vIC4uLlxuICAgIH1cbiAgICA7XG4gICAgcmV0dXJuIHJlcztcbn07XG52YXIgYnl0ZV9pbnRfdG9fc3RyX2hleF8yID0gZnVuY3Rpb24oYnl0ZV9pbnQpIHtcbiAgICB2YXIgYSA9IE1hdGguZmxvb3IoYnl0ZV9pbnQgLyAxNiksIGIgPSBieXRlX2ludCAlIDE2LCBzYSA9IGFycl9oZXhfY2hhcnNbYV0sIHNiID0gYXJyX2hleF9jaGFyc1tiXSwgcmVzID0gc2FcbiAgICAgICAgICAgICsgc2I7XG4gICAgcmV0dXJuIHJlcztcbn07XG52YXIgYXJyX3JnYl90b19zdHJfaGV4XzYgPSBmdW5jdGlvbihhcnJfcmdiKSB7XG4gICAgdmFyIHIgPSBieXRlX2ludF90b19zdHJfaGV4XzIoYXJyX3JnYlswXSk7XG4gICAgdmFyIHJlcyA9IHIgKyBieXRlX2ludF90b19zdHJfaGV4XzIoYXJyX3JnYlsxXSlcbiAgICAgICAgICAgICsgYnl0ZV9pbnRfdG9fc3RyX2hleF8yKGFycl9yZ2JbMl0pO1xuICAgIHJldHVybiByZXM7XG59O1xudmFyIGFycl9yZ2JfdG9fY3NzX2hleF82ID0gZnVuY3Rpb24oYXJyX3JnYikge1xuICAgIC8vIGEgLyBiIC8vIGRpdmlkZSBhIGJ5IGJcbiAgICAvLyBhICUgYiAvLyBmaW5kIHRoZSByZW1haW5kZXIgb2YgZGl2aXNpb24gb2YgYSBieSBiXG4gICAgcmV0dXJuICcjJyArIGFycl9yZ2JfdG9fc3RyX2hleF82KGFycl9yZ2IpO1xufTtcbi8qXG4gKiBDb25zaWRlciB0aGUgZm9sbG93aW5nOlxuICpcbiAqXG4gKiB2YXIgYXJyX211bHRpX3NldF9pdGVtID0gZnVuY3Rpb24oYXJyLCBpQmVnaW4sIGlFbmQsIGl0ZW1fbmFtZSwgdmFsdWUpIHtcbiAqIHZhciBjID0gaUJlZ2luOyB3aGlsZSAoYyA8PSBpRW5kKSB7IGFycltpdGVtX25hbWVdW2NdID0gdmFsdWU7IH07IHJldHVyblxuICogYXJyOyB9OyB2YXIgaXRlbV9jb25kX3NldF9tdWx0aV92YWx1ZXMgPSBmdW5jdGlvbih0YXJnZXQsIHNvdXJjZSxcbiAqIHZhbHVlX25hbWVzKSB7IGVhY2godmFsdWVfbmFtZXMsIGZ1bmN0aW9uKGksIHYpIHsgaWYgKHR5cGVvZiBzb3VyY2Vbdl0gIT1cbiAqICd1bmRlZmluZWQnKSB7IHRhcmdldFt2XSA9IHNvdXJjZVt2XTsgfSB9KTsgcmV0dXJuIHRhcmdldDsgfTsgdmFyXG4gKiBhcnJfaXRlbV9jb25kX3NldF9tdWx0aV92YWx1ZXMgPSBmdW5jdGlvbihhcnJfdGFyZ2V0LCBhcnJfc291cmNlLCBpTWluLFxuICogaU1heCwgdmFsdWVfbmFtZXMpIHsgZm9yICh2YXIgYyA9IGlNaW47IGMgPD0gaU1heDsgYysrKSB7XG4gKiBpdGVtX2NvbmRfc2V0X211bHRpX3ZhbHVlcyhhcnJfdGFyZ2V0W2NdLCBhcnJfc291cmNlW2NdLCB2YWx1ZV9uYW1lcyk7IH07IH07XG4gKlxuICovXG5cbi8vIGluZm9ybWF0aW9uIGFib3V0IGRhdGEgdHlwZXMgc3VjaCBhcyAnaW50Jz9cbi8vIFBlcmhhcHMgc29tZSBudW1iZXIgZGF0YSB0eXBlcyBjb3VsZCBiZSByZS1pbXBsZW1lbnRlZCwgbGlrZSBEZWNpbWFsLlxuXG52YXIgaW5wdXRfcHJvY2Vzc29ycyA9IHt9O1xuXG52YXIgb3V0cHV0X3Byb2Nlc3NvcnMgPSB7fTtcblxudmFyIHZhbGlkYXRvcnMgPSB7XG4gICAgJ251bWJlcicgOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdG9mKHZhbHVlKSA9PSAnbnVtYmVyJztcbiAgICB9XG59O1xuXG4vLyBjcmVhdGUgZGF0YSB0eXBlIGluc3RhbmNlIGZyb20gaW5mb1xuXG4vLyBDb2RlIHdpbGwgYmUgYmV0dGVyIG9yZ2FuaXplZCB1c2luZyB0aGlzLCBidXQgaXQgd2lsbCBzdGlsbCBiZSBxdWl0ZSBhXG4vLyBsYXJnZSBhbW91bnQgb2YgbG9naWMuXG4vLyBXaWxsIG1ha2UgcmVmZXJlbmNlIHRvIHNwZWNpYWwgY2FzZXMgKGRpcmVjdGl2ZXMpIHRvIGNvbnRyb2wgdGhlIGZsb3cuXG5cbi8vIEkgdGhpbmsgdGhlIHJlY3Vyc2lvbiBpbmhlcmFudCBpbiB0aGUgZGF0YSB0eXBlcyB3aWxsIGJlIGVub3VnaCBmb3IgdGhpc1xuLy8gdG8gd29yayAoaG9wZSBzbykuXG4vLyBUaGUgbG9naWMgaGVyZSBsb29rcyBhdCB0d28gbGF5ZXJzIHNvbWV0aW1lcywgSSBob3BlIGl0IGRvZXMgbm90IG5lZWRcbi8vIHJlY3Vyc2lvbiB0aGVyZSwgYnV0IHJhdGhlciB0aGF0IG9uZSBkaXJlY3RpdmUgbWF5IHJlZmVyZW5jZSBvdGhlclxuLy8gdGhpbmdzLlxuLy8gVGhvc2Ugb3RoZXIgdGhpbmdzIGNvdWxkIGJlIHRoZWlyIG93biBkYXRhIHR5cGVzIHRoYXQgY2FuIGJlIHJlZmVyZW5jZWQuXG5cbnZhciByZWZlcnJlZF9vYmplY3RfaXNfZGVmaW5lZCA9IGZ1bmN0aW9uKG9iamVjdF9yZWZlcmVuY2UpIHtcbiAgICByZXR1cm4gaXNfZGVmaW5lZChvYmplY3RfcmVmZXJlbmNlWzBdW29iamVjdF9yZWZlcmVuY2VbMV1dKTtcbn1cblxuLy8gVGhpcyBjb2RlIGlzIHJlYWxseSBiaWcgbm93LlxuLy8gV2l0aG91dCBXUyBhbmQgbG9nZ2luZyBpdCB3aWxsIGJlIHNtYWxsZXIuXG5cbi8vIFRoZSBIVE1MIG1vZHVsZSB3aWxsIGdpdmUgaXQgSFRNTCBhbmQgQ1NTLWxpa2UgcHJvcGVydGllcyBpdCB3aWxsIHVzZSBmb3Jcbi8vIGl0cyBpbnRlcm5hbCByZXByZXNlbnRhdGlvbiBhbmQgdHJhbnNsYXRpb25zIHRvIGFuZCBmcm9tXG4vLyBET00gcmVwcmVzZW50YXRpb25zLlxuXG4vLyBUaGUgQiAob3IgQis/KSB0cmVlIGNvbWluZyB1cC4gSXQncyBxdWl0ZSBhIGJpZyBvbmUuLi4uXG4vLyBUaGVyZSB3aWxsIGJlIHNvbWUgb3RoZXIsIHNpbXBsZXIgY2xhc3NlcyB0aGF0IHVzZSBpdC5cblxuLy8gS1NWUywgS2V5cyBhbmQgVmFsdWVzIHN0b3JlXG4vLyBNYXkgd2FudCBzb21ldGhpbmcgdGhhdCBzdG9yZXMgb25seSBhIHNpbmdsZSB2YWx1ZSBmb3IgYSBrZXkuXG4vLyBMaWtlbHkgdG8gd2FudCB0byBzcGVjaWZ5IHRoaXMsIGluIGhvdyBhbiBpbmRleCBpcyB1c2VkLlxuLy8gRG9uJ3Qgd2FudCB0byBpbXBvc2UgYW4gZXh0cmEgcmVxdWlyZW1lbnQgb24gdGhlcmUgYmVpbmcgdW5pcXVlIHZhbHVlc1xuLy8gZm9yIGluZGV4ZWQgZmllbGRzLlxuLy8gVGhhdCdzIHdoeSBtb3JlIGNvbXBsZXggZGF0YSB0eXBlcyBtYXkgZml0IHRoZSBkYXRhIGJldHRlciB0aGFuIGRpY3RzLlxuXG4vLyBXaWxsIG1ha2UgYSBuZXcgQisgdHJlZSBzdHJ1Y3R1cmUuXG4vLyAgSSdsbCB3YW50IHRvIGtub3cgd2hhdCBpdCBkb2VzIGFueXdheSAtIGFuZCBJJ2xsIHNlZSB0aGF0IHRoaXMgb25lIGlzIG9wdGltaXplZCBhcyB3ZWxsIGFzIHVzZWZ1bCBmb3IgdmFyaW91cyBvcGVyYXRpb25zIHRoYXQgd291bGQgZ2V0IHBlcmZvcm1lZCBvbiB0aGUgdHJlZS5cblxuLy8gUXVpdGUgYSBmZXcgZGF0YSB0eXBlcyB3aWxsIHdpbmQgdXAgaGVyZSwgaW4gdGhpcyBiaXQgb2YgdGhlIGxpYnJhcnkuXG4vLyAgSSBkb24ndCB0aGluayB0aGV5IHdpbGwgdGFrZSB1cCBhbGwgdGhhdCBtdWNoIHNwYWNlLlxuXG4vLyBDb3VsZCBoYXZlIERhdGFfU3RydWN0dXJlcyBiZWZvcmUgdXRpbD9cbi8vICBJIGRvbid0IHRoaW5rIHRoZXknbGwgYmUgbWFraW5nIHVzZSBvZiBmdW5jdGlvbmFsaXR5IHN1Y2ggYXMgQ29sbGVjdGlvbiBvciBEYXRhX09iamVjdC4gQ29sbGVjdGlvbiB3aWxsIHVzZSB0aGVzZSBkYXRhIHN0cnVjdHVyZXMgZm9yIGl0cyBpbmRleC5cbi8vICAgTWF5IGJlIGdvb2QgaGF2aW5nIHRoZW0gcmVhbGx5IGNvbXBhdGFibGUgdG9vP1xuXG4vLyAgUGVyaGFwcyB0aGVyZSB3aWxsIGJlIGEgbGFuZyAnZXNzZW50aWFscycgc2V0P1xuLy8gICBCZWZvcmUgZGF0YSBzdHJ1Y3R1cmVzLCBjb3JlIHRvb2xzIHN1Y2ggYXMgcG9seW1vcnBoaXNtLCBzdHJpbmdpZnksIGVhY2gsIHRvZlxuLy8gICAgVGhhdCB3b3VsZCBiZSBhIHJlYWxseSBnb29kIHRvb2xraXQgaW4gYSBmZXcgS0Igb2YgY29kZS5cbi8vICAgIEkgdGhpbmsgdGhvc2UgdGhpbmdzIHdvbid0IGNoYW5nZSBzbyBtdWNoLlxuLy8gICAgIE90aGVyIHBhcnRzIG9mIGxhbmcgYXJlIGRldmVsb3BpbmcsIGJ1dCBhcmUgdGFraW5nIGZhciBtb3JlIGNvZGUgdG8gZG8uXG5cblxuXG5cbi8vIERhdGFfT2JqZWN0IGFuZCBDb2xsZWN0aW9uIGFyZSBub3QgZGF0YSBzdHJ1Y3R1cmVzIC0gdGhleSBhcmUgbW9yZSB0aGFuIHRoYXQuXG4vLyAgVGhleSBwcm92aWRlIGEgdXRpbGl0eSwgYW5kIHVzZSB0aGUgYXBwcm9wcmlhdGUgZGF0YSBzdHJ1Y3R1cmVzIHRvIGRvIHNvLiBUaGV5IGFsc28gZGVhbCB3aXRoIGV2ZW50cyBhbmQgaGF2ZS9lbmFibGUgTVZDIHBhdHRlcm5zLlxuLy8gIFRoYXQgbWVhbnMgdGhhdCBkYXRhIHN0cnVjdHVyZXMgd29uJ3QgdXNlIHRoZW0uXG5cbi8vIFRoZXJlIHdpbGwgYmUgYSBkYXRhIHN0cnVjdHVyZXMgcGFydCBvZiB0aGUgc3lzdGVtIHRoYXQgd2lsbCBiZSB1c2VkIGFzIGJ1aWxkaW5nIGJsb2NrcyBmb3IgdGhpcyBwYXJ0LlxuLy8gIFRoZSBkYXRhIHN0cnVjdHVyZXMgd2lsbCB1c2UganNndWktbGFuZy1lc3NlbnRpYWxzLlxuXG5cblxuXG5cblxuLy92YXIgRG91Ymx5X0xpbmtlZF9MaXN0ID1cblxuXG4vLyB2YXIgQlRyZWUgPSBmdW5jdGlvbigpIHtcblxuLy8gQlRyZWUgaXMgZmFpcmx5IGJpZy5cbi8vIEl0IGNhbiBiZSBzaHJ1bmsgYSBiaXQgZnVydGhlci4uLiBidXQgbm90IG1hc3NpdmVseVxuLy8gTWF5IGZpbmQgdGhpcyBpcyBhbiBpbnRlZ3JhbCBwYXJ0IG9mIGNvZGUgdG8gd2VsbCBmdW5jdGlvbmluZyBkYXRhXG4vLyBzeXN0ZW1zIG9uIHRoZSBjbGllbnQuXG4vLyBNYXkgb25seSBiZSB1c2VmdWwgd2hlbiB0aGVyZSBpcyBhIG1vcmUgc2lnbmlmaWNhbnQgYW1vdW50IG9mIGRhdGEgdG9cbi8vIGRlYWwgd2l0aD9cblxuLy8gTWFrZXMgdGhpbmdzIHBvc3NpYmxlIHRob3VnaC5cblxudmFyIHNldF92YWxzID0gZnVuY3Rpb24ob2JqLCBtYXApIHtcbiAgICBlYWNoKG1hcCwgZnVuY3Rpb24oaSwgdikge1xuICAgICAgICBvYmpbaV0gPSB2O1xuICAgIH0pO1xufTtcblxuLy8gaXRzIGZ1bmN0aW9ucyBtYXkgZ2V0IHByb3hpZWQuXG5cbi8vIE9LLCBzbyBsb29rcyBsaWtlIGl0J3Mgd29ya2luZyBzbyBmYXIuXG5cbi8vIGluZGV4ZWQgY29sbGVjdGlvbi4ga2VlcHMgdHJhY2sgb2YgdGhlIGluZGV4IG9mIGVhY2ggaXRlbSBpbiBpdC5cblxuLy8gV2lsbCB1c2UgdGhpcyB3aXRoaW4gdGhlIHR5cGVkIGRhdGEgSSB0aGluay5cblxuLy8gZXZlcnkgaXRlbSBuZWVkcyBhbiBpZCwgbmVlZCBhbiBpbmRleCB0b28uXG5cbi8vIE5lZWQgdG8gYmUgYWJsZSB0byBhY2Nlc3MgY29udHJvbHMgaW4gYSBjb2xsZWN0aW9uIHVzaW5nIGEgbmljZSBpbnRlcmZhY2Vcbi8vIGF0IGRpZmZlcmVudCBsZXZlbHMuXG5cbi8vIGl0ZW1zIGluIHRoZSBjb2xsZWN0aW9uIGhhdmUgZ290IGluZGV4KCkgYW5kIGlkKCkgZnVuY3Rpb25zIGZvciBhY2Nlc3MgdG9cbi8vIHRoZSB2YXJpYWJsZXMuXG4vLyBpbmRleCBpcyB0aGUgcG9zaXRpb24gaW4gdGhlIGNvbGxlY3Rpb24uXG5cbi8vIFRoaW5rIHRoaXMgb25lIGlzIHF1aXRlIHNwZWNpZmljIGZvciB3aGVuIGl0ZW1zIGhhdmUgaWRzLlxuXG4vLyBTaG91bGQgYmUgbWFkZSBtdWNoIG1vcmUgZ2VuZXJhbCwgb3IgZ2l2ZW4gc3BlY2lmaWMgbmFtZS5cblxuLy8gV2lsbCBiZSBwaGFzZWQgb3V0LlxuLy8gV2lsbCBoYXZlIENvbGxlY3Rpb24uXG5cbi8vIFRoYXQgd2lsbCBiZSBhIERhdGFfT2JqZWN0LlxuLy8gSXQgd2lsbCBoYXZlIGFuIGFycmF5XG4vLyBJdCB3aWxsIGhhdmUgaW5kZXggY2FwYWJpbGl0aWVzLlxuLy8gUGVyaGFwcyBpdCBjb3VsZCBldmVuIGJlIGFibGUgdG8gaGFuZGxlIGxhcmdlciBkYXRhc2V0cyB3aXRoIGVmZmljaWVudFxuLy8gaW5kZXhpbmcgY2FwYWJpbGl0aWVzLlxuXG4vLyBBcyBhbiBhYnN0cmFjdCBjbGFzcz9cblxuLy8gSW5kZXhlZCBieSBwb3NpdGlvbiBpbiBhbm90aGVyIGluZGV4P1xuLy8gT3Igb3JkZXJlZCBieSBpdC4uLlxuXG4vLyBBbmQgdGhhdCBvcmRlciBjb3VsZCBjaGFuZ2UsIHRvby5cbi8vIGhhdmUgaXQgcmVzcG9uZCBhdXRvbWF0aWNhbGx5IGZvciB0aGF0Li4uXG4vLyBXb3VsZCBsaWtlIHRvIGdldCB0aGlzIHRvIGJlIGVhc3kgdG8gZXhwcmVzcy5cblxuLy8gY29sbGVjdGlvbiAxIG5vdCBwYXJ0aWN1bGFybHkgb3JkZXJlZFxuLy8gY29sbGVjdGlvbiAyIG9yZGVyZWQgYnkgaXRlbXMnIHBvc2l0aW9ucyBpbiBjb2xsZWN0aW9uIDEuXG4vLyBkb24ndCB3YW50IGxvdHMgb2YgY29kZSBzcGVjaWZpY2FsbHkgZm9yIHRoaXMgLSBidXQgc2hvdWxkIGJlIHBvc3NpYmxlXG4vLyB1c2luZyBhIGZhaXJseSBnZW5lcmFsIHN5c3RlbS5cbi8vIHNvIGVhY2ggb2JqZWN0IHdpbGwgaGF2ZSBpdHMgY29sbGVjdGlvbjFfaW5kZXggdmFsdWUgYXZhaWxhYmxlLlxuLy8gTmVlZCB0byB0aGluayBhYm91dCB3aGVyZSB0byBob29rIHVwIHRoZSBsaXN0ZW5lcnMgdG8gbGlzdGVuIGZvciBhIGNoYW5nZVxuLy8gaW4gY29sbGVjdGlvbjEgc28gb3JkZXIgY291bGQgYmUgdXBkYXRlZCBpbiBjb2xsZWN0aW9uIDIuXG4vLyBQcm9iYWJseSBub3QgZm9yIGFueSBzaW5nbGUgaXRlbSB0aGF0IGNoYW5nZXMgcG9zaXRpb25cbi8vIENvdWxkIG1heWJlIGJlIGdpdmVuIGEgbGlzdCBvZiBhbGwgaXRlbXMgdGhhdCBjaGFuZ2UgcG9zaXRpb24uLi5cbi8vIE9yIGl0IGNvdWxkIGJlIGFuIGV2ZW50IG9uIHRoZSBvYmplY3QuXG4vLyBNYXkgcmUtaW5kZXggdGhhdC5cblxuLy8gQWxzbywgbmVlZCB0byBsb29rIG91dCBmb3IgcHJvcGVydHkgY2hhbmdlcyBvbiBpbmRleGVkIGl0ZW1zLlxuLy8gTmVlZCB0byB1cGRhdGUgdGhlIGluZGV4IGluIHRoYXQgc2l0dWF0aW9uLlxuXG4vLyBTZWVtcyBsaWtlIHF1aXRlIGEgbG90IG9mIHdvcmsgdG8gZ2V0IHRoaXMgYWxsIGdvaW5nIC0gYnV0IEkgdGhpbmsgaXRcbi8vIHdpbGwgYmUgd29ydGggaXQgd2hlbiB0aGUgaW5kZXhlZCBjb2xsZWN0aW9uIHN5c3RlbSBpcyB3b3JraW5nLlxuLy8gV2lsbCBuZWVkIHRvIHJlZmVyIHRvIHRoZSBpbmRleCByZWNvcmQgd2hlbiB0aGUgcHJvcGVydHkgdmFsdWUgY2hhbmdlcy5cbi8vIFBlcmhhcHMgdXBkYXRlIGFsbCByZWxldmFudCBpbmRleGVzLlxuLy8gQnV0IHRoZW4gZG9uJ3Qgd2FudCB0byBwcm9jZWVkIHdpdGggb3RoZXIgdGhpbmdzIHVudGlsIHRoaXMgaXMgZG9uZS5cblxuLy8gVGhlIHN5c3RlbSBnZXRzIHNvbWV3aGF0IGNvbXBsaWNhdGVkLCBidXQgdGhpcyBpcyBzb21ldGhpbmcgd2hpY2ggY291bGRcbi8vIGJlIGFuIGludGVncmFsIGNvbXBvbmVudCB0aGF0IGNvdWxkIGJlIHJldXNlZCBhIGxvdCwgaWYgaXQgaXMgZG9uZSByaWdodC5cblxuLy8gQSBjb2xsZWN0aW9uIG9mIGNvbGxlY3Rpb25zIGNvdWxkIGJlIGEgbG90IGxpa2UgYSBkYXRhYmFzZS5cbi8vIE1heSB3YW50IG1vcmUgZXhhbXBsZXMgYWJvdXQgZGVhbGluZyB3aXRoIHN1Y2ggY29sbGVjdGlvbnMuXG5cbi8vIERvbid0IHdhbnQgdG8gc3BlbmQgYSBsb25nIHRpbWUgbWFraW5nIGFuZCB0ZXN0aW5nIHZhcmlvdXMgdGhpbmdzIHRoYXRcbi8vIGhhdmUgdGhpcyBjb2xsZWN0aW9uIGFuZCBvcmRlcmluZyBmdW5jdGlvbmFsaXR5Li4uXG4vLyBIb3dldmVyIG5lZWQgdG8gZG8gd2hhdCBpcyBuZWNlc3NhcnkuIFNvbWUgb2YgdGhlbSBtYXkgbm90IHNlZW0gdGhhdFxuLy8gdXNlZnVsIGluIHRoZSBhYnN0cmFjdCAtIGxpa2UgaGF2aW5nIHNvbWV0aGluZyB0aGF0IGlzIGluZGV4ZWQgYnkgdGhlXG4vLyBwb3NpdGlvbiB3aXRoaW4gYW5vdGhlciBjb250cm9sLlxuLy8gSW5kZXhlZCBieSB0aGUgcG9zaXRpb24gaW4gYW5vdGhlciBjb250cm9sIG9yIG9yZGVyZWQgYnkgaXQ/IFNhbWUgdGhpbmc/XG4vLyBNYXkgcmVxdWlyZSBxdWl0ZSBhIGJpdCBiZWhpbmQgdGhlIHNjZW5lcyB0byBnZXQgZXZlcnl0aGluZyB3b3JraW5nXG4vLyByaWdodC5cbi8vIEl0IHdvbid0IGJlIGEgdmVyeSBsYXJnZSBhbW91bnQgb2YgY29kZS4uLiBidXQgaXQgbmVlZHMgdG8gYmUgcmlnaHQuXG4vLyBSZWFsbHkgZG9uJ3Qgd2FudCB0byBtYWtlIHRoZSBkb3dubG9hZCB0b28gbGFyZ2UuIE1heSBjaGFuZ2UgdGhlIGIrXG4vLyBpbXBsZW1lbnRhdGlvbiBhbmQgZXhwZXJpbWVudCB3aXRoIGl0LCBnZXQgYSBzbWFsbGVyIGIrIHRyZWUgc2l6ZS5cbi8vIENvdWxkIHBlcmhhcHMgYmUgbG9hZGVkIGFmdGVyIGxhbmcsIGFzIGEgc2VwYXJhdGUgbW9kdWxlLCBidXQgdXNpbmcgbGFuZy5cbi8vIExhbmcgY291bGQgc3RhcnQgd2l0aCB0aGUgaW5kZXhpbmcgc3lzdGVtIHNldCB1cCwgYnV0IG5vdCBhbGwgdGhlIHR5cGVzXG4vLyBvZiBpbmRleGVzLiBNYXliZSBqdXN0IHRoZSBkaWN0IGluZGV4P1xuLy8gT3RoZXIgaW5kZXhlcyB3aWxsIHRoZW4gYmUgZWFzaWVyIHRvIHdvcmsgb24gc2VwYXJhdGVseS5cbi8vIEJ1dCBiKyBjb3VsZCBiZSBzbyBlc3NlbnRpYWwgdG8gdGhlIGxpYnJhcnkgd29ya2luZyBzbW9vdGhseSBpbiB0aGUgR1VJLlxuLy8gV29uJ3QgYmUgaW1wb3NzaWJsZSB0byBtYWtlIGEgbWljcm8tYisgaW1wbGVtZW50YXRpb24uXG4vLyBTbyBjb3VsZCBzdGlsbCBnZXQgYnkgaWQgd2l0aCB0aGUgZGljdCBpbmRleFxuLy8gTWFpbnRhaW5pbmcgYW5vdGhlciBjb2xsZWN0aW9uIG9yZGVyZWQgYnkgdGhlIHBvc2l0aW9uIGluIGFub3RoZXJcbi8vIGNvbGxlY3Rpb24gZG9lcyBzZWVtIGxpa2UgYSBnb29kIG9iamVjdGl2ZS5cbi8vIFBvc2l0aW9uIGluIGNvbGxlY3Rpb24gPSBwb3NpdGlvbiB3aXRoaW4gdGhlIG5vcm1hbCBhcnJheS4uLlxuLy8gTm90IHRoZSBwb3NpdGlvbiB3aXRoaW4gc29tZSBraW5kIG9mIGluZGV4LlxuXG4vLyBpbmRleF9ieShvdGhlcl9jb2xsZWN0aW9uKVxuLy8gb25seSBpZiBpdGVtcyBhcmUgaW4gdGhlIG90aGVyIGNvbGxlY3Rpb24uLi5cblxuLy8gaXRlbSBwb3NpdGlvbiBpbiBjb2xsZWN0aW9uLi4uIGNvbGxlY3Rpb24gaXMgYWx3YXlzIGFuIGFycmF5IGFzIHdlbGwuXG4vLyBjb3VsZCB0aGF0IG1ha2UgdGhpbmdzIGluZWZmaWNpZW50IHRoZXJlP1xuLy8gbW92aW5nIGl0ZW1zIGFyb3VuZCB0aGUgYXJyYXksIGNoYW5naW5nIHRoZSBhcnJheSBpbmRleCBvZiBpdGVtcy5cbi8vIG1heSBub3QgYmUgd29ydGggc28gbXVjaCBpbmRleGluZyB3aXRoIHRob3NlIGluaGVyYW50IGxpbWl0YXRpb25zP1xuXG4vLyBjb3VsZCBtYWtlIGRpZmZlcmVudCBjb2xsZWN0aW9ucyB3aXRoIGRpZmZlcmVudCBpbnRlcm5hbCBzdG9yYWdlP1xuLy8gbGlua2VkIGxpc3Q/IHNvbWV0aGluZyB0aGF0IG1haW50YWlucyBhbiBvcmRlcj9cblxuLy8gYXQgdGhlIG1vbWVudCwgY29udHJvbHMgYXJlIHN0b3JlZCBpbiBhbiBhcnJheSwgb3RoZXIgaW5kZXhpbmcgaXMgZG9uZVxuLy8gdG9vLlxuXG4vLyBBIHNpbmdsZSBpbmRleC5cblxuXG4vKlxudmFyIERhdGFDb2xsZWN0aW9uID0gQ2xhc3MuZXh0ZW5kKHtcbiAgICAnaW5pdCcgOiBmdW5jdGlvbihzcGVjKSB7XG4gICAgICAgIHRoaXMuX2lkX21hcCA9IHt9O1xuICAgICAgICB0aGlzLl9hcnIgPSBbXTtcbiAgICAgICAgdGhpcy5sZW5ndGggPSAwO1xuICAgIH0sXG5cbiAgICAvLyBmdW5jdGlvbiByZWZlcmVuY2UgLSBhZGQgZnVuY3Rpb25zIHRvIHRoYXQ/XG5cbiAgICAvLyBtdWNoIGxpa2UgZm5fY2FsbC4gUGVyaGFwcyBEYXRhT2JqZWN0IGNvdWxkIGhhdmUgZm5fY2FsbCAtIHRoZSBzYW1lXG4gICAgLy8gYXMgdGhpcy4gQnV0IHRoaXMgb25lIGRlYWxzIHdpdGggYW4gZW1wdHkgc2lnLCBtYXliZSB0aGF0J3MgdGhlXG4gICAgLy8gZGVmYXVsdCBmdW5jdGlvbiB3aGljaCBjYW4gYmUgYXNzaWduZWQuXG4gICAgJ2FjdGlvbicgOiBmcChmdW5jdGlvbihhLCBzaWcpIHtcbiAgICAgICAgLy8gd2hhdCBhYm91dCBjYWxsaW5nIHRoaXMgd2l0aCBtb3JlIHBhcmFtZXRlcnM/XG5cbiAgICAgICAgLy8gY29uc29sZS5sb2coJ2FjdGlvbiBzaWcgJyArIHNpZyk7XG5cbiAgICAgICAgaWYgKHNpZyA9PSAnW10nKSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnMSkgdGhpcy5fYXJyICcgKyB0b2YodGhpcy5fYXJyKSk7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyh0aGlzLl9hcnIubGVuZ3RoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hcnI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgYWN0aW9uX25hbWUgPSBhWzBdO1xuXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnYWN0aW9uX25hbWUgJyArIGFjdGlvbl9uYW1lKTtcblxuICAgICAgICAgICAgLy8gdGhlbiBjYWxsIHRoZSByZWxldmFudCBmdW5jdGlvbi4uLiBlZyBhZGQoYVsxXSlcblxuICAgICAgICAgICAgLy8gYW5kIHRoZW4gbWFrZSBpdCBzbyB0aGF0IG1vcmUgcGFyYW1ldGVycyBjYW4gYmUgZ2l2ZW4uXG5cbiAgICAgICAgICAgIHZhciBwYXJhbXMgPSBhLnNsaWNlKDEpO1xuXG4gICAgICAgICAgICAvLyByZXR1cm4gdGhpc1thY3Rpb25fbmFtZV0oYVsxXSk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzW2FjdGlvbl9uYW1lXS5hcHBseSh0aGlzLCBwYXJhbXMpO1xuXG4gICAgICAgIH1cblxuICAgIH0pLFxuXG4gICAgJ2FkZCcgOiBmcChmdW5jdGlvbihhLCBzaWcpIHtcbiAgICAgICAgLy8gaXRlbVxuICAgICAgICBjb25zb2xlLmxvZygnYWRkIHNpZyAnICsgc2lnKTtcblxuICAgICAgICBpZiAoc2lnID09ICdbb10nIHx8IHNpZyA9PSAnW2NdJykge1xuICAgICAgICAgICAgLy8gaWYgKClcbiAgICAgICAgICAgIHZhciBpID0gdGhpcy5fYXJyLmxlbmd0aDtcbiAgICAgICAgICAgIHRoaXMuX2Fyci5wdXNoKGFbMF0pO1xuICAgICAgICAgICAgdGhpcy5sZW5ndGgrKztcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCcyKSB0aGlzLl9hcnIgJyArICh0aGlzLl9hcnIpKTtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCcyKSB0aGlzLl9hcnIgJyArIHN0cmluZ2lmeSh0aGlzLl9hcnIpKTtcblxuICAgICAgICAgICAgLy8gY2lyY3VsYXIgcmVmZXJlbmNlcyB3aXRoIGNvbnRyb2xzP1xuXG4gICAgICAgICAgICAvLyBidXQgY291bGQgaW5kZXggYmUgYSByZWFkLW9ubHkgcHJvcGVydHk/XG4gICAgICAgICAgICBpZiAodG9mKGFbMF0uaW5kZXgpID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBhWzBdLmluZGV4KGkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodG9mKGFbMF0uaWQpID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB2YXIgaWQgPSBhWzBdLmlkKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5faWRfbWFwW2lkXSA9IGFbMF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgfSksXG4gICAgJ2dldCcgOiBmcChmdW5jdGlvbihhLCBzaWcpIHtcbiAgICAgICAgLy8gc3RyaW5nLCBpdCdzIGFuIGlkXG4gICAgICAgIGlmIChzaWcgPT0gJ1tzXScpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pZF9tYXBbYVswXV07XG4gICAgICAgIH0gZWxzZSBpZiAoc2lnID09ICdbbl0nKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYXJyW2FbMF1dO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbnVtYmVyIGl0J3MgYW4gaW5kZXhcblxuICAgIH0pLFxuICAgICdpbnNlcnQnIDogZnAoZnVuY3Rpb24oYSwgc2lnKSB7XG4gICAgICAgIC8vIGNhbiBiZSBnaXZlbiBvbmUgb2JqZWN0IHRvIGluc2VydCwgY2FuIGJlIGdpdmVuIGFuIGFycmF5IG9mIGl0ZW1zXG4gICAgICAgIC8vIHRvIGluc2VydD9cbiAgICAgICAgLy8gbm90IGZvciBhY3R1YWxseSBpbnNlcnRpbmcgYW4gYXJyYXkgdGhvdWdoLiBGb3IgdXNlIHdpdGggY29udHJvbHNcbiAgICAgICAgLy8gcmVhbGx5LCBjb3VsZCBiZSB1c2VkIHdpdGggb3RoZXIgb2JqZWN0cy5cbiAgICAgICAgLy8gQ291bGQgbWF5YmUgdHVybiB0aGlzIG9mZiBhcyBhbiBvYmplY3QgaW4gdGhlIGNvbnN0cnVjdGlvbi5cbiAgICAgICAgLy8gbWF5YmUgdG9sZCB0byBpbnNlcnQoY29udHJvbCwgcG9zaXRpb24pXG5cbiAgICAgICAgY29uc29sZS5sb2coJ2luc2VydCBzaWcgJyArIHNpZyk7XG4gICAgICAgIC8vIGlmIChzaWcgPT0gJ1snKVxuICAgICAgICAvLyBjaGVja2luZyBmb3IgYW4gYXJyYXkgaW4gdGhlIHNpZyBpcyB0cmlja3kuXG5cbiAgICAgICAgaWYgKHNpZyA9PSAnW28sbl0nKSB7XG4gICAgICAgICAgICAvLyB3aWxsIG5lZWQgdG8gbW92ZSB0aGUgaW5kZXggb2YgaXRlbXMgYWJvdmUgZm9yd2FyZC5cblxuICAgICAgICAgICAgdGhpcy5fYXJyLnNwbGljZShhWzFdLCAwLCBhWzBdKTtcbiAgICAgICAgICAgIGZvciAoIHZhciBjID0gYVsxXSwgbCA9IHRoaXMuX2Fyci5sZW5ndGg7IGMgPCBsOyBjKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IHRoaXMuX2FycltjXTtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5pbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBpdGVtLl8uaW5kZXggPSBjO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubGVuZ3RoKys7XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgaWYgKHRvZihhWzBdKSA9PSAnYXJyYXknKSB7XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodG9mKGFbMF0pID09ICdvYmplY3QnIHx8IHRvZihhWzBdKSA9PSAnY29udHJvbCcpIHtcbiAgICAgICAgICAgICAgICAvLyB3aWxsIG5lZWQgdG8gbW92ZSB0aGUgb25lcyBhZnRlciBpdCB1cCBhcyB3ZWxsLlxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgfSlcbn0pO1xudmFyIHAgPSBEYXRhQ29sbGVjdGlvbi5wcm90b3R5cGU7XG4qL1xuLy8gRnVuY3Rpb25hbGl0eSBmb3IgdGhlIGNvbnRyb2wncyBJRHMgLSB0aGF0IHNlZW1zIGxpa2UgaXRzIHBhZ2VfY29udGV4dCxcbi8vIHdoaWNoIGNvdWxkIGJlIHBhcnQgb2YgaHRtbC5cblxudmFyIF9kYXRhX2dlbmVyYXRvcnMgPSB7XG4gICAgLy8nT3JkZXJlZF9TdHJpbmdfTGlzdCcgOiBmdW5jdGlvbigpIHtcbiAgICAvL1x0Ly8gY29uc29sZS5sb2coJ2RnIE9yZGVyZWRfU3RyaW5nX0xpc3QnKTtcbiAgICAvL1x0cmV0dXJuIG5ldyBPcmRlcmVkX1N0cmluZ19MaXN0KCk7XG4gICAgLy99XG59XG5cbi8vIFRoaXMgY291bGQgYmUgdXNlZnVsIGZvciBhIGZldyB0aGluZ3MsIGxpa2Ugc3RvcmluZyB0YWJsZXMgaW4gYSBEQlxuLy8gc2NoZW1hLlxuLy8gTWF5YmUgcXVpdGUgYSBmZXcgbW9yZSB0aGluZ3MuXG5cbi8vIFVzZXMgcHJpdmF0ZSB2YXJpYWJsZXMuXG5cbi8vIERpZmZlcmVudCB0byBzb3J0ZWQgc3RyaW5nIGxpc3QuXG4vLyAgSW5kZXhlZCBieSB0aGUgc3RyaW5nIHRvby4uLlxuXG5cblxudmFyIHRydXRoID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IHRydWU7XG59XG5cbi8vIHdpbGwgcHV0IGZ1bmN0aW9ucyBpbnRvIHRoZSBqc2d1aSBvYmplY3QuXG5cbi8vIHdpdGggdGhlIGZ1bmN0aW9ucyBsaXN0ZWQgbGlrZSB0aGlzIGl0IHdpbGwgYmUgZWFzaWVyIHRvIGRvY3VtZW50IHRoZW0uXG5cbnZhciBleHRlbmQgPSBqc2d1aS5leHRlbmQsIGZwID0ganNndWkuZnAsIHN0cmluZ2lmeSA9IGpzZ3VpLnN0cmluZ2lmeSwgdG9mID0ganNndWkudG9mO1xuXG5cbi8vIENvbm5lY3RpbmcgdGhlc2UgaW5wdXQgcHJvY2Vzc29ycyBpbiB0aGlzIGluc3RhbmNlIHRvIHRoZSBFbmhhbmNlZF9EYXRhX09iamVjdD9cblxuXG5cbmV4dGVuZChqc2d1aS5kYXRhX3R5cGVzX2luZm8sIHtcblxuICAgICdjb2xvcic6IFsnaW5kZXhlZF9hcnJheScsIFtcbiAgICAgICAgWydyZWQnLCAnbnVtYmVyJ10sXG4gICAgICAgIFsnZ3JlZW4nLCAnbnVtYmVyJ10sXG4gICAgICAgIFsnYmx1ZScsICdudW1iZXInXVxuICAgIF1dLFxuICAgICdvbHRyYic6IFsnb3B0aW9uYWxfYXJyYXknLCBbJ2xlZnQnLCAndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbSddXVxufSk7XG5cbnZhciBjcmVhdGVfaW5wdXRfZnVuY3Rpb25fZnJvbV9kYXRhX3R5cGVfaW5mbyA9IGZ1bmN0aW9uIChkYXRhX3R5cGVfaW5mbykge1xuICAgIGNvbnNvbGUubG9nKCdjcmVhdGVfaW5wdXRfZnVuY3Rpb25fZnJvbV9kYXRhX3R5cGVfaW5mbyBkYXRhX3R5cGVfaW5mbyAnICsgc3RyaW5naWZ5KGRhdGFfdHlwZV9pbmZvKSk7XG5cbiAgICBpZiAodG9mKGRhdGFfdHlwZV9pbmZvKSA9PSAnYXJyYXknKSB7XG4gICAgICAgIHZhciBzZWNvbmRhcnlfaW5zdHJ1Y3Rpb24gPSBkYXRhX3R5cGVfaW5mb1swXTtcbiAgICAgICAgdmFyIGFycl9pdGVtcyA9IGRhdGFfdHlwZV9pbmZvWzFdO1xuICAgICAgICAvL2NvbnNvbGUubG9nKCdzZWNvbmRhcnlfaW5zdHJ1Y3Rpb24gJyArIHNlY29uZGFyeV9pbnN0cnVjdGlvbik7XG4gICAgICAgIC8vY29uc29sZS5sb2coJ3RvZihhcnJfaXRlbXMpICcgKyB0b2YoYXJyX2l0ZW1zKSk7XG5cbiAgICAgICAgaWYgKHRvZihhcnJfaXRlbXMpID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAvLyB0aGUgZGlzdGFuY2UuXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnYXJyX2l0ZW1zICcgKyBhcnJfaXRlbXMpO1xuXG5cbiAgICAgICAgICAgIGlmIChqc2d1aS5kYXRhX3R5cGVzX2luZm9bc2Vjb25kYXJ5X2luc3RydWN0aW9uXSkge1xuICAgICAgICAgICAgICAgIC8vIHByb2Nlc3MgaXQgd2l0aCB0aGF0IGluc3RydWN0aW9uLCBidXQgbmVlZCB0byBoYXZlIGl0IG9wZXJhdGluZyB3aXRoIHRoZSBkYXRhIHR5cGUgZ2l2ZW4gaGVyZSxcbiAgICAgICAgICAgICAgICAvLyAgJ2Rpc3RhbmNlJy5cblxuICAgICAgICAgICAgICAgIC8vIHNlZW1zIHF1aXRlIGhhcmQgdG8gZG8sIG1heSBiZSBhIHJlY3Vyc2l2ZSBwcm9jZXNzLlxuICAgICAgICAgICAgICAgIC8vICBvcHRpb25hbCBhcnJheSBiZWluZyB0aGUgZXhhbXBsZSBoZXJlLlxuXG4gICAgICAgICAgICAgICAgLy8gb3RscmIuXG5cbiAgICAgICAgICAgICAgICAvLyBjYWxsIGEgbmV3IHByb2NlZHVyZSBmb3Igb3RscmI/XG4gICAgICAgICAgICAgICAgLy8gIG1heSBuZWVkIHRvIGF1dG9tYXRpY2FsbHkganVtcCB0aHJvdWdoIHNvbWUgaW5kaXJlY3Rpb24uXG4gICAgICAgICAgICAgICAgLy8gICByZWFsbHksIHdhbnQgdG8gYmUgbGF5ZXJpbmcgZnVuY3Rpb25hbCBwcm9jZXNzb3JzLlxuXG4gICAgICAgICAgICAgICAgaWYgKGpzZ3VpLmRhdGFfdHlwZXNfaW5mb1thcnJfaXRlbXNdKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHByb2Nlc3MgaXQgd2l0aCB0aGF0IGluc3RydWN0aW9uLCBidXQgbmVlZCB0byBoYXZlIGl0IG9wZXJhdGluZyB3aXRoIHRoZSBkYXRhIHR5cGUgZ2l2ZW4gaGVyZSxcbiAgICAgICAgICAgICAgICAgICAgLy8gICdkaXN0YW5jZScuXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gc2VlbXMgcXVpdGUgaGFyZCB0byBkbywgbWF5IGJlIGEgcmVjdXJzaXZlIHByb2Nlc3MuXG4gICAgICAgICAgICAgICAgICAgIC8vICBvcHRpb25hbCBhcnJheSBiZWluZyB0aGUgZXhhbXBsZSBoZXJlLlxuXG4gICAgICAgICAgICAgICAgICAgIC8vIG90bHJiLlxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGNhbGwgYSBuZXcgcHJvY2VkdXJlIGZvciBvdGxyYj9cbiAgICAgICAgICAgICAgICAgICAgLy8gIG1heSBuZWVkIHRvIGF1dG9tYXRpY2FsbHkganVtcCB0aHJvdWdoIHNvbWUgaW5kaXJlY3Rpb24uXG4gICAgICAgICAgICAgICAgICAgIC8vICAgcmVhbGx5LCB3YW50IHRvIGJlIGxheWVyaW5nIGZ1bmN0aW9uYWwgcHJvY2Vzc29ycy5cblxuICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdwcm9jZXNzaW5nICcgKyBhcnJfaXRlbXMgKyAnIGFjY29yZGluZyB0byAnICsgc2Vjb25kYXJ5X2luc3RydWN0aW9uKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBsb2FkIHVwIHRoZSBvbHRyYiBpdGVtLi4uXG4gICAgICAgICAgICAgICAgICAgIC8vICBJIHRoaW5rIHdlIG5lZWQgYSByZWFkZXIgZm9yIHRoYXQuXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQSBjb25zdHJ1Y3RvciAvIGEgZnVuY3Rpb24gdGhhdCBpcyBhbiBpbnB1dCBwcm9jZXNzb3IgZm9yIG9sdHJiLlxuICAgICAgICAgICAgICAgICAgICAvLyAgVGVzdCB0aGF0LCB0aGVuIHVzZSBpdCBoZXJlLlxuXG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodG9mKGFycl9pdGVtcykgPT0gJ2FycmF5Jykge1xuICAgICAgICAgICAgLy8gcHJvY2VzcyB0aGUgc2Vjb25kYXJ5IGluc3RydWN0aW9uLi4uXG4gICAgICAgICAgICBpZiAoc2Vjb25kYXJ5X2luc3RydWN0aW9uID09ICdpbmRleGVkX2FycmF5Jykge1xuXG4gICAgICAgICAgICAgICAgdmFyIHJlcyA9IGZwKGZ1bmN0aW9uIChhLCBzaWcpIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayB0aGUgYXJndW1lbnRzIGdpdmVuLi4uIGRvIHRoZXkgbWF0Y2ggd2hhdCBpcyBleHBlY3RlZD9cblxuICAgICAgICAgICAgICAgICAgICAvLyBvciBpZiBpdCBpcyBhbiBvYmplY3QsIHB1dCB0aGVtIGludG8gcGxhY2UgaW4gdGhlIGNvcnJlY3QgcG9zaXRpb24uXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gZGF0YV90eXBlc19pbmZvIGNvdWxkIGhhdmUgYXNzb2NpYXRlZCBtYXBzLCBhdHRhY2hlZCB0byB0aGUgZGF0YV90eXBlc19pbmZvLlxuXG4gICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2lucHV0IHByb2Nlc3NvciBmb3IgZHRpICcgKyBzdHJpbmdpZnkoZGF0YV90eXBlX2luZm8pKTtcbiAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnc2lnICcgKyBzaWcpO1xuICAgICAgICAgICAgICAgICAgICAvLyB3aXRoIGFuIGluZGV4ZWQgYXJyYXksIHRoZXJlIHNob3VsZCBiZSBhIGR0aS5wb3NpdGlvbl9tYXBcblxuICAgICAgICAgICAgICAgICAgICBpZiAoc2lnID09ICdbW1tuLG4sbl1dXScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcyA9IGFbMF1bMF07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHByZXByb2Nlc3NvciBpcyBkZWFsaW5nIHdpdGggdGhlc2UuXG4gICAgICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICAgIGlmIChzaWcgPT0gJ1tbc11dJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbGlrZWx5IHRvIGJlc3QgdXNlIHNvbWUgcmVnZXggY29sb3IgbWF0Y2hlcy5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICBjb3VsZCBoYXZlIGEgcHJlLWlucHV0P1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gIHNwZWNpZmlmaWMgZm9ybWF0dGluZyBmb3IgY29sb3IgYW55d2F5LCBjb3VsZCB1c2UgYSBwcmVwcm9jZXNzb3IuXG5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICghZGF0YV90eXBlX2luZm8ubWFwX3Bvcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YV90eXBlX2luZm8ubWFwX3BvcyA9IHt9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBlYWNoKGFycl9pdGVtcywgZnVuY3Rpb24gKGksIHYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnaSAnICsgaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ3YgJyArIHYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFfdHlwZV9pbmZvLm1hcF9wb3NbdlswXV0gPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoc2lnID09ICdbW29dXScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHB1dCB0aGUgaXRlbXMgZnJvbSB0aGF0IG9iamVjdCBpbnRvIGFuIGFycmF5LlxuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZHRpbXAgPSBkYXRhX3R5cGVfaW5mby5tYXBfcG9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG8gPSBhWzBdWzBdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzID0gW107XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGVhY2gobywgZnVuY3Rpb24gKGksIHYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcG9zID0gZHRpbXBbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ3BvcyAnICsgcG9zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygndiAnICsgdik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzW3Bvc10gPSB2O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdyZXMgJyArIHN0cmluZ2lmeShyZXMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBhbHNvIHVzZSByZWd1bGFyIGV4cHJlc3Npb24gaWRlbnRpZmllcnMgZm9yIHBhcnNpbmcgZnJvbSBhIHN0cmluZz9cblxuICAgICAgICAgICAgICAgICAgICAvL3Rocm93ICczKSBzdG9wJztcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlbiB1c2UgZGF0YV90eXBlX2luZm8ubWFwX3Bvc1xuXG4gICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2RhdGFfdHlwZV9pbmZvLm1hcF9wb3MgJyArIHN0cmluZ2lmeShkYXRhX3R5cGVfaW5mby5tYXBfcG9zKSk7XG5cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG4vLyBvciBqdXN0IC5leHRlbmQoJ2NvbnRyb2wnKTtcbi8vICBEYXRhX09iamVjdCgnY29udHJvbCcpOyAobm90IGEgY29uc3RydWN0b3IpLlxuXG4vL3ZhciBDb250cm9sID0gRGF0YV9PYmplY3QuZXh0ZW5kKHsnZGF0YV90eXBlJzogJ2NvbnRyb2wnfSk7XG4vL3ZhciBDb250cm9sID0gRGF0YV9PYmplY3QuZXh0ZW5kKCdjb250cm9sJyk7XG5cblxuLy8gY291bGQgaGF2ZSBhbiBpbnB1dCBwcmVwcm9jZXNzb3IgYXMgd2VsbC5cbi8vICBzbyB0aGF0IGdlbmVyYWxpemVkIGZ1bmN0aW9uYWxpdHkgZ2V0cyB1c2VkIHRvby5cblxuLy8gSXMgcmVhbGx5IGEgQ1NTIGhleCBzdHJpbmcgLT4gW3IsIGcsIGJdIGNvbnZlcnRlclxuXG4vLyBjb2xvciBwYXJzZXIuLi5cbi8vICB3YW50IHRvIHBhcnNlIHRoZSBpbnB1dFxuLy8gY29sb3IgcHJlcHJvY2Vzc29yX3BhcnNlclxuXG52YXIgY29sb3JfcHJlcHJvY2Vzc29yX3BhcnNlciA9IGZwKGZ1bmN0aW9uKGEsIHNpZykge1xuICAgIGNvbnNvbGUubG9nKCdjb2xvcl9wcmVwcm9jZXNzb3JfcGFyc2VyIGEgJyArIHN0cmluZ2lmeShhKSk7XG4gICAgY29uc29sZS5sb2coJ2NvbG9yX3ByZXByb2Nlc3Nvcl9wYXJzZXIgc2lnICcgKyBzaWcpO1xuICAgIGlmIChzaWcgPT0gJ1tzXScpIHtcbiAgICAgICAgdmFyIGlucHV0ID0gYVswXTtcbiAgICAgICAgdmFyIHJ4X2hleCA9IC8oIyhbMC05QS1GYS1mXXsyfSkoWzAtOUEtRmEtZl17Mn0pKFswLTlBLUZhLWZdezJ9KSkvO1xuICAgICAgICB2YXIgbSA9IGlucHV0Lm1hdGNoKHJ4X2hleCk7XG4gICAgICAgIC8vY29uc29sZS5sb2coJ20gJyArIHN0cmluZ2lmeShtKSk7XG5cbiAgICAgICAgaWYgKG0pIHtcbiAgICAgICAgICAgIC8vIENvdWxkIHVzZSBhcnJheWlmeSBvciBzb21ldGhpbmcgdG8gbWFrZSB0aGUgY29udmVyc2lvbiBxdWlja2VyLi4uIHdpbGwgZG8gdGhhdCBpbiBtb3JlIHBsYWNlcywgbWFpbmx5IHdhbnQgdG8gZ2V0IHRoZSBjb2RlIHdvcmtpbmcgbm93LlxuXG4gICAgICAgICAgICB2YXIgciA9IGpzZ3VpLnN0cl9oZXhfdG9faW50KG1bMl0pO1xuICAgICAgICAgICAgdmFyIGcgPSBqc2d1aS5zdHJfaGV4X3RvX2ludChtWzNdKTtcbiAgICAgICAgICAgIHZhciBiID0ganNndWkuc3RyX2hleF90b19pbnQobVs0XSk7XG5cbiAgICAgICAgICAgIHZhciByZXMgPSBbciwgZywgYl07XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9XG4gICAgfVxuXG59KVxuXG5cbnZhciBjb2xvcl9wcmVwcm9jZXNzb3IgPSAoZnVuY3Rpb24gKGZuX2NvbG9yX3Byb2Nlc3Nvcikge1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAvL3Rocm93ICchc3RvcCc7XG4gICAgdmFyIHJlcyA9IGZwKGZ1bmN0aW9uIChhLCBzaWcpIHtcblxuICAgICAgICAvL2NvbnNvbGUubG9nKCdjb2xvcl9wcmVwcm9jZXNzb3Igc2lnICcgKyBzaWcpO1xuXG4gICAgICAgIGlmIChzaWcgPT0gJ1tbc11dJykge1xuICAgICAgICAgICAgLy92YXIgbmV3X2lucHV0ID1cbiAgICAgICAgICAgIC8vIHVzZSByZWdleGVzIHRvIGRldGVjdCAvIHJlYWQgdGhlIHN0cmluZy5cblxuICAgICAgICAgICAgLy92YXIgcnhfaGV4ID0gL14jP1thLWZBLUYwLTldW2EtZkEtRjAtOV1bYS1mQS1GMC05XSQvO1xuICAgICAgICAgICAgdmFyIHJ4X2hleCA9IC8oIyhbMC05QS1GYS1mXXsyfSkoWzAtOUEtRmEtZl17Mn0pKFswLTlBLUZhLWZdezJ9KSkvO1xuICAgICAgICAgICAgLy92YXIgcnhfaGV4ID0gLygjKChbMC05QS1GYS1mXXsyfSl7M30pKS87XG4gICAgICAgICAgICAvL3ZhciByeF9oZXggPSAvKCMoWzAtOUEtRmEtZl17Mn0pezN9KS87XG4gICAgICAgICAgICB2YXIgaW5wdXQgPSBhWzBdWzBdO1xuXG4gICAgICAgICAgICAvL3ZhciBtID0gcnhfaGV4Lm1hdGNoKGlucHV0KTtcbiAgICAgICAgICAgIHZhciBtID0gaW5wdXQubWF0Y2gocnhfaGV4KTtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ20gJyArIHN0cmluZ2lmeShtKSk7XG5cbiAgICAgICAgICAgIGlmIChtKSB7XG4gICAgICAgICAgICAgICAgLy8gQ291bGQgdXNlIGFycmF5aWZ5IG9yIHNvbWV0aGluZyB0byBtYWtlIHRoZSBjb252ZXJzaW9uIHF1aWNrZXIuLi4gd2lsbCBkbyB0aGF0IGluIG1vcmUgcGxhY2VzLCBtYWlubHkgd2FudCB0byBnZXQgdGhlIGNvZGUgd29ya2luZyBub3cuXG5cbiAgICAgICAgICAgICAgICB2YXIgciA9IGpzZ3VpLnN0cl9oZXhfdG9faW50KG1bMl0pO1xuICAgICAgICAgICAgICAgIHZhciBnID0ganNndWkuc3RyX2hleF90b19pbnQobVszXSk7XG4gICAgICAgICAgICAgICAgdmFyIGIgPSBqc2d1aS5zdHJfaGV4X3RvX2ludChtWzRdKTtcblxuICAgICAgICAgICAgICAgIHZhciByZXMgPSBbciwgZywgYl07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gY2FsbCB3aXRoIHRoZSBzYW1lIGFyZ3VtZW50cy5cbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2NhbGxpbmcgbm9ybWFsLi4uJyk7XG4gICAgICAgICAgICByZXR1cm4gZm5fY29sb3JfcHJvY2Vzc29yLmFwcGx5KHRoYXQsIGEpO1xuXG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzO1xufSk7XG5cbi8vIEluIHByZXZpb3VzIG1vZHVsZXMsIGl0IHdvbid0IGtlZXAgdGhlIHNhbWUgaW5wdXRfcHJvY2Vzc29ycy5cbi8vICBJcyB0aGVyZSBhIHdheSBvZiByZXRyaWV2aW5nIHRoYXQgZnJvbSB0aGUgbW9zdCBpbm5lciBtb2R1bGVzP1xuLy90ZXN0X0NvbG9yKCk7XG5cbi8vIEFuZCBpbnB1dHRpbmcgYW4gaW5kZXhlZCBhcnJheS5cbi8vICBXaWxsIG5lZWQgdG8gYWNjZXB0IDJkIHNpemUgaW5wdXRzLlxuLy8gU2l6ZSBjb3VsZCBwb3NzaWJseSBiZSAzZCwgbWF5YmUgMWQ/IEEgbGluZSBoYXMgYSBzaXplLCB3aGljaCBpcyBhbHNvIGl0cyBsZW5ndGggKHRob3VnaCBpbiB0aGUgd29ybGQgb2YgR1VJIGl0IGNvdWxkIGFsc28gaGF2ZVxuLy8gIGEgdGhpY2tuZXNzKS5cblxuLy8gT3B0aW9uYWwgYXJyYXkgbG9va3MgbW9yZSBsaWtlIGEgbGFuZ3VhZ2UgZmVhdHVyZSAoZW5oYW5jZW1lbnQpLlxuLy8gIE9yIGV2ZW4gYSBjb3JlIGxhbmd1YWdlIGZlYXR1cmU/XG5cblxuLy8gVGhlcmUgd2lsbCBiZSBkaWZmZXJlbnQgdHlwZXMgb2Ygb3B0aW9uYWwgYXJyYXlzLCB3aWxsIGhhdmUgZGlmZmVyZW50IGlucHV0IHBhcmFtZXRlcnMuXG5qc2d1aS5pbnB1dF9wcm9jZXNzb3JzWydvcHRpb25hbF9hcnJheSddID0gZnAoZnVuY3Rpb24gKGEsIHNpZykge1xuICAgIC8vIHdvdWxkIG5lZWQgdG8gdGFrZSBpbiBvYmplY3RzIHdpdGggdGhlIG5hbWVzIG9mIHRoZSBwcm9wZXJ0aWVzIGFzIHdlbGwuXG4gICAgLy8gIHBvcHVsYXRlIGEgc3BhcnNlIGFycmF5IHdpdGggdGhlbS5cbiAgICAvLyAgIHdpbGwgbWFrZSBhIHZlcnkgZmxleGlibGUgSFRNTCBpbnRlcmZhY2UuXG4gICAgLy8gICBjb250cm9scyB3aWxsIGJlIGFibGUgdG8gaGF2ZSB0aGVpciBwcm9wZXJ0aWVzIGNoYW5nZWQgaW4gYSBmbGV4aWJsZSB3YXksIGFuZCBvdXRwdXQgc2VhbWxlc3NseSB0byBhIHdpZGUgdmFyaWV0eSBvZiBicm93c2Vycy5cblxuICAgIC8vIHRoZSBpdGVtcyBpbiB0aGUgaW5kZXggY291bGQgYmUgYSBiaXQgbW9yZSBjb21wbGljYXRlZCwgYnV0IHdlIGFyZSBnb2luZyB0byBzYXkgdGhleSBhcmUganVzdCBzdHJpbmdzIGZvciB0aGUgbW9tZW50LlxuICAgIC8vICBpdGVtc19kYXRhX3R5cGVfbmFtZS4uLlxuICAgIC8vICAgaXMgdGhlIHBhcmFtcyBhbiBhcnJheSBvZiBzdHJpbmdzP1xuICAgIC8vIG9hX3BhcmFtcywgaW5wdXRcbiAgICBpZiAoYS5sID09IDIpIHtcbiAgICAgICAgdmFyIG9hX3BhcmFtcyA9IGFbMF0sXG4gICAgICAgICAgICBpbnB1dCA9IGFbMV07XG4gICAgICAgIGlmICh0b2YoaW5wdXQpID09ICdhcnJheScpIHtcbiAgICAgICAgICAgIC8vIGNoZWNrIGl0IGlzIHdpdGhpbiB0aGUgcmlnaHQgbnVtYmVyLlxuICAgICAgICAgICAgaWYgKGlucHV0Lmxlbmd0aCA8PSBvYV9wYXJhbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChhLmwgPT0gMykge1xuICAgICAgICB2YXIgb2FfcGFyYW1zID0gYVswXSxcbiAgICAgICAgICAgIGl0ZW1zX2RhdGFfdHlwZV9uYW1lID0gYVsxXSxcbiAgICAgICAgICAgIGlucHV0ID0gYVsyXTtcbiAgICAgICAgLy8gbm93IG5lZWQgdG8gZ2V0IGV2ZXJ5IGl0ZW0gaW4gdGhlIGFycmF5IG9yIHRoZSBpdGVtIHRvIGNvbmZvcm0gdG8gdGhlIGdpdmVuIHR5cGUuXG4gICAgICAgIHZhciBpbnB1dF9wcm9jZXNzb3JfZm9yX2l0ZW1zID0ganNndWkuaW5wdXRfcHJvY2Vzc29yc1tpdGVtc19kYXRhX3R5cGVfbmFtZV07XG4gICAgICAgIC8vY29uc29sZS5sb2coJ2lucHV0X3Byb2Nlc3Nvcl9mb3JfaXRlbXMgJyArIGlucHV0X3Byb2Nlc3Nvcl9mb3JfaXRlbXMpO1xuICAgICAgICAvL2NvbnNvbGUubG9nKCd0b2YoaW5wdXQpICcgKyB0b2YoaW5wdXQpKTtcbiAgICAgICAgaWYgKHRvZihpbnB1dCkgPT0gJ2FycmF5Jykge1xuICAgICAgICAgICAgLy8gY2hlY2sgaXQgaXMgd2l0aGluIHRoZSByaWdodCBudW1iZXIuXG4gICAgICAgICAgICBpZiAoaW5wdXQubGVuZ3RoIDw9IG9hX3BhcmFtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzID0gW107XG4gICAgICAgICAgICAgICAgZWFjaChpbnB1dCwgZnVuY3Rpb24gKGksIHYpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2goaW5wdXRfcHJvY2Vzc29yX2Zvcl9pdGVtcyh2KSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dF9wcm9jZXNzb3JfZm9yX2l0ZW1zKGlucHV0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvL2NvbnNvbGUubG9nKCdvYV9wYXJhbXMgJyArIHN0cmluZ2lmeShvYV9wYXJhbXMpKTtcbn0pO1xuXG5qc2d1aS5pbnB1dF9wcm9jZXNzb3JzWydpbmRleGVkX2FycmF5J10gPSBmcChmdW5jdGlvbiAoYSwgc2lnKSB7XG4gICAgLy8gaXQgbWF5IGJlIHRha2luZyBzb21lIGtpbmQgb2YgZGF0YSB0eXBlIHRoYXQgdGhpbmdzIG5lZWQgdG8gYmUgYXBwbGllZCB0by5cbiAgICAvLyBlZyAnc2l6ZSc6IFsnaW5kZXhlZF9hcnJheScsIFsnZGlzdGFuY2UnLCBbJ3dpZHRoJywgJ2hlaWdodCddXV0sXG4gICAgLy8gd291bGQgbmVlZCB0byB0YWtlIGluIG9iamVjdHMgd2l0aCB0aGUgbmFtZXMgb2YgdGhlIHByb3BlcnRpZXMgYXMgd2VsbC5cbiAgICBpZiAoYS5sID09IDIpIHtcbiAgICAgICAgdmFyIGlhX3BhcmFtcyA9IGFbMF0sXG4gICAgICAgICAgICBpbnB1dCA9IGFbMV07XG4gICAgICAgIC8vY29uc29sZS5sb2coJ2lhX3BhcmFtcyAnICsgc3RyaW5naWZ5KGlhX3BhcmFtcykpO1xuXG4gICAgICAgIGlmICh0b2YoaW5wdXQpID09ICdhcnJheScpIHtcbiAgICAgICAgICAgIGlmIChpbnB1dC5sZW5ndGggPD0gaWFfcGFyYW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbnB1dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoYS5sID09IDMpIHtcbiAgICAgICAgdmFyIGlhX3BhcmFtcyA9IGFbMF0sXG4gICAgICAgICAgICBpdGVtc19kYXRhX3R5cGVfbmFtZSA9IGFbMV0sXG4gICAgICAgICAgICBpbnB1dCA9IGFbMl07XG4gICAgICAgIHZhciBpbnB1dF9wcm9jZXNzb3JfZm9yX2l0ZW1zID0ganNndWkuaW5wdXRfcHJvY2Vzc29yc1tpdGVtc19kYXRhX3R5cGVfbmFtZV07XG4gICAgICAgIGlmICh0b2YoaW5wdXQpID09ICdhcnJheScpIHtcbiAgICAgICAgICAgIC8vIGNoZWNrIGl0IGlzIHdpdGhpbiB0aGUgcmlnaHQgbnVtYmVyLlxuICAgICAgICAgICAgaWYgKGlucHV0Lmxlbmd0aCA8PSBpYV9wYXJhbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlcyA9IFtdO1xuICAgICAgICAgICAgICAgIGVhY2goaW5wdXQsIGZ1bmN0aW9uIChpLCB2KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcy5wdXNoKGlucHV0X3Byb2Nlc3Nvcl9mb3JfaXRlbXModikpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuanNndWkuaW5wdXRfcHJvY2Vzc29yc1snbl91bml0cyddID0gZnVuY3Rpb24gKHN0cl91bml0cywgaW5wdXQpIHtcbiAgICAvLyB0aGlzIHdpbGwgY2hhbmdlIHRoaW5ncyB0byBoYXZlIGJvdGggdGhlIG51bWJlciBvZiB1bml0cyBhbmQgYSBzdHJpbmcgd2l0aCB0aGUgdW5pdCBpbiBhbiBhcnJheS5cbiAgICAvLyAgd2lsbCBtYWtlIGl0IGVhc2llciB0byBkbyBtYXRocyBvbiB0aGUgZGlzdGFuY2VzLlxuXG4gICAgaWYgKHRvZihpbnB1dCkgPT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIFtpbnB1dCwgc3RyX3VuaXRzXTtcbiAgICB9XG4gICAgaWYgKHRvZihpbnB1dCkgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy92YXIgcnhfbl91bml0cyA9IC9eKD86KFxcZCspKFxcdyspKXwoPzooXFxkKilcXC4oXFxkKykoXFx3KykpJC87XG4gICAgICAgIHZhciByeF9uX3VuaXRzID0gL14oXFxkKykoXFx3KykkLztcbiAgICAgICAgLy8gdGhlbiBtYXRjaCBpdCwgc2hvdWxkIGJlIG11bHRpcGxlIHBhcnRzIHRvIHRoZSBtYXRjaC5cblxuICAgICAgICAvLyBEbyB3YW50IHRvIGdldCB0aGUgdmFyaW91cyBwaWVjZXMgd29ya2luZyBmb3IgdGhlIENvbnRyb2wgc3lzdGVtLlxuICAgICAgICAvLyAgVGhlbiB3aWxsIGJlIHZlcnkgbmljZSBpbmRlZWQgd2hlbiBjb21wYWN0ZWQgZm9yIGEgbW9iaWxlLWNsaWVudC5cblxuICAgICAgICB2YXIgbWF0Y2ggPSBpbnB1dC5tYXRjaChyeF9uX3VuaXRzKTtcbiAgICAgICAgLy9jb25zb2xlLmxvZygnbWF0Y2ggJyArIHN0cmluZ2lmeShtYXRjaCkpO1xuXG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgcmV0dXJuIFtwYXJzZUludChtYXRjaFsxXSksIG1hdGNoWzJdXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJ4X25fdW5pdHMgPSAvXihcXGQqXFwuXFxkKykoXFx3KykkLztcbiAgICAgICAgbWF0Y2ggPSBpbnB1dC5tYXRjaChyeF9uX3VuaXRzKTtcbiAgICAgICAgLy9jb25zb2xlLmxvZygnbWF0Y2ggJyArIHN0cmluZ2lmeShtYXRjaCkpO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIHJldHVybiBbcGFyc2VGbG9hdChtYXRjaFsxXSksIG1hdGNoWzJdXTtcbiAgICAgICAgfVxuICAgICAgICAvL3Rocm93KCdzdG9wJyk7XG4gICAgfVxufTtcbmpzZ3VpLm1hcF9kYXRhX3R5cGVfZGF0YV9vYmplY3RfY29uc3RydWN0b3JzID0ganNndWkubWFwX2RhdGFfdHlwZV9kYXRhX29iamVjdF9jb25zdHJ1Y3RvcnMgfHwge307XG5cblxudmFyIGVuc3VyZV9kYXRhX3R5cGVfZGF0YV9vYmplY3RfY29uc3RydWN0b3IgPSBmdW5jdGlvbiAoZGF0YV90eXBlX25hbWUpIHtcbiAgICAvL2NvbnNvbGUubG9nKCcnKTtcbiAgICAvL2NvbnNvbGUubG9nKCcnKTtcbiAgICAvL2NvbnNvbGUubG9nKCdqc2d1aS5tYXBfZGF0YV90eXBlX2RhdGFfb2JqZWN0X2NvbnN0cnVjdG9yc1tkYXRhX3R5cGVfbmFtZV0gJyArIHN0cmluZ2lmeShqc2d1aS5tYXBfZGF0YV90eXBlX2RhdGFfb2JqZWN0X2NvbnN0cnVjdG9yc1tkYXRhX3R5cGVfbmFtZV0pKTtcbiAgICAvL2NvbnNvbGUubG9nKCcnKTtcbiAgICAvL2NvbnNvbGUubG9nKCcnKTtcblxuICAgIGlmICghanNndWkubWFwX2RhdGFfdHlwZV9kYXRhX29iamVjdF9jb25zdHJ1Y3RvcnNbZGF0YV90eXBlX25hbWVdKSB7XG4gICAgICAgIC8vY29uc29sZS5sb2coJ2h0bWwgbW9kdWxlOiBjcmVhdGluZyBuZXcgRGF0YV9PYmplY3QgY29uc3RydWN0b3IgZm9yIGRhdGFfdHlwZTogJyArIGRhdGFfdHlwZV9uYW1lKVxuICAgICAgICAvL3Rocm93ICdzdG9wJztcbiAgICAgICAgLy8gTmVlZCB0byBnZXQgdGhlIHZhcmlhYmxlIGJhY2sgdGhyb3VnaCB0aGUgbW9kdWxlcy4uLlxuICAgICAgICAvLyAgTWlzc2luZyBnbG9iYWwgdmFyaWFibGVzP1xuICAgICAgICAvLyAgTW92ZSB0aGlzIGZ1bmN0aW9uIHNvbWV3aGVyZSBlbHNlP1xuICAgICAgICAvLyAgTWF5YmUgd2UgY291bGQgaGF2ZSBzb21lIHN0b3JhZ2UgYXZhaWxhYmxlIGluIGpzZ3VpLWxhbmctZXNzZW50aWFscyB0aHJvdWdoIGEgY2xvc3VyZS5cbiAgICAgICAgLy8gIFRoYXQgd2F5IHRoZSBjb2RlIGNvdWxkIGJlIHNlbnQgYmFjay4uLiBidXQgZG8gd2Ugc3RpbGwgaGF2ZSBkaWZmZXJlbnQgaW5zdGFuY2VzIHJ1bm5pbmc/XG5cbiAgICAgICAgLy8gQ291bGQganVzdCBiZSBkaWZmZXJlbnQgZXhlY3V0aW9uIGNvbnRleHRzLi4uIGNvIGNhbid0IGZlZWQgYmFjayB0aGlzIGluZm9ybWF0aW9uIGFib3V0IG90aGVyIG9iamVjdHMuXG4gICAgICAgIC8vICBCdXQgY2FuIGZlZWQgZnVuY3Rpb25hbGl0eSBmb3JhcmRzLlxuXG4gICAgICAgIC8vIE1heSBuZWVkIHRvIGhhdmUgdGhpbmdzIG1vcmUgaW5kZXBlbmRhbnQuXG5cbiAgICAgICAgLy92YXIgZHRpID0ganNndWkuZ2V0KCdkdGknKTtcbiAgICAgICAgLy9jb25zb2xlLmxvZygnZHRpICcgKyBkdGkpO1xuICAgICAgICAvL3Rocm93ICdzdG9wJztcbiAgICAgICAgdmFyIGR0byA9IGpzZ3VpLmRhdGFfdHlwZXNfaW5mb1tkYXRhX3R5cGVfbmFtZV07XG4gICAgICAgLy9jb25zb2xlLmxvZygnZHRvICcgKyBzdHJpbmdpZnkoZHRvKSk7XG4gICAgICAgIC8vY29uc29sZS5sb2coKVxuICAgICAgICAvL3Rocm93ICdzdG9wJztcbiAgICAgICAgdmFyIGR0YyA9IERhdGFfT2JqZWN0LmV4dGVuZCh7XG4gICAgICAgICAgICAnZmllbGRzJzogZHRvXG4gICAgICAgIH0pXG4gICAgICAgIGR0Yy5wcm90b3R5cGUuX2RhdGFfdHlwZV9uYW1lID0gZGF0YV90eXBlX25hbWU7XG4gICAgICAgIGpzZ3VpLm1hcF9kYXRhX3R5cGVfZGF0YV9vYmplY3RfY29uc3RydWN0b3JzW2RhdGFfdHlwZV9uYW1lXSA9IGR0YztcbiAgICB9XG4gICAgcmV0dXJuIGpzZ3VpLm1hcF9kYXRhX3R5cGVfZGF0YV9vYmplY3RfY29uc3RydWN0b3JzW2RhdGFfdHlwZV9uYW1lXTtcbn1cbmpzZ3VpLmVuc3VyZV9kYXRhX3R5cGVfZGF0YV9vYmplY3RfY29uc3RydWN0b3IgPSBlbnN1cmVfZGF0YV90eXBlX2RhdGFfb2JqZWN0X2NvbnN0cnVjdG9yO1xuLy9jb25zb2xlLmxvZygnanNndWkuaW5wdXRfcHJvY2Vzc29ycyAnICsgc3RyaW5naWZ5KE9iamVjdC5rZXlzKGpzZ3VpLmlucHV0X3Byb2Nlc3NvcnMpKSk7XG52YXIgZHRpX2NvbG9yID0ganNndWkuZGF0YV90eXBlc19pbmZvWydjb2xvciddO1xuXG5qc2d1aS5pbnB1dF9wcm9jZXNzb3JzWydjb2xvciddID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgICBjb25zb2xlLmxvZygncHJvY2Vzc2luZyBjb2xvciBpbnB1dDogJyArIHN0cmluZ2lmeShpbnB1dCkpO1xuXG4gICAgdmFyIGlucHV0X3NpZyA9IGdldF9pdGVtX3NpZyhpbnB1dCwgMik7XG4gICAgLy9jb25zb2xlLmxvZygnaW5wdXRfc2lnICcgKyBpbnB1dF9zaWcpO1xuXG4gICAgaWYgKGlucHV0X3NpZyA9PSAnW3NdJykgaW5wdXQgPSBpbnB1dFswXTtcblxuICAgIHZhciByZXMgPSBjb2xvcl9wcmVwcm9jZXNzb3JfcGFyc2VyKGlucHV0KTtcbiAgICAvLyBub3Qgc3VyZSB0aGF0IHVzaW5nIHRoZSBwcmVwcm9jZXNzb3IgaXMgcmlnaHQuLi5cbiAgICAvLyAgaXQgcmV0dXJucyBhIGZ1bmN0aW9uLCBJIHRoaW5rIGl0IGFwcGxpZXMgdG8gYSBmdW5jdGlvbi5cbiAgICB0aHJvdyAnISFzdG9wJztcbiAgICAvL2NvbnNvbGUubG9nKCdyZXMgJyArIHN0cmluZ2lmeShyZXMpKTtcbiAgICByZXR1cm4gcmVzO1xufVxuXG4vL2NvbG9yX3ByZXByb2Nlc3NvcihjcmVhdGVfaW5wdXRfZnVuY3Rpb25fZnJvbV9kYXRhX3R5cGVfaW5mbyhkdGlfY29sb3IpKTtcbmpzZ3VpLmVuc3VyZV9kYXRhX3R5cGVfZGF0YV9vYmplY3RfY29uc3RydWN0b3IoJ2NvbG9yJyk7XG5cbmpzZ3VpLm91dHB1dF9wcm9jZXNzb3JzWydjb2xvciddID0gZnVuY3Rpb24gKGpzZ3VpX2NvbG9yKSB7XG4gICAgdmFyIHJlcyA9IGpzZ3VpLmFycl9yZ2JfdG9fY3NzX2hleF82KGpzZ3VpX2NvbG9yKTtcbiAgICByZXR1cm4gcmVzO1xufTtcblxuLy8gY29sbGVjdGlvbiBuZWVkcyBhIGNvbnRleHQuLi5cbi8vICBjYW4gZ2V0IHRoZSBjb250ZXh0IGZyb20gdGhlIGZpcnN0IG9iamVjdC5cblxuLy8gR3JvdXBpbmcgbm90IHdvcmtpbmcgc28gd2VsbCBzbyBmYXIuLi5cbi8vICBNYXliZSBhIGxlc3MgcmVmbGVjdGl2ZSB3YXkgb2YgbWFraW5nIHRoZSBncm91cCBmdW5jdGlvbj9cblxuXG5cbnZhciBncm91cCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgLy8gSG9wZSB0aGlzIGdyb3VwaW5nIHN5c3RlbSBpcyBub3QgdG9vIHNsb3cuXG4gICAgLy8gIE1heSBiZSBhYmxlIHRvIG9wdGltaXplIC8gc2VsZWN0aXZlbHkgbWFrZSB0aGUgZ3JvdXBpbmcgZnVuY3Rpb25zLlxuXG4gICAgdmFyIGEgPSBhcmd1bWVudHM7XG5cbiAgICBpZiAoYS5sZW5ndGggPT0gMSAmJiB0b2YoYVswXSkgPT0gJ2FycmF5Jykge1xuICAgICAgICByZXR1cm4gZ3JvdXAuYXBwbHkodGhpcywgYVswXSk7XG4gICAgfVxuXG4gICAgLy92YXIgcmVzID0gbmV3IENvbGxlY3Rpb24oKTtcbiAgICB2YXIgcmVzO1xuICAgIGZvciAodmFyIGMgPSAwLCBsID0gYS5sZW5ndGg7IGMgPCBsOyBjKyspIHtcbiAgICAgICAgdmFyIGl0ZW0gPSBhW2NdO1xuXG4gICAgICAgIGlmIChjID09IDApIHtcbiAgICAgICAgICAgIHJlcyA9IG5ldyBDb2xsZWN0aW9uKHsnY29udGV4dCc6IGl0ZW0uX2NvbnRleHR9KTtcblxuICAgICAgICB9XG4gICAgICAgIHJlcy5wdXNoKGl0ZW0pO1xuXG4gICAgfVxuXG4gICAgdmFyIEMgPSBhWzBdLmNvbnN0cnVjdG9yO1xuICAgIHZhciBwID0gQy5wcm90b3R5cGU7XG5cbiAgICAvL2NvbnNvbGUubG9nKCdDICcgKyBDKTtcbiAgICAvL2NvbnNvbGUubG9nKCdwICcgKyBwKTtcblxuICAgIGZvciAoaSBpbiBwKSB7XG5cbiAgICAgICAgdmFyIHRwaSA9IHRvZihwW2ldKTtcbiAgICAgICAgLy9jb25zb2xlLmxvZygndHBpICcgKyB0cGkpO1xuXG4gICAgICAgIC8vIGlmIHRwaSBpcyBhIGZ1bmN0aW9uLCB0aGVuIHdlIGNhbiBtYWtlIGEgdmVyc2lvbiBmb3IgdGhlIGNvbGxlY3Rpb24uXG5cbiAgICAgICAgLy8gbmVlZCB0aGlzIHRvIHJlbWVtYmVyIHRoZSBmdW5jdGlvbiBuYW1lLi4uIG1heWJlIHdpdGggYW5vdGhlciBjbG9zdXJlLlxuXG5cblxuICAgICAgICBpZiAodHBpID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIG1ha2UgYSBncm91cCB2ZXJzaW9uLlxuXG4gICAgICAgICAgICAoZnVuY3Rpb24oaSkge1xuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2kgJyArIGkpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGkgIT0gJ2VhY2gnICYmIGkgIT0gJ2dldCcgJiYgaSAhPSAnYWRkX2V2ZW50X2xpc3RlbmVyJykge1xuICAgICAgICAgICAgICAgICAgICByZXNbaV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coaSArICcgY2FsbGVkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdjYWxsZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vdGhyb3cgJ3N0b3AnO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGVuIGZvciBlYWNoIG9mIHRoZSBpdGVtcyBpbiB0aGUgY29sbGVjdGlvbiB3ZSBjYWxsIHdpdGggdGhlIHNhbWUgcGFyYW1ldGVycy5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJ1dCB3aXRoIHdoaWNoIGNvbnRleHQ/XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgQ2FuIHdlIGhhdmUgYSBncm91cCBjb250ZXh0P1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIC0gd2lsbCBiZSB0aGUgY29sbGVjdGlvbj9cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlbiB3ZSBuZWVkIHRvIGNhbGwgdGhlIGNvbGxlY3RpdmUgZnVuY3Rpb24gLi4uXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgb24gZWFjaCBvZiB0aGVtP1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSBhcmd1bWVudHM7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcy5lYWNoKGZ1bmN0aW9uKGkyLCB2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnaSAnICsgaSk7XG5cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdltpXS5hcHBseShyZXMsIGEpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWRkaW5nIGFuIGV2ZW50IGxpc3RlbmVyLi4uXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkbyBpdCBkaWZmZXJlbnRseT9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgaGF2ZSBpdCBzbyB0aGF0IHRoZSBjb250ZXh0IGlzIHRoZSBvYmplY3QuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICBpdCBuZWVkcyB0byBiZSB0aGF0IGZvciB0aGUgZnVuY3Rpb24gdG8gd29yay5cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhbiB0aGF0IGJlIGNoYW5nZWQgc28gd2UgZ2l2ZSBpdCBhbm90aGVyIGNvbnRleHQ/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gIHNvIHRoYXQgaXQgd2hlbiB0aGUgZXZlbnQgaGFwcGVucywgaXRzIHRyaWdnZXJlZCBjb250ZXh0IGlzIHRoZSBncm91cD9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBncm91cCBldmVudHMgd2lsbCBiZSB2ZXJ5IHVzZWZ1bC4gdGhlbiBhcHBseWluZyBjaGFuZ2VzIHRvIGEgZ3JvdXAuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdltpXS5hcHBseSh2LCBhKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcblxuXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KShpKVxuXG5cblxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICAvL3Rocm93ICdzdG9wJztcblxuXG4gICAgLy8gYnV0IHRoZSBncm91cCBtZXRob2RzLi4uXG4gICAgLy8gIENvbGxlY3RpdmUgbWV0aG9kcy5cbiAgICAvLyAgIENvdWxkIGdldCB0aGUgdHlwZSBvZiB0aGUgZmlyc3Qgb2JqZWN0LlxuXG5cblxuICAgIHJldHVybiByZXM7XG5cbn1cblxudmFyIHRydWVfdmFscyA9IGZ1bmN0aW9uKG1hcCkge1xuICAgIHZhciByZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpIGluIG1hcCkge1xuICAgICAgICBpZiAobWFwW2ldKSByZXMucHVzaChtYXBbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuXG5cblxudmFyIGpzZ3VpID0gZXh0ZW5kKGpzZ3VpLCB7XG4vL3ZhciBqc2d1aSA9IHtcbiAgICAndmVjdG9yaWZ5JyA6IHZlY3RvcmlmeSxcbiAgICAndl9hZGQnIDogdl9hZGQsXG4gICAgJ3Zfc3VidHJhY3QnIDogdl9zdWJ0cmFjdCxcbiAgICAndl9tdWx0aXBseScgOiB2X211bHRpcGx5LFxuICAgICd2X2RpdmlkZScgOiB2X2RpdmlkZSxcbiAgICAndmVjdG9yX21hZ25pdHVkZScgOiB2ZWN0b3JfbWFnbml0dWRlLFxuICAgICdkaXN0YW5jZV9iZXR3ZWVuX3BvaW50cycgOiBkaXN0YW5jZV9iZXR3ZWVuX3BvaW50cyxcbiAgICAvLydhcnJfdHJpbV91bmRlZmluZWQnIDogYXJyX3RyaW1fdW5kZWZpbmVkLFxuICAgIC8vICdyZW1vdmVfc2lnX2Zyb21fYXJyX3NoZWxsJzogcmVtb3ZlX3NpZ19mcm9tX2Fycl9zaGVsbFxuICAgIC8vJ2xsX3NldCcgOiBsbF9zZXQsXG4gICAgLy8nbGxfZ2V0JyA6IGxsX2dldCxcbiAgICAnZXhlY3V0ZV9vbl9lYWNoX3NpbXBsZScgOiBleGVjdXRlX29uX2VhY2hfc2ltcGxlLFxuICAgICdtYXBpZnknIDogbWFwaWZ5LFxuICAgICdmaWx0ZXJfbWFwX2J5X3JlZ2V4JyA6IGZpbHRlcl9tYXBfYnlfcmVnZXgsXG4gICAgJ2F0b2YnIDogYXRvZixcbiAgICAnbnB4JyA6IG5weCxcbiAgICAnbm9fcHgnIDogbm9fcHgsXG4gICAgJ3N0cl9hcnJfbWFwaWZ5JyA6IHN0cl9hcnJfbWFwaWZ5LFxuICAgICdhcnJfbHRyYicgOiBhcnJfbHRyYixcbiAgICAndHJ1ZV92YWxzJzogdHJ1ZV92YWxzLFxuXG4gICAgLy8gJ2RhdGFfdHlwZV9pbnN0YW5jZSc6IGRhdGFfdHlwZV9pbnN0YW5jZSxcblxuICAgIC8vICdkYXRhX3R5cGVzX2luZm8nOiBkYXRhX3R5cGVzX2luZm8sXG5cbiAgICAvLydpbnB1dF9wcm9jZXNzb3JzJyA6IGlucHV0X3Byb2Nlc3NvcnMsXG4gICAgLy8nb3V0cHV0X3Byb2Nlc3NvcnMnIDogb3V0cHV0X3Byb2Nlc3NvcnMsXG5cbiAgICAvLyBUaGlzIGlzIGdvaW5nIHRvIGRvIGEgYml0IG1vcmUgdG8gZG8gd2l0aCB2YWxpZGF0aW9uLlxuICAgIC8vICBXaWxsIHZhbGlkYXRlIGFjY29yZGluZyB0byB0eXBlc1xuICAgIC8vICBXaWxsIHZhbGlkYXRlIGFjY29yZGluZyB0byBvdGhlciBzcGVjaWZpZWQgcmVxdWlyZW1lbnRzXG4gICAgLy8gICBUeXBlIHZhbGlkYXRpb24gd2lsbCBiZSBmYWlybHkgZWFzeS4uLiBidXQgZG8gbmVlZCB0byBrbm93IHdoYXQgdHlwZXMgYXJlIGV4cGVjdGVkLlxuICAgIC8vICAgIFdvdWxkIGJlIGRpZmZlcmVudCB3YXlzIG9mIGNoZWNraW5nIHR5cGVzLCBwYXJ0aWN1bGFybHkgd2l0aCBhIGNsYXNzIGluaGVyaXRhbmNlIHN0cnVjdHVyZS5cbiAgICAvLyAgICAnSVMnIHR5cGUgY2hlY2suXG5cbiAgICAvLyBXYW50IHRvIGRvIGNoZWNrcyBJIGxpa2UgSSB0aGluayBpcyBleHByZXNzZWQgaW4gdGhlIEhUTUwgc2VjdGlvbi5cbiAgICAvLyAgVGhpcyB3aWxsIGJlIGludGVncmF0ZWQgd2l0aCBmb3JtIHZhbGlkYXRpb24uXG4gICAgLy8gV2lsbCBicmluZyB0aGF0IGZ1bmN0aW9uYWxpdHkgb3V0IG9mICduZXN0ZWQnLlxuXG4gICAgLy8gV2FudCB0byBzcGVjaWZ5IHRoZSByZXF1aXJlbWVudHMgc28gdGhhdCBpdCBjYW4ga25vdyB0byBjaGVjayBmb3IgYSBwcm9wZXJ0eSB2YWx1ZS5cblxuICAgICd2YWxpZGF0b3JzJyA6IHZhbGlkYXRvcnMsXG5cbiAgICAvLydEYXRhT2JqZWN0JyA6IERhdGFPYmplY3QsXG4gICAgLy8nRGF0YV9PYmplY3QnIDogRGF0YU9iamVjdCxcblxuICAgIC8vIEluIHNvbWUgY2FzZXMgdGhlIHdyYXBwZXIgd2lsbCBhZGQgZGlmZmljdWx0eSAvIHNsb3duZXNzLlxuICAgIC8vICBJbiBvdGhlcnMgaXQgY291bGQgYmUgdXNlZnVsIGZvciBzb21lIHByZWNpc2UgbnVtYmVyIG9wZXJhdGlvbnMuXG5cbiAgICAvLydLU1ZTJzogS1NWUyxcbiAgICAvLydLU1ZTX0N1cnNvcic6IEtTVlNfQ3Vyc29yLFxuXG4gICAgLy8gIERhdGFWYWx1ZXMgY291bGQgcGVyaGFwcyBiZSBhZGRyZXNzYWJsZSB3aXRoaW4gYSByZXNvdXJjZSBhYnN0cmFjdGlvbi5cblxuICAgIC8vJ0RhdGFfVmFsdWUnOiBEYXRhX1ZhbHVlLFxuICAgIC8vJ0NvbGxlY3Rpb24nIDogQ29sbGVjdGlvbixcblxuICAgICdfX2RhdGFfaWRfbWV0aG9kJyA6ICdsYXp5JyxcbiAgICAvLyAnX19kYXRhX2lkX21ldGhvZCc6ICdpbml0JyxcblxuICAgIC8vICdEYXRhQ29sbGVjdGlvbic6IERhdGFDb2xsZWN0aW9uLFxuXG4gICAgJ3N0cl9oZXhfdG9faW50JyA6IHN0cl9oZXhfdG9faW50LFxuICAgICdhcnJfcmdiX3RvX2Nzc19oZXhfNicgOiBhcnJfcmdiX3RvX2Nzc19oZXhfNixcblxuICAgIC8vIFRoZXNlIGFyZSBsaWtlbHkgdG8gYmUgZGVwcmVjYXRlZCBpbiBmYXZvdXIgb2YgaGF2aW5nIGxhbmcgaGFuZGxlXG4gICAgLy8gdGhlc2UgaW50ZXJuYWxseSBhbmQgZXhwb3NpbmcgYWRkX2RhdGFfdHlwZSwgd2hpY2ggd2lsbCBiZSBtYXBpZmllZC5cblxuICAgIC8qXG4gICAgICogJ3BvcHVsYXRlX2FueV9tYXBzJzogcG9wdWxhdGVfYW55X21hcHMsXG4gICAgICogJ3BvcHVsYXRlX29wdGlvbmFsX2FycmF5X3Bvc19tYXBzJzogcG9wdWxhdGVfb3B0aW9uYWxfYXJyYXlfcG9zX21hcHMsXG4gICAgICogJ3BvcHVsYXRlX2luZGV4ZWRfYXJyYXlfcG9zX21hcHMnOiBwb3B1bGF0ZV9pbmRleGVkX2FycmF5X3Bvc19tYXBzXG4gICAgICovXG4gICAgLy8gJ3BvcHVsYXRlX2FsbF9kdF9tYXBzJzogcG9wdWxhdGVfYWxsX2R0X21hcHMsXG4gICAgJ19kYXRhX2dlbmVyYXRvcnMnIDogX2RhdGFfZ2VuZXJhdG9ycyxcblxuICAgICdncm91cCc6IGdyb3VwXG5cbiAgICAvLydPcmRlcmVkX1N0cmluZ19MaXN0JyA6IE9yZGVyZWRfU3RyaW5nX0xpc3QsXG5cbn0pO1xuLy9jb25zb2xlLmxvZygnanNndWkuaW5wdXRfcHJvY2Vzc29ycyAnICsgc3RyaW5naWZ5KGpzZ3VpLmlucHV0X3Byb2Nlc3NvcnMpKTtcbi8vIHZhciBqc2d1aSA9IHt9O1xuLy8gYWxlcnQoJ3JldHVybmluZyBqc2d1aSBmcm9tIGpzZ3VpLWxhbmcnKTtcbi8vcmV0dXJuIGpzZ3VpO1xubW9kdWxlLmV4cG9ydHMgPSBqc2d1aTtcbi8vfSk7XG4iLCJcbi8qXG5kZWZpbmUoWycuLi8uLi93ZWIvanNndWktaHRtbCcsICcuL2NsaWVudC1yZXNvdXJjZScsICcuL3Bvb2wnXSxcblxuXHRmdW5jdGlvbihqc2d1aSwgUmVzb3VyY2UsIFJlc291cmNlX1Bvb2wpIHtcbiovXG5cbnZhciBqc2d1aSA9IHJlcXVpcmUoJy4uLy4uL3dlYi9qc2d1aS1odG1sJyk7XG52YXIgUmVzb3VyY2UgPSByZXF1aXJlKCcuL2NsaWVudC1yZXNvdXJjZScpO1xudmFyIFJlc291cmNlX1Bvb2wgPSByZXF1aXJlKCcuL3Bvb2wnKTtcblxuXG5cdC8vIENsaWVudF9SZXNvdXJjZT9cblx0Ly8gIEkgdGhpbmsgdGhhdCBtYWtlcyBzZW5zZSwgc28gdGhhdCB3ZSBoYXZlIHNvbWV0aGluZyBzcGVjaWZpYyB3aGljaCBoYXMgdGhlIFVSTCBhdHRhY2hlZC5cblx0Ly8gICBJdCBpcyBhYmxlIHRvIG1ha2UgSFRUUCByZXF1ZXN0cyB0byB0aGUgc2VydmVyIHJlc291cmNlLlxuXG5cblxuXHRcblx0dmFyIHN0cmluZ2lmeSA9IGpzZ3VpLnN0cmluZ2lmeSwgZWFjaCA9IGpzZ3VpLmVhY2gsIGFycmF5aWZ5ID0ganNndWkuYXJyYXlpZnksIHRvZiA9IGpzZ3VpLnRvZjtcblx0dmFyIGZpbHRlcl9tYXBfYnlfcmVnZXggPSBqc2d1aS5maWx0ZXJfbWFwX2J5X3JlZ2V4O1xuXHR2YXIgQ2xhc3MgPSBqc2d1aS5DbGFzcywgRGF0YV9PYmplY3QgPSBqc2d1aS5EYXRhX09iamVjdCwgRW5oYW5jZWRfRGF0YV9PYmplY3QgPSBqc2d1aS5FbmhhbmNlZF9EYXRhX09iamVjdDtcblx0dmFyIGZwID0ganNndWkuZnAsIGlzX2RlZmluZWQgPSBqc2d1aS5pc19kZWZpbmVkO1xuXHR2YXIgQ29sbGVjdGlvbiA9IGpzZ3VpLkNvbGxlY3Rpb247XG5cdFxuXHQvL3ZhciBleGVjID0gcmVxdWlyZSgnY2hpbGRfcHJvY2VzcycpLmV4ZWM7XG5cblx0Ly8gUGVyaGFwcyB0aGlzIHdpbGwgaGF2ZSBIVFRQIGVuZHBvaW50cyBhcyB3ZWxsP1xuXHQvLyAgTWF5YmUgd2UgY2FuIGFjY2VzcyBpdCB0aHJvdWdoIHVybC9yZXNvdXJjZXMvXG5cblx0Ly8gUGVyaGFwcyBhIHJlc291cmNlIHB1Ymxpc2hlciwgb3IgYSBmZXcgb2YgdGhlbSBjb3VsZCBiZSB1c2VmdWwuXG5cdC8vICBIVFRQX1Jlc291cmNlX1B1Ymxpc2hlcj9cblx0Ly8gIEdlbmVyYWxseSBwdWJsaXNoZXMgYSByZXNvdXJjZSBvdmVyIEhUVFAuXG5cdC8vICAgV2lsbCBoYXZlIHNvbWUgYXV0aG9yaXphdGlvbiBhbmQgYXV0aGVudGljYXRpb24gcHJvcGVydGllcywgaG9va2VkIHVwIHdpdGggdGhlIHByb3BlciBwcm92aWRlcnMuXG5cblx0Ly8gVGhpcyBtYXkgYmUgdGhlIHBsYWNlIGluIHdoaWNoIHJlbW90ZSBhY2Nlc3MgdG8gdGhlIHJlc291cmNlcyBpcyBnaXZlbi5cblx0Ly8gIEl0IHdvdWxkIG1ha2Ugc2Vuc2UuXG5cdC8vICBQZXJoYXBzIGl0IGlzIHdvcnRoIHVzaW5nIGEgcmVzb3VyY2UgcHVibGlzaGVyPyBUaGVuIGlzIHRoYXQgYSByZXNvdXJjZT9cblx0Ly8gIEkgdGhpbmsgdGhlIHJlc291cmNlIHBvb2wgbWF5IGJlIHRoZSBzZW5zaWJsZSBwb2ludCBvZiBhY2Nlc3MuXG5cdFxuXHR2YXIgQ2xpZW50X1Jlc291cmNlX1Bvb2wgPSBSZXNvdXJjZV9Qb29sLmV4dGVuZCh7XG5cdFx0J2ZpZWxkcyc6IHtcblx0XHRcdCd1cmwnOiBTdHJpbmdcblx0XHR9LFxuXHRcdCdpbml0JzogZnVuY3Rpb24oc3BlYykge1xuXHRcdFx0dGhpcy5fc3VwZXIoc3BlYyk7XG5cblxuXG5cdFx0XHRcblx0XHRcdC8vIHdpbGwgYWRkIHRoZSBSZXNvdXJjZV9Mb2NhbF9TZXJ2ZXJfSW5mb3JtYXRpb25cblx0XHRcdFxuXHRcdFx0XG5cdFx0XHQvLyBXaWxsIGJlIG5pY2UgdG8gc2V0IHRoZW0gd2l0aCBhbiBvYmplY3QuXG5cdFx0XHQvLyAgTm90IGp1c3QgdGhlIG5vcm1hbCBzcGVjLlxuXHRcdFx0Ly8gIE1heWJlIGNhbiBzZWUgaWYgdGhlIHNwZWMgbWF0Y2hlcyBmaWVsZHM/XG5cdFx0XHQvLyAgT3IgY29weSBmaWVsZHMgZnJvbSB0aGUgc3BlYz9cblxuXHRcdFx0Ly8gSGF2ZSByZW1vdGUgc2VydmVyIGluZm9cblx0XHRcdC8vICBBbGxvdyBmb3IgaW5mbyBvbiBhIG51bWJlciBvZiBkaWZmZXJlbnQgcmVtb3RlIHNlcnZlcnMuXG5cdFx0XHQvLyAgICgwIHdpbGwgYmUgdGhlIG9uZSBpdCBnb3Qgc2VydmVkIGZyb20gb3IgdGhlIGVxdWl2YWxlbnQganNndWkgc2VydmljZSBwcm92aWRlcilcblx0XHRcdC8vIEhhdmUgbG9jYWwgYnJvd3NlciBpbmZvXG5cdFx0XHQvLyBPdGhlciBsb2NhbCBpbmZvIGFzIG5lY2Vzc2FyeVxuXG5cblxuXHRcdFx0Lypcblx0XHRcdHZhciBsc2kgPSBuZXcgTG9jYWxfU2VydmVyX0luZm8oe1xuXHRcdFx0XHQnbWV0YSc6IHtcblx0XHRcdFx0XHQnbmFtZSc6ICdMb2NhbCBTZXJ2ZXIgSW5mbydcblx0XHRcdFx0fSxcblx0XHRcdFx0J3N0YXJ0dXBfdHlwZSc6ICdhdXRvJyxcblx0XHRcdFx0J2FjY2Vzcyc6IHtcblx0XHRcdFx0XHQnZnVsbCc6IFsnc2VydmVyX2FkbWluJ11cblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0XHRcblx0XHRcdHRoaXMuYWRkKGxzaSk7XG5cdFx0XHQqL1xuXG5cdFx0XHQvLyBBbmQgYSByZXNvdXJjZSBwdWJsaXNoZXIgcmVzb3VyY2UuXG5cdFx0XHQvLyAgSXQgZ29lcyBpbiB0aGUgcG9vbCwgYW5kIGl0IHB1Ymxpc2hlcyBvdGhlciByZXNvdXJjZXMgKG92ZXIgSFRUUClcblx0XHRcdC8vICAgVGhlIHJlc291cmNlIHBvb2wgY29udGFpbnMgaXRzIG93biBwdWJsaXNoZXIuXG5cblx0XHRcdC8qXG5cdFx0XHR2YXIgcHVibGlzaGVyID0gbmV3IFJlc291cmNlX1B1Ymxpc2hlcl9IVFRQKHtcblx0XHRcdFx0J21ldGEnOiB7XG5cdFx0XHRcdFx0J25hbWUnOiAnSFRUUCBSZXNvdXJjZSBQdWJsaXNoZXInXG5cdFx0XHRcdH0sXG5cdFx0XHRcdCdzdGFydHVwX3R5cGUnOiAnYXV0bycsXG5cdFx0XHRcdCdhY2Nlc3MnOiB7XG5cdFx0XHRcdFx0J2Z1bGwnOiBbJ3NlcnZlcl9hZG1pbiddXG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdFx0XG5cdFx0XHR0aGlzLmFkZChwdWJsaXNoZXIpO1xuXG5cdFx0XHQqL1xuXHRcdFx0XG5cdFx0XHRcblx0XHR9LFxuXHRcdCdzdGFydCc6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG5cblx0XHRcdC8vIGRvd25sb2FkIHRoZSByZXNvdXJjZSBpbmZvcm1hdGlvbiBmcm9tIHRoZSBzZXJ2ZXIuLi5cblx0XHRcdC8vICBodHRwIHJlcXVlc3QuXG5cblx0XHRcdC8vIFRoaW5rIHRoYXQgd2lsbCBiZSBpbiBqc2d1aS1jbGllbnQuXG5cdFx0XHQvLyAgSXQncyB3b3J0aCBtYWtpbmcgdGhlIGpzZ3VpLWNsaWVudCBidW5kbGVcblxuXHRcdFx0Ly8gTWF5YmUgc29tZSBvdGhlciBqc2d1aSBjbGllbnQgYnVuZGxlcywgbGlrZSBqc2d1aS1jbGllbnQtcGxhdGZvcm1cblx0XHRcdC8vICBpbmNsdWRpbmcgYWxsIHBsYXRmb3JtIGNsaWVudCBjb21wb25lbnRzLiBUaGVuIHRoZXJlIGNvdWxkIGJlIHNvbWUgb3RoZXIgYnVpbGRzIHRoYXQgaW5jbHVkZSBtb3JlIHRoaWducyBzdGlsbCxcblx0XHRcdC8vICBsaWtlIGJ1bmNoZXMgb2YgY29udHJvbHMgLyBjb21wb25lbnRzIGZvciBkaWZmZXJlbnQgY3VzdG9tZXJzIC8gd2Vic2l0ZXMuXG5cblx0XHRcdC8vY29uc29sZS5sb2coJ0NsaWVudF9SZXNvdXJjZV9Qb29sIHN0YXJ0LCB3aW5kb3cubG9jYXRpb24gJyArIHdpbmRvdy5sb2NhdGlvbik7XG5cblx0XHRcdC8vIG5lZWQgdG8gZ2V0IHRoZSByZXNvdXJjZXMgdXJsLi4uXG5cblxuXHRcdFx0dmFyIF9yZXF1ZXN0X3Jlc291cmNlcyA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgbG9jID0gd2luZG93LmxvY2F0aW9uLnRvU3RyaW5nKCk7XG5cdFx0XHRcdHZhciBwb3MxID0gbG9jLmluZGV4T2YoJy8vJyk7XG5cdFx0XHRcdHZhciBwb3MyID0gbG9jLmluZGV4T2YoJy8nLCBwb3MxICsgMik7XG5cdFx0XHRcdHZhciBwYXJ0MSA9IGxvYy5zdWJzdHIoMCwgcG9zMiArIDEpO1xuXHRcdFx0XHQvL2NvbnNvbGUubG9nKCdwYXJ0MSAnICsgcGFydDEpO1xuXG5cdFx0XHRcdHZhciB0aGF0ID0gdGhpcztcblxuXHRcdFx0XHQvLyBjYXJyeSBvdXQgdGhlIEhUVFAgcmVxdWVzdC5cblx0XHRcdFx0Ly8gIFVzZSB0aGUgcmVzdWx0IHRvIGluaXRpYWxpemUgdGhlIHZhcmlvdXMgcmVzb3VyY2Ugb2JqZWN0cyBpbiBhIGNvbGxlY3Rpb24uLi5cblx0XHRcdFx0Ly8gIG9yIHVzaW5nIHRoZSBwb29sIHJlYWxseS5cblxuXHRcdFx0XHQvLyBQZXJoYXBzIHRoZSBjbGllbnQgcG9vbCB3aWxsIGhhdmUgYmVlbiB0b2xkIHdoYXQgcmVzb3VyY2VzIGFyZSB0aGVyZS5cblx0XHRcdFx0Ly8gIEFsc28sIHRoZSBjbGllbnQgcG9vbCBjb3VsZCBiZSB1c2VkIHRvIGFjY2VzcyBhIHNpbmdsZSByZXNvdXJjZSBvbiB0aGUgc2VydmVyLCBhbmQgaGF2ZSBhIGJ1bmNoIG9mIHJlc291cmNlcyBhdmFpbGFibGUgb24gdGhlIGNsaWVudC5cblx0XHRcdFx0Ly8gIFRoZXNlIHJlc291cmNlcyB3aWxsIGJlIGEgYml0IGxpa2UgZ2xvYmFsIHZhcmlhYmxlcyB3aXRoIGFuIGFzeW5jcm9ub3VzIGludGVyZmFjZS5cblxuXHRcdFx0XHQvLyBOb3Qgc3VyZSBhYm91dCBhc3N1bWluZyB0aGUgc2VydmVyIHdpbGwgcHJvdmlkZSB0aGUgcmVzb3VyY2VzIGxpc3QgYSAvcmVzb3VyY2VzXG5cblx0XHRcdFx0Ly8gV2UgZG9uJ3Qgd2FudCB0aGF0IGRlZmF1bHQsIGl0IG1ha2VzIGFuIGV4dHJhIHJlcXVpcmVtZW50IGZvciB0aGUgc2VydmVyIHRvIGZ1bGZpbGwuXG5cblx0XHRcdFx0XG5cdFx0XHRcdHRoaXMuc2V0KCd1cmwnLCB1cmxSZXNvdXJjZXMpO1xuXG5cdFx0XHRcdHZhciB1cmxSZXNvdXJjZXMgPSBwYXJ0MSArICdyZXNvdXJjZXMnO1xuXHRcdFx0XHRjb25zb2xlLmxvZygndXJsUmVzb3VyY2VzJywgdXJsUmVzb3VyY2VzKTtcblxuXHRcdFx0XHQvLyBBbiBodHRwIGFic3RyYWN0aW9uIG1heSBiZSBnb29kIGZvciBvbGRlciBicm93c2Vycywgb3IgcG9seWZpbGwgZWxzZXdoZXJlLlxuXHRcdFx0XHR2YXIgb1JlcSA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXHRcdFx0XHRvUmVxLm9ubG9hZCA9IGZ1bmN0aW9uKHJlcykge1xuXHRcdFx0XHRcdGNvbnNvbGUubG9nKCdvUmVxLnJlc3BvbnNlVGV4dCAnICsgb1JlcS5yZXNwb25zZVRleHQpO1xuXG5cdFx0XHRcdFx0dmFyIG9ialJlc3BvbnNlID0gSlNPTi5wYXJzZShvUmVxLnJlc3BvbnNlVGV4dCk7XG5cblx0XHRcdFx0XHQvLyBUaGVuIGZvciBlYWNoIG9mIHRoZW0gd2UgY3JlYXRlIGFuIG9iamVjdC5cblxuXHRcdFx0XHRcdGlmICh0b2Yob2JqUmVzcG9uc2UpID09ICdhcnJheScpIHtcblx0XHRcdFx0XHRcdGVhY2gob2JqUmVzcG9uc2UsIGZ1bmN0aW9uKGksIHYpIHtcblx0XHRcdFx0XHRcdFx0dmFyIHR2ID0gdG9mKHYpO1xuXG5cdFx0XHRcdFx0XHRcdGlmICh0diA9PSAnc3RyaW5nJykge1xuXHRcdFx0XHRcdFx0XHRcdC8vIGl0J3MgdGhlIG5hbWUgb2YgdGhlIFJlc291cmNlLlxuXG5cdFx0XHRcdFx0XHRcdFx0dmFyIHJlc291cmNlID0gbmV3IFJlc291cmNlKHtcblx0XHRcdFx0XHRcdFx0XHRcdCdtZXRhJzoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHQnbmFtZSc6IHYsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCdwb29sJzogdGhhdCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0J3VybCc6IHVybFJlc291cmNlcyArICcvJyArIHZcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0XHR0aGF0LmFkZChyZXNvdXJjZSk7XG5cdFx0XHRcdFx0XHRcdFx0Ly9jb25zb2xlLmxvZygncmVzb3VyY2UnLCByZXNvdXJjZSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0aWYgKHR2ID09ICdvYmplY3QnKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly9jb25zb2xlLmxvZygndicsIHYpO1xuXHRcdFx0XHRcdFx0XHRcdHZhciByZXNvdXJjZSA9IG5ldyBSZXNvdXJjZSh7XG5cdFx0XHRcdFx0XHRcdFx0XHQnbWV0YSc6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0J25hbWUnOiB2Lm5hbWUsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCdwb29sJzogdGhhdCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0J3VybCc6IHVybFJlc291cmNlcyArICcvJyArIHYubmFtZSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0J3R5cGVfbGV2ZWxzJzogdi50eXBlX2xldmVsc1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHRcdHRoYXQuYWRkKHJlc291cmNlKTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9O1xuXHRcdFx0XHRvUmVxLm9wZW4oXCJnZXRcIiwgdXJsUmVzb3VyY2VzLCB0cnVlKTtcblx0XHRcdFx0b1JlcS5zZW5kKCk7XG5cdFx0XHR9XG5cblx0XHRcdGNhbGxiYWNrKG51bGwsIHRydWUpO1xuXG5cblx0XHRcdFxuXG5cblxuXHRcdFx0LyogRnJvbSByZXNvdXJjZV9wb29sIGluaXQuXG5cblxuXG5cdFx0XHR0aGlzLl9yZXNvdXJjZXMgPSBuZXcgQ29sbGVjdGlvbih7XG5cdFx0XHRcdCdpbmRleCc6IHtcblx0XHRcdFx0XHQvLydzb3J0ZWQnOiBbWyduYW1lJ11dIC8vIHNpbWlsYXIgdG8gYWJvdmUsIGJ1dCBsaXRlcmFsbHkgaXQncyBhIHNpbmdsZSBpbmRleCBpbiBhIGxpc3Qgb2YgaW5kZXhlcywgdGhhdCBpbmRleCBqdXN0IGhhcyBvbmUgZmllbGQsIGluIGEgbGlzdCBvZiBmaWVsZHNcblx0XHRcdFx0XHRcblx0XHRcdFx0XHQvLyBUaGUgc3ludGF4IGZvciBzcGVjaWZ5aW5nIGEgKHNvcnRlZCkgaW5kZXggaXMgZm9yIGFuIGF0dGFjaGVkIGZpZWxkLlxuXHRcdFx0XHRcdC8vICBJdCBnZXRzIHRoZSBkYXRhIGZvciB0aGUgYXR0YWNoZWQgb2JqZWN0LlxuXHRcdFx0XHRcdC8vIHsnYXR0YWNoZWQnOiB7J21ldGEnOiAnbmFtZSd9fVxuXHRcdFx0XHRcdCdzb3J0ZWQnOiBbW3snYXR0YWNoZWQnOiB7J21ldGEnOiAnbmFtZSd9fV1dXG5cdFx0XHRcdFx0Ly9zb3J0ZWQ6IFtbWydhdHRhY2hlZCcsICdtZXRhJywgJ25hbWUnXV1dXG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHQqL1xuXG5cblxuXG5cblx0XHRcdC8vIGh0dHA6Ly8xOTIuMTY4LjEuMTQ6NTAwOS9yZXNvdXJjZXNcblx0XHRcdC8vICBub3Qgc28gc3VyZSBpdCBuZWVkcyB0byBtYWtlIGFuIEhUVFAgcmVxdWVzdC5cblx0XHRcdC8vICBQZXJoYXBzIGl0IGNhbiBmaW5kIG91dCBhYm91dCB0aGUgcmVzb3VyY2UgdHlwZXM/XG5cblx0XHRcdC8vIFRob3VnaCwgdGhlIHJlc291cmNlIHBvb2wgaGF2aW5nIHRoZSBiYXNpYyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgcmVzb3VyY2VzIG1ha2VzIGEgbG90IG9mIHNlbnNlLlxuXHRcdFx0Ly8gUGVyaGFwcyBoYXZlIHNvbWUgbW9yZSBpbmZvcm1hdGlvbiBhYm91dCB0aGUgcmVzb3VyY2UsIG1ldGFkYXRhIGFib3V0IHdoYXQgdGhleSBkbz9cblx0XHRcdC8vICBUaGVpciBBUEkgdmVyc2lvbnM/XG5cblx0XHRcdC8vIFNvbWUgcmVzb3VyY2UgdHlwZSBpbmZvIHdvdWxkIGhlbHAuXG5cdFx0XHQvLyAgVGhlcmUgY291bGQgYmUgcHVibGlzaGVkIEFQSXMgb24gaG93IHRvIGFjY2VzcyBwYXJ0aWN1bGFyIHJlc291cmNlcywgbWF5YmUgY2FsbCB0aGVtIGludGVyZmFjZXMuXG5cblx0XHRcdC8vIFtcIkxvY2FsIFNlcnZlciBJbmZvXCIsXCJIVFRQIFJlc291cmNlIFB1Ymxpc2hlclwiLFwiTG9naW4gSFRNTCBSZXNvdXJjZVwiLFwiQXBwbGljYXRpb24gUm91dGVyXCIsXCJMb2NhbCBGaWxlIFN5c3RlbVwiLFwiV2ViIEFkbWluXCIsXCJJbmZvXCIsXCJTaXRlIEphdmFTY3JpcHRcIixcIlNpdGUgQ1NTXCIsXCJTaXRlIEltYWdlc1wiLFwiQXV0aGVudGljYXRpb25cIixcIm1ldGFiZW5jaFwiXVxuXG5cdFx0XHQvLyBMb2NhbCBTZXJ2ZXIgSW5mb1xuXHRcdFx0Ly8gIFNlZSBhIGJpdCBvZiBpbmZvIGFib3V0IHRoZSBsb2NhbCBzZXJ2ZXJcblx0XHRcdC8vIEhUVFAgUmVzb3VyY2UgUHVibGlzaGVyXG5cdFx0XHQvLyAgRGV0ZXJtaW5lIGhvdyBIVFRQIHJlc291cmNlcyBnZXQgcHVibGlzaGVkPyBXaWxsIHNlZSB3aGF0IHdvdWxkIGJlIGdvb2QgdG8gYWRtaW5pc3RlciBoZXJlLCBidXRcblx0XHRcdC8vICB3ZSB3YW50IG1hbnkgb2YgdGhlIHNldHRpbmdzIHRvIGJlIG9wZW4uXG5cdFx0XHQvLyBXZWIgQWRtaW5cblx0XHRcdC8vICBXb3VsZCBiZSBhIGdvb2QgcmVzb3VyY2UgdG8gaW50ZXJhY3Qgd2l0aC4gVGhyb3VnaCByZXNvdXJjZSBtZWNoYW5pc21zIHdlIHdpbGwgYmUgYWJsZSB0byBhbHRlciB0aGVcblx0XHRcdC8vICBjb250ZW50IG9mIHRoZSB3ZWJzaXRlLlxuXHRcdFx0Ly8gTG9jYWwgRmlsZSBTeXN0ZW1cblx0XHRcdC8vICBIYXZpbmcgYWNjZXNzIHRvIHRoZSBzZXJ2ZXIgZmlsZSBzeXN0ZW0uXG5cdFx0XHQvLyAgIENvdWxkIG1vZGlmeSB0aGUgc2l0ZSBmaWxlcyBhcyB0aGV5IGFyZSBydW5uaW5nLlxuXHRcdFx0Ly8gSW5mb1xuXHRcdFx0Ly8gIFRoaXMgaXMgYSBwYXJ0aWN1bGFyIGRhdGFiYXNlIHRhYmxlIEkgdGhpbmsuXG5cdFx0XHQvLyBtZXRhYmVuY2hcblx0XHRcdC8vICBUaGlzIGlzIGEgZGF0YWJhc2UuXG5cblx0XHRcdC8vIElkZW50aWZ5aW5nIHRoZSB0eXBlcyBvZiByZXNvdXJjZXMgd2hlbiAvcmVzb3VyY2VzIGlzIGNhbGxlZCB3b3VsZCBiZSB1c2VmdWwuIEEgYml0IG1vcmUgbWV0YWRhdGEgdG9vXG5cdFx0XHQvLyAgaWYgYXBwcm9wcmlhdGUuXG5cblxuXG5cblxuXHRcdH1cblx0XHRcblx0fSlcbm1vZHVsZS5leHBvcnRzID0gQ2xpZW50X1Jlc291cmNlX1Bvb2w7XG5cdFxuXHRcblx0Ly9yZXR1cm4gQ2xpZW50X1Jlc291cmNlX1Bvb2w7XG5cdFxuXHRcbi8vfSk7IiwiLy8gQnV0IGlzIHRoaXMgcGFydCBvZiB0aGUgaHRtbCBjbGllbnQsIG9yIGl0IHVzZXMgdGhlIGh0bWwgY2xpZW50LlxuXG4vLyBUaGUgY2xpZW50IGhhcyBwYWdlIGNvbnRleHQuXG4vLyAgUGFnZSBjb250ZXh0IGhhcyB0aGUgcmVzb3VyY2UgcG9vbC5cblxuLy8gU28sIGNsaWVudC1yZXNvdXJjZSB3aWxsIG5lZWQgaHRtbC1lbmggSSB0aGluaywgYnV0IG5vdCB0aGUgY2xpZW50IHN5c3RlbS5cblxuXG4vKlxuZGVmaW5lKFsnLi4vLi4vd2ViL2pzZ3VpLWh0bWwtZW5oJywgJy4vcmVzb3VyY2UnXSxcblx0ZnVuY3Rpb24oanNndWksIFJlc291cmNlKSB7XG4qL1xudmFyIGpzZ3VpID0gcmVxdWlyZSgnLi4vLi4vd2ViL2pzZ3VpLWh0bWwtZW5oJyk7XG52YXIgUmVzb3VyY2UgPSByZXF1aXJlKCcuL3Jlc291cmNlJyk7XG5cbnZhciBzdHJpbmdpZnkgPSBqc2d1aS5zdHJpbmdpZnksIGVhY2ggPSBqc2d1aS5lYWNoLCBhcnJheWlmeSA9IGpzZ3VpLmFycmF5aWZ5LCB0b2YgPSBqc2d1aS50b2Y7XG52YXIgZmlsdGVyX21hcF9ieV9yZWdleCA9IGpzZ3VpLmZpbHRlcl9tYXBfYnlfcmVnZXg7XG52YXIgQ2xhc3MgPSBqc2d1aS5DbGFzcywgRGF0YV9PYmplY3QgPSBqc2d1aS5EYXRhX09iamVjdCwgRW5oYW5jZWRfRGF0YV9PYmplY3QgPSBqc2d1aS5FbmhhbmNlZF9EYXRhX09iamVjdDtcbnZhciBmcCA9IGpzZ3VpLmZwLCBpc19kZWZpbmVkID0ganNndWkuaXNfZGVmaW5lZDtcbnZhciBDb2xsZWN0aW9uID0ganNndWkuQ29sbGVjdGlvbjtcblxuLy8gRXh0ZW5kcyBBdXRvU3RhcnRfUmVzb3VyY2U/XG5cbi8vIE1heSBuZWVkIHRvIGNoYW5nZSBhcm91bmQgYSBmYWlyIGZldyByZWZlcmVuY2VzIHRvIG1ha2UgaXQgd29ya2FibGUuXG4vLyBNYXkgbmVlZCBzb21lIG1vcmUgY29tcGxpY2F0ZWQgbG9naWMgdG8gY2hhbmdlIGl0IHRvIHRoZSBwYXRoIGZvciBzZXJ2aWNlLlxuXG4vLyBUaGVyZSBjYW4gYmUgYSBjbGllbnQgYXBwIHRoYXQncyBzcGVjaWZpY2FsbHkgZm9yIGEgcmVzb3VyY2UuXG4vLyAgVGhhdCdzIGEgc3BlY2lhbCBjYXNlLlxuLy8gT3RoZXIgY2xpZW50IHNpZGUgYXBwcyB3aWxsIGFjY2VzcyBtdWx0aXBsZSByZXNvdXJjZXMuXG4vLyAgVGhleSBjYW4gZG8gdGhpcyB0aHJvdWdoIGEgUmVzb3VyY2VfUG9vbC5cbi8vICBUaGVyZSBjb3VsZCBiZSBjbGllbnQtc2lkZSByZXNvdXJjZXMgdGhhdCBtYWtlIHVzZSBvZiBpbmZvcm1hdGlvbiBzaGFyaW5nIGJldHdlZW4gdGhlc2UgY2xpZW50IGFuZCBzZXJ2ZXIgc2lkZSByZXNvdXJjZXMuXG5cblxuXG5cbi8vIFRoaXMgY2xpZW50IHJlc291cmNlIGNvdWxkIHJlZmVyZW5jZSBhIHJlbW90ZSByZXNvdXJjZS5cblxuLy8gV2lsbCBoYXZlIGNsaWVudC1yZW1vdGUtcmVmZXJlbmNlIHJlc291cmNlXG4vLyAgbWF5YmUganVzdCBjbGllbnQtcmVtb3RlXG4vLyAgd2lsbCB3b3JrIGluIGEgc2ltaWxhciB3YXkgdG8gcmVtb3RlIG9yIG5vZGUtcmVtb3RlIGluIHRlcm1zIG9mIEFQSSwgYnV0IGludGVybmFsbHkgaXQgd2lsbCBkbyBIVFRQIGNhbGxzIGRpZmZlcmVudGx5LlxuLy8gIFBvc3NpYmx5IGNvdWxkIGp1c3QgdXNlIGpzZ3VpIHRob3VnaCwgaGF2ZSBpdCBleHBvc2UgdGhlIHNhbWUgQVBJIGZvciBub2RlIGFuZCB0aGUgY2xpZW50LlxuXG4vLyBUaGlzIG9uZSBpcyBzdGlsbCBmYWlybHkgYWJzdHJhY3QuXG4vLyAgSXQgd2lsbCBiZSB0aGUgY2xpZW50LXJlbW90ZS1saW5rIHJlc291cmNlIHdoaWNoIHdpbGwgaGF2ZSB0aGUgZnVuY3Rpb25hbGl0eS5cbi8vICBjbGllbnQtcmVtb3RlLWxpbmsgd2lsbCBjb25uZWN0IHdpdGggd2Vic29ja2V0cyB0byBnZXQgZXZlbnRzXG4vLyAgaXQgd2lsbCBkbyBnZXQgd2l0aCBodHRwLlxuXG5cbi8vIEEgcmVzb3VyY2UgY29udHJvbCB3aWxsIHJlY2lldmUgZXZlbnRzIGZyb20gdGhlIGNsaWVudCByZXNvdXJjZS5cbi8vICBJdCBtYXkgYWxzbyBlbnN1cmUgaXQgaGFzIGJlZW4gc2V0IHVwLlxuXG4vLyBBbHNvIGEgUmVzb3VyY2VfQ2xpZW50IGZpbGUgdGhhdCBzZXRzIHVwIGEgcmVzb3VyY2UgY29ubmVjdGlvbiB3aXRoIGEgcGFydGljdWxhciByZXNvdXJjZT9cbi8vICBNYXliZSBkb24ndCBzZXQgdXAgc3VjaCBhYnN0cmFjdCByZXNvdXJjZSBsaW5raW5nIGZvciB0aGUgbW9tZW50P1xuXG4vLyBXaXRoIHRoZSBSZXNvdXJjZS1DbGllbnQgYXJjaGl0dXJlLCB3ZSBjb3VsZCBkZWZpbmUgdGhlIGJhY2stZW5kIGluIHRlcm1zIG9mIGEgUmVzb3VyY2UsIGFuZCBub3QgbmVlZCB0byB3cml0ZSB2YXJpb3VzIHBpZWNlcyBvZiBib2lsZXJwbGF0ZSBmb3IgdGhlbVxuLy8gIHRvIGNvbW11bmljYXRlIHdpdGggZWFjaCBvdGhlci5cblxuXG4vLyBSZXNvdXJjZV9DbGllbnQgbWF5IGJlIGEgbmVjZXNzYXJ5IEpTIGZpbGUuXG4vLyAgV291bGQgYmUgSmF2YVNjcmlwdCB0aGF0IHJ1bnMgb24gYSBwYWdlIHRoYXQncyBmb3Igd2hlbiBpdCdzIHRoZSBjbGllbnQgZm9yIGEgc2luZ2xlIHJlc291cmNlP1xuXG4vLyBXaXRoIHRoZSBjbG9jayByZXNvdXJjZSwgd291bGQgd2FudCBpdCB0byBoYXZlIGEgcmVzb3VyY2UgY29udHJvbC5cbi8vICBUaGF0IGNvbnRyb2wgY291bGQgcG9zc2libHkgc3BlYWsgdG8gdGhlIHJlc291cmNlIGRpcmVjdGx5LlxuLy8gIEl0IGNvdWxkIHBvc3NpYmx5IHNwZWFrIHRvIGEgY2xpZW50LXNpZGUgcmVzb3VyY2UgLyBhZ2dyZWdhdG9yIHRoYXQgdGhlbiBzcGVha3MgdG8gdGhlIHNlcnZlciByZXNvdXJjZS5cblxuLy8gU2VydmluZyBhIHBhZ2Ugd2l0aCBhIGNvbXBvbmVudCB0aGF0IGNvbm5lY3RzIGJhY2sgdG8gdGhlIHJlc291cmNlLi4uXG4vLyAgSSB0aGluayBhIGxvdCBvZiB0aGUgYWN0aXZpdHkgd2lsbCBiZSBpbiB0aGUgdXNlciBjb250cm9sLFxuLy8gIGhvd2V2ZXIsIGl0IG1heSBiZSB0aGF0IHRoZSB1c2VyIGNvbnRyb2wgd2lsbCBqdXN0IGJlIG1ha2luZyB1c2Ugb2YgdGhlIGNsaWVudC1zaWRlIHJlc291cmNlcyBvciBjbGllbnQtc2lkZSByZXNvdXJjZSBwb29sLlxuXG5cbnZhciBlbmRzX3dpdGggPSBmdW5jdGlvbihzdHIsIHN1ZmZpeCkge1xuICAgIHJldHVybiBzdHIuaW5kZXhPZihzdWZmaXgsIHN0ci5sZW5ndGggLSBzdWZmaXgubGVuZ3RoKSAhPT0gLTE7XG59XG5cbnZhciBDbGllbnRfUmVzb3VyY2UgPSBSZXNvdXJjZS5leHRlbmQoe1xuICAgIC8vJ2ZpZWxkcyc6IHtcbiAgICAvL1x0J3VybCc6IFN0cmluZ1xuICAgIC8vfSxcblxuICAgICdpbml0JzogZnVuY3Rpb24oc3BlYykge1xuICAgICAgICB0aGlzLl9zdXBlcihzcGVjKTtcblxuICAgICAgICBpZiAoc3BlYy5tZXRhKSB7XG4gICAgICAgICAgICB2YXIgbWV0YSA9IHNwZWMubWV0YTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCcxKSBtZXRhLnVybCcsIG1ldGEudXJsKTtcbiAgICAgICAgICAgIGlmIChtZXRhLnVybCkgdGhpcy5tZXRhLnNldCgndXJsJywgbWV0YS51cmwpO1xuICAgICAgICAgICAgaWYgKG1ldGEudHlwZV9sZXZlbHMpIHRoaXMubWV0YS5zZXQoJ3R5cGVfbGV2ZWxzJywgbWV0YS50eXBlX2xldmVscyk7XG5cblxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnbWV0YS5uYW1lICcgKyBtZXRhLm5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5kYXRhID0gbmV3IERhdGFfT2JqZWN0KCk7XG5cbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG5cbiAgICAgICAgLy8gYm90aCBpbiBvbmUgcGFyYW1ldGVyIGhlcmU/XG5cblxuICAgICAgICAvLyBXaHkgbm90IGxpc3RlbiB0byB0aGUgcmVzb3VyY2UncyBkYXRhIGRpcmVjdGx5P1xuICAgICAgICAvLyAgU2hvdWxkIG5vdCBiZSBhIHByb2JsZW0gd2hlbiBkb2luZyBpdCBvbiB0aGUgY2xpZW50P1xuXG5cbiAgICAgICAgdGhpcy5kYXRhLm9uKCdjaGFuZ2UnLCBmdW5jdGlvbihwcm9wZXJ0eV9uYW1lLCBwcm9wZXJ0eV92YWx1ZSkge1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnJyk7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdyZXNvdXJjZSBkYXRhIGNoYW5nZSBwcm9wZXJ0eV9uYW1lJywgcHJvcGVydHlfbmFtZSk7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdwcm9wZXJ0eV92YWx1ZScsIHByb3BlcnR5X3ZhbHVlKTtcblxuICAgICAgICAgICAgdGhhdC50cmlnZ2VyKCdjaGFuZ2UnLCBwcm9wZXJ0eV9uYW1lLCBwcm9wZXJ0eV92YWx1ZSk7XG5cbiAgICAgICAgfSlcblxuXG4gICAgICAgIC8vdGhpcy5tZXRhLnNldCgnY3VzdG9tX3BhdGhzJywgbmV3IERhdGFfT2JqZWN0KHt9KSk7XG4gICAgICAgIC8vIFRob3NlIGFyZSBjdXN0b20gZmlsZSBwYXRocy5cblxuICAgICAgICAvLyBjb3VsZCBoYXZlIGEgY29sbGVjdGlvbiBvZiBkaXJlY3RvcmllcywgaW5kZXhlZCBieSBuYW1lLCB0aGF0IGdldCBzZXJ2ZWQuXG5cbiAgICAgICAgLy8gSW5kZXggdGhlIGNvbGxlY3Rpb24gYnkgc3RyaW5nIHZhbHVlP1xuICAgICAgICAvL3RoaXMubWV0YS5zZXQoJ3NlcnZlZF9kaXJlY3RvcmllcycsIG5ldyBDb2xsZWN0aW9uKHsnaW5kZXhfYnknOiAnbmFtZSd9KSk7XG5cbiAgICAgICAgLy8gV2lsbCBhbHNvIGhhdmUgYSBVUkwuXG4gICAgICAgIC8vICBUaGUgY2xpZW50IHJlc291cmNlIHBvb2wgd2lsbCBoYXZlIGEgYmFzZSB1cmwuXG4gICAgICAgIC8vICAgTWF5YmUgZGVmYXVsdCBiYXNlIFVSTCwgaXQncyBzZXQgdXAgdG8gY29tbXVuaWNhdGUgd2l0aCB0aGUgc2VydmVyIHRoYXQgc2VydmVkIHRoZSBIVE1MIGRvY3VtZW50LlxuXG4gICAgICAgIC8vIGNvdWxkIGhhdmUgYSB2YXJpZXR5IG9mIHNlcnZlciBVUkxzLCBidXQgbGV0J3MgZGVhbCB3aXRoIG9uZSBmb3IgdGhlIG1vbWVudC5cblxuXG4gICAgfSxcbiAgICAnZ2V0JzogZnAoZnVuY3Rpb24oYSwgc2lnKSB7XG4gICAgICAgIHZhciB1cmwsIGNhbGxiYWNrO1xuICAgICAgICB2YXIgdXJsX3BhdGg7XG4gICAgICAgIGlmIChhLmwgPT09IDEpIHtcbiAgICAgICAgICAgIHVybCA9IHRoaXMubWV0YS5nZXQoJ3VybCcpLnZhbHVlKCk7XG4gICAgICAgICAgICBjYWxsYmFjayA9IGFbMF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGEubCA9PT0gMikge1xuICAgICAgICAgICAgdXJsX3BhdGggPSBhWzBdO1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBhWzFdO1xuXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCd1cmxfcGF0aCcsIHVybF9wYXRoKTtcblxuICAgICAgICAgICAgdXJsID0gdGhpcy5tZXRhLmdldCgndXJsJykudmFsdWUoKSArIHVybF9wYXRoO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2hvdWxkIGJlIGFibGUgdG8gc3VwcGx5IHRoZSB1cmxcblxuICAgICAgICAvL3ZhclxuXG4gICAgICAgIC8vIGpzZ3VpIGxhbmcgZXNzZW50aWFscyBlbmRzIGZ1bmN0aW9uXG4gICAgICAgIC8vICB0ZXN0IGlmIGEgc3RyaW5nIGVuZHMgd2l0aCBzb21ldGhpbmcuXG5cbiAgICAgICAgdmFyIGVuZHNfZG90X2pzb24gPSBlbmRzX3dpdGgodXJsLCAnLmpzb24nKTtcbiAgICAgICAgLy9jb25zb2xlLmxvZygnZW5kc19kb3RfanNvbicsIGVuZHNfZG90X2pzb24pO1xuXG4gICAgICAgIHZhciBqc29uX3VybDtcblxuICAgICAgICBpZiAoIWVuZHNfZG90X2pzb24pIHtcbiAgICAgICAgICAgIGpzb25fdXJsID0gdXJsICsgJy5qc29uJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGpzb25fdXJsID0gdXJsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9jb25zb2xlLmxvZygnanNvbl91cmwnLCBqc29uX3VybCk7XG4gICAgICAgIGpzZ3VpLmh0dHAoanNvbl91cmwsIGZ1bmN0aW9uKGVyciwgcmVzKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygncmVzJywgcmVzKTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCByZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgIH0pLFxuXG4gICAgLy8gV2UgZG9uJ3Qgbm90aWZ5IGl0IHRoaXMgd2F5LlxuICAgIC8vICBUaGlua2luZyBvZiBtYWtpbmcgYSBzZXJwYXJhdGUgUmVzb3VyY2UgdGhhdCB1c2VzIHdlYnNvY2tldHMgb3Igc29ja2pzLiBTaG91bGQgY29udGludWUgdG8gaGF2ZSB0aGUgbm9ybWFsIG5vbi1zb2NrIGNsaWVudC1zaWRlIHJlc291cmNlIGFzIHdlbGwuXG4gICAgLy8vICBXaWxsIG5vdCBtYWtlIGl0cyBvd24gSFRUUCBjb25uZWN0aW9ucy5cblxuXG5cblxuICAgIC8vIE5vdCB0aGF0IGNsZWFyIGhvdyB0aGlzIHR5cGUgb2YgcmVzb3VyY2Ugd2lsbCByZWNlaXZlIHRoZXNlIGNoYW5nZSBub3RpZmljYXRpb25zLlxuICAgIC8vICBTZWVtcyBsZXNzIGxpa2VseSB0aGF0IHdlIHdpbGwgbmVlZCB0aGlzIGZ1bmN0aW9uIGhlcmUuXG4gICAgLy8gIDA2LzA2LzIwMTUgLSBhYm91dCB0byBtYWtlIHRoZSBzb2NrcyByZXNvdXJjZSBjb25uZWN0aW9uIGZvciB0aGUgY2xpZW50LCBpdCdzIGdvaW5nIHRvIGFsbG93IGZvciByZWFsLXRpbWUgdXBkYXRlcywgd2hpbGUgdXNpbmcgZ2VuZXJhbGx5IFJFU1RmdWwgYWRkcmVzc2luZy5cblxuICAgICdub3RpZnlfY2hhbmdlX2Zyb21fc2VydmVyJzogZnVuY3Rpb24ocHJvcGVydHlfbmFtZSwgcHJvcGVydHlfdmFsdWUpIHtcbiAgICAgICAgLy8gbmVlZHMgdG8gZG8gc29tZSBraW5kIG9mIHNpbGVudCBzZXQuXG5cbiAgICAgICAgLy9jb25zb2xlLmxvZygnY2xpZW50IHJlc291cmNlIG5vdGlmeV9jaGFuZ2VfZnJvbV9zZXJ2ZXInKTtcblxuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcblxuICAgICAgICAvL2NvbnNvbGUubG9nKCdkYXRhJywgdGhpcy5kYXRhKTtcblxuICAgICAgICAvLyBtYXkgbmVlZCB0byBkbyBhIHNldCB3aXRoIG9wdGlvbnMsIHN1Y2ggYXMge3NpbGVudDogdHJ1ZX07XG4gICAgICAgIC8vICBtYXkgbmVlZCB0byBkZWZpbmUgbWVzc2FnZSBwcm9wYWdhdGlvbiBpbiBtb3JlIGRldGFpbC5cbiAgICAgICAgLy8gV2lsbCBuZWVkIHRvIGhhdmUgaXQgd29ya2luZyBieSBkZWZhdWx0LCBidXQgdmFyaW91cyB0aGluZ3MgZXhwbGljaXRseSBzZXQgaW4gdGhlIG1lc3NhZ2VzIHRvIGRldGVybWluZSB3aGVyZSB0aGUgbWVzc2FnZSBnZXRzXG4gICAgICAgIC8vICBzZW50IHRvLCBhbmQgcHJlc2VudGVkIGluIHdoaWNoIHdheSwgaW5jbHVkaW5nIG1lc3NhZ2VzIGFja25vd2x3ZGdpbmcgdGhhdCBhIHByZXZpb3VzIG1lc3NhZ2UgaGFzIGJlZW4gcHJvY2Vzc2VkLlxuXG4gICAgICAgIC8vIERvbid0IHdhbnQgdGhpcyB0byBiZSB0b28gY29tcGxpY2F0ZWQuXG4gICAgICAgIC8vICBJIHRoaW5rIHdpdGhvdXQgbXVjaCBtb3JlIGNvZGUgd2Ugd2lsbCBoYXZlIHRoZSBmdW5jdGlvbmFsaXR5LlxuXG4gICAgICAgIC8vIENvdWxkIGRvIG1vcmUgZGV0YWlsIGluIHNvbWUgYXJlYXMgbGF0ZXIgb24uXG5cblxuXG5cbiAgICAgICAgdGhpcy5kYXRhLl9bcHJvcGVydHlfbmFtZV0gPSBwcm9wZXJ0eV92YWx1ZTtcblxuICAgICAgICAvLyBhbHNvIGRpZmZlcmVudCB3YXlzIG9mIHJhaXNpbmcgZXZlbnRzIG9yIG9wdGlvbnMgZm9yIHRoZSBldmVudHMgdGhhdCBhcmUgcmFpc2VkLlxuICAgICAgICAvLyAgTWF5IG5lZWQgdG8gaW5jbHVkZSBtb3JlIGNoYW5nZSBldmVudCBtZXRhZGF0YS5cbiAgICAgICAgLy8gICBTdWNoIGFzIHdoYXQgaW5pdGlhdGVkIHRoZSBldmVudC4gUGVyaGFwcyBhIHVzZXIuXG4gICAgICAgIC8vICAgIE1heWJlIGluZm8gb24gdGhlIGV2ZW50IHByb2Nlc3NpbmcgY2hhaW4uIFN1Y2ggYXMgdXNlcixkYXRhX29iamVjdFxuICAgICAgICAvLyAgICBvciByZW1vdGUsZGF0YV9vYmplY3RcblxuICAgICAgICAvLyBTbyB0aGUgc3lzdGVtIGNhbiB0ZWxsIHdoZXJlIHRoZSBjaGFuZ2UgY2FtZSBmcm9tLCBpdCBjYW4ga25vdyBob3cgdG8gcHJvcGFnYXRlIHRoZSBjaGFuZ2UgYW5kIGhvdyBhbmQgd2hldGhlciB0byBhY2tub3dsZWRnZSBpdC5cblxuICAgICAgICAvLyBJdCBtYXkgYmUgd29ydGggaGF2aW5nIG1lc3NhZ2UgSURzLlxuICAgICAgICAvLyAgQWxzbyBhZ2dyZWdhdGluZyBtZXNzYWdlcyB0aGF0IGdldCBzZW50IGZyb20gdGhlIHNlcnZlci5cbiAgICAgICAgLy8gIENvdWxkIGhhdmUgc3VibWVzc2FnZXMgd2l0aGluIGFuIG9yaWdpbmFsIG9uZS5cblxuICAgICAgICAvLyBXYW50IGEgc2ltcGxlIGVub3VnaCBjb3JlIHRvIHRoaXMuXG4gICAgICAgIC8vICBFYXN5IHRvIHVuZGVyc3RhbmQgYW5kIHBvd2VyZnVsLCBhbmQgdGhlbiBtb3JlIGNvbXBsZXhpdHkgY2FuIGJlIGJ1aWx0IG9uIHRvcCBvZiB0aGF0LlxuXG4gICAgICAgIC8vIEkgdGhpbmsgbW9yZSBwcm9wZXJ0aWVzIGluIGNoYW5nZSBldmVudHMgY291bGQgYmUgaGVscGZ1bC5cbiAgICAgICAgLy8gIFRoZSBjaGFuZ2UgZXZlbnRzIGNvdWxkIGJlIHVzZWQgaW4gcHJvY2Vzc2luZyB0aGUgZXZlbnRzIGluIHNvbWUgY2FzZXMsIGFuZCB3YW50IHRvIGF2aW91ZCBhbWJpZ3VpdHkgYW5kIGluZmluaXRlIGxvb3BzLlxuICAgICAgICAvLyBTZW5kaW5nIGEgZmV3IGV4dHJhIHN0cmluZyBjb2RlcyBzdWNoIGFzIGl0J3MgaW5pdGlhdG9yLCBwb3NzaWJseSBhIG1lc3NhZ2UgaWQgdGhhdCBpcyB0aGUgY2hhbmdlIG5vdGlmaWNhdGlvbiwgd2lsbCBoZWxwIHRoZSBhcHAgcHJvY2Vzc1xuICAgICAgICAvLyAgdGhlIGNoYW5nZXMgYXMgdGhleSB0YWtlIHBsYWNlIGluIGRpZmZlcmVudCBwbGFjZXMuXG5cbiAgICAgICAgLy8gUmVzb3VyY2UgY2hhbmdlcyBvbiB0aGUgc2VydmVyLiBNZXNzYWdlIHNlbnQgdG8gY2xpZW50cy4gQ2xpZW50cyBjaGFuZ2UgdGhlIGRhdGEgaW4gY29ycmVzcG9uZGluZyBjbGllbnQtc2lkZSByZXNvdXJjZS4gQ2xpZW50IGNvbXBvbmVudHNcbiAgICAgICAgLy8gIGxpc3RlbiBmb3IgY2hhbmdlcyB0byB0aGUgbG9jYWwgcmVzb3VyY2UgYW5kIHJlc3BvbmQgYWNjb3JkaW5nbHkuXG5cbiAgICAgICAgLy8gV2lsbCBiZSB1c2luZyBkaWZmZXJlbnQgdHlwZXMgb2YgY2hhbmdlIGJpbmRpbmcuXG4gICAgICAgIC8vICBUaGVyZSB3aWxsIGJlIHNvbWUgY29tcGxleGl0eSB0aGVyZS5cbiAgICAgICAgLy8gIEl0J3MgZ29pbmcgdG8gd29yayBlYXNpbHkgd2l0aCBkZWZhdWx0IGNvbmZpZ3VyYXRpb25zLlxuICAgICAgICAvLyAgIFdpbGwgYmUgdmVyeSBmYXN0IHRvIHNldCBzb21ldGhpbmcgdXAgYXMgYSByZXNvdXJjZSwgYW5kIHRoZSBkZWZhdWx0cyB3aWxsIG1ha2Ugc2Vuc2UuXG5cbiAgICAgICAgLy8gVGhlcmUgd2lsbCBiZSBhIGZldyBkaWZmZXJlbnQgaW5mb3JtYXRpb24gbGlmZWN5Y2xlcywgd2l0aCBjaGFuZ2VzIGluaXRpYXRpbmcgaW4gdmFyaW91cyBwbGFjZXMgYW5kIGJlaW5nIHByb3BhZ2F0ZWQgdG9cbiAgICAgICAgLy8gIHZhcmlvdXMgb3RoZXIgcGxhY2VzLlxuXG4gICAgICAgIC8vICBDb3VsZCBiZSBhIHBsYWNlIGZvciBzZWN1cml0eSB0byB2YWxpZGF0ZSB0aGF0IHdoYXRldmVyIGlzIG1ha2luZyB0aGUgY2hhbmdlIGhhcyBnb3QgdGhlIGF1dGhvcml0eSB0byBkbyBzby5cblxuICAgICAgICAvLyBUaGUgY2hhbmdlIGV2ZW50IGhhbmRsaW5nIGluIHRoZSBEYXRhX09iamVjdHMgcHJvYmFibHkgcmVxdWlyZSBtb3JlIHdvcmsgdG8gdGhlbS5cbiAgICAgICAgLy8gIE1ha2luZyBpdCBzbyB0aGF0IHdpdGggZGlmZmVyZW50IHR5cGVzIG9mIGNoYW5nZXMgdGhleSBub3RpZnkgZGlmZmVyZW50IHRoaW5ncyBhYm91dCBpdC5cblxuICAgICAgICAvLyBBIHJlc291cmNlIHB1Ymxpc2hlciBjb3VsZCBiZSBsaXN0ZW5pbmcgZm9yIGNoYW5nZXMgaW4gYSBkYXRhX29iamVjdCBvbiBhIHNlcnZlci5cbiAgICAgICAgLy8gIFRoZSBjaGFuZ2VzIG9yaWdpbmF0ZSBmcm9tIHRoZSBzZXJ2ZXIsIGFuZCBhcmUgdG8gYmUgdmlld2VkIGFzIHRoZSAnY29ycmVjdCcgdmVyc2lvbiBvZiB0aGUgaW5mb3JtYXRpb24uXG5cbiAgICAgICAgLy8gVGhlcmUgY291bGQgYmUgc29tZSByZWFkLW9ubHkgZGF0YSBzb3VyY2VzLCBsaWtlIGEgY2xvY2sgb24gdGhlIGludGVybmV0LlxuICAgICAgICAvLyAgT3Igc2V0dGluZyBpdHMgdGltZSB3b3VsZCBpbnZvbHZlIHNldHRpbmcgdGhlIGNvbXB1dGVyJ3Mgc3lzdGVtIHRpbWUuIFBvc3NpYmx5LCBidXQgc29tZXRoaW5nIHRoYXQgbWF5IG5lZWQgaGlnaGVyIHNlY3VyaXR5LlxuXG4gICAgICAgIC8vIFRoZSBzaW1wbGUgY2xvY2sgZXhhbXBsZSB3aWxsIGp1c3Qgc2VuZCBkYXRhIGZybyBtdGhlIHNlcnZlci4gVGhhdCBkYXRhIGlzIHJlYWQtb25seS5cbiAgICAgICAgLy8gIEl0IHdpbGwgYmUgZ29vZCB0byBtYWtlIGVub3VnaCBkZXRhaWwgYWJvdXQgdGhlIGRhdGEgaXMgc2VudC5cbiAgICAgICAgLy8gIFdpbGwgYmUgaW50ZXJlc3RpbmcgdG8gdXNlIHRoaXMgY2xvY2sgZXhhbXBsZSBmb3Igc29tZSBvdGhlciB0eXBlcyBvZiBkYXRhIHRyYW5zbWlzc2lvbiwgc3VjaCBhcyBwZWVyLXRvLXBlZXIsIHdpdGggdGhlIHBlZXJzIHJ1bm5pbmdcbiAgICAgICAgLy8gIG5vZGUuanMgYW5kIGJlaW5nIGNvb3JkaW5hdGVkIGJ5IGEgY2VudHJhbCBzZXJ2ZXIuIFRoZSBjZW50cmFsIHNlcnZlciB3b3VsZCBzZW5kIGl0cyB1cGRhdGVzIHRvIG9ubHkgc29tZSBvZiB0aGUgY2xpZW50cywgYW5kXG4gICAgICAgIC8vICB0aG9zZSBjbGllbnRzIHdvdWxkIHNlbmQgaXQgb24uIENvdWxkIG1heWJlIGhhdmUgYSBjZW50cmFsIHN5c3RlbSBkZWZpbmluZyB3aGVyZSB0aGUgY2xpZW50cyBhcmUsIGFuZCB3aGF0IGhvcHMgb2YgdGhlIGNoYWluIGl0IGlzLlxuICAgICAgICAvLyBDb3VsZCBhbHNvIGhhdmUgdGhlIGNlbnRyYWwgc3lzdGVtIG1haW50YWluIGtleXMuIFB1YmxpYyBrZXkgZW5jcnlwdGlvbi4gQ29tbXVuaWNhdGlvbiBiZXR3ZWVuIGNsaWVudHMgY291bGQgYmUgZW5jcnlwdGVkLiBUaGV5IGNvdWxkIGJlIGVuY3J5cHRlZFxuICAgICAgICAvLyAgc28gdGhhdCBvdGhlciBjbGllbnRzIHdvdWxkIG5vdCB1bmRlcnN0YW5kIHRoZW0sIGFuZCBzbyB0aGV5IG5lZWQgdG8gc3BlYWsgdG8gdGhlIGNsaWVudCB0aGV5IGFyZSBhc3NpZ25lZCBieSB0aGUgY2VudHJhbCBzZXJ2ZXIuXG5cblxuXG5cblxuXG4gICAgICAgIC8vIFdoZW4gYSBjbGllbnQtcmVzb3VyY2UgY2hhbmdlcywgaXQgbWF5IHNlbmQgaXQncyBpbmZvIHRvIHRoZSBzZXJ2ZXI/XG4gICAgICAgIC8vICBPciBvbmx5IHdoZW4gc2V0IGlzIGNhbGxlZD9cblxuXG4gICAgICAgIHRoaXMuZGF0YS50cmlnZ2VyKCdjaGFuZ2UnLCBwcm9wZXJ0eV9uYW1lLCBwcm9wZXJ0eV92YWx1ZSk7XG5cbiAgICAgICAgLy8gT3IgdGhlIHJlc291cmNlIGxpc3RlbnMgdG8gZGF0YSBjaGFuZ2VzLCB0cmlnZ2VycyBjaGFuZ2Ugb24gaXRzZWxmIHdoZW4gdGhlIGRhdGEgY2hhbmdlcy5cblxuICAgICAgICAvLyBPciBjaGFuZ2Ugb24gdGhlIHJlc291cmNlIGl0c2VsZiBJIHRoaW5rLlxuXG5cblxuXG5cblxuXG4gICAgfVxuICAgIC8vJ3N0YXJ0JzogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAvL1x0Y2FsbGJhY2sobnVsbCwgdHJ1ZSk7XG4gICAgLy99XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBDbGllbnRfUmVzb3VyY2U7IiwiLy8gTWF5YmUgaXQgaGFzIGRpZmZlcmVudCByZXF1aXJlbWVudHMgaW4gbm9kZS5cbi8vICBDb3VsZCBwb3NzaWJseSBsb2FkIHRoZXNlIG9uZXMgc2VwZXJhdGVseSBpZiBpdCdzIGEgbm9kZSBlbnZpcm9ubWVudC5cblxuLy8gVGhpcyBzZWVtcyBhIGxvdCB0byBkbyB3aXRoIHRoZSBzZXJ2ZXItc2lkZSByZXNvdXJjZSBwb29sLlxuLy8gIEhvd2V2ZXIsIGl0IG1heSBiZSB3b3J0aCBoYXZpbmcgYSBjbGllbnQtc2lkZSByZXNvdXJjZSBwb29sIG9wZXJhdGUgZmFpcmx5IHNpbWlsYXJseS5cblxuLy8gSGF2aW5nIHNvbWUgc3BlY2lmaWMgSlNPTiBhbmQgSFRNTCBpbnRlcmZhY2VzIHRvIHNvbWUgcmVzb3VyY2VzIHdvdWxkIGJlIG5pY2Vcbi8vICBhcyB3ZWxsIGFzIGhhdmluZyB0aGUgc3lzdGVtIGJlIGFibGUgdG8gZXhwbGFpbiBzdWNoIHJlc291cmNlcy5cbi8vICAgbWF5YmUgcmVzb3VyY2UvbWV0YVxuXG4vLyBUaGlzIGNvdWxkIHBvc3NpYmx5IGdldCBwdWJsaXNoZWQgYnkgYSByZXNvdXJjZSBwdWJsaXNoZXIuXG5cbi8qXG5pZiAodHlwZW9mIGRlZmluZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBkZWZpbmUgPSByZXF1aXJlKCdhbWRlZmluZScpKG1vZHVsZSk7XG59XG5cblxuZGVmaW5lKFsnLi4vLi4vd2ViL2pzZ3VpLWh0bWwnLCAnLi9yZXNvdXJjZSddLCBcblxuXHRmdW5jdGlvbihqc2d1aSwgUmVzb3VyY2UpIHtcbiovXG52YXIganNndWkgPSByZXF1aXJlKCcuLi8uLi93ZWIvanNndWktaHRtbCcpO1xudmFyIFJlc291cmNlID0gcmVxdWlyZSgnLi9yZXNvdXJjZScpO1xuXHRcblx0dmFyIHN0cmluZ2lmeSA9IGpzZ3VpLnN0cmluZ2lmeSwgZWFjaCA9IGpzZ3VpLmVhY2gsIGFycmF5aWZ5ID0ganNndWkuYXJyYXlpZnksIHRvZiA9IGpzZ3VpLnRvZjtcblx0dmFyIGZpbHRlcl9tYXBfYnlfcmVnZXggPSBqc2d1aS5maWx0ZXJfbWFwX2J5X3JlZ2V4O1xuXHR2YXIgQ2xhc3MgPSBqc2d1aS5DbGFzcywgRGF0YV9PYmplY3QgPSBqc2d1aS5EYXRhX09iamVjdCwgRW5oYW5jZWRfRGF0YV9PYmplY3QgPSBqc2d1aS5FbmhhbmNlZF9EYXRhX09iamVjdDtcblx0dmFyIGZwID0ganNndWkuZnAsIGlzX2RlZmluZWQgPSBqc2d1aS5pc19kZWZpbmVkO1xuXHR2YXIgQ29sbGVjdGlvbiA9IGpzZ3VpLkNvbGxlY3Rpb247XG5cblx0Ly8gU2hvdWxkIHdvcmsgdG8gZ2V0IHRoaXMgY2xvc2VyIHRvIHRoZSBkZXNpcmVkIGdldC9zZXQgcmVzb3VyY2UgaW50ZXJmYWNlLlxuXHQvLyAgVGhhdCB3b3VsZCBoZWxwIHdpdGggYWRtaW5pc3RlcmluZyBpdC5cblx0Ly8gIEFsc28gd291bGQgbWFrZSBzdWJyZXNvdXJjZXMgYXZhaWxhYmxlLCB0aGVzZSB3b3VsZCBoYXZlIHRoZWlyIG93biBpbnRlcmZhY2VzLlxuXG5cdC8vIE5vdCBzdXJlIGlmIHRoZSBSZXNvdXJjZV9Qb29sIHNob3VsZCBoYXZlIGFuIEhUVFAgZW5kcG9pbnQuLi4gbWF5YmUgU2VydmVyX1Jlc291cmNlX1Bvb2w/XG5cblxuXG5cdC8vIEtlZXBzIHRyYWNrIG9mIHJlc291cmNlcyBhdmFpbGFibGUgd2l0aGluIEphdmFTY3JpcHQgcHJvY2VzcyAoYnJvd3NlciBvciBub2RlLmpzKS5cblx0dmFyIFJlc291cmNlX1Bvb2wgPSBSZXNvdXJjZS5leHRlbmQoe1xuXG5cdFx0J2luaXQnOiBmdW5jdGlvbihzcGVjKSB7XG5cdFx0XHR0aGlzLl9zdXBlcihzcGVjKTtcblx0XHRcdFxuXHRcdFx0Ly8gU29ydGluZyB0aGVtIGJ5IGEgRGF0YV9PYmplY3Qncy5tZXRhIG5hbWU/XG5cdFx0XHQvLyAgbmVlZCBhbiBlYXN5IHdheSBvZiBleHByZXNzaW5nIHRoaXMuXG5cdFx0XHQvLyAgbWV0YSgnbmFtZScpP1xuXHRcdFx0Ly8gIGF0dGFjaGVkKCdtZXRhJywgJ25hbWUnKVxuXG5cdFx0XHQvLyBJIHRoaW5rIGluZGV4aW5nIGJ5IGF0dGFjaGVkIERhdGFfT2JqZWN0IHByb3BlcnRpZXMgbWFrZXMgc2Vuc2UuXG5cdFx0XHQvLyAgVGhhdCB3b3VsZCBtZWFuIGRlZmluaW5nIGFuIGluZGV4IGFzIGFwcGx5aW5nIHRvIGFuIGF0dGFjaGVkIG9iamVjdC5cblx0XHRcdC8vICAgaW4gdGhpcyBjYXNlICdtZXRhJ1xuXG5cdFx0XHQvLyBzb3J0ZWQ6IFtbJ2F0dGFjaGVkJywgJ21ldGEnLCAnbmFtZSddXVxuXHRcdFx0Ly8gIGRvZXMgbm90IGxvb2sgbmljZSwgYnV0IGl0IGdldHMgdGhlIHBvaW50IGFjY3Jvc3MuXG5cdFx0XHQvLyAgaG9wZWZ1bGx5IHdvdWxkIG5vdCBiZSBjb25mdXNlZC5cblx0XHRcdC8vICBPbmUgc29ydGVkIGluZGV4IGJ5IGl0cyBtZXRhLm5hbWVcblx0XHRcdC8vIEkgdGhpbmsgdGhlIGF0dGFjaGVkIGtleXdvcmQgbWFrZXMgc2Vuc2UgaGVyZSBhcyBtZXRhIGlzIGF0dGFjaGVkIHRvIHRoZSBvYmplY3QgcmF0aGVyXG5cdFx0XHQvLyAgdGhhbiByZWFsbHkgYSBjb21wb25lbnQgb2YgdGhlIG9iamVjdCBpdHNlbGYuXG5cblx0XHRcdC8vIEkgdGhpbmsgcmVnaXN0ZXJpbmcgb2JqZWN0IGF0dGFjaG1lbnRzIG1ha2VzIHNlbnNlLlxuXHRcdFx0Ly8gIFRoYXQgaXMgbW9yZSBjb3JlLWxldmVsIHdvcmsgYW5kIEkgd2FudCB0byBkcmF3IGFuIGVuZCB0byB0aGF0IGZvciB0aGUgbW9tZW50LlxuXHRcdFx0Ly8gT2JqZWN0IGF0dGFjaG1lbnRzIGJlaW5nIGFub3RoZXIgaW50ZXJlc3RpbmcgcGFydCB3aGljaCB3aWxsIGJlIHdvcnRod2hpbGUuXG5cblxuXHRcdFx0dGhpcy5fcmVzb3VyY2VzID0gbmV3IENvbGxlY3Rpb24oe1xuXHRcdFx0XHQnaW5kZXgnOiB7XG5cdFx0XHRcdFx0Ly8nc29ydGVkJzogW1snbmFtZSddXSAvLyBzaW1pbGFyIHRvIGFib3ZlLCBidXQgbGl0ZXJhbGx5IGl0J3MgYSBzaW5nbGUgaW5kZXggaW4gYSBsaXN0IG9mIGluZGV4ZXMsIHRoYXQgaW5kZXgganVzdCBoYXMgb25lIGZpZWxkLCBpbiBhIGxpc3Qgb2YgZmllbGRzXG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Ly8gVGhlIHN5bnRheCBmb3Igc3BlY2lmeWluZyBhIChzb3J0ZWQpIGluZGV4IGlzIGZvciBhbiBhdHRhY2hlZCBmaWVsZC5cblx0XHRcdFx0XHQvLyAgSXQgZ2V0cyB0aGUgZGF0YSBmb3IgdGhlIGF0dGFjaGVkIG9iamVjdC5cblx0XHRcdFx0XHQvLyB7J2F0dGFjaGVkJzogeydtZXRhJzogJ25hbWUnfX1cblx0XHRcdFx0XHQnc29ydGVkJzogW1t7J2F0dGFjaGVkJzogeydtZXRhJzogJ25hbWUnfX1dXVxuXHRcdFx0XHRcdC8vc29ydGVkOiBbW1snYXR0YWNoZWQnLCAnbWV0YScsICduYW1lJ11dXVxuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHRcdFxuXHRcdH0sXG5cblx0XHQncmVzb3VyY2VzJzogZnAoZnVuY3Rpb24oYSwgc2lnKSB7XG5cdFx0XHRpZiAoc2lnID09ICdbXScpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3Jlc291cmNlcztcblx0XHRcdH1cblx0XHR9KSxcblx0XHRcblx0XHQnX2dldF9yZXNvdXJjZXNfYnlfaW50ZXJmYWNlJzogZnVuY3Rpb24oaV9uYW1lKSB7XG5cdFx0XHR2YXIgcmVzID0gW107XG5cdFx0XHRcblx0XHRcdHRoaXMuX3Jlc291cmNlcy5lYWNoKGZ1bmN0aW9uKGksIHJlc291cmNlKSB7XG5cdFx0XHRcdGNvbnNvbGUubG9nKCdyZXNvdXJjZSAnICsgcmVzb3VyY2UpO1xuXG5cdFx0XHRcdC8vIE5vdCBzbyBzdXJlIHdlIHNob3VsZCB0cmVhdCAnZ2V0JyBsaWtlIHRoYXQgZm9yIHRoZSByZXNvdXJjZS5cblx0XHRcdFx0Ly8gIFRoZSByZXNvdXJjZSBtYXkgYmUgYSBsaXN0IG9mIGl0ZW1zLCBvbmUgb2Ygd2hpY2ggaXMgY2FsbGVkICdpbnRlcmZhY2UnXG5cblx0XHRcdFx0Ly8gTmVlZCB0aGF0IG9uZSBvbiBhIGxvd2VyIGxldmVsLlxuXHRcdFx0XHQvLyAgTGlrZSByZXNvdXJjZS5pbnRlcmZhY2VcblxuXG5cblx0XHRcdFx0dmFyIGkgPSByZXNvdXJjZS5nZXQoJ2ludGVyZmFjZScpO1xuXHRcdFx0XHRpZiAodG9mKGkpID09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdFx0aWYgKGkgPT0gaV9uYW1lKSByZXMucHVzaChyZXNvdXJjZSk7XG5cdFx0XHRcdH0gZWxzZSBpZiAodG9mKGkpID09ICdhcnJheScpIHtcblx0XHRcdFx0XHR2YXIgZG9uZSA9IHRydWU7XG5cdFx0XHRcdFx0ZWFjaChpLCBmdW5jdGlvbihpMiwgdikge1xuXHRcdFx0XHRcdFx0aWYgKCFkb25lKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChpID09IGlfbmFtZSkgcmVzLnB1c2gocmVzb3VyY2UpO1xuXHRcdFx0XHRcdFx0XHRkb25lID0gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KVxuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0fSlcblx0XHRcdFxuXHRcdFx0aWYgKHJlcy5sZW5ndGggPiAxKSByZXR1cm4gcmVzO1xuXHRcdFx0cmV0dXJuIHJlc1swXTtcblx0XHRcdFxuXHRcdH0sXG5cdFx0XG5cdFx0J2luZGV4X3Jlc291cmNlJzogZnVuY3Rpb24ob2JqKSB7XG5cdFx0XHQvLyB3aWxsIGdldCBzb21lIG1ldGFkYXRhIGZyb20gdGhlIHJlc291cmNlLlxuXHRcdFx0XG5cdFx0XHQvLyByZXNvdXJjZSB3aWxsIGJlIGluZGV4ZWQgYnkgaXRzIGxvY2F0aW9uIGFuZCBpdHMgdHlwZS5cblx0XHRcdC8vICBzbyB3aWxsIGJlIGFibGUgdG8gZmluZCB0aGUgbG9jYWwgcG9zdGdyZXMgZGF0YWFiYXNlIHRoYXQgd2F5XG5cdFx0XHRcblx0XHRcdC8vIFRoZXJlIHdpbGwgYmUgZGlmZmVyZW50IGxldmVscyBvZiBsb2NhbGl0eVxuXHRcdFx0Ly8gIE1heSBiZSBhIHNob3J0aGFuZCBmb3IgdGhlIHRpbWUgYW5kIGRpZmZpY3VsdHkgaW4gY29tbXVuaWNhdGluZyBiZXR3ZWVuIHR3byBsb2NhdGlvbnNcblx0XHRcdFxuXHRcdFx0Ly8gaW4tcHJvY2Vzc1xuXHRcdFx0Ly8gc2FtZSBtYWNoaW5lXG5cdFx0XHQvLyBsYW4gKHNhbWUgZGF0YSBjZW50cmUpXG5cdFx0XHQvLyBpbnRlcm5ldCwgc2FtZSByZWdpb25cblx0XHRcdC8vIGludGVybmV0XG5cdFx0XHQvLyBzdGVsbGFyIChjb3VsZCBoYXZlIG1vcmUgdmFyaWF0aW9ucyBwZXJoYXBzIGJ1dCB3aWxsIG5vdCBiZSBuZWNlc3NhcnkgZm9yIG1vc3QgYXBwbGljYXRpb25zKVxuXHRcdFx0XG5cdFx0XHQvLyB0byBiZWdpbiB3aXRoLCB0aGVyZSB3aWxsIGxpa2VseSBiZSBzb21lIGluLXByb2Nlc3MgcmVzb3VyY2VzLlxuXHRcdFx0Ly8gIHNvbWUgb2YgdGhlc2UgcmVzb3VyY2VzIGNvdWxkIGJlIHJlc291cmNlIGNvbm5lY3RvcnMuXG5cdFx0XHRcblx0XHRcdFxuXHRcdH0sXG5cdFx0XG5cdFx0J3JlY2VpdmVfcmVzb3VyY2VfZXZlbnQnOiBmcChmdW5jdGlvbihhLCBzaWcpIHtcblx0XHRcdC8vY29uc29sZS5sb2coJ3JlY2VpdmVfcmVzb3VyY2VfZXZlbnQgc2lnICcgKyBzaWcpO1xuXHRcdFx0XG5cdFx0XHRpZiAoc2lnID09ICdbRCxzLFtzLHNdXScpIHtcblx0XHRcdFx0dmFyIGRhdGFfb2JqZWN0ID0gYVswXTtcblx0XHRcdFx0Ly9jb25zb2xlLmxvZygnZGF0YV9vYmplY3QgJyArIHN0cmluZ2lmeShkYXRhX29iamVjdCkpO1xuXHRcdFx0XHRcblx0XHRcdFx0Ly9jb25zb2xlLmxvZygnYVsxXSAnICsgYVsxXSk7XG5cdFx0XHRcdC8vY29uc29sZS5sb2coJ2FbMl0gJyArIHN0cmluZ2lmeShhWzJdKSk7XG5cdFx0XHRcdFxuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRpZiAoc2lnID09ICdbRCxzXScpIHtcblx0XHRcdFx0dmFyIGRhdGFfb2JqZWN0ID0gYVswXTtcblx0XHRcdFx0Ly9jb25zb2xlLmxvZygnZGF0YV9vYmplY3QgJyArIHN0cmluZ2lmeShkYXRhX29iamVjdCkpO1xuXHRcdFx0XHQvL2NvbnNvbGUubG9nKCdhWzFdICcgKyBhWzFdKTtcblx0XHRcdFx0XG5cdFx0XHRcdHZhciBldmVudF9uYW1lID0gYVsxXTtcblx0XHRcdFx0Ly9jb25zb2xlLmxvZygnZXZlbnRfbmFtZSAnICsgZXZlbnRfbmFtZSk7XG5cdFx0XHRcdC8vIGNvdWxkIGJlIHRoYXQgaXQgaGFzIHN0YXJ0ZWQ/XG5cdFx0XHRcdFxuXHRcdFx0XHRcblx0XHRcdFx0Ly8gdGhlbiBuZWVkIHRvIHJhaXNlIHRoaXMgZXZlbnQuXG5cdFx0XHRcdFxuXHRcdFx0XHRcblx0XHRcdFx0XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBzbyBpZiBhbiByZXNvdXJjZSBoYXMgc3RhcnRlZCwgY291bGQgaGF2ZSBhIHBhcnRpY3VsYXIgaGFuZGxlciBmb3IgdGhhdC5cblx0XHRcdFx0XG5cdFx0XHRcdC8vIFRoZXJlIHdpbGwgYmUgZ3JvdXBzIG9mIHJlc291cmNlcyB0aGF0IGFyZSBuZWVkZWQgZm9yIG90aGVyIG9uZXMgdG8gc3RhcnQuXG5cdFx0XHRcdC8vICBXaGVuIG9uZSBvZiB0aGVzZSByZXNvdXJjZXMgaGFzIGxvYWRlZCwgaXQgd2lsbCBjaGVjayB0byBzZWUgaWYgb3RoZXJzIGhhdmUgYWxzbyBsb2FkZWQuXG5cdFx0XHRcdC8vIFRoaXMgc2hvdWxkIGJlIGRvbmUgd2l0aCBmYWlybHkgZmFzdCBhbGdvcml0aG1zLCB3ZSBkb24ndCB3YW50IHRoZSBzeXN0ZW0gdG8gc2xvdyBkb3duIGFzIGl0IGlzIGdldHRpbmcgZ29pbmcuXG5cdFx0XHRcdFxuXHRcdFx0XHRcblx0XHRcdFx0XG5cdFx0XHRcdFxuXHRcdFx0XHRcblx0XHRcdFx0XG5cdFx0XHRcdFxuXHRcdFx0fVxuXHRcdFx0XG5cdFx0fSksXG5cdFx0XG5cdFx0J2FkZCc6IGZ1bmN0aW9uKG9iaikge1xuXHRcdFx0Ly8gYWRkcyB0aGUgcmVzb3VyY2Ugb2JqIHRvIHRoZSBwb29sLlxuXHRcdFx0XG5cdFx0XHQvLyBFYWNoIHJlc291cmNlIHdpbGwgaGF2ZSBpdHMgb3duIGluZGl2aWR1YWwgbmFtZSB3aXRoaW4gdGhlIHBvb2wuXG5cdFx0XHQvLyAgVGhlcmUgbWF5IGJlIHJlc291cmNlcyB0aGF0IGdldCBwdXQgaW50byBncm91cHMgdG9vLlxuXHRcdFx0dmFyIHRoYXQgPSB0aGlzO1xuXHRcdFx0XG5cdFx0XHQvL2NvbnNvbGUubG9nKCdvYmogJyArIHN0cmluZ2lmeShvYmopKTtcblxuXHRcdFx0dmFyIG9ial9uYW1lID0gb2JqLm1ldGEuZ2V0KCduYW1lJyk7XG5cdFx0XHRcblx0XHRcdC8vY29uc29sZS5sb2coJyoqIG9ial9uYW1lICcgKyBvYmpfbmFtZSk7XG5cdFx0XHRcblx0XHRcdGlmICh0aGlzLmhhc19yZXNvdXJjZShvYmpfbmFtZSkpIHtcblx0XHRcdFx0dGhyb3cgJ1Jlc291cmNlIHBvb2wgYWxyZWFkeSBoYXMgcmVzb3VyY2Ugd2l0aCBuYW1lICcgKyBvYmpfbmFtZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFxuXHRcdFx0XHQvL3RoaXMuX2RpY3RfcmVzb3VyY2VzW29ial9uYW1lXSA9IG9iajtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIHJhaXNlIGFuIGV2ZW50IHNheWluZyB0aGF0IHRoZSByZXNvdXJjZSB3YXMgYWRkZWQuXG5cdFx0XHRcdFxuXHRcdFx0XHR0aGlzLl9yZXNvdXJjZXMuYWRkKG9iaik7XG5cdFx0XHRcdC8vb2JqLnBhcmVudCh0aGlzKTtcblxuXHRcdFx0XHQvLyBkb24ndCB0aGluayB3ZSBjYW4gZG8gaXQgbGlrZSB0aGF0LlxuXHRcdFx0XHQvLyAgb2JqLnNldCgncG9vbCcsIHRoaXMpO1xuXHRcdFx0XHQvLyAgdGhlIHJlc291cmNlIGNvdWxkIGhhdmUgYSAncG9vbCcgb2JqZWN0IG9mIGl0cyBvd24sIHRoZSByZXNvdXJjZSBjb3VsZCBob2xkIHNwb3J0cyByZXN1bHRzXG5cdFx0XHRcdC8vICAgZm9yIGV4YW1wbGUuXG5cblx0XHRcdFx0b2JqLm1ldGEuc2V0KCdwb29sJywgdGhpcyk7XG5cdFx0XHRcdFxuXG5cblx0XHRcdFx0dGhpcy5yYWlzZV9ldmVudCgnYWRkZWQnLCBvYmopO1xuXHRcdFx0XHQvLyBsaXN0ZW4gdG8gZXZlbnRzIGZyb20gdGhhdCByZXNvdXJjZS5cblxuXHRcdFx0XHQvLyBEbyB3ZSB3YW50IGp1c3QgYSBnZW5lcmFsIGxpc3RlbmVyIGZvciBldmVudHM/XG5cdFx0XHRcdC8vICBTbyB3ZSBsaXN0ZW4gdG8gYW55IGV2ZW50IGZyb20gaXQ/XG5cdFx0XHRcdC8vb2JqLmFkZF9ldmVudF9saXN0ZW5lcih0aGF0LnJlY2VpdmVfcmVzb3VyY2VfZXZlbnQpO1xuXHRcdFx0XHRcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0XG5cdFx0fSxcblx0XHQncHVzaCc6IGZ1bmN0aW9uKG9iaikge1xuXHRcdFx0cmV0dXJuIHRoaXMuYWRkKG9iaik7XG5cdFx0fSxcblx0XHQnaGFzX3Jlc291cmNlJzogZnAoZnVuY3Rpb24oYSwgc2lnKSB7XG5cdFx0XHRcblx0XHRcdFxuXHRcdFx0Ly9yZXR1cm4gaXNfZGVmaW5lZCh0aGlzLl9kaWN0X3Jlc291cmNlc1tyZXNvdXJjZV9uYW1lXSk7XG5cdFx0XHRcblx0XHRcdC8vcmV0dXJuIFxuXHRcdFx0XG5cdFx0XHRpZiAoc2lnID09ICdbc10nKSB7XG5cdFx0XHRcdC8vIG9uZSBzdHJpbmcgdmFsdWUsIHRoYXQgd2lsbCBiZSB0aGUgdmFsdWUgb2YgdGhlIHVuaXF1ZSBwcmltYXJ5IGluZGV4XG5cdFx0XHRcdFxuXHRcdFx0XHR2YXIgb2JqX2xvb2t1cF92YWwgPSBhWzBdO1xuXHRcdFx0XHRcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3Jlc291cmNlcy5oYXMob2JqX2xvb2t1cF92YWwpO1xuXHRcdFx0XHRcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0XG5cdFx0XHRcblx0XHR9KSxcblx0XHRcblx0XHQvLyBMaWtlbHkgdG8ganVzdCBiZSAnZ2V0Jywgd2l0aCBpdCByZXR1cm5pbmcgcmVzb3VyY2VzIGluc2lkZS5cblx0XHQvLyAgQW5kIHBlcmhhcHMgZ29pbmcgdGhyb3VnaCBhbiBhZGFwdGVyLlxuXG5cdFx0Ly8gQ2FuIG5vdCBnZXQgdGhlIGFjdHVhbCByZXNvdXJjZSBhcyBhIHByb2dyYW1taW5nIG9iamVjdCBpZiBpdCBpcyByZW1vdGUuXG5cdFx0Ly8gIEluIHRoYXQgY2FzZSwgd2UgbmVlZCB0byB1c2UgYSB0cmFuc3BvcnQgbWVjaGFuaXNtLlxuXG5cdFx0Ly8gTmVlZCB0byBiZSBhYmxlIHRvIGFjY2VzcyB0aGUgcmVzb3VyY2VzJyBkYXRhIHdpdGggYSBjb252ZW5pZW50IGludGVyZmFjZSwgbm90IGhhdmluZyB0byB3cml0ZSByZXBlYXRlZCBIVFRQIHBsdW1iaW5nLlxuXG5cdFx0XG5cblxuXHRcdCdnZXRfcmVzb3VyY2UnOiBmcChmdW5jdGlvbihhLCBzaWcpIHtcblx0XHRcdC8vY29uc29sZS5sb2coJ2dldF9yZXNvdXJjZSBzaWcgJyArIHNpZyk7XG5cdFx0XHRcblx0XHRcdC8vcmV0dXJuIGlzX2RlZmluZWQodGhpcy5fZGljdF9yZXNvdXJjZXNbcmVzb3VyY2VfbmFtZV0pO1xuXHRcdFx0Ly9yZXR1cm4gXG5cdFx0XHRcblx0XHRcdGlmIChzaWcgPT0gJ1tzXScpIHtcblx0XHRcdFx0Ly8gb25lIHN0cmluZyB2YWx1ZSwgdGhhdCB3aWxsIGJlIHRoZSB2YWx1ZSBvZiB0aGUgdW5pcXVlIHByaW1hcnkgaW5kZXhcblx0XHRcdFx0XG5cdFx0XHRcdHZhciBvYmpfbG9va3VwX3ZhbCA9IGFbMF07XG5cdFx0XHRcdC8vY29uc29sZS5sb2coJ3RoaXMuX3Jlc291cmNlcyAnICsgc3RyaW5naWZ5KHRoaXMuX3Jlc291cmNlcykpO1xuXHRcdFx0XHQvL3Rocm93ICdzdG9wJztcblx0XHRcdFx0Ly9jb25zb2xlLmxvZygnb2JqX2xvb2t1cF92YWwgJyArIG9ial9sb29rdXBfdmFsKTtcblxuXHRcdFx0XHQvL2NvbnNvbGUubG9nKCd0aGlzLl9yZXNvdXJjZXMgJyArIHN0cmluZ2lmeSh0aGlzLl9yZXNvdXJjZXMpKTtcblxuXHRcdFx0XHQvLyBuZWVkcyB0byBjaGVjayBbJ21ldGEnXS5uYW1lXG5cdFx0XHRcdC8vICBtZXRhIGlzIG5vdCBhY2Nlc3NlZCB0aHJvdWdoIHRoZSBub3JtYWwgaW50ZXJmYWNlLlxuXHRcdFx0XHQvLyAgIHBlcmhhcHMgd2UgY291bGQgaGF2ZSBhIC5tZXRhIGZvciBkZWFsaW5nIHdpdGggcHJvcGVydGllcyBsaWtlIG5hbWVcblx0XHRcdFx0Ly8gICB0aGUgcmVzb3VyY2UncyBnZXQgYW5kIHNldCBzaG91bGQgYmUgYW4gdW5vYnN0cnVjdGVkIGludGVyZmFjZSB0byB0aGUgcmVzb3VyY2Vcblx0XHRcdFx0Ly8gICBpdHNlbGYuXG5cblx0XHRcdFx0Ly8gSW5kZXhpbmcgYSBEYXRhX09iamVjdCBub3QgYnkgaXQncyBub3JtYWwgY29udGVudHMsIGJ1dCBieSBtZXRhZGF0YSBvciBcblx0XHRcdFx0Ly8gIG90aGVyIGF0dGFjaGVkIG9iamVjdHMuXG5cblx0XHRcdFx0Ly8gSSB0aGluayBEYXRhX09iamVjdCBhbmQgUmVzb3VyY2UgbWV0YShkYXRhKSBpbmRleGluZyBtYWtlcyB0aGUgbW9zdCBzZW5zZS5cblxuXHRcdFx0XHQvLyBEYXRhX09iamVjdC5tZXRhIGNvdWxkIG1ha2UgYSBsb3Qgb2Ygc2Vuc2UuXG5cdFx0XHRcdC8vICBXZSBjb3VsZCBwb3NzaWJseSBoYXZlIHRoZSBzYW1lIG5hbWUgZmllbGQgaW4gc29tZSBjYXNlcy5cblx0XHRcdFx0Ly8gIE1ldGEgbWFrZXMgdGhlIG1vc3Qgc2Vuc2UgZm9yIHJlc291cmNlcy4gUGVyaGFwcyBvbmx5IHVzZSB0aGVtIHRoZXJlIGFzIHRoZXkgZW5hYmxlIHRoZVxuXHRcdFx0XHQvLyAgIGRpcmVjdCBvYmplY3QgaW50ZXJmYWNlLlxuXG5cdFx0XHRcdC8vIEhvd2V2ZXIsIHRoZSBjb2xsZWN0aW9uIG9mIHJlc291cmNlcyBpbiBhIHBvb2wgbWF5IG5lZWQgaW5kZXhpbmcgYnkgdGhlIG5hbWUgZmllbGRcblx0XHRcdFx0Ly8gIHdoaWNoIGlzIHdpdGhpbiAnbWV0YScuXG5cblx0XHRcdFx0Ly92YXIgcmVzID0gdGhpcy5fcmVzb3VyY2VzLmZpbmQoJ25hbWUnLCBvYmpfbG9va3VwX3ZhbClbMF07XG5cdFx0XHRcdC8vY29uc29sZS5sb2coJ29ial9sb29rdXBfdmFsICcgKyBvYmpfbG9va3VwX3ZhbCk7XG5cdFx0XHRcdC8vdmFyIHJlcyA9IHRoaXMuX3Jlc291cmNlcy5maW5kKCdbXCJhdHRhY2hlZFwiLCBcIm1ldGFcIiwgXCJuYW1lXCJdJywgb2JqX2xvb2t1cF92YWwpWzBdO1xuXG5cdFx0XHRcdC8vIE5lZWQgdG8gc2F5IGl0J3MgZmluZGluZyBhIHNpbmdsZSBhdHRhY2hlZCBmaWVsZC5cblx0XHRcdFx0Ly8gIGRvbid0IHdhbnQgdGhpcyB0byBiZSBtaXN1bmRlcnN0b29kIGZvciB0aHJlZSBmaWVsZHMgdG8gbG9vayBmb3IuXG5cdFx0XHRcdC8vIFBlcmhhcHMgbmVlZCB0byB0aGluayBhYm91dCBhbmQgZm9ybWFsaXNlIHRoZSBBUEkgYSBiaXQgbW9yZS5cblx0XHRcdFx0Ly8gIEJ1dCBnZXR0aW5nIGl0IHRvIHdvcmsgd2lsbCBiZSBhIGdyZWF0IGhlbHAhXG5cblx0XHRcdFx0Ly8gQ29sbGVjdGlvbi5maW5kIHN5bnRheC5cblxuXHRcdFx0XHQvLyBGaW5kIHJlcXVlc3RzLi4uIHBlcmhhcHMgdGhleSBjb3VsZCB0YWtlIG1vcmUgd29yayB0byBtYWtlIGEgZnVsbHkgZmxleGlibGUgYW5kIFxuXHRcdFx0XHQvLyAgaW50dWl0aXZlIGZvcm1hdC5cblx0XHRcdFx0Ly8gW1wiYXR0YWNoZWRcIiwgXCJtZXRhXCIsIFwibmFtZVwiXSBiYXNpY2FsbHkgYmVpbmcgb25lIGZpZWxkIGluIHRoaXMgY29udGV4dC5cblxuXHRcdFx0XHQvLyBUaGlzIGNvdWxkIHF1aXRlIHBvc3NpYmx5IGRvIHdpdGggbW9yZSBzcGVjaWZpY2F0aW9uIHdvcmsgZG9uZSBvdXRzaWRlIG9mIHRoZSBSZXNvdXJjZV9Qb29sLlxuXG5cdFx0XHRcdC8vIC5maW5kSW5BdHRjaGVkKCdtZXRhJywgJ25hbWUnKSB3b3VsZCBzZWFyY2ggdGhlIGF0dGFjaGVkIGZpZWxkcy5cblxuXHRcdFx0XHQvLyBJbmRleGluZyB3aXRoaW4gdGhlIGF0dGFjaGVkIGZpZWxkcy5cblxuXHRcdFx0XHQvLyBUcmVhdGluZyB0aGUgYXR0YWNoZWQgZmllbGRzIGFzIGp1c3Qgb25lIGZpZWxkIG5hbWUgd2l0aGluIHRoZSBpbmRleD9cblx0XHRcdFx0Ly8gIEJ1dCBjYW4gd2UgdGVsbCB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIFtcImF0dGFjaGVkXCIsIFwibWV0YVwiLCBcIm5hbWVcIl0gYW5kIGEgY29sbGVjdGlvbiAvIGFycmF5XG5cdFx0XHRcdC8vICAgb2YgZmllbGRzP1xuXG5cdFx0XHRcdC8vIHsnYXR0YWNoZWQnOiAnbWV0YS5uYW1lJ31cblx0XHRcdFx0Ly8gIFRoYXQgbWF5IGJlIGJldHRlciBmb3IgYXR0YWNoZWQgZmllbGRzLlxuXHRcdFx0XHQvLyAgVGhlIGZpZWxkIGlzIGhlbGQgYnkgYW4gb2JqZWN0LCB3aGljaCB3b3VsZCBub3QgZ2V0IGNvbmZ1c2VkIHdpdGggYSBwbHVyYWwuXG5cblx0XHRcdFx0Ly8geydhdHRhY2hlZCc6IHsnbWV0YSc6ICduYW1lJ319IC0gd291bGQgd29yayBmb3IgbXVsdGktbGV2ZWwgYXR0YWNobWVudHNcblx0XHRcdFx0Ly8gIE11bHRpLWxldmVsIGF0dGFjaG1lbnRzP1xuXG5cdFx0XHRcdC8vIHsnYXR0YWNoZWQnOiB7J21ldGEnOiB7J2F0dGFjaGVkJzogeydzZWNvbmRBdHRhY2htZW50JzogJ2ZpZWxkTmFtZSd9fX19XG5cdFx0XHRcdC8vICBUaGF0IGNvdWxkIHdvcmsgZm9yIG11bHRpLWxldmVsIGF0dGFjaG1lbnRzXG5cblx0XHRcdFx0Ly8gQXR0YWNoZWQgZmllbGRzIGFzIG9iamVjdCBtYWtlcyBhIGxvdCBvZiBzZW5zZS5cblxuXG5cblx0XHRcdFx0Ly8gd2UgY2FuIGhhdmUgYSBsb29rIGF0IHRoZSBpbmRleCBpbiB0aGUgZmluZCBmdW5jdGlvblxuXG5cblxuXG5cdFx0XHRcdC8vdmFyIHJlcyA9IHRoaXMuX3Jlc291cmNlcy5maW5kKFtcImF0dGFjaGVkXCIsIFwibWV0YVwiLCBcIm5hbWVcIl0sIG9ial9sb29rdXBfdmFsKVswXTtcblx0XHRcdFx0Ly9jb25zb2xlLmxvZygncHJlIGZpbmQgcmVzb3VyY2UnKTtcblxuXHRcdFx0XHQvLyBOb3Qgc3VyZSBpdCdzIGJlaW5nIGluZGV4ZWQgcHJvcGVybHkgYnkgYXR0YWNoZWQgcHJvcGVydGllcy5cblxuXG5cblx0XHRcdFx0dmFyIHJlcyA9IHRoaXMuX3Jlc291cmNlcy5maW5kKHsnYXR0YWNoZWQnOiB7J21ldGEnOiAnbmFtZSd9fSwgb2JqX2xvb2t1cF92YWwpWzBdO1xuXHRcdFx0XHQvL2NvbnNvbGUubG9nKCdwb3N0IGZpbmQgcmVzb3VyY2UnKTtcblxuXHRcdFx0XHQvL3ZhciByZXMgPSB0aGlzLl9yZXNvdXJjZXMuZmluZChzdHJpbmdpZnkoW1wiYXR0YWNoZWRcIiwgXCJtZXRhXCIsIFwibmFtZVwiXSksIG9ial9sb29rdXBfdmFsKVswXTtcblx0XHRcdFx0Ly9jb25zb2xlLmxvZygndGhpcy5fcmVzb3VyY2VzLmxlbmd0aCgpICcgKyB0aGlzLl9yZXNvdXJjZXMubGVuZ3RoKCkpO1xuXHRcdFx0XHQvL2NvbnNvbGUubG9nKCdyZXMgJyArIHN0cmluZ2lmeShyZXMpKTtcblx0XHRcdFx0XG5cdFx0XHRcdHJldHVybiByZXM7XG5cdFx0XHRcdFxuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRcblx0XHRcdFxuXHRcdH0pLFxuXHRcdFxuXHRcdC8vIGhhdmUgcmVzb3VyY2VzIGFzIGEgZmllbGQ/XG5cdFx0Ly8gIE1lYW5zIG5vIG5lZWQgZm9yIHRoZSBib2lsZXJwbGF0ZSBjb2RlIHdoZW4gaXQgaXMgbGlua2VkLlxuXHRcdC8vJ3Jlc291cmNlcydcblx0XHRcblx0XHRcblx0XHQvLyBNYXkgYmUgdXNlZnVsIHRvIGhhdmUgYSBjYWxsYmFjayBwYXJhbWV0ZXIgaGVyZSByYXRoZXIgdGhhbiBqdXN0IHB1Ymxpc2ggLyBzdWJzY3JpYmUuXG5cdFx0XG5cdFx0J3N0YXJ0JzogZnVuY3Rpb24oY2FsbGJhY2spIHtcblxuXHRcdFx0Ly9jb25zb2xlLmxvZygncmVzb3VyY2UgcG9vbCBzdGFydCcpO1xuXG5cdFx0XHQvLyBuZWVkcyB0byBsb29rIGF0IHRoZSB2YXJpb3VzIHJlc291cmNlcyBpbiB0aGUgcG9vbC5cblx0XHRcdC8vICBzdGFydCBlYWNoIG9mIHRoZW0gaWYgdGhleSBhcmUgc3VwcG9zZWQgdG8gc3RhcnQgYXV0b21hdGljYWxseS5cblx0XHRcdFxuXHRcdFx0XG5cdFx0XHR2YXIgYXJyX3Jlc291cmNlc19tZWV0aW5nX3JlcXVpcmVtZW50cyA9IFtdO1xuXHRcdFx0XG5cdFx0XHQvL2NvbnNvbGUubG9nKCd0aGlzLl9yZXNvdXJjZXMubGVuZ3RoKCkgJyArIHRoaXMuX3Jlc291cmNlcy5sZW5ndGgoKSk7XG5cdFx0XHRcblx0XHRcdHRoaXMuX3Jlc291cmNlcy5lYWNoKGZ1bmN0aW9uKGksIHYpIHtcblx0XHRcdFx0Ly9jb25zb2xlLmxvZygnaSAnICsgaSk7XG5cdFx0XHRcdC8vY29uc29sZS5sb2coJ3YgJyArIHN0cmluZ2lmeSh2KSk7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBpZiBpdCBoYXMgYWxsIGl0cyByZXF1aXJlbWVudHMgbWV0LCBzdGFydCBpdC5cblx0XHRcdFx0XG5cdFx0XHRcdC8vIHJlcXVpcm1lbnRzIC0gdGhlcmUgbWF5IGJlIGNvbmRpdGlvbmFsIHJlcXVpcmVtZW50cyBpbiB0aGUgZnV0dXJlIChsaWtlIGVtYWlsIGFkZHJlc3MgaXMgbm90IHJlcXVpcmVkIHdoZW4gYSBGYWNlYm9vayBwcm9maWxlIFVSTCBpcyBnaXZlbiksIGJ1dCBmb3IgdGhlIG1vbWVudCBlYWNoIHJlcXVpcmVtZW50IGlzIHJlcXVpcmVkXG5cdFx0XHRcdC8vICBjb3VsZCBzdGlsbCBiZSBzaW1pbGFyLCB3aXRoIE9SIGNvbXBvc2l0ZSByZXF1aXJlbWVudHMuXG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBjaGVjayBpZiB0aGUgcmVzb3VyY2UgbWVldHMgdGhlIHJlcXVpcmVtZW50cy4uLlxuXHRcdFx0XHQvL2NvbnNvbGUubG9nKCdwcmUgbWVldHNfcmVxdWlyZW1lbnRzJyk7XG5cdFx0XHRcdHZhciBtciA9IHYubWVldHNfcmVxdWlyZW1lbnRzKCk7XG5cdFx0XHRcdC8vY29uc29sZS5sb2coJ3Bvc3QgbWVldHNfcmVxdWlyZW1lbnRzJyk7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBhbmQgbmVlZCBhIGNhbGxiYWNrIGZvciB3aGVuIHRoZXkgYWxsIGhhdmUgc3RhcnRlZC5cblx0XHRcdFx0XG5cdFx0XHRcdC8vICBJIHRoaW5rIGRvaW5nIHRoZSByZXF1aXJlbWVudHMgbmV0d29yayBwbGFubmluZyBiZWZvcmUgc3RhcnRpbmcgd2lsbCBiZSB0aGUgYmVzdCB3YXkuXG5cdFx0XHRcdC8vICAgVGhhdCBjb3VsZCBnZXQgdGhpbmdzIHRvIHN0YXJ0IHZlcnkgZWZmaWNpZW50bHkuXG5cdFx0XHRcdFxuXHRcdFx0XHQvL2NvbnNvbGUubG9nKCdtZWV0c19yZXF1aXJlbWVudHMgJyArIG1yKTtcblx0XHRcdFx0aWYgKG1yKSB7XG5cdFx0XHRcdFx0Ly92LnN0YXJ0KCk7XG5cdFx0XHRcdFx0YXJyX3Jlc291cmNlc19tZWV0aW5nX3JlcXVpcmVtZW50cy5wdXNoKHYpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHRcdFxuXHRcdFx0Ly9jb25zb2xlLmxvZygnYXJyX3Jlc291cmNlc19tZWV0aW5nX3JlcXVpcmVtZW50cy5sZW5ndGggJyArIGFycl9yZXNvdXJjZXNfbWVldGluZ19yZXF1aXJlbWVudHMubGVuZ3RoKTtcblx0XHRcdHZhciBsX3Jlc291cmNlcyA9IHRoaXMuX3Jlc291cmNlcy5sZW5ndGgoKTtcblx0XHRcdC8vY29uc29sZS5sb2coJ2xfcmVzb3VyY2VzICcgKyBsX3Jlc291cmNlcyk7XG5cblxuXHRcdFx0XG5cdFx0XHRpZiAoYXJyX3Jlc291cmNlc19tZWV0aW5nX3JlcXVpcmVtZW50cy5sZW5ndGggPT0gbF9yZXNvdXJjZXMpIHtcblx0XHRcdFx0XG5cdFx0XHRcdHZhciBmbnMgPSBbXTtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIGNhbiBkbyB0aGlzIHdpdGhvdXQgY2FsbF9tdWx0aSAtIHRob3VnaCBJIHdvdWxkIHByZWZlciB0byB1c2UgY2FsbF9tdWx0aSBhbmQgaGF2ZSBpdCB3b3JrIGJ5IGEgbG9uZyB3YXkuXG5cdFx0XHRcdFxuXHRcdFx0XHR2YXIgbnVtX3RvX3N0YXJ0ID0gYXJyX3Jlc291cmNlc19tZWV0aW5nX3JlcXVpcmVtZW50cy5sZW5ndGg7XG5cdFx0XHRcdFxuXHRcdFx0XHQvL2NvbnNvbGUubG9nKCdudW1fdG9fc3RhcnQgJyArIG51bV90b19zdGFydCk7XG5cdFx0XHRcdC8vdGhyb3cgJ3N0b3AnO1xuXHRcdFx0XHRcblx0XHRcdFx0dmFyIG51bV9zdGFydGluZyA9IDAsIG51bV9zdGFydGVkID0gMDtcblx0XHRcdFx0dmFyIGNiID0gZnVuY3Rpb24oZXJyLCBzdGFydF9yZXMpIHtcblx0XHRcdFx0ICAgIG51bV9zdGFydGluZy0tO1xuXHRcdFx0XHQgICAgbnVtX3N0YXJ0ZWQrKztcblx0XHRcdFx0ICAgIC8vY29uc29sZS5sb2coJ2NiJyk7XG5cdFx0XHRcdCAgICAvL2NvbnNvbGUubG9nKCdudW1fc3RhcnRlZCAnICsgbnVtX3N0YXJ0ZWQpO1xuXHRcdFx0XHQgICAgXG5cdFx0XHRcdCAgICBpZiAobnVtX3N0YXJ0ZWQgPT0gbnVtX3RvX3N0YXJ0KSB7XG5cdFx0XHRcdCAgICAgICAgY2FsbGJhY2sobnVsbCwgdHJ1ZSk7XG5cdFx0XHRcdCAgICB9XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdGVhY2goYXJyX3Jlc291cmNlc19tZWV0aW5nX3JlcXVpcmVtZW50cywgZnVuY3Rpb24oaSwgcmVzb3VyY2VfcmVhZHlfdG9fc3RhcnQpIHtcblx0XHRcdFx0ICAgIC8vY29uc29sZS5sb2coJycpO1xuXHRcdFx0XHQgICAgLy9jb25zb2xlLmxvZygnJyk7XG5cdFx0XHRcdCAgICAvL2NvbnNvbGUubG9nKCdyZXNvdXJjZV9yZWFkeV90b19zdGFydCAnLCByZXNvdXJjZV9yZWFkeV90b19zdGFydCk7XG5cdFx0XHRcdCAgICAvL3Rocm93ICdzdG9wJztcblx0XHRcdFx0ICAgIC8vIHNob3VsZCBnaXZlIHRoZSBjb250ZXh0IE9LLlxuXHRcdFx0XHRcdC8vZm5zLnB1c2goW3Jlc291cmNlX3JlYWR5X3RvX3N0YXJ0LCByZXNvdXJjZV9yZWFkeV90b19zdGFydC5zdGFydCwgW11dKTtcblx0XHRcdFx0XHQvL2NvbnNvbGUubG9nKCdwcmUgcmVzb3VyY2Ugc3RhcnQnKTtcblxuXHRcdFx0XHRcdC8vIEJ1dCBzdGFydGluZyB3aXRoIHRoZSB3cm9uZyBjb250ZXh0Pz8/XG5cdFx0XHRcdFx0cmVzb3VyY2VfcmVhZHlfdG9fc3RhcnQuc3RhcnQoY2IpO1xuXHRcdFx0XHRcdC8vY29uc29sZS5sb2coJ3Bvc3QgcmVzb3VyY2Ugc3RhcnQnKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRudW1fc3RhcnRpbmcrKztcblx0XHRcdFx0XHQvLyBidXQgdGhlIGNhbGxiYWNrLi4uXG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Ly9mbnMucHVzaChbZnVuY3Rpb24oY2FsbGJhY2spIHtcblx0XHRcdFx0XHQvLyAgICByZXNvdXJjZV9yZWFkeV90b19zdGFydC5zdGFydChjYWxsYmFjayk7XG5cdFx0XHRcdFx0Ly99LCBbXV0pXG5cdFx0XHRcdFx0XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRcblx0XHR9XG5cdH0pO1xuXHRcbm1vZHVsZS5leHBvcnRzID0gUmVzb3VyY2VfUG9vbDtcblx0Ly9yZXR1cm4gUmVzb3VyY2VfUG9vbDtcblx0XG5cdFxuLy99KTsiLCIvLyBXYW50IHRvIGdldCB0aGUgY29yZSByZXNvdXJjZXMgd29ya2luZyBhbmQgdGVzdGVkLlxuLy8gIFdhbnQgdG8gcnVuIGEgY2xvY2sgd2Vic2l0ZSAvIHNlcnZpY2UgdG8gc3RhcnQgd2l0aC5cbi8vICBUaGUgc2VydmVyIGNvdWxkIGhhdmUgYSBjbG9jaywgd2hpbGUgY2xpZW50cyBjb3VsZCBjb25uZWN0IHRvIGl0IGFuZCBzaGFyZSB0aGUgaW5mb3JtYXRpb24uXG4vLyAgQ291bGQgYWxzbyBleHBlcmltZW50IHdpdGggUDJQIGRpc3RyaWJ1dGlvbiBvZiB0aGUgZGF0YS5cbi8vICBBIGNsb2NrIGlzIGFsc28gdXNlZnVsIGJlY2F1c2UgaXQgY29udGFpbnMgdGltZSBzaWduYWxzIHNvIHdlIGNhbiBzZWUgaG93IGxvbmcgaXQgdGFrZXMgZm9yIGRhdGEgdG8gcmVhY2ggdmFyaW91cyBtYWNoaW5lcy5cblxuXG4vLyBJbnRlcnN0ZWQgaW4gaGF2aW5nIGEgcmVtb3RlIExpbnV4IGNvbXB1dGVyLlxuLy8gIEFiaWxpdHkgdG8gU1NIIGludG8gaXQgYW5kIHJ1biBjb21tYW5kcy5cblxuLy8gV2FudCB0byBiZSBhYmxlIHRvIHJlbW90ZWx5IGNvbmZpZ3VyZSBhbmQgYWNjZXNzIGEgUmFzcGJlcnJ5IFBpIGFzIGEgUmVzb3VyY2UuXG5cblxuXG5cblxudmFyIGpzZ3VpID0gcmVxdWlyZSgnLi4vLi4vY29yZS9qc2d1aS1sYW5nLXV0aWwnKTtcblxudmFyIENsYXNzID0ganNndWkuQ2xhc3MsIERhdGFfT2JqZWN0ID0ganNndWkuRGF0YV9PYmplY3QsIENvbGxlY3Rpb24gPSBqc2d1aS5Db2xsZWN0aW9uO1xudmFyIGlzX2RlZmluZWQgPSBqc2d1aS5pc19kZWZpbmVkLCBmcCA9IGpzZ3VpLmZwLCBzdHJpbmdpZnkgPSBqc2d1aS5zdHJpbmdpZnksIHRvZiA9IGpzZ3VpLnRvZjtcbnZhciBjYWxsX211bHRpcGxlX2NhbGxiYWNrX2Z1bmN0aW9ucyA9IGpzZ3VpLmNhbGxfbXVsdGlwbGVfY2FsbGJhY2tfZnVuY3Rpb25zLCBjYWxsX211bHRpID0ganNndWkuY2FsbF9tdWx0aTtcbnZhciBlYWNoID0ganNndWkuZWFjaDtcblxuLy8gU3RhdHVzIHRvIHNlZSBpZiBhIHJlc291cmNlIGhhcyBzdGFydGVkIG9yIG5vdD9cbi8vICBJIHRoaW5rIHJlc291cmNlIHN0YXR1cyBpcyBpbXBvcnRhbnQuXG4vLyAgSG93ZXZlciBzdGF0dXMgbWF5IGVudGFpbCBtb3JlIHRoaW5ncy5cbi8vICAgc3RhdHVzLnBoYXNlXG4vLyAgIHBoYXNlXG5cbi8vIG1ldGEucGhhc2VcblxuLy8gQSByZXNvdXJjZSdzIGNvbnRleHQgbWF0dGVycy5cbi8vICBJdCB3aWxsIGJlIHRoZSBzZXJ2ZXIgcmF0aGVyIHRoYW4gYSBwYWdlIGNvbnRleHQuXG5cblxuXG4vLyBSZXNvdXJjZXMgY2FuIGhhdmUgZXZlbnRzIGFzIHdlbGwuXG4vLyAgTG9vayBpbnRvIGhvdyB0aGUgcHVibGlzaGVyIGRlYWxzIHdpdGggdGhlbS5cblxuXG52YXIgUmVzb3VyY2UgPSBEYXRhX09iamVjdC5leHRlbmQoe1xuICAgIC8vIFRoZSBsaW5rIGJldHdlZW4gdGhlIGFic3RyYWN0IHJlc291cmNlIGFuZCB0aGUgcmVzb3VyY2Ugb24gdGhlIGludGVybmV0IC8gbmV0d29yayAvIGNvbXB1dGVyLlxuICAgIC8vJ2ZpZWxkcyc6IHtcbiAgICAvL1x0Ly8nbWV0YSc6IERhdGFfT2JqZWN0XG4gICAgLy9cdCdtZXRhJzogJ2RhdGFfb2JqZWN0J1xuICAgIC8vfSxcblxuICAgICdpbml0JzogZnVuY3Rpb24oc3BlYykge1xuICAgICAgICAvL1xuICAgICAgICBpZiAoIWlzX2RlZmluZWQoc3BlYykpIHNwZWMgPSB7fTtcblxuICAgICAgICB0aGlzLl9zdXBlcihzcGVjKTtcblxuICAgICAgICBpZiAoaXNfZGVmaW5lZChzcGVjLm5hbWUpKSB7XG4gICAgICAgICAgICAvLyBOZWVkIHRvIGRlYWwgd2l0aCBib3RoIHJlc291cmNlIHByb3BlcnRpZXMgYW5kIGlubmVyIHByb3BlcnRpZXMuXG4gICAgICAgICAgICAvLyAgTm90IHN1cmUgYWJvdXQgaGF2aW5nIHJlc291cmNlLnNldCgnbmFtZScpIG5hbWluZyB0aGUgcmVzb3VyY2UuXG4gICAgICAgICAgICAvLyAgIFNvdW5kcyBPSyBub3JtYWxseSwgYnV0IFJlc291cmNlIG5lZWRzIHRvIGJlIGZsZXhpYmxlLCBlZyBhIHJlc291cmNlIGNvdWxkIHByb3ZpZGVcbiAgICAgICAgICAgIC8vICAgdHJhbnNsYXRpb25zIG9mIGEgd29yayB0byBhIGRpZmZlcmVudCBsYW5ndWFnZSwgc28gZ2V0KCduYW1lJykgbmVlZHMgdG8ganVzdCBiZSBjYWxsaW5nXG4gICAgICAgICAgICAvLyAgIHRoZSByZXNvdXJjZSB3aXRoIHRoYXQgdmFsdWUuXG5cbiAgICAgICAgICAgIC8vIFBlcmhhcHMgc29tZSBraW5kIG9mIGlubmVyIGdldCBhbmQgc2V0P1xuICAgICAgICAgICAgLy8gT3IgaW5uZXIgaXMgdGhlIG5vcm1hbC5cbiAgICAgICAgICAgIC8vICBBbiBvYmplY3QgdG8gcmVwcmVzZW50IGEgcmVzb3VyY2UncyBleHRlcm5hbCBwcm9wZXJ0aWVzP1xuXG4gICAgICAgICAgICAvLyBDb3VsZCBoYXZlIC5uYW1lIGZvciBpdCdzIG5hbWVcbiAgICAgICAgICAgIC8vICBvciAuc2VsZiBmb3IgYSBEYXRhX09iamVjdCB0aGF0IHJlZmVycyB0byBpdHNlbGYuXG4gICAgICAgICAgICAvLyAgb3IgLmlubmVyIG9yIC5yZXNvdXJjZSBmb3IgdGhlIERhdGFfT2JqZWN0IHRoYXQgaXMgdGhlIHJlc291cmNlJ3MgaW5uZXIgZGF0YT9cbiAgICAgICAgICAgIC8vICAuZGF0YVxuXG4gICAgICAgICAgICAvLyBJIGxpa2UgaGF2aW5nIC5nZXQgYW5kIC5zZXQgZm9yIGRlYWxpbmcgd2l0aCB0aGUgcmVzb3VyY2UncyBkYXRhLlxuICAgICAgICAgICAgLy8gIGFuZCBkaWZmZXJlbnQgd2F5cyBmb3IgaW5kZXhpbmcgdGhlIHJlc291cmNlLlxuXG4gICAgICAgICAgICAvLyAubWV0YWRhdGFcblxuICAgICAgICAgICAgLy8gYW5kIG5hbWUgaXMgcGFydCBvZiB0aGUgbWV0YWRhdGEuXG5cbiAgICAgICAgICAgIC8vIHRoaXMuc2V0KCdtZXRhLm5hbWUnKVxuXG4gICAgICAgICAgICAvLyBUaGlzIHdheSB0aGVyZSBpcyBhIC5tZXRhIG9iamVjdCB3aGljaCBob2xkcyB0aGUgbmFtZVxuXG5cblxuXG4gICAgICAgICAgICAvL3RoaXMuc2V0KCdtZXRhLm5hbWUnLCBzcGVjLm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWV0YSA9IG5ldyBEYXRhX09iamVjdCh7XG4gICAgICAgICAgICAnZmllbGRzJzoge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdzdHJpbmcnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEJ1dCBnaXZlIHRoZSByZXNvdXJjZSBuYW1lIGluIHRoZSBzcGVjP1xuICAgICAgICAvLyAgVGhhdCBtYXkgYmUgdGhlIGJlc3Qgd2F5IG9mIGRvaW5nIGl0LCBidXQgaXQncyBub3QgdGhlIEFQSSBmb3Igbm93LlxuXG5cbiAgICAgICAgaWYgKHNwZWMubWV0YSkge1xuICAgICAgICAgICAgdmFyIG1ldGEgPSBzcGVjLm1ldGE7XG4gICAgICAgICAgICBpZiAobWV0YS5uYW1lKSB0aGlzLm1ldGEuc2V0KCduYW1lJywgbWV0YS5uYW1lKTtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ21ldGEubmFtZSAnICsgbWV0YS5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTZXQgdGhlIG1ldGEgdXJsIGluIHRoZSBjbGllbnQgc2lkZSByZXNvdXJjZS5cblxuICAgICAgICBpZiAoaXNfZGVmaW5lZChzcGVjLnN0YXJ0dXBfdHlwZSkpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0KCdzdGFydHVwX3R5cGUnLCBzcGVjLnN0YXJ0dXBfdHlwZSk7XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICAnc3RhcnQnOiBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgICAvLyBjaGVjayB0aGUgcmVxdWlyZW1lbnRzXG5cbiAgICAgICAgLy8gIGNoZWNrIHJlcXVpcmVtZW50cyByZWN1cnNpdmUgLSBjaGVja3MgdGhlIHJlcXVpcmVtZW50cyBvZiBldmVyeXRoaW5nIHJlcXVpcmVkLCBhbmQgaWYgdGhleSBoYXZlIHRoZSBjaGVja19yZXF1aXJlbWVudHMgZnVuY3Rpb24sIGl0IHVzZXMgdGhhdC5cbiAgICAgICAgLy8gICBJIHRoaW5rIHVzaW5nIHRoZSBzeXN0ZW0gb2YgbmFtZXMgQVBJcyB3aWxsIGhlbHAgaGVyZS5cblxuICAgICAgICAvLyBJIHRoaW5rIHRoZSBiYXNlIGNsYXNzIHNob3VsZCByYWlzZSB0aGUgZXZlbnQuXG5cbiAgICAgICAgLy90aGlzLnRyaWdnZXIoJ3N0YXJ0Jyk7XG5cbiAgICAgICAgLy9jb25zb2xlLmxvZyhuZXcgRXJyb3IoKS5zdGFjayk7XG4gICAgICAgIC8vdGhyb3cgJ25vIHN0YXJ0IGZ1bmN0aW9uIGRlZmluZWQgZm9yIHJlc291cmNlIChzdWJjbGFzcyknXG5cbiAgICB9LFxuXG4gICAgLy8gbWVldHNfcmVxdWlyZW1lbnRzXG4gICAgLy8gIGNoZWNrIGlmIGFsbCB0aGUgcHJlcmVxdWlzaXRlIHJlc291cmNlcyBhcmUgYWN0aXZlXG4gICAgLy8gIG1heWJlIGNoZWNrIGZvciBsb2dpbiBzdGF0dXMgaWYgYXBwbGljYWJsZS5cblxuICAgICdtZWV0c19yZXF1aXJlbWVudHMnOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gTGlrZWx5IHdpbGwgYmUgcGFydCBvZiBTdGF0dXNcblxuICAgICAgICAvL3JldHVybiBmYWxzZTtcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLy8gJ2dldCcgd2lsbCBiZSB0aGUgZnVuY3Rpb24gdG8gdXNlLlxuXG4gICAgLy8gbWF5IGhhdmUgdG9Kc29uIC8gdG9fanNvbi5cbiAgICAnZ2V0X2Fic3RyYWN0JzogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgLy8gQWJzdHJhY3RfUmVzb3VyY2UgLSB3b3VsZCBiZSBhIGRlc2NyaXB0aW9uIG9mIGEgcmVzb3VyY2U/XG4gICAgICAgIC8vICBQZXJoYXBzIHdlJ2xsIG9ubHkgbmVlZCBqc29uIGFuZCBqc29uIHNjaGVtYS5cbiAgICAgICAgLy8gIE1ha2luZyB0aGUgZGF0YV9vYmplY3QgYW5kIGNvbGxlY3Rpb24gY29uZm9ybSB0byBqc29uIHNjaGVtYSB3b3VsZCBiZSBuaWNlLlxuICAgICAgICAvLyAgV291bGQgaGF2ZSBzb21ldGhpbmcgdmVyeSBuaWNlIHRvIGRvIHdpdGggY3JlYXRpbmcgYSBndWkgZm9yIGZvcm1zLlxuICAgICAgICAvKlxuXG5cbiAgICAgICAgdmFyIHJlcyA9IG5ldyBBUi5BYnN0cmFjdF9SZXNvdXJjZSh7XG5cbiAgICAgICAgfSlcbiAgICAgICAgKi9cbiAgICB9LFxuXG4gICAgLy8gdGhlIGxhc3QgaXRlbSBpbiB0aGUgc2lnbmF0dXJlIGlzIHRoZSBjYWxsYmFja1xuXG4gICAgJ3NldCc6IGZwKGZ1bmN0aW9uKGEsIHNpZykge1xuXG4gICAgICAgIC8vY29uc29sZS5sb2coJ1Jlc291cmNlLnNldCBzaWcgJyArIHNpZyk7XG4gICAgICAgIC8vY29uc29sZS5sb2coJ1Jlc291cmNlLnNldCBhICcgKyBzdHJpbmdpZnkoYSkpO1xuICAgICAgICB2YXIgbGFzdF9wYXJhbSA9IGFbYS5sIC0gMV07XG4gICAgICAgIHZhciBjYWxsYmFjaztcblxuICAgICAgICBpZiAodG9mKGxhc3RfcGFyYW0pID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gbGFzdF9wYXJhbTtcbiAgICAgICAgICAgIHZhciBhcnJfcGFyYW1zID0gYS5zbGljZSgwLCBhLmwgLSAxKTtcbiAgICAgICAgICAgIHZhciByZXMgPSB0aGlzLl9zdXBlci5hcHBseSh0aGlzLCBhcnJfcGFyYW1zKTtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHJlcyk7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGJ1dCB3aHkgaXMgYSBjYWxsYmFjayBzdGlsbCBuZWVkZWQ/XG4gICAgICAgICAgICAvLyAgYmVjYXVzZSBpbiBzdXBlciwgaXQgcmVxdWlyZXMgYSBjYWxsYmFjayB3aGVuIGl0IGNhbGxzICdnZXQnLCB3aGljaCBpcyB0aGUgbmV3ZXIgZ2V0LlxuXG4gICAgICAgICAgICB2YXIgcmVzID0gdGhpcy5fc3VwZXIuYXBwbHkodGhpcywgYSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9XG5cblxuXG5cbiAgICB9KSxcblxuICAgIC8vIENhbiB3ZSBleHBlY3QgYSBSZXNvdXJjZSB0byByZXR1cm4gaXRzIGRhdGEgYXMgYSBSZXNvdXJjZT9cbiAgICAvLyAgTWF5YmUgbm90IGFsd2F5c1xuXG5cblxuXG4gICAgJ2dldCc6IGZwKGZ1bmN0aW9uKGEsIHNpZykge1xuXG4gICAgICAgIC8vY29uc29sZS5sb2coJ1Jlc291cmNlIGdldCBzaWcnLCBzaWcpO1xuXG4gICAgICAgIC8vIGlmIGl0IGRvZXMgbm90IGhhdmUgYSBmdW5jdGlvbiBpbiB0aGUgc2lnLCBpdCdzIHN5bmNyb25vdXNcblxuICAgICAgICB2YXIgaXNfYXN5bmMgPSBzaWcuaW5kZXhPZignZicpID4gMDtcblxuICAgICAgICBpZiAoaXNfYXN5bmMpIHtcbiAgICAgICAgICAgIHZhciBjYWxsYmFjaztcbiAgICAgICAgICAgIHZhciBsYXN0X3BhcmFtID0gYVthLmwgLSAxXTtcbiAgICAgICAgICAgIGlmICh0b2YobGFzdF9wYXJhbSkgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gbGFzdF9wYXJhbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHZhciBhcnJfcGFyYW1zID0gYS5zbGljZSgwLCBhLmwgLSAxKTtcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdhcnJfcGFyYW1zLmxlbmd0aCAnICsgYXJyX3BhcmFtcy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIC8vIF9zdXBlciB3aXRoIGZwP1xuXG4gICAgICAgICAgICAgICAgLy8gY29udGV4dCB3aXRoIGZwP1xuICAgICAgICAgICAgICAgIC8vIE5lZWQgdG8gc29ydCBvdXQgc3VwZXIgd2l0aCBmcCFcbiAgICAgICAgICAgICAgICAvLyAgVGhvdWdoIHN1cGVyIG1heSB3ZWxsIHVzZSBmcCBhbnl3YXkuXG5cblxuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3RoaXMuX3N1cGVyICcgKyB0aGlzLl9zdXBlcik7XG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygncmVzb3VyY2UgYXJyX3BhcmFtcyAnICsgc3RyaW5naWZ5KGFycl9wYXJhbXMpKTtcbiAgICAgICAgICAgICAgICAvL3ZhciByZXMgPSB0aGlzLl9zdXBlci5hcHBseSh0aGlzLCBhcnJfcGFyYW1zKTtcblxuICAgICAgICAgICAgICAgIC8vIFdlIGNhbiBhcHBseSBhIGNvbGxlY3Rpb24gcmVzb3VyY2UncyBnZXQgYXN5bmNyb25vdXNseT9cbiAgICAgICAgICAgICAgICAvLyAgUG9zc2libHkgdXBncmFkZSBjb2xsZWN0aW9uIGFuZCBkYXRhX29iamVjdCB0byBoYW5kbGUgYXN5bmMgb3BlcmF0aW9ucyAodGhvdWdoIGl0J3Mgbm90IGFzeW5jIGNvZGUpXG5cbiAgICAgICAgICAgICAgICAvLyBpZiBpdCBpcyBhIHJlc291cmNlP1xuICAgICAgICAgICAgICAgIC8vICBoYXZlIGFuIGluZGljYXRvciBvbiBhIGZ1bmN0aW9uIHRvIHNlZSBpZiBpdCBpcyBhc3luYyBvciBub3Q/XG4gICAgICAgICAgICAgICAgLy8gIGFzeW5jaWZ5P1xuXG4gICAgICAgICAgICAgICAgLy9cblxuXG5cbiAgICAgICAgICAgICAgICB2YXIgcmVzID0gdGhpcy5fc3VwZXIuYXBwbHkodGhpcywgYSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcblxuXG5cbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdyZXMgJyArIHN0cmluZ2lmeShyZXMpKTtcbiAgICAgICAgICAgICAgICAvL2NhbGxiYWNrKG51bGwsIHJlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvL3ZhciBzdGFjayA9IG5ldyBFcnJvcigpLnN0YWNrO1xuICAgICAgICAgICAgLy92YXIgbWVzc2FnZSA9ICdSZXNvdXJjZS5nZXQgcmVxdWlyZXMgYSBjYWxsYmFjayAoZXJyLCByZXN1bHQpIGFzIGl0cyBsYXN0IHBhcmFtZXRlcic7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKG1lc3NhZ2UpO1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhzdGFjayk7XG5cbiAgICAgICAgICAgIC8vdGhyb3dcblxuICAgICAgICAgICAgdmFyIHJlcyA9IHRoaXMuX3N1cGVyLmFwcGx5KHRoaXMsIGEpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfVxuXG5cblxuXG4gICAgfSlcblxufSk7XG5cbi8qXG52YXIgV2ViX1Jlc291cmNlID0gUmVzb3VyY2UuZXh0ZW5kKHtcbiAgICAnaW5pdCc6IGZ1bmN0aW9uKHNwZWMpIHtcbiAgICAgICAgdGhpcy5fc3VwZXIoc3BlYyk7XG4gICAgfSxcbiAgICAncmVzcG9uZCc6IGZ1bmN0aW9uKHJlcywgcmVxKSB7XG5cbiAgICB9XG5cbn0pXG5cbnZhciBIdG1sX1Jlc291cmNlID0gV2ViX1Jlc291cmNlLmV4dGVuZCh7XG4gICAgJ2luaXQnOiBmdW5jdGlvbihzcGVjKSB7XG4gICAgICAgIHRoaXMuX3N1cGVyKHNwZWMpO1xuICAgIH1cbn0pXG5cblxudmFyIFJlc291cmNlX0Vycm9yID0gRGF0YV9PYmplY3QuZXh0ZW5kKHtcbiAgICAnaW5pdCc6IGZ1bmN0aW9uKHNwZWMpIHtcbiAgICAgICAgdGhpcy5fc3VwZXIoc3BlYyk7XG5cbiAgICAgICAgaWYgKHNwZWMudGV4dCkge1xuICAgICAgICAgICAgdGhpcy5zZXQoJ3RleHQnLCBzcGVjLnRleHQpO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbnZhciByZXMgPSB7XG4gICAgICAgICdSZXNvdXJjZV9FcnJvcic6IFJlc291cmNlX0Vycm9yLFxuICAgICAgICAvLydSZXNvdXJjZV9Db25uZWN0b3InOiBSZXNvdXJjZV9Db25uZWN0b3IsXG4gICAgICAgICdSZXNvdXJjZSc6IFJlc291cmNlLFxuICAgICAgICAnV2ViJzogV2ViX1Jlc291cmNlLFxuICAgICAgICAnSHRtbCc6IEh0bWxfUmVzb3VyY2Vcbn1cblxucmV0dXJuIHJlcztcbiovXG5cbm1vZHVsZS5leHBvcnRzID0gUmVzb3VyY2U7XG5cdC8vcmV0dXJuIFJlc291cmNlO1xuLy99KTtcbiIsIlxuLy8gd2lsbCBhbHNvIHVzZSB0aGUgY2xpZW50LXJlc291cmNlLXBvb2wuXG4vLyAgVGhpcyBpcyBnb2luZyB0byBiZSBhbiBpbnRlcmVzdGluZyBjbGFzcyB0aGF0IGVuYWJsZXMgdGhlIGNsaWVudCB0byBjb25uZWN0IHRvIHZhcmlvdXMgcmVzb3VyY2VzIG9uIHRoZSBzZXJ2ZXIuXG4vLyAgSXQgbWF5IGhhdmUgYW4gaW50ZXJmYWNlIHRvIGJyb3dzZSAvIGNvbm5lY3QgdG8gdGhlIHJlc291cmNlcyBvbiB0aGUgc2VydmVyIHRoYXQgc2VydmVkIGl0LlxuXG4vLyBNYXliZSBpdCB3aWxsIGRvIGEgZ2V0IHJlcXVlc3QsIHdpdGggaXRzIGF1dGhlbnRpY2F0aW9uLCBwZXJoYXBzIGEga2V5IHRoYXQgd2FzIHNlbnQgZm9yIHRoYXQgc3BlY2lmaWMgcmVxdWVzdC5cbi8vICBXZSB3YW50IHRvIGZpbnMgYSB3YXkgdG8gZXhwb3NlIHJlc291cmNlcyBvbiB0aGUgc2VydmVyIGZvciB0aGUgY2xpZW50IHRvIGFjY2Vzcy5cblxuLy8gQW5kIHRoaXMgaXMgZ29pbmcgdG8gaW5jbHVkZSBhIGNsaWVudC1zaWRlIHJlc291cmNlIHBvb2wuXG5cbi8vIEFub3RoZXIgcHJvYmxlbSB3aXRoIGNpcmN1bGFyIHJlZmVyZW5jZXMgaGVyZS5cblxuLy8gSSB0aGluayB0aGUgcGFnZSBjb250ZXh0IHNob3VsZCBiZSBwYXJ0IG9mIGh0bWwtZW5oXG4vLyAgaHRtbC1lbmggaW5jbHVkaW5nIGNsaWVudC1zaWRlIGVuaGFuY2VtZW50cy5cblxuXG5cbnZhciBqc2d1aSA9IHJlcXVpcmUoJy4vanNndWktaHRtbCcpO1xuXG52YXIgc3RyaW5naWZ5ID0ganNndWkuc3RyaW5naWZ5LCBlYWNoID0ganNndWkuZWFjaCwgYXJyYXlpZnkgPSBqc2d1aS5hcnJheWlmeSwgdG9mID0ganNndWkudG9mO1xudmFyIGZpbHRlcl9tYXBfYnlfcmVnZXggPSBqc2d1aS5maWx0ZXJfbWFwX2J5X3JlZ2V4O1xudmFyIENsYXNzID0ganNndWkuQ2xhc3MsIERhdGFfT2JqZWN0ID0ganNndWkuRGF0YV9PYmplY3QsIEVuaGFuY2VkX0RhdGFfT2JqZWN0ID0ganNndWkuRW5oYW5jZWRfRGF0YV9PYmplY3Q7XG52YXIgZnAgPSBqc2d1aS5mcCwgaXNfZGVmaW5lZCA9IGpzZ3VpLmlzX2RlZmluZWQ7XG52YXIgQ29sbGVjdGlvbiA9IGpzZ3VpLkNvbGxlY3Rpb247XG5cbi8vIFRoZSBjbGllbnQgcGFnZSBjb250ZXh0IHNob3VsZCBiZSBhYmxlIHRvIGdlbmVyYXRlIHNlbGVjdGlvbiBzY29wZXMuXG4vLyAgV2UgYXNrIHRoZSBjb250ZXh0IGZvciBzZWxlY3Rpb24gc2NvcGVzLCBhbmQgdGhlIHNlbGVjdGlvbiBzY29wZXMgaGF2ZSBJRHMgdGhhdCBhcmUgaW5kaXZpZHVhbCB0byB0aGUgY29udGV4dC5cblxuLy8gTm93IHRoaW5raW5nIHRoYXQgdGhlIENsaWVudF9QYWdlX0NvbnRleHQgc2hvdWxkIGFsc28gaG9sZCB0aGUgQ2xpZW50X1Jlc291cmNlX1Bvb2wuXG4vLyAgVGhhdCBjbGllbnQtc2lkZSByZXNvdXJjZSBwb29sIHdvdWxkIGhvbGQgcmVzb3VyY2VzIHRoYXQgYXJlIHVzYWJsZSBjbGllbnQtc2lkZS4gVGhleSB3b3VsZCBsaWtlbHkgaW52b2x2ZSBpbnRlcmFjdGluZyB3aXRoIGEgc2VydmVyLlxuLy8gIFRoZXkgd291bGQgYmUgY2xpZW50LXNpZGUgcHJveGllcyBvZiB0aGUgc2VydmVyLXNpZGUgcmVzb3VyY2UsIHdoaWNoIGdvZXMgdGhyb3VnaCBhIFJlc291cmNlX1B1Ymxpc2hlciB0byBnZXQgaXQgb3V0IG92ZXIgdGhlIG5ldHdvcmsuXG5cbnZhciBDbGllbnRfUmVzb3VyY2VfUG9vbCA9IHJlcXVpcmUoJy4uL3Jlc291cmNlL2NvcmUvY2xpZW50LXBvb2wnKTtcblxuLy8gQWxzbyBzaG91bGQgaGF2ZSB0aGUgbWVhbnMgdG8gc2VuZCBzb2NrcyBtZXNzYWdlcyB0byB0aGUgc2VydmVyLlxuXG4vLyBXYW50IHRoZXJlIHRvIGJlIGEgY2xpZW50IHNvY2tzIHJlc291cmNlLCB3aGljaCBwcm94aWVzIGFsbCBzb2NrcyBjb25uZWN0aW9ucz8/P1xuXG4vLyBPciBwYXJ0aWN1bGFybHkgc2V0IHVwIGEgc29ja3Mgcm91dGVyLlxuXG5cbi8vIE9uIHRoZSBjbGllbnQsIG1heSB3YW50IHRvIHNldCBhIHRhc2sgZm9yIHRoZSBzZXJ2ZXIgcmVzb3VyY2UuXG4vLyAgVGhvdWdoIHRhc2sgc2V0dGluZyBzZWVtcyBsaWtlIGEgcm91bmRhYm91dCB3YXkgb2YgdXNpbmcgY29uc3RyYWluZWQgdmVyYnMgaGVyZS4gRml0cyBpbiB3aXRoIGdyYW1tYXIgT0suXG5cblxuXG4vLyBMZXQncyB3cml0ZSBzb21lIGNvZGUgb24gdGhlIGNsaWVudCB0aGF0IHdvdWxkIHNldCBhIHRhc2sgZm9yIGEgcmVzb3VyY2UuXG4vLyAgTmVlZCBhIFJlc291cmNlIHRoYXQgY2FuIGFjY2VwdCB0YXNrcyB0b28uXG5cbi8vIExpbnV4IFN5c3RlbSByZXNvdXJjZSBmb3IgdGhlIG1vbWVudC5cbi8vICBXaWxsIGhhdmUgaXQgY2FwYWJsZSBvZiBnZXR0aW5nIC8gc2V0dGluZyBMaW51eCBzeXN0ZW0gaW5mb3JtYXRpb24uXG4vLyAgV2lsbCBpbmNsdWRlIHRoZSBjYXBhYmlsaXR5IHRvIHNldCBpdCB0YXNrcy5cblxuLy8gTGV0J3Mga2VlcCB0aGluZ3MgKHNwZWNpZmljIHJlc291cmNlcykgd2l0aGluIHRoZSAnUmVzb3VyY2UnIGRpcmVjdG9yeSwgYXMgaXQncyBhbiBhYnN0cmFjdGlvbiB0aGF0IG1ha2VzIHVzZSBvZiBvdGhlciBwYXJ0cyBvZiB0aGUganNndWkgcGxhdGZvcm0uXG5cblxuXG5cblxuXG5cblxuXG5cblxudmFyIFNlbGVjdGlvbl9TY29wZSA9IHJlcXVpcmUoJy4vc2VsZWN0aW9uLXNjb3BlJyk7XG5cblxuLy9jb25zb2xlLmxvZygnanNndWkuUGFnZV9Db250ZXh0JywganNndWkuUGFnZV9Db250ZXh0KTtcbnZhciBDbGllbnRfUGFnZV9Db250ZXh0ID0ganNndWkuUGFnZV9Db250ZXh0LmV4dGVuZCh7XG4gICAgJ2luaXQnOiBmdW5jdGlvbihzcGVjKSB7XG4gICAgICAgIHNwZWMgPSBzcGVjIHx8IHt9O1xuXG5cbiAgICAgICAgdGhpcy5fc3VwZXIoc3BlYyk7XG4gICAgICAgIC8vdGhpcy5zZXQoJ2RvY3VtZW50Jywgc3BlYy5kb2N1bWVudCk7XG4gICAgICAgIHRoaXMuZG9jdW1lbnQgPSBzcGVjLmRvY3VtZW50IHx8IGRvY3VtZW50O1xuXG4gICAgICAgIC8vIE5vdCBzbyBzdXJlIGFib3V0IGNyZWF0aW5nIHRoZSByZXNvdXJjZSBwb29sIG9yIHJlcXVpcmluZyB0aGUgcmVzb3VyY2VzLlxuICAgICAgICAvLyAgQ291bGQgaGF2ZSBwcm9ibGVtcyB3aXRoIGRlcGVuZGVuY2llcy5cblxuXG4gICAgICAgIC8vIG1hcF9jb250cm9sc1xuXG4gICAgICAgIC8vIG1hcF9lbHNcblxuICAgICAgICAvLyBUaGUgY29udGV4dCB3aWxsIGhhdmUgYSBtYXAgb2YgZWxlbWVudHMgYnkgdGhlaXIganNndWkgaWRzLlxuICAgICAgICAvLyAgVGhpcyB3aWxsIGJlIG5lZWRlZCBmb3IgYWN0aXZhdGlvbiBpbiBzb21lIHBsYWNlcy5cbiAgICAgICAgLy8gICBJdCBzZWVtcyBub3QgdG8gYmUgbmVlZGVkIChzbyBmYXIpIG9uIHRoZSBzZXJ2ZXIuXG5cblxuXG5cblxuXG5cbiAgICAgICAgLy92YXIgcmVzb3VyY2VfcG9vbCA9IG5ldyBDbGllbnRfUmVzb3VyY2VfUG9vbCgpO1xuICAgICAgICAvL3RoaXMucG9vbCA9IHJlc291cmNlX3Bvb2w7XG5cbiAgICAgICAgLy9yZXNvdXJjZV9wb29sLnN0YXJ0KCk7XG4gICAgICAgIC8vIHNvIHRoZSBwb29sIHByb2JhYmx5IHdvbid0IGhhdmUgbG9hZGVkIHdoZW4gY29udHJvbHMgZ2V0IGFjdGl2YXRlZC5cblxuICAgICAgICAvLyBBZGQgdGhlIHJlc291cmNlX3Bvb2wgaW50byB0aGUgcGFnZSBjb250ZXh0IGF0IGEgbGF0ZXIgb2NjYXNpb24uXG4gICAgICAgIC8vICBUaGUgYmFzaWMgaHRtbCBjbGllbnQgd2lsbCBub3QgbmVlZCByZXNvdXJjZS5cbiAgICAgICAgLy8gIFJlc291cmNlIHJlcXVpcmVzIHNvbWUgaHRtbCBmdW5jdGlvbmFsaXR5IHRob3VnaC5cbiAgICAgICAgdGhpcy5yZXNvdXJjZV9wb29sID0gbmV3IENsaWVudF9SZXNvdXJjZV9Qb29sKHt9KTtcblxuICAgICAgICB0aGlzLm1hcF9lbHMgPSB7fTtcblxuXG4gICAgICAgIC8vIFRoZSBpdGVtIElEcyBjb3VsZCBiZSBoYW5kbGVkIGhlcmUuLi4gdXNlIHRoZSBsb2NhbCB2YXJpYWJsZSBjbG9zdXJlIGhlcmUuXG4gICAgICAgIHRoaXMuc2VsZWN0aW9uX3Njb3BlcyA9IHt9O1xuXG4gICAgICAgIHRoaXMuc2VsZWN0aW9uX3Njb3BlX2lkX2NvdW50ZXIgPSAwO1xuXG4gICAgfSxcbiAgICAnbmV3X3NlbGVjdGlvbl9zY29wZSc6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBjcmVhdGUgdGhlIHNlbGVjdGlvbiBzY29wZSwgd2l0aCBhbiBhc3NpZ25lZCBpZFxuXG4gICAgICAgIHZhciByZXMgPSBuZXcgU2VsZWN0aW9uX1Njb3BlKHtcbiAgICAgICAgICAgICdjb250ZXh0JzogdGhpcyxcbiAgICAgICAgICAgICdpZCc6IHRoaXMuc2VsZWN0aW9uX3Njb3BlX2lkX2NvdW50ZXIrK1xuICAgICAgICB9KVxuXG4gICAgICAgIHJldHVybiByZXM7XG5cbiAgICB9LFxuXG4gICAgJ2dldF9zZWxlY3Rpb25fc2NvcGVfYnlfaWQnOiBmdW5jdGlvbihpZCkge1xuICAgICAgICBpZiAoIXRoaXMuc2VsZWN0aW9uX3Njb3Blc1tpZF0pIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uX3Njb3Blc1tpZF0gPSBuZXcgU2VsZWN0aW9uX1Njb3BlKHtcbiAgICAgICAgICAgICAgICAnY29udGV4dCc6IHRoaXMsXG4gICAgICAgICAgICAgICAgJ2lkJzogaWRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGlvbl9zY29wZXNbaWRdO1xuICAgIH0sXG5cblxuICAgICdib2R5JzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBkb2MgPSB0aGlzLmRvY3VtZW50O1xuICAgICAgICAvL2NvbnNvbGUubG9nKCdkb2MnLCBkb2MpO1xuICAgICAgICB2YXIgYm9kID0gZG9jLmNoaWxkTm9kZXNbMF0uY2hpbGROb2Rlc1sxXTtcbiAgICAgICAgLy92YXIgYm9kID0gZG9jLmJvZHk7XG4gICAgICAgIC8vY29uc29sZS5sb2coJ2JvZCcsIGJvZCk7XG5cbiAgICAgICAgdmFyIGJvZF9pZCA9IGJvZC5nZXRBdHRyaWJ1dGUoJ2RhdGEtanNndWktaWQnKTtcbiAgICAgICAgLy9jb25zb2xlLmxvZygnYm9kX2lkJywgYm9kX2lkKTtcbiAgICAgICAgdmFyIHJlcyA9IHRoaXMubWFwX2NvbnRyb2xzW2JvZF9pZF07XG4gICAgICAgIC8vY29uc29sZS5sb2coJ3JlcycsIHJlcyk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgLy9nZXQgaWQncyBvZiBwYXJ0aWN1bGFyIHR5cGVzIG9mIGl0ZW1zLi4uXG5cbn0pO1xuLy8gQWxzbyB3YW50IGEgRmlsZV9TZXJ2ZXIuXG4vLyAgV2FudCBmaWxlcyB0byBiZSBzZXJ2ZWQgZnJvbSBhIHBhcnRpY3VsYXIgcGF0aCwgYXMgYSByZXNvdXJjZSBpbiB0aGUgVVJMIHN5c3RlbS5cbi8vICBXaWxsIGJlIGFibGUgdG8gcG9zdCBmaWxlcyB0aGVyZSB3aXRoIHRoZSByaWdodCBwZXJtaXNzaW9uLlxubW9kdWxlLmV4cG9ydHMgPSBDbGllbnRfUGFnZV9Db250ZXh0O1xuXHQvKlxuXHRyZXR1cm4gQ2xpZW50X1BhZ2VfQ29udGV4dDtcblxuXG59KTtcblxuKi9cbiIsIi8vIG9iamVjdCB2aWV3ZXJcblxuXG4vL2lmICh0eXBlb2YgZGVmaW5lICE9PSAnZnVuY3Rpb24nKSB7IHZhciBkZWZpbmUgPSByZXF1aXJlKCdhbWRlZmluZScpKG1vZHVsZSkgfVxuXG4vLyBodG1sLWVuaCBkZXBlbmRpbmcgb24gQ29udGV4dF9NZW51P1xuXHRcblxuXG4vL2RlZmluZShbXCIuLi8uLi9qc2d1aS1odG1sXCIsIFwiLi9tZW51LW5vZGVcIl0sXG5cdC8vZnVuY3Rpb24oanNndWksIE1lbnVfTm9kZSkge1xuXG4gICAgICAgIHZhciBqc2d1aSA9IHJlcXVpcmUoJy4uLy4uL2pzZ3VpLWh0bWwnKTtcbiAgICAgICAgdmFyIE1lbnVfTm9kZSA9IHJlcXVpcmUoJy4vbWVudS1ub2RlJyk7XG5cdFx0XG5cdFx0dmFyIHN0cmluZ2lmeSA9IGpzZ3VpLnN0cmluZ2lmeSwgZWFjaCA9IGpzZ3VpLmVhYywgdG9mID0ganNndWkudG9mLCBpc19kZWZpbmVkID0ganNndWkuaXNfZGVmaW5lZDtcblx0XHR2YXIgQ29udHJvbCA9IGpzZ3VpLkNvbnRyb2w7XG5cblx0XHR2YXIgZ3JvdXAgPSBqc2d1aS5ncm91cDtcblxuXHRcdHZhciBDb250ZXh0X01lbnUgPSBDb250cm9sLmV4dGVuZCh7XG5cblx0XHRcdC8vIGNvdWxkIGhhdmUgYSB0aXRsZSBmaWVsZC5cblx0XHRcdC8vJ2ZpZWxkcyc6IHtcblx0XHRcdC8vXHQndGl0bGUnOiBTdHJpbmdcblx0XHRcdC8vfSxcblxuICAgICAgICAgICAgLy8gTmVlZCB0byBjYWxsIHRoZSByaWdodCBldmVudHMgd2hlbiB0aGUgaXRlbSBnZXRzIGNob3NlbiAvIGNsaWNrZWQgb24uXG5cblxuXG5cblx0XHRcdC8vIG1heWJlIGFkZCBiZWZvcmUgbWFrZSB3b3VsZCBiZSBiZXR0ZXIuIGFkZCB3aWxsIHByb2JhYmx5IGJlIHVzZWQgbW9yZS5cblx0XHRcdCdpbml0JzogZnVuY3Rpb24oc3BlYywgYWRkLCBtYWtlKSB7XG5cdFx0XHRcdHRoaXMuX3N1cGVyKHNwZWMpO1xuXG5cdFx0XHRcdHRoaXMuX190eXBlX25hbWUgPSAnY29udGV4dF9tZW51JztcblxuXHRcdFx0XHR0aGlzLnNldCgnZG9tLmF0dHJpYnV0ZXMuY2xhc3MnLCAnY29udGV4dCBtZW51Jyk7XG5cdFx0XHRcdGNvbnNvbGUubG9nKCdDb250ZXh0X01lbnUgaW5pdCBzcGVjLmVsJywgc3BlYy5lbCk7XG5cblx0XHRcdFx0Ly8gVGhlbiBpbnNpZGUgdGhlIG1lbnUgd2Ugd2FudCBhIHZhcmlldHkgb2YgbWVudSBub2Rlcy5cblxuXG5cblx0XHRcdFx0Ly8gTmVlZCB0byBkZWFsIHdpdGggZGlmZmVyZW50IGNvbnN0cnVjdGlvbiBzdGFnZXMgYmV0dGVyLlxuXHRcdFx0XHQvLyAgQ29uc3RydWN0IGFuZCByZW5kZXIuLi5cblx0XHRcdFx0Ly8gIEZvciB0aGUgbW9tZW50IHdpbGwgc3RpY2sgd2l0aCB3aGV0aGVyIHRoZXJlIGlzIGFuIGVsZW1lbnQgZ2l2ZW4gaW4gdGhlIHNwZWMuXG5cblx0XHRcdFx0Ly8gTWF5IGJlIGdpdmVuIHRoZSBtZW51IG9iamVjdCwgYW5kIG5lZWQgdG8gY3JlYXRlIHRoZSBtZW51IG5vZGVzIGZyb20gdGhhdC5cblxuXHRcdFx0XHQvL2lmICghc3BlYy5hYnN0cmFjdCAmJiAhc3BlYy5lbCkge1xuXHRcdFx0XHRpZiAoIXNwZWMuYWJzdHJhY3QpIHtcblx0XHRcdFx0XHQvLyB0aGUgYmFyIGF0IHRoZSB0b3AuXG5cblx0XHRcdFx0XHQvLyBJdCdzIGdvaW5nIHRvIGFjdCBhcyBhIGRyYWcgaGFuZGxlIGZvciB0aGlzLlxuXHRcdFx0XHRcdC8vICBUaGUgZHJhZyBzeXN0ZW0gd2lsbCBpbnRlZ3JhdGUgd2l0aCB2YXJpb3VzIGJhbmRzIC8gd2luZG93IHBvc2l0aW9ucy5cblxuXHRcdFx0XHRcdC8vIE1heWJlIGEgcHJvcGVydHkgdG8gc2F5IHRoYXQgaXQncyBkb2NrYWJsZS5cblx0XHRcdFx0XHRcblxuXHRcdFx0XHRcdC8vdmFyIHRvcF9iYXIgPSBuZXcgQ29udHJvbCh7XG5cdFx0XHRcdFx0Ly9cdCdjb250ZXh0JzogdGhpcy5fY29udGV4dFxuXHRcdFx0XHRcdC8vfSlcblx0XHRcdFx0XHQvL3RvcF9iYXIuc2V0KCdkb20uYXR0cmlidXRlcy5jbGFzcycsICd0aXRsZSBiYXInKTtcblx0XHRcdFx0XHQvL3RoaXMuYWRkKHRvcF9iYXIpO1xuXG5cdFx0XHRcdFx0Ly8gXG5cblx0XHRcdFx0XHR2YXIgb2JqID0gc3BlYy52YWx1ZTtcblxuXHRcdFx0XHRcdGNvbnNvbGUubG9nKCdtZW51IG9iaicsIG9iaik7XG5cblx0XHRcdFx0XHQvLyBDcmVhdGUgdGhlIG1lbnUgbm9kZXMgZnJvbSBpdC5cblx0XHRcdFx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cblx0XHRcdFx0XHR2YXIgdG9iaiA9IHRvZihvYmopO1xuXHRcdFx0XHRcdGNvbnNvbGUubG9nKCd0b2JqJywgdG9iaik7XG5cdFx0XHRcdFx0aWYgKHRvYmogPT0gJ29iamVjdCcpIHtcblx0XHRcdFx0XHRcdGVhY2gob2JqLCBmdW5jdGlvbih2LCBrZXkpIHtcblx0XHRcdFx0XHRcdFx0dmFyIG1lbnVfbm9kZSA9IG1ha2UoTWVudV9Ob2RlKHtcblx0XHRcdFx0XHRcdFx0XHQndGV4dCc6IGtleSxcblx0XHRcdFx0XHRcdFx0XHQndmFsdWUnOiB2LFxuXHRcdFx0XHRcdFx0XHRcdCdtZW51JzogdGhhdFxuXHRcdFx0XHRcdFx0XHR9KSlcblx0XHRcdFx0XHRcdFx0dGhhdC5hZGQobWVudV9ub2RlKTtcblxuXHRcdFx0XHRcdFx0fSlcblxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAodG9iaiA9PSAnYXJyYXknKSB7XG5cdFx0XHRcdFx0XHRlYWNoKG9iaiwgZnVuY3Rpb24odiwgaW5kZXgpIHtcblxuXHRcdFx0XHRcdFx0XHR2YXIgdHYgPSB0b2Yodik7XG5cdFx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKCd0dicsIHR2KTtcblxuXHRcdFx0XHRcdFx0XHQvLyB0aGVuIGlmIGl0J3Mgc3RyaW5nIGFuZCBmdW5jdGlvbi4uLlxuXG5cdFx0XHRcdFx0XHRcdHZhciB2c2lnID0ganNndWkuZ2V0X2l0ZW1fc2lnKHYsIDEpO1xuXHRcdFx0XHRcdFx0XHRjb25zb2xlLmxvZygndnNpZycsIHZzaWcpO1xuXG5cdFx0XHRcdFx0XHRcdGlmICh2c2lnID09ICdbcyxmXScpIHtcblx0XHRcdFx0XHRcdFx0XHR2YXIgdGV4dCA9IHZbMF07XG5cdFx0XHRcdFx0XHRcdFx0dmFyIGl0ZW1fY2FsbGJhY2sgPSB2WzFdO1xuXG5cdFx0XHRcdFx0XHRcdFx0dmFyIG1lbnVfbm9kZSA9IG1ha2UoTWVudV9Ob2RlKHtcblx0XHRcdFx0XHRcdFx0XHRcdCd0ZXh0JzogdGV4dCxcblx0XHRcdFx0XHRcdFx0XHRcdCd2YWx1ZSc6IHRleHQsXG5cdFx0XHRcdFx0XHRcdFx0XHQnbWVudSc6IHRoYXRcblx0XHRcdFx0XHRcdFx0XHR9KSlcblx0XHRcdFx0XHRcdFx0XHR0aGF0LmFkZChtZW51X25vZGUpO1xuXHRcdFx0XHRcdFx0XHR9XG5cblxuXHRcdFx0XHRcdFx0XHQvKlxuXHRcdFx0XHRcdFx0XHR2YXIgbWVudV9ub2RlID0gbWFrZShNZW51X05vZGUoe1xuXHRcdFx0XHRcdFx0XHRcdCd0ZXh0Jzoga2V5LFxuXHRcdFx0XHRcdFx0XHRcdCd2YWx1ZSc6IHYsXG5cdFx0XHRcdFx0XHRcdFx0J21lbnUnOiB0aGF0XG5cdFx0XHRcdFx0XHRcdH0pKVxuXHRcdFx0XHRcdFx0XHR0aGF0LmFkZChtZW51X25vZGUpO1xuXHRcdFx0XHRcdFx0XHQqL1xuXHRcdFx0XHRcdFx0XHRjb25zb2xlLmxvZygndicsIHYpO1xuXHRcdFx0XHRcdFx0fSlcblx0XHRcdFx0XHRcdC8vdGhyb3cgJ3N0b3AnO1xuXG5cdFx0XHRcdFx0fVxuXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdlbmQgaW5pdCBDb250ZXh0X01lbnUnLCB0aGlzKTtcblxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygndGhpcy5fLmNvbnRlbnQuX2Fyci5sZW5ndGggJyArIHRoaXMuXy5jb250ZW50Ll9hcnIubGVuZ3RoKTtcblxuXG4gICAgICAgICAgICAgICAgICAgIC8vdGhyb3cgJ3N0b3AnO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIHN0b3AgaGVyZSwgdGhlIG1lbnUgc2VlbXMgdG8gaGF2ZSB0aGUgcmlnaHQgbnVtYmVyIG9mIG5vZGVzLlxuICAgICAgICAgICAgICAgICAgICAvLyBIb3dldmVyLCB3aGVuIGl0IGdldHMgYWRkZWQgaW50byB0aGUgYWN0aXZlIGRvY3VtZW50LCBpdCBzZWVtcyBhcyB0aG91Z2ggY29udGVudCBvZiB0aGUgY29udGV4dF9tZW51IGdldHMgZHVwbGljYXRlZFxuICAgICAgICAgICAgICAgICAgICAvLyAgVGhlcmUgaXMgYSBzZXF1ZW5jZSBvZiBldmVudHMgd2hlbiBpdCBnZXRzIGFkZGVkIHRvIHRoZSBkb2N1bWVudC5cbiAgICAgICAgICAgICAgICAgICAgLy8gICBJdCBjb3JyZWN0bHkgc2VlbXMgdG8gYWRkIGl0IHRvIHRoZSBET00gYW5kIHJlbmRlciB0aGUgaW5pdGlhbCBjb250ZW50LlxuICAgICAgICAgICAgICAgICAgICAvLyAgIEhvd2V2ZXIsIGl0IHRoZW4gc2VlbXMgdG8gZHVwbGljYXRlIHRoZSBpbnRlcm5hbCBjb250ZW50LlxuICAgICAgICAgICAgICAgICAgICAvLyAgICBJdCBoYXMgZ290IHRoZSBzYW1lIGl0ZW1zIGxpc3RlZCBtb3JlIHRoYW4gb25jZS5cbiAgICAgICAgICAgICAgICAgICAgLy8gICAgTWF5IGJlIGFibGUgdG8gaGVscCB0cmFjayB0aGlzIGRvd24gYnkgbWFraW5nIGFuIGVycm9yIGlmIHlvdSB0cnkgdG8gYWRkIGFuIGl0ZW0gdGhhdCdzIGFscmVhZHkgdGhlcmUuXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICBQb3NzaWJseSB3b3VsZCByZXF1aXJlIG1haW50YWluaW5nIGEgbWFwIG9mIHdoYXQgdGhlIGNoaWxkIGVsZW1lbnRzIGFyZSBjYWxsZWQuXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgVGhhdCB3b3VsZCBiZSBwb3NzaWJsZSB3aXRoIHRoZSBDb2xsZWN0aW9uIHN5c3RlbSwgd2hlcmUgaXQgZ2V0cyB0aGVpciBJRHMgYXMgdGhleSBhcmUgYWRkZWQuXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gTWF5YmUgdHJhY2sgdGhlIGFkZGluZyBvZiBjb250ZW50IGJldHRlciB3aXRoIGNvbnNvbGUgbG9nZ2luZz9cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblx0XHRcdFx0XHQvLyB0aGVuIHdpdGggdGhlIG1lbnUgb2JqIHdlIGNvbnN0cnVjdCB0aGUgbWVudVxuXG5cdFx0XHRcdFx0Ly8gTWVudSBkZWFsdCB3aXRoIGFzIG9iamVjdHMgb3IgYXJyYXlzP1xuXHRcdFx0XHRcdC8vICBQb3NzaWJseSBhcyBpdCBoYXMgbW9yZSBleHBsaWNpdCBvcmRlcmluZz9cblx0XHRcdFx0XHQvL3ZhciBleG9iaiA9IFtcblx0XHRcdFx0XHQvL1x0WydGaWxlJywgWydPcGVuJywgJ0Nsb3NlJ11dXG5cdFx0XHRcdFx0Ly9dXG5cblx0XHRcdFx0XHQvLyBEb25lIHdpdGgga2V5cyBjb3VsZCBiZSBlYXNpZXI/XG5cdFx0XHRcdFx0Ly8gIE1heWJlIGFycmF5cyBhcmUgY2xlYXJlciB0aG91Z2guXG5cblxuXG5cdFx0XHRcdFx0Ly90aHJvdyAnc3RvcCc7XG5cblx0XHRcdFx0XHRcblxuXHRcdFx0XHRcdFxuXHRcdFx0XHR9XG5cblx0XHRcdH0sXG5cdFx0XHQnYWN0aXZhdGUnOiBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdwcmUgc3VwZXIgdGhpcy5fLmNvbnRlbnQuX2Fyci5sZW5ndGggJyArIHRoaXMuXy5jb250ZW50Ll9hcnIubGVuZ3RoKTtcblxuICAgICAgICAgICAgICAgIC8vIFNvIGl0IHNlZW1zIHRoZSBwcm9ibGVtIGxpZXMgd2l0aGluIHRoZSBhY3RpdmF0ZSBmdW5jdGlvbi5cblxuXHRcdFx0XHR0aGlzLl9zdXBlcigpO1xuXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ3Bvc3Qgc3VwZXIgdGhpcy5fLmNvbnRlbnQuX2Fyci5sZW5ndGggJyArIHRoaXMuXy5jb250ZW50Ll9hcnIubGVuZ3RoKTtcblxuICAgICAgICAgICAgICAgIC8vIElmIHBvc3NpYmxlLCB0aGlzIHNob3VsZCBiZSBhdXRvbWF0aWNhbGx5IGFjdGl2YXRlZCB3aGVuIGl0J3MgcHV0IGludG8gdGhlIGRvY3VtZW50LlxuICAgICAgICAgICAgICAgIC8vICBCdXQgZG9lcyB0aGF0IGJyZWFrIHNvbWV0aGluZyBlbHNlP1xuXG5cdFx0XHRcdGNvbnNvbGUubG9nKCdhY3RpdmF0ZSBDb250ZXh0X01lbnUnKTtcblxuXHRcdFx0XHQvLyBXaGlsZSBpdCBpcyBvcGVuLCBjbGlja2luZyBvdXRzaWRlIG9mIHRoZSBtZW51IHNob3VsZCBjbG9zZSBpdC5cblxuXHRcdFx0XHQvLyBSZXNwb25kIHRvIGNsaWNraW5nIGFueXdoZXJlLlxuXHRcdFx0XHQvLyAgSWYgaXQncyBub3QgYSBsZWFmIG5vZGUgb2YgdGhlIHRyZWUsIHdpbGwgb3BlbiBmdXJ0aGVyIG5lc3RlZCBtZW51LlxuXG5cdFx0XHRcdC8vdmFyIGN0cmxfaHRtbF9yb290ID0gdGhpcy5fY29udGV4dC5jdHJsX2RvY3VtZW50O1xuXHQgICAgICAgIFx0dmFyIGJvZHkgPSB0aGlzLl9jb250ZXh0LmJvZHkoKTtcblxuXHQgICAgICAgIFx0dmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgICAgICAgICAgICAgLy8gTGlzdGVuIGZvciBzZWxlY3QgZXZlbnRzIG9uIHRoZSBub2Rlcy5cbiAgICAgICAgICAgICAgICAvLyAgVGhlIG1lbnUgaGFzIGEgcHVibGlzaC9zdWJzY3JpYmUgc3lzdGVtIGZvciB0aGUgbWVudSBub2RlcycgZXZlbnRzLlxuXG4gICAgICAgICAgICAgICAgLy8gY3JlYXRlIGV2ZW50IGxpc3RlbmVycyBvbiB0aGUgbm9kZXMuXG4gICAgICAgICAgICAgICAgLy8gIG5lZWQgYSB3YXkgb2YgZ2V0dGluZyBhbGwgb2YgdGhlIG5vZGVzLlxuXG4gICAgICAgICAgICAgICAgLy8gaGVpcmljaGljYWwgaXRlcmF0aW9uLCBsaWtlIC5hbmNlc3RvclxuICAgICAgICAgICAgICAgIC8vIC5maW5kIChsaWtlIGpxdWVyeSlcbiAgICAgICAgICAgICAgICAvLyAuZGVzY2VuZGFudHNcbiAgICAgICAgICAgICAgICAvLyAuZGVzY1xuXG4gICAgICAgICAgICAgICAgdmFyIG5vZGVzID0gdGhpcy5kZXNjZW5kYW50cygnbWVudV9ub2RlJyk7XG5cbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnbm9kZXMnLCBub2Rlcyk7XG5cblxuXG5cblxuXG5cblxuXG5cblx0ICAgICAgICBcdC8vIHRoaXMub25lX21vdXNlZG93bl9hbnl3aGVyZVxuXG5cdCAgICAgICAgXHRcblxuXG5cblxuXG5cblx0XHRcdFx0Ly8gXG5cblx0XHRcdH0sXG5cdFx0XHQnY2xvc2VfYWxsJzogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGNvbnNvbGUubG9nKCdtZW51IGNsb3NlX2FsbCcpO1xuXG5cdFx0XHRcdC8vIG5lZWQgdG8gZG8gdGhpcyByZWN1cnNpdmVseSBJIHRoaW5rLlxuXHRcdFx0XHQvLyAgY291bGQgY2FsbCB0aGlzIHJlY3Vyc2l2ZWx5IG9uIGFsbCBub2Rlcy5cblxuXHRcdFx0XHR0aGlzLmdldCgnY29udGVudCcpLmVhY2goZnVuY3Rpb24oaSwgdikge1xuXHRcdFx0XHRcdC8vY29uc29sZS5sb2coJ2knLCBpKTtcblx0XHRcdFx0XHQvL2NvbnNvbGUubG9nKCd2Jywgdik7XG5cblx0XHRcdFx0XHR2LmNsb3NlX2FsbCgpO1xuXHRcdFx0XHR9KTtcblxuXG5cdFx0XHR9XG5cdFx0fSlcblxuXG5cblx0XHQvL3JldHVybiBDb250ZXh0X01lbnU7XG5cbiAgICAgICAgLy8gYnV0IHRoZW4gaXQgd291bGQgbmVlZCB0byBiZSBicm93c2VyaWZpZWQgaW4gdGhlIGNsaWVudD9cblxuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IENvbnRleHRfTWVudTtcblx0Ly99XG4vLyk7IiwiXG52YXIganNndWkgPSByZXF1aXJlKCcuLi8uLi9qc2d1aS1odG1sJyk7XG5cbnZhciBzdHJpbmdpZnkgPSBqc2d1aS5zdHJpbmdpZnksIGVhY2ggPSBqc2d1aS5lYWMsIHRvZiA9IGpzZ3VpLnRvZjtcbnZhciBDb250cm9sID0ganNndWkuQ29udHJvbDtcblxudmFyIE1lbnVfTm9kZSA9IENvbnRyb2wuZXh0ZW5kKHtcbiAgICAvLyBmaWVsZHMuLi4gdGV4dCwgdmFsdWUsIHR5cGU/XG4gICAgLy8gIHR5cGUgY291bGQgc3BlY2lmeSBzb21lIGtpbmQgb2YgdmFsaWRhdGlvbiwgb3IgYWxzbyAncGFzc3dvcmQnLlxuXG4gICAgLy8gc2luZ2xlIGZpZWxkP1xuXG4gICAgLy8gQWN0dWFsbHkgaGF2aW5nIGEgZGlmZmVyZW50IGNvbnRlbnQ/XG4gICAgLy8gIE9yIHVzZSBpbm5lcl9jb250ZW50LlxuXG4gICAgLy8gTWVudSBub2RlIGhhdmluZyBleHBhbmRlZCBhbmQgY29udHJhY3RlZCBzdGF0ZXMuXG5cbiAgICAvLyBNZW51IE5vZGUgaGFzIGFuIGltYWdlIGFuZCBzb21lIHRleHQsIGFuZCBhIGNvbnRyYWluZXIgY29udHJvbCBmb3Igb3RoZSBNZW51IG5vZGVzLlxuICAgIC8vICBDYW4gYmUgY29sbGFwc2VkIHNvIHRoYXQgdGhlIGludGVybmFsIGl0ZW1zIGRvbid0IHNob3dcblxuICAgIC8vJ2ZpZWxkcyc6IFtcbiAgICAgICAgLy9bJ3RleHQnLCBTdHJpbmddXG5cblxuICAgIC8vXSxcblxuICAgIC8vJ2ZpZWxkcyc6IHtcbiAgICAvL1x0J2ltZ19zcmMnOiAnc3RyaW5nJyxcbiAgICAvL1x0J3RleHQnOiAnc3RyaW5nJ1xuICAgIC8vfSxcblxuICAgIC8vICBhbmQgY2FuIGhhdmUgb3RoZXIgZmllbGRzIHBvc3NpYmx5LlxuXG5cbiAgICAnaW5pdCc6IGZ1bmN0aW9uKHNwZWMsIGFkZCwgbWFrZSkge1xuICAgICAgICAvLyBXb250IGZpZWxkcyBoYXZlIGJlZW4gc2V0P1xuXG4gICAgICAgIHRoaXMuX3N1cGVyKHNwZWMpO1xuXG4gICAgICAgIC8vIENhbiB0YWtlIGFuIGltYWdlXG4gICAgICAgIC8vIENhbiB0YWtlIHNvbWUgdGV4dC5cbiAgICAgICAgLy8gIFRoYXQncyBhbGwgSSdsbCBoYXZlIGluIHRoZSBNZW51IG5vZGUgZm9yIG5vdy5cbiAgICAgICAgdGhpcy5fX3R5cGVfbmFtZSA9ICdtZW51X25vZGUnO1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgIGlmICghdGhpcy5fYWJzdHJhY3QpIHtcbiAgICAgICAgICAgIGlmICghc3BlYy5lbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0KCdkb20uYXR0cmlidXRlcy5jbGFzcycsICdtZW51LW5vZGUnKTtcbiAgICAgICAgICAgICAgICB2YXIgc3BlY19zdGF0ZSA9IHNwZWMuc3RhdGUsIHN0YXRlO1xuXG4gICAgICAgICAgICAgICAgdmFyIG1haW5fY29udHJvbCA9IG1ha2UoQ29udHJvbCh7ICdjbGFzcyc6ICdtYWluJyB9KSk7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGQobWFpbl9jb250cm9sKTtcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCcqKioqIHNwZWMuaW1nX3NyYycsIHNwZWMuaW1nX3NyYyk7XG4gICAgICAgICAgICAgICAgaWYgKHNwZWMuaW1nX3NyYykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW1nX3NyYyA9IHRoaXMuZ2V0KCdpbWdfc3JjJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzcGVjLnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXQoJ3RleHQnLCBzcGVjLnRleHQpO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBzcGFuID0gbWFrZShqc2d1aS5zcGFuKHt9KSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy92YXIgdGV4dCA9IHRoaXMuZ2V0KCd0ZXh0Jyk7XG4gICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3RleHQnLCB0ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygndG9mIHRleHQnLCB0b2YodGV4dCkpO1xuXG4gICAgICAgICAgICAgICAgICAgIHNwYW4uYWRkKHNwZWMudGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIG1haW5fY29udHJvbC5hZGQoc3Bhbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBtZW51ID0gc3BlYy5tZW51O1xuICAgICAgICAgICAgICAgIGlmIChtZW51KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0KCdtZW51JywgbWVudSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGlubmVyX2NvbnRyb2wgPSBtYWtlKENvbnRyb2woeyAnY2xhc3MnOiAnaW5uZXIgaGlkZGVuJyB9KSk7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGQoaW5uZXJfY29udHJvbCk7XG5cbiAgICAgICAgICAgICAgICAvLyBJbm5lciBtYXkgbm90IGp1c3QgYmUgdGhlIHRpdGxlLlxuXG4gICAgICAgICAgICAgICAgdGhpcy5zZXQoJ2lubmVyX2NvbnRyb2wnLCBpbm5lcl9jb250cm9sKTtcblxuICAgICAgICAgICAgICAgIC8vaW5uZXJfY29udHJvbC5oaWRlKCk7XG5cbiAgICAgICAgICAgICAgICAvL3ZhciBpbm5lcl9jb250cm9sX2NvbnRlbnQgPSBpbm5lcl9jb250cm9sLmdldCgnY29udGVudCcpO1xuICAgICAgICAgICAgICAgIC8vIHJlZmVyZW5jZSB0byBhIG1lbnUgY29udHJvbC5cbiAgICAgICAgICAgICAgICAvLyBtYXliZSB0YWtlICd2YWx1ZScgaGVyZVxuICAgICAgICAgICAgICAgIGlmIChzcGVjLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGRlcGVuZGluZyBvbiB0aGUgdHlwZSBvZiBvYmosIHdvcmsgZGlmZmVyZW50bHkuXG4gICAgICAgICAgICAgICAgICAgIC8vICBhcnJheSBvZiBzdHJpbmdzLCBqdXN0IG1ha2UgdGhvc2UgbWVudSBpdGVtcy5cblxuICAgICAgICAgICAgICAgICAgICB2YXIgb2JqX21lbnUgPSBzcGVjLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdF9vYmpfbWVudSA9IHRvZihvYmpfbWVudSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCd0X29ial9tZW51JywgdF9vYmpfbWVudSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRfb2JqX21lbnUgPT0gJ2FycmF5Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWFjaChvYmpfbWVudSwgZnVuY3Rpb24odikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1ha2UgYSBuZXcgbWVudSBub2RlIHdpdGggdGhhdCBhcyB0aGUgdmFsdWU/XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHYgPSB0b2Yodik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR2ID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5ldyBub2RlIHdpdGggdGV4dCwgbm8gaW5uZXIgbm9kZXMuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5lc3RlZF9tZW51X25vZGUgPSBtYWtlKE1lbnVfTm9kZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAndGV4dCc6IHYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbWVudSc6IG1lbnVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbm5lcl9jb250cm9sLmFkZChuZXN0ZWRfbWVudV9ub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGN0cmxfZmllbGRzID0ge1xuICAgICAgICAgICAgICAgICAgICAnaW5uZXJfY29udHJvbCc6IGlubmVyX2NvbnRyb2wuX2lkKCksXG4gICAgICAgICAgICAgICAgICAgICdtYWluX2NvbnRyb2wnOiBtYWluX2NvbnRyb2wuX2lkKCksXG4gICAgICAgICAgICAgICAgICAgICdtZW51Jzogc3BlYy5tZW51Ll9pZCgpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gdXNlIGRpZmZlcmVudCBxdW90ZXMuLi5cblxuICAgICAgICAgICAgICAgIHRoaXMuc2V0KCdkb20uYXR0cmlidXRlcy5kYXRhLWpzZ3VpLWN0cmwtZmllbGRzJywgc3RyaW5naWZ5KGN0cmxfZmllbGRzKS5yZXBsYWNlKC9cIi9nLCBcIidcIikpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHNwZWNfc3RhdGUpIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBvcGVuIGFuZCBjbG9zZWRcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNwZWNfc3RhdGUgPT0gJ29wZW4nIHx8IHNwZWNfc3RhdGUgPT0gJ2Nsb3NlZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0gdGhpcy5zZXQoJ3N0YXRlJywgc3BlY19zdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyAnc3BlYy5zdGF0ZSBleHBlY3RzIFwib3BlblwiIG9yIFwiY2xvc2VkXCIuJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlID0gdGhpcy5zZXQoJ3N0YXRlJywgJ29wZW4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgICdhY3RpdmF0ZSc6IGZ1bmN0aW9uKCkge1xuXG5pZiAoIXRoaXMuX19hY3RpdmUpIHtcbiAgdGhpcy5fc3VwZXIoKTtcblxuICAgICAgICB2YXIgaW5uZXJfY29udHJvbCA9IHRoaXMuZ2V0KCdpbm5lcl9jb250cm9sJyk7XG4gICAgICAgIHZhciBtYWluX2NvbnRyb2wgPSB0aGlzLmdldCgnbWFpbl9jb250cm9sJyk7XG4gICAgICAgIHZhciBtZW51ID0gdGhpcy5nZXQoJ21lbnUnKTtcblxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgLy8gcmFpc2UgYSBzZWxlY3QgZXZlbnQgb24gdGhlIG1lbnUuXG4gICAgICAgIC8vIGFuZCBpZiB0aGVyZSBhcmUgb3RoZXIgbm9kZXMgaW5zaWRlLFxuXG4gICAgICAgIC8vIFVwb24gYWN0aXZhdGlvbiwgd2UgbWF5IG5vdCBoYXZlIHRoZSBib2R5IG5vZGUgdGhvdWdoLlxuICAgICAgICAvLyAgUGVyaGFwcyBkZWxheSB0aGlzP1xuICAgICAgICAvLyBNYXkgYmUgZ29vZCB0byBoYXZlIHRoZSBjb250ZXh0IGdldCB0aGUgYm9keSBjb250cm9sIGVhcmxpZXIsIHdpdGggdGhlIGJvZHkgY29udHJvbCBzcGVjaWZpY2FsbHkgbWFkZSAmIGFjdGl2YXRlZCBlYXJsaWVyIG9uLlxuXG5cbiAgICAgICAgLy8gQ2FuJ3QgaGF2ZSBlYWNoIG5vZGUgY2hlY2sgZm9yIGEgbW91c2Vkb3duIGFueXdoZXJlLlxuICAgICAgICAvLyAgQmV0dGVyIHRvIGhhdmUgdGhlIGNvbnRleHQgbWVudSBpdHNlbGYgZG8gdGhlIGNoZWNraW5nLlxuXG5cbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgLypcbiAgICAgICAgICAgIHRoYXQub25lX21vdXNlZG93bl9hbnl3aGVyZShmdW5jdGlvbihlX21vdXNlZG93bikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdvbWRhJywgZV9tb3VzZWRvd24pO1xuXG4gICAgICAgICAgICAgICAgdmFyIHdpdGhpbl90aGlzID0gZV9tb3VzZWRvd24ud2l0aGluX3RoaXM7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ3dpdGhpbl90aGlzJywgd2l0aGluX3RoaXMpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHdpdGhpbl90aGlzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdvdWxkIGJlIG5pY2UgdG8gaGF2ZSBhIHRhcmdldF9jb250cm9sIGFzIHBhcnQgb2YgdGhlIG1vdXNlIGV2ZW50LlxuXG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvL3RoYXQuY2xvc2VfYWxsKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgKi9cbiAgICAgICAgfSwgMCk7XG5cblxuICAgICAgICAvKlxuXG4gICAgICAgIG1haW5fY29udHJvbC5vbignY2xpY2snLCBmdW5jdGlvbihlX2NsaWNrKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnaW5uZXJfY29udHJvbCcsIGlubmVyX2NvbnRyb2wpO1xuXG4gICAgICAgICAgICB2YXIgaWNjID0gaW5uZXJfY29udHJvbC5nZXQoJ2NvbnRlbnQnKTtcblxuXG4gICAgICAgICAgICB2YXIgaWNjbCA9IGljYy5sZW5ndGgoKTtcblxuICAgICAgICAgICAgaWYgKGljY2wgPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gTWF5YmUgbm90LCBpZiBpdCdzIG5lc3RlZC5cbiAgICAgICAgICAgICAgICAvLyAgQ291bGQgY2xvc2Ugb3RoZXIgYnJhbmNoZXMuXG4gICAgICAgICAgICAgICAgbWVudS5jbG9zZV9hbGwoKTtcblxuXG4gICAgICAgICAgICAgICAgaW5uZXJfY29udHJvbC5zaG93KCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdpbm5lciBsZWFmIG5vZGUgY2xpY2tlZCcpO1xuXG4gICAgICAgICAgICAgICAgLy8gbWVhbnMgd2UgY2xvc2UgYWxsIG9wZW4gbm9kZXMsIGFuZCByZWdpc3RlciBpdGVtIGFzIGJlaW5nIHNlbGVjdGVkLlxuXG4gICAgICAgICAgICAgICAgLy8gcmFpc2UgYSBzZWxlY3RlZCBvciBpdGVtLXNlbGVjdGVkPyBldmVudC5cblxuICAgICAgICAgICAgICAgIC8vIG9yIGNoYW5nZSBldmVudD8gcHJvYiBub3QuXG5cbiAgICAgICAgICAgICAgICAvLyByYWlzZSBzZWxlY3QgZXZlbnQuXG4gICAgICAgICAgICAgICAgbWVudS5jbG9zZV9hbGwoKTtcbiAgICAgICAgICAgICAgICBtZW51LnJhaXNlKCdzZWxlY3QnLCB0aGF0KTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0pXG4gICAgICAgICovXG5cbiAgICAgICAgLy8gdGhlbiB3aGVuIHRoZSBtYWluIHBhcnQgaXMgY2xpY2tlZCwgc2hvdyB0aGUgaW5uZXIgY29udHJvbC5cbn1cblxuXG5cblxuXG4gICAgfSxcbiAgICAnY2xvc2VfYWxsJzogZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdtZW51LW5vZGUgY2xvc2VfYWxsJyk7XG5cbiAgICAgICAgLy8gbmVlZCB0byBkbyB0aGlzIHJlY3Vyc2l2ZWx5IEkgdGhpbmsuXG4gICAgICAgIC8vICBjb3VsZCBjYWxsIHRoaXMgcmVjdXJzaXZlbHkgb24gYWxsIG5vZGVzLlxuXG4gICAgICAgIC8vXG5cbiAgICAgICAgdmFyIGlubmVyX2NvbnRyb2wgPSB0aGlzLmdldCgnaW5uZXJfY29udHJvbCcpO1xuXG4gICAgICAgIGlubmVyX2NvbnRyb2wuZ2V0KCdjb250ZW50JykuZWFjaChmdW5jdGlvbihpLCB2KSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnaScsIGkpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ3YnLCB2KTtcblxuXG5cbiAgICAgICAgICAgIHZhciB0biA9IHYuX190eXBlX25hbWU7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygndG4nLCB0bik7XG5cbiAgICAgICAgICAgIGlmICh0biA9PSAnbWVudV9ub2RlJykge1xuICAgICAgICAgICAgICAgIHYuY2xvc2VfYWxsKCk7XG4gICAgICAgICAgICB9XG5cblxuXG4gICAgICAgICAgICAvL3YuY2xvc2VfYWxsKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlubmVyX2NvbnRyb2wuaGlkZSgpO1xuICAgICAgICB0aGlzLnNldCgnc3RhdGUnLCAnY2xvc2VkJyk7XG5cblxuICAgIH0sXG4gICAgJ2Nsb3NlJzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBpbm5lcl9jb250cm9sID0gdGhpcy5nZXQoJ2lubmVyX2NvbnRyb2wnKTtcbiAgICAgICAgaW5uZXJfY29udHJvbC5oaWRlKCk7XG4gICAgICAgIHRoaXMuc2V0KCdzdGF0ZScsICdjbG9zZWQnKTtcbiAgICB9LFxuICAgICdvcGVuJzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBpbm5lcl9jb250cm9sID0gdGhpcy5nZXQoJ2lubmVyX2NvbnRyb2wnKTtcbiAgICAgICAgaW5uZXJfY29udHJvbC5zaG93KCk7XG4gICAgICAgIHRoaXMuc2V0KCdzdGF0ZScsICdvcGVuJyk7XG4gICAgfVxuXG5cbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBNZW51X05vZGU7XG4iLCIvLyBqc2d1aS1jbGllbnRcclxuXHJcbi8vIHJlcXVpcmUgYSB3aG9sZSBidW5jaCBvZiB0aGluZ3NcclxuXHJcblxyXG4vLyBuZWVkIHRvIGhhdmUgdGhlIGV4dHJhIGluZm9ybWF0aW9uIHRvIGluaXRpYWxpemUgdGhlIHZhcmlvdXMgb2JqZWN0cy5cclxuLy8gIHBhcnQgb2YgdGhlIHNlcnZlci1zaWRlIHJlbmRlcmluZyB3b3VsZCBiZSBpZGVudGlmeWluZyBvYmplY3RzIGFuZCByZWxldmFudCBwcm9wZXJ0aWVzIHRvIHNlbmQgdG8gdGhlIGNsaWVudC5cclxuLy8gIGZvciBleGFtcGxlLCB0aGF0IHNvbWV0aGluZyBpcyBhIHBhcnRpY3VsYXIgY29udHJvbC5cclxuXHJcbi8vICBpZGVudGlmeSBpZHMgYnkgY29udHJvbC5cclxuLy8gdGhlbiB0aGVyZSBpcyBzZXBhcmF0ZSBjbGllbnQtc2lkZSBjb2RlLi4uXHJcbi8vICBvciBjb250cm9scyAocGVyaGFwcyBhZHZhbmNlZCBvbmVzKSBoYXZlIGdvdCB2YXJpb3VzIGV2ZW50cyBvbiB0aGVtIHRoYXQgcmVzcG9uZCB0byBjbGllbnQtc2lkZSBpbywgYnV0IGNhbiBnZXQgdXNlZCBvbiB0aGUgc2VydmVyIGFzIHdlbGwsXHJcbi8vICAgcGVyaGFwcyB3aXRoIHRoZXNlIGNsaWVudC1zaWRlIGV2ZW50cyBjYWxsZWQgZm9yIHRlc3RpbmcuXHJcbi8vIEFwcGxpY2F0aW9uIGNvZGUgd291bGQgbGlrZWx5IGJ1aWxkIHZpZXdzIGJvdGggb24gdGhlIHNlcnZlciBhbmQgdGhlIGNsaWVudCwgYW5kIGhhdmUgdGhlIGludGVyYWN0b24gZG9uZSBvbiB0aGUgY2xpZW50LCB3aGlsZSBhbHNvIHVzaW5nIHRoZVxyXG4vLyAgZm9yIGl0cyBBUEksIGRlYWxpbmcgd2l0aCBsYXJnZXIgYW1vdW50cyBvZiBkYXRhIHRoYW4gaW4gdGhlIGluaXRpYWwgdmlldy5cclxuXHJcbi8vIFdpbGwgdXNlIHBhcnRpY3VsYXIgY2xpZW50IGZpbGVzLi4uXHJcbi8vICBNYXliZSBoYXZlIGFsbCB0aGUgbG9naWMgaW4gb25lIGNvbXBvbmVudC5cclxuLy8gIFdpbGwgaGF2ZSBkaWZmZXJlbnQgbWVhbnMgb2YgbG9hZGluZyBhbmQgYWN0aXZhdGlvbiBhcyB3ZWxsLlxyXG4vLyAgIE1heSBiZSBlYXNpZXIgd2hlbiB0aGUgd2hvbGUganNndWkgaXMgaW4gb25lIGZpbGUsIG9yIGF0IGxlYXN0IGEgbGFyZ2UgY29yZS5cclxuXHJcbi8vIExpa2VseSB0byBpbmNsdWRlIGEgY2xpZW50LXNpZGUgY29tcG9uZW50LlxyXG4vLyAgTGlrZSBsb2FkIGEgcGFydGljdWxhciBmaWxlIHdoaWNoIHdpbGwgaW5jbHVkZSBzb21lIHBhcnRpY3VsYXIganNndWkgY2xpZW50IGNvZGUuXHJcblxyXG4vLyBOZWVkcyBhIENsaWVudF9QYWdlX0NvbnRleHRcclxuXHJcbi8vIFBlcmhhcHMgd2UgbmVlZCBhIFJlc291cmNlX0NsaWVudCBhcyB3ZWxsLlxyXG5cclxuLy8gV2FudCB0aGUgaHRtbCBjbGllbnQgdG8gYmUgYWJsZSB0byBhY2Nlc3MgcmVzb3VyY2VzLlxyXG4vLyBXYW50IHRoZSBjbGllbnQgdG8gaGF2ZSB0aGUgcmlnaHQgcmVzb3VyY2UgcG9vbCBvbiB0aGUgY2xpZW50LlxyXG5cclxuLy8gV2FudCB0byBiZSBhYmxlIHRvIGNvZGUgY2xpZW50IGFwcHMgcmVsYXRpdmVseSBzaW1wbHksIHVzaW5nIHRoZSBjbGllbnQtc2lkZSByZXNvdXJjZSBzeXN0ZW0gdG8gYWNjZXNzIHJlc291cmNlcyBvbiB0aGUgc2VydmVyIC8gb24gc2VydmVycy5cclxuXHJcbi8vIFNob3VsZCBtYXliZSBzZW5kIG92ZXIgcmVzb3VyY2UgaW5mbyBmcm9tIHRoZSBzZXJ2ZXIuXHJcbi8vIFJlc291cmNlIG1hbmlmZXN0IG9yIGRlc2NyaXB0aW9uLlxyXG5cclxuLy8gUmVzb3VyY2VzIGNvdWxkIGFsc28gc2hhcmUgYSBkZXNjcmlwdGlvbi5cclxuXHJcbi8vIEhvd2V2ZXIsIGRvbid0IHdhbnQgdGhpcyB0byBnZXQgdG9vIGNvbXBsaWNhdGVkLlxyXG4vLyAgV2l0aCB0aGUgcGFnZSwgY2FuIHNlcnZlIGEgc2V0IG9mIHJlc291cmNlcyBmb3IgaXQgdG8gdXNlLlxyXG4vLyAgVGhhdCB3b3VsZCBiZSBhbiBpbmxpbmUgc2NyaXB0LCBidXQgdGhlbiBtYXliZSB3ZSBuZWVkIHRvIHNlcnZlIHRoZSBhcHAncyBKUyBhbG9uZ3NpZGUgaXQuXHJcblxyXG4vLyBXaWxsIG5lZWQgdG8gaGF2ZSB0aGUgcmVzb3VyY2UgY2xpZW50IGFjY2VzcyB0aGUgcmVzb3VyY2UgZm9yIGl0cyBvd24gVVJMLlxyXG4vLyAgKG9yIHRlbGwgaXQgd2hpY2ggVVJMIHRvIGxvb2sgZm9yIHRoZSByZXNvdXJjZShzKSBhdClcclxuXHJcbi8vIFNlbmRpbmcgYSByZXNvdXJjZS1jbGllbnQgd291bGQgZW5hYmxlIHRoZSByZXNvdXJjZSB0byBiZSBhY2Nlc3NlZC5cclxuXHJcbi8vIEZvciB0aGUgc2ltcGxlIGNhc2Ugb2YgdGhlIGNsb2NrIHJlc291cmNlLCB3ZSB3YW50IGl0IHRvIGRpc3BsYXkgdGhlIHJlc291cmNlJ3MgZGF0YS5cclxuXHJcbi8vIEltcG9ydGFudCB0byBhdm9pZCBib2lsZXJwbGF0ZSB3aGlsZSBjb2RpbmcsIG1ha2luZyBpdCBlYXN5IHRvIHNlcnZlIHNvbWUgZGF0YS5cclxuXHJcbi8vIFRob3VnaCB0aGUgY2xpZW50IHNpZGUgcmVzb3VyY2Ugc3lzdGVtIHdpbGwgYmUgdGhlcmUgYXMgY29kZSwgaXQgd291bGQgYmUgZ29vZCB0byBoYXZlIHRoaW5ncyBhdXRvbWF0aWNhbGx5IGluc3RhbnRpYXRlZC5cclxuXHJcbi8vIE5lZWQgYSByZXNvdXJjZSBjbGllbnQgY29udHJvbC5cclxuXHJcbi8vIGpzZ3VpLWh0bWwtcmVzb3VyY2UtY2xpZW50XHJcbi8vICBUaGF0IHdvdWxkIGFsc28gaGF2ZSByZXNvdXJjZXMsIGFuZCB3b3VsZCBzdGFydCB1cCB0aGUgcmVzb3VyY2UgcG9vbCBhbmQgY2xpZW50IHBhZ2UgY29udGV4dC5cclxuLy8gIE5vdCBzdXJlIGhvdyB1c2VmdWwgdGhlIGNsaWVudCBjb2RlIHdvdWxkIGJlIHdpdGhvdXQgdGhlIHJlc291cmNlIHBvb2wsIGJ1dCBpdCdzIGJldHRlciB0byBrZWVwIHRoaW5ncyBtb3JlIG1vZHVsYXIuXHJcblxyXG5cclxuXHJcbi8vIFRoZSBub3JtYWwgY2hpZW5kIHNob3VsZCBoYXZlIGEgcGFnZV9jb250ZXh0IGF0IGxlYXN0Li4uXHJcblxyXG4vLyBqc2d1aS1odG1sLXJlc291cmNlLWNsaWVudFxyXG4vLyAgVGhhdCB3b3VsZCBiZSBhIHBhZ2UgdGhhdCBjb25uZWN0cyBiYWNrIHRvIHRoZSAuanNvbiBmb3IgdGhlIHBhZ2UgaXQgd2FzIHNlcnZlZCBmcm9tLlxyXG4vLyAgQWxzbyB3b3VsZCBjb25uZWN0IHRvIHRoZSB3ZWJzb2NrZXQgY29ubmVjdGlvbi5cclxuXHJcbi8vIE1heSBoYXZlIGpzZ3VpLWh0bWwtcG9vbGVkLXJlc291cmNlcy1jbGllbnQgYXMgd2VsbCBhdCBzb21lIHBvaW50LlxyXG4vLyAgV2FudCBpdCBzbyB0aGF0IHRoZSByZXNvdXJjZXMgd2hpY2ggYXJlIG9uIHRoZSBzZXJ2ZXIgY2FuIGJlIHN1YnNjcmliZWQgdG8gdXNpbmcgYSBzaW5nbGUgd2Vic29ja2V0IGNvbm5lY3Rpb24uXHJcblxyXG4vLyBUaGUgcmVzb3VyY2UgY2xpZW50IHdvdWxkIGNvbm5lY3QgYmFjayB3aXRoIGEgd2Vic29ja2V0IGNvbm5lY3Rpb24uXHJcbi8vICBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IHJlc291cmNlcyBhcmUgcHVibGlzaGVkIHRoYXQgd2F5LlxyXG5cclxuLy8gV2lsbCBiZSBwb3NzaWJsZSB0byBoYXZlIGEgc2luZ2xlIGNvbm5lY3Rpb24gcGVyIHJlc291cmNlLlxyXG4vLyAgVGhhdCdzIGhvdyBpdCB3aWxsIHN0YXJ0LlxyXG5cclxuLy8gV2hlbiBjb25uZWN0aW5nIHRvIG11bHRpcGxlIHJlc291cmNlcyBvdmVyIHdlYnNvY2tldHMsIHdpbGwgZG8gc28gdGhyb3VnaCB0aGUgc2VydmVyJ3MgcmVzb3VyY2UgcG9vbC5cclxuLy8gIFRoZSBzZXJ2ZXIgd2lsbCBub3RpZnkgdGhlIGNsaWVudCBvZiByZXNvdXJjZSBldmVudHMgdGhhdCBpdCBoYXMgc3Vic2NyaWJlZCB0by5cclxuXHJcbi8vIE5lZWQgdG8gZ2V0IHRoZSByZWFsLXRpbWUgdHJhbnNmZXIgb2YgaW5mbyB3b3JraW5nIHNvb24gb24gYSBiYXNpYyBsZXZlbCwgc2hhcmluZyBjbG9jayBkYXRhLlxyXG5cclxuLy8gV2lsbCB0aGVuIGhhdmUgaXQgc2hhcmluZyBtb3JlIGNvbXBsZXggYW5kIHZhcmllZCBkYXRhIGF0IHNvbWUgcG9pbnQgc29vbiBhZnRlci5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG4vKlxyXG5cclxuaWYgKHR5cGVvZiBkZWZpbmUgIT09ICdmdW5jdGlvbicpIHtcclxuICAgIHZhciBkZWZpbmUgPSByZXF1aXJlKCdhbWRlZmluZScpKG1vZHVsZSk7XHJcbn07XHJcblxyXG4qL1xyXG5cclxuLy8gUmF0aGVyIHRoYW4ganVzdCBqc2d1aS1odG1sLWVuaCwgaXQgd291bGQgYmUgZ29vZCB0byBsb2FkIGEganNndWkgbW9kdWxlIHRoYXQgaGFzIGdvdCBhIGxvdCBvZiBjb250cm9sc1xyXG4vLyAgYW5kIHBvc3NpYmx5IHJlc291cmNlcyBidWlsdCBpbi5cclxuXHJcbi8vIGpzZ3VpLldpbmRvd1xyXG4vLyBqc2d1aS5DYWxlbmRhclxyXG4vLyBqc2d1aS5EYXRlX1JhbmdlX0VkaXRvclxyXG5cclxuLy8gSSB0aGluayBtYWtpbmcgYSBnZW5lcmFsIHB1cnBvc2Ugc2V0IG9mIHRvb2xzIHdvdWxkIGJlIHF1aXRlIGEgZ29vZCBpZGVhXHJcblxyXG5cclxuXHJcbi8vICBzbyB0aGF0J3MgYXZhaWxhYmxlXHJcblxyXG5cclxuXHJcbi8vIGpzZ3VpLWh0bWwtdG9vbGtpdFxyXG4vLyBqc2d1aS1odG1sLXdpdGgtY29udHJvbHNcclxuXHJcbi8vIFdhbnQgYSBmYWlybHkgbGFyZ2Ugc2V0IG9mIGNvbnRyb2xzIHRvIGNvbWUgaW4gdGhlIGJ1bmRsZS5cclxuXHJcblxyXG5cclxuXHJcbi8qXHJcblxyXG5kZWZpbmUoW1wiLi9qc2d1aS1odG1sLWVuaFwiLCBcIi4vY2xpZW50LXBhZ2UtY29udGV4dFwiLCBcIi4uL3Jlc291cmNlL2NvcmUvY2xpZW50LXBvb2xcIl0sXHJcbi8vZGVmaW5lKFtcIi4vanNndWktaHRtbFwiXSxcclxuZnVuY3Rpb24gKGpzZ3VpLCBDbGllbnRfUGFnZV9Db250ZXh0LCBDbGllbnRfUmVzb3VyY2VfUG9vbCkge1xyXG5cclxuICAgICovXHJcbnZhciBqc2d1aSA9IHJlcXVpcmUoJy4vanNndWktaHRtbC1lbmgnKTtcclxudmFyIENsaWVudF9QYWdlX0NvbnRleHQgPSByZXF1aXJlKCcuL2NsaWVudC1wYWdlLWNvbnRleHQnKTtcclxudmFyIENsaWVudF9SZXNvdXJjZV9Qb29sID0gcmVxdWlyZSgnLi4vcmVzb3VyY2UvY29yZS9jbGllbnQtcG9vbCcpO1xyXG5cclxudmFyIGZwID0ganNndWkuZnA7XHJcbi8valF1ZXJ5LCBjYW52YXMgYW5kIHRoZSBhcHAvc3ViIG1vZHVsZSBhcmUgYWxsXHJcbi8vbG9hZGVkIGFuZCBjYW4gYmUgdXNlZCBoZXJlIG5vdy5cclxuXHJcbi8vY29uc29sZS5sb2coJ3J1bm5pbmcgY2xpZW50IGZ1bmN0aW9uLicpO1xyXG5cclxuLy8gQXQgdGhpcyBwb2ludCBjb3VsZCBkbyB2YXJpb3VzIHRoaW5ncyB0byBhY3RpdmF0ZSB0aGUgZG9jdW1lbnQuXHJcblxyXG4vLyBIb3dldmVyLCB3ZSBjb3VsZCBoYXZlIGEgcGFydCBvZiB0aGUgZmlsZSB0aGF0IGdldHMgcmVwbGFjZWQgd2l0aCBsb2NhbCB2YXJpYWJsZXMuXHJcbi8vICBUaGV5IGNvdWxkIGJlIHdyaXR0ZW4gaGVyZSBhcyBKU09OIGJlZm9yZSB0aGUgZmlsZSBnZXRzIHNlcnZlZCAtIHdpdGggdGhlIGZpbGUgYmVpbmcgZ2l2ZW4gYSBzcGVjaWFsIFVSTD9cclxuXHJcbi8vIEkgdGhpbmsgaW5jbHVkaW5nIHRoZSBsb2NhbCB2YXJpYWJsZXMgaW4gdGhlIHBhZ2UgaXRzZWxmIG1heSBiZSBtZXN0LiBObyBuZWVkIGZvciBkZWFsaW5nIHdpdGggYW5vdGhlciBKYXZhU3ZpcHQgZmlsZS5cclxuLy8gIENvdWxkIHBvc3NpYmx5IGNvbXByZXNzIHRoZW0gaW4gYSBuZWF0IHdheSwgbGlrZSBiYXNlNjQuXHJcblxyXG4vLyBDb250cm9scyB3aWxsIGRvIGEgZmFpciBiaXQgd2l0aCB0aGVpciBjbGllbnQtc2lkZSBjb2RlLi4uXHJcbi8vICBCdXQgaXQgd2lsbCBiZSBpbXBvcnRhbnQgdG8gZ2V0IHByb3BlcnRpZXMgb3ZlciB0byB0aGUgY2xpZW50LlxyXG4vLyAgRGF0YSBhdHRyaWJ1dGVzIHdvdWxkIGJlIGEgcG9zc2liaWxpdHkgdG9vLlxyXG5cclxuLy8gQ2xpZW50IHNpZGUgcmVzb3VyY2VzIHRvbz8gRG9uJ3QgdGhpbmsgc28sIGNsaWVudCBzaWRlIHJlc291cmNlIG5lZWRzIHRoaXMuXHJcblxyXG4vLyAgQWxzbyBjYXBhYmlsaXR5IGZvciBkb2luZyBIVFRQIHJlcXVlc3QgZWFzaWx5LlxyXG4vLyAganNndWkuaHR0cCgncG9zdCcsIHVybCwgY2FsbGJhY2spO1xyXG5cclxudmFyIG1ha2VIdHRwT2JqZWN0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICB0cnkge3JldHVybiBuZXcgWE1MSHR0cFJlcXVlc3QoKTt9XHJcbiAgICBjYXRjaCAoZXJyb3IpIHt9XHJcbiAgICB0cnkge3JldHVybiBuZXcgQWN0aXZlWE9iamVjdChcIk1zeG1sMi5YTUxIVFRQXCIpO31cclxuICAgIGNhdGNoIChlcnJvcikge31cclxuICAgIHRyeSB7cmV0dXJuIG5ldyBBY3RpdmVYT2JqZWN0KFwiTWljcm9zb2Z0LlhNTEhUVFBcIik7fVxyXG4gICAgY2F0Y2ggKGVycm9yKSB7fVxyXG5cclxuICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBjcmVhdGUgSFRUUCByZXF1ZXN0IG9iamVjdC5cIik7XHJcbn1cclxuXHJcblxyXG5cclxuanNndWkuaHR0cCA9IGZwKGZ1bmN0aW9uKGEsIHNpZykge1xyXG5cclxuICAgIC8vIHdlIG1heSB3YW50IHRvIGRvIGFuIEhUVFAgcG9zdCBpbnN0ZWFkLCBwZXJoYXBzIHBvc3RpbmcgYSBkb2N1bWVudC5cclxuXHJcbiAgICB2YXIgbWV0aG9kID0gJ0dFVCc7XHJcbiAgICB2YXIgdXJsLCBjYWxsYmFjaywgYm9keSA9IG51bGw7XHJcbiAgICBpZiAoc2lnID09ICdbcyxmXScpIHtcclxuICAgICAgICB1cmwgPSBhWzBdO1xyXG4gICAgICAgIGNhbGxiYWNrID0gYVsxXTtcclxuICAgIH1cclxuICAgIGlmIChzaWcgPT0gJ1tzLHMsZl0nKSB7XHJcbiAgICAgICAgdXJsID0gYVswXTtcclxuICAgICAgICBtZXRob2QgPSBhWzFdLnRvVXBwZXJDYXNlKCk7XHJcbiAgICAgICAgY2FsbGJhY2sgPSBhWzJdO1xyXG4gICAgfVxyXG4gICAgaWYgKHNpZyA9PSAnW3MscyxzLGZdJykge1xyXG4gICAgICAgIHVybCA9IGFbMF07XHJcbiAgICAgICAgbWV0aG9kID0gYVsxXS50b1VwcGVyQ2FzZSgpO1xyXG4gICAgICAgIGJvZHkgPSBhWzJdO1xyXG4gICAgICAgIGNhbGxiYWNrID0gYVszXTtcclxuICAgIH1cclxuICAgIGlmIChzaWcgPT0gJ1tzLHMsYSxmXScpIHtcclxuICAgICAgICB1cmwgPSBhWzBdO1xyXG4gICAgICAgIG1ldGhvZCA9IGFbMV0udG9VcHBlckNhc2UoKTtcclxuICAgICAgICBib2R5ID0gSlNPTi5zdHJpbmdpZnkoYVsyXSk7XHJcbiAgICAgICAgY2FsbGJhY2sgPSBhWzNdO1xyXG4gICAgfVxyXG4gICAgaWYgKHNpZyA9PSAnW3MscyxvLGZdJykge1xyXG4gICAgICAgIHVybCA9IGFbMF07XHJcbiAgICAgICAgbWV0aG9kID0gYVsxXS50b1VwcGVyQ2FzZSgpO1xyXG4gICAgICAgIGJvZHkgPSBKU09OLnN0cmluZ2lmeShhWzJdKTtcclxuICAgICAgICBjYWxsYmFjayA9IGFbM107XHJcbiAgICB9XHJcbiAgICB2YXIgcmVxdWVzdCA9IG1ha2VIdHRwT2JqZWN0KCk7XHJcblxyXG4gICAgcmVxdWVzdC5vcGVuKG1ldGhvZCwgdXJsLCB0cnVlKTtcclxuXHJcbiAgICBpZiAobWV0aG9kLnRvVXBwZXJDYXNlKCkgPT0gJ1BPU1QnICYmIGJvZHkpIHtcclxuICAgICAgICAvL2NvbnNvbGUubG9nKCdib2R5JywgYm9keSk7XHJcbiAgICAgICAgcmVxdWVzdC5zZW5kKGJvZHkpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXF1ZXN0LnNlbmQobnVsbCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmVxdWVzdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBpZiAocmVxdWVzdC5yZWFkeVN0YXRlID09IDQpIHtcclxuICAgICAgICAgICAgLy8gUGVyaGFwcyBwYXJzZSB0aGF0Li4uXHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3JlcXVlc3QnLCByZXF1ZXN0KTtcclxuXHJcbiAgICAgICAgICAgIHZhciBjb250ZW50X3R5cGUgPSByZXF1ZXN0LmdldFJlc3BvbnNlSGVhZGVyKCdDb250ZW50LVR5cGUnKTtcclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnY29udGVudF90eXBlJywgY29udGVudF90eXBlKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChjb250ZW50X3R5cGUgPT0gJ2FwcGxpY2F0aW9uL2pzb24nKSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCBKU09OLnBhcnNlKHJlcXVlc3QucmVzcG9uc2VUZXh0KSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCByZXF1ZXN0LnJlc3BvbnNlVGV4dCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH07XHJcbn0pO1xyXG5cclxuLy8gVGhlIHBhZ2UgbmVlZHMgdG8gZ2V0IGFjdGl2YXRlZC5cclxuXHJcbmNvbnNvbGUubG9nKCdSdW5uaW5nIGpzZ3VpLWh0bWwtY2xpZW50Jyk7XHJcblxyXG5qc2d1aS5DbGllbnRfUGFnZV9Db250ZXh0ID0gQ2xpZW50X1BhZ2VfQ29udGV4dDtcclxuXHJcbnZhciBjbGllbnRfcGFnZV9jb250ZXh0ID0gbmV3IENsaWVudF9QYWdlX0NvbnRleHQoKTtcclxuXHJcbnZhciByZXNvdXJjZV9wb29sID0gY2xpZW50X3BhZ2VfY29udGV4dC5yZXNvdXJjZV9wb29sID0gbmV3IENsaWVudF9SZXNvdXJjZV9Qb29sKCk7XHJcblxyXG5yZXNvdXJjZV9wb29sLnN0YXJ0KGZ1bmN0aW9uKCkge1xyXG4gICAgY29uc29sZS5sb2coJ2NsaWVudC1zaWRlIHJlc291cmNlIHBvb2wgc3RhcnRlZCcpO1xyXG59KTtcclxuXHJcbi8vIE5vIGF1dG9tYXRpYyBhY3RpdmF0aW9uIGhlcmUsIHRoZSBjbGllbnQgYXBwLmpzIG1heSB3YW50IHRvIGxvYWQgaW0gcmVmZXJlbmNlcy5cclxuLy9qc2d1aS5hY3RpdmF0ZShjbGllbnRfcGFnZV9jb250ZXh0KTtcclxuY29uc29sZS5sb2coJ2pzZ3VpLWh0bWwtY2xpZW50IHBvc3QgYWN0aXZhdGUnKTtcclxuXHJcblxyXG5cclxuXHJcblxyXG4vLyBBbHNvIHdhbnQgdGhpcyB0byBhY2Nlc3MgcmVzb3VyY2VzLlxyXG5cclxuLy8gVGhpbmsgd2Ugd2lsbCBoYXZlIGEgY2xpZW50IHNpZGUgcmVzb3VyY2UgcG9vbCAoYnkgZGVmYXVsdD8pXHJcblxyXG5cclxuXHJcbi8vIFBvc3NpYmx5IHRoaXMgc2hvdWxkIGF1dG9tYXRpY2FsbHkgYWN0aXZhdGUgb24gdGhlIGNsaWVudC5cclxuXHJcblxyXG5cclxuLy9qc2d1aS5DbGllbnRfUGFnZV9Db250ZXh0ID0gQ2xpZW50X1BhZ2VfQ29udGV4dDtcclxuXHJcbi8vcmV0dXJuIGpzZ3VpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBqc2d1aTtcclxuXHJcblxyXG5cclxuXHJcbi8vfSk7XHJcbiIsIlxyXG52YXIganNndWkgPSByZXF1aXJlKCcuLi9jb3JlL2pzZ3VpLWxhbmctZW5oJyk7XHJcbi8vVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgd2hlbiBzY3JpcHRzL2hlbHBlci91dGlsLmpzIGlzIGxvYWRlZC5cclxuXHJcbi8vIEhUTUwgd2lsbCBiZW5lZml0IGZyb20gYSBiaWcgdGlkeS11cC5cclxuLy8gIEhUTUwgY29yZS5cclxuLy8gICBUaGVuIHZhcmlvdXMgZW5oYW5jZW1lbnRzLlxyXG4vLyAgIFBhZ2VfQ29udGV4dCBiZWluZyBhIG1ham9yIGZlYXR1cmUuXHJcbi8vICAgIEl0IHRpZXMgZXZlcnl0aGluZyB0b2dldGhlci5cclxuLy8gICAgIFNvIGFzIHdlbGwgYXMgYW4gYW5ub3lhbmNlIHdpdGggY29udHJvbHMgcmVxdWlyaW5nIGl0LCBpdCBzZWVtcyB1c2VmdWwuXHJcbi8vICAgICAgTWF5YmUgbWFrZSBpdCBzbyB0aGF0IGNvbnRyb2xzIGRlZmF1bHQgdG8gdGhhdCBQYWdlX0NvbnRleHQuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbnZhciBzdHJpbmdpZnkgPSBqc2d1aS5zdHJpbmdpZnksXHJcbiAgICBmcCA9IGpzZ3VpLmZwLFxyXG4gICAgdG9mID0ganNndWkudG9mLFxyXG4gICAgZXh0ZW5kID0ganNndWkuZXh0ZW5kLFxyXG4gICAgaXNfZGVmaW5lZCA9IGpzZ3VpLmlzX2RlZmluZWQsXHJcbiAgICBzdHJfYXJyX21hcGlmeSA9IGpzZ3VpLnN0cl9hcnJfbWFwaWZ5O1xyXG52YXIgY2xvbmUgPSBqc2d1aS5jbG9uZSxcclxuICAgIGVhY2ggPSBqc2d1aS5lYWMsXHJcbiAgICBkYXRhX3R5cGVfaW5zdGFuY2UgPSBqc2d1aS5kYXRhX3R5cGVfaW5zdGFuY2U7XHJcblxyXG52YXIgc3RyX2hleF90b19pbnQgPSBqc2d1aS5zdHJfaGV4X3RvX2ludCxcclxuICAgIGhleF9yZ2JfNl9tYXRjaCA9IGpzZ3VpLmhleF9yZ2JfNl9tYXRjaCxcclxuICAgIGFycl9yZ2JfdG9fY3NzX2hleF82ID0ganNndWkuYXJyX3JnYl90b19jc3NfaGV4XzY7XHJcblxyXG52YXIgRGF0YV9WYWx1ZSA9IGpzZ3VpLkRhdGFfVmFsdWUsXHJcbiAgICBEYXRhX09iamVjdCA9IGpzZ3VpLkRhdGFfT2JqZWN0LFxyXG4gICAgQ29sbGVjdGlvbiA9IGpzZ3VpLkNvbGxlY3Rpb247XHJcblxyXG52YXIgQ2xhc3MgPSBqc2d1aS5DbGFzcztcclxuXHJcbnZhciBlbnN1cmVfZGF0YV90eXBlX2RhdGFfb2JqZWN0X2NvbnN0cnVjdG9yID0ganNndWkuZW5zdXJlX2RhdGFfdHlwZV9kYXRhX29iamVjdF9jb25zdHJ1Y3RvcjtcclxuXHJcbnZhciBFbmhhbmNlZF9EYXRhX09iamVjdCA9IGpzZ3VpLkVuaGFuY2VkX0RhdGFfT2JqZWN0O1xyXG5cclxuZXh0ZW5kKGpzZ3VpLmRhdGFfdHlwZXNfaW5mbywge1xyXG4gICAgJ2JvcmRlcl9zdHlsZSc6IFsnYW55JywgWydzb2xpZCcsICdkb3R0ZWQnLCAnZGFzaGVkJ11dLFxyXG4gICAgJ2Rpc3RhbmNlJzogWyduX3VuaXRzJywgJ3B4J10sXHJcbiAgICAnc2luZ2xlX2JvcmRlcic6IFsnaW5kZXhlZF9hcnJheScsIFtcclxuICAgICAgICBbJ3dpZHRoJywgJ2Rpc3RhbmNlJ10sXHJcbiAgICAgICAgWydzdHlsZScsICdib3JkZXJfc3R5bGUnXSxcclxuICAgICAgICBbJ2NvbG9yJywgJ2NvbG9yJ11cclxuICAgIF1dLFxyXG4gICAgJ2JvcmRlcic6IFsnb2x0cmInLCAnc2luZ2xlX2JvcmRlciddLFxyXG4gICAgJ21hcmdpbic6IFsnb2x0cmInLCAnZGlzdGFuY2UnXSxcclxuICAgICdzaXplJzogWydpbmRleGVkX2FycmF5JywgWydkaXN0YW5jZScsIFsnd2lkdGgnLCAnaGVpZ2h0J11dXSxcclxuICAgICdjb250cm9sX2NvbGxlY3Rpb24nOiBbJ0RhdGFDb2xsZWN0aW9uJywgJ2NvbnRyb2wnXSxcclxuXHJcbiAgICAvLyBEZWZpbmluZyB0aGUgdHlwZXMgdGhhdCB0aGluZ3Mgd2lsbCBnZXQgYXV0b21hdGljYWxseSBjcmVhdGVkIGFzLlxyXG4gICAgJ2RvbV9hdHRyaWJ1dGVzJzogJ29yZGVyZWRfc3RyaW5nX2xpc3QnLFxyXG5cclxuICAgIC8vJ2RvbV9hdHRyaWJ1dGVzJzoge1xyXG4gICAgICAgIC8vJ2NsYXNzJzogJ09yZGVyZWRfU3RyaW5nX0xpc3QnXHJcbiAgICAvLyAgICAnY2xhc3MnOiAnb3JkZXJlZF9zdHJpbmdfbGlzdCdcclxuXHJcbiAgICAvL30sXHJcbiAgICAvLyB0aGVzZSBhcmUgaXRzIGZpZWxkcy5cclxuICAgIC8vICBzaG91bGQgYmUgYWJsZSB0byBidWlsZCBhIGNvbnRyb2xfZG9tIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLlxyXG4gICAgJ2NvbnRyb2xfZG9tJzoge1xyXG4gICAgICAgICdub2RlJzogJ29iamVjdCcsXHJcbiAgICAgICAgJ2F0dHJpYnV0ZXMnOiAnZG9tX2F0dHJpYnV0ZXMnLFxyXG4gICAgICAgICd0YWdOYW1lJzogJ3N0cmluZydcclxuICAgIH0sXHJcbiAgICAnY29udHJvbCc6IHtcclxuXHJcbiAgICAgICAgLy8gQW5vdGhlciB0eXBlIG9mIHN0eWxlIGluc2lkZSBoZXJlP1xyXG4gICAgICAgICdzdHlsZSc6ICdzdHlsZScsXHJcbiAgICAgICAgLy8gdGhhdCBtYXkgYmUgYXV0b21hdGljYWxseSBkb25lIGZyb20gaXRzIHJlbGF0aW9uc2hpcCB0byBpdHMgcGFyZW50LlxyXG4gICAgICAgIC8vJ2luZGV4JzogJ2ludCcsXHJcbiAgICAgICAgLy8gSXQgbWF5YmUgaGFzIGFuIElEIGFueXdheSBhcyBhIGpzZ3VpIERhdGFfT2JqZWN0LlxyXG4gICAgICAgIC8vICBCdXQgSSB0aGluayB0aGlzIHNpZ25pZmllcyBpdD8gTm90IHN1cmUuXHJcbiAgICAgICAgJ2lkJzogJ2NvbnRleHRfaWQnLFxyXG4gICAgICAgIC8vJ2NvbnRyb2xzJzogJ2NvbnRyb2xfY29sbGVjdGlvbicsXHJcbiAgICAgICAgLy8gY29udGVudCBjb2xsZWN0aW9uLlxyXG4gICAgICAgICdkb20nOiAnY29udHJvbF9kb20nLFxyXG4gICAgICAgICdjbGFzc19uYW1lJzogJ3N0cmluZydcclxuICAgICAgICAvLyBjc3NfY2xhc3MgaW4gdGhlIGRvbSBhdHRyaWJ1dGVzLiBzdHlsZSBpcyBpbmxpbmUgc3R5bGUtbGlrZSB0aGluZy5cclxuICAgICAgICAvLyAgc3R5bGUgd2lsbCBhbHNvIGJlIHVzZWQgZm9yIGJ1aWxkaW5nIGFuZCBtb2RpZnlpbmcgYWN0dWFsIGNzcyBmaWxlcyBvciBzZXR1cHMuXHJcblxyXG4gICAgfSxcclxuICAgICdzdHlsZSc6IHtcclxuICAgICAgICAvLyBhbiBvYmplY3QgZGVjbGFyYXRpb24sIG5vdCBhcnJheS4gY2FuIGhhdmUgdmFyaW91cyB0aGluZ3MgaW5zaWRlXHJcbiAgICAgICAgLy8nYm9yZGVyJzogWydvbHRyYicsICdzaW5nbGVfYm9yZGVyJ10sXHJcbiAgICAgICAgLy8gdG9wLCBsZWZ0IGV0Y1xyXG5cclxuICAgICAgICAvLyBXYW50IENTUyB0byB3b3JrIGJ5IGRlZmF1bHQsIGJ1dCB3aWxsIGhhdmUgc29tZSBvdmVycmlkZXMgLyBwYXJzaW5nIC8gcmVpbnRlcnByZXRhdGlvbi5cclxuXHJcblxyXG5cclxuICAgICAgICAnYm9yZGVyJzogJ2JvcmRlcicsXHJcbiAgICAgICAgJ21hcmdpbic6ICdtYXJnaW4nLFxyXG4gICAgICAgIC8vIHdoZW4gZGVhbGluZyB3aXRoICdhbnknOiB0aGVyZSBtYXkgbmVlZCB0byBiZSBhIG1hcCB0aGF0IHNheXMgaWYgYSB2YWx1ZSBpcyBjb250YWluZWQuXHJcbiAgICAgICAgLy8gIGNvdWxkIGV2ZW4gc3RvcmUgdGhlc2UgbWFwcyBpbiBhIHRyZWUuIHdvdWxkIHVzZSBzb21ldGhpbmcgbGlrZSAnZW5zdXJlJ1xyXG4gICAgICAgICdjdXJzb3InOiBbJ2FueScsIFsnYXV0bycsICdjcm9zc2hhaXInLCAnZGVmYXVsdCcsICdlLXJlc2l6ZScsICdoZWxwJywgJ21vdmUnLCAnbi1yZXNpemUnLCAnbmUtcmVzaXplJywgJ253LXJlc2l6ZScsICdwb2ludGVyJywgJ3Byb2dyZXNzJywgJ3MtcmVzaXplJywgJ3NlLXJlc2l6ZScsICdzdy1yZXNpemUnLCAndGV4dCcsICd3LXJlc2l6ZScsICd3YWl0JywgJ2luaGVyaXQnXV1cclxuICAgIH1cclxufSk7XHJcblxyXG4vLyBXYW50IGFuIHVuZGVybHlpbmcgc3lzdGVtIHRoYXQgcmVwcmVzZW50cyBDU1Mgd2VsbC5cclxuLy8gIE1ha2luZyBpdCBhIGxvdCBlYXNpZXIgdG8gd29yayB3aXRoIENTUywgYXMgaXQgaXMgaW4gdGhlIGJyb3dzZXIuXHJcbi8vICBPbiB0b3Agb2YgdGhhdCB3ZSBoYXZlIGFub3RoZXIgc3R5bGUgbGF5ZXIuIE1heWJlIGpzZ3VpLXN0eWxlPyBBIGRpZmZlcmVudCB3YXkgb2YgaW50ZXJhY3Rpbmcgd2l0aCB0aGUgc3R5bGUgc3lzdGVtLlxyXG4vLyAgSXQgbWF5IGJlIHRoYXQgc29tZSAuc3R5bGUgaW5zdHJ1Y3Rpb25zIHdpbGwgYmUgaW50ZXJwcmV0ZWQgdG8gZ28gdGhyb3VnaCB0aGUganNndWkgc3R5bGUgbGF5ZXIuXHJcbi8vICAgV2hlbiBzZXR0aW5nIGJvcmRlci1yYWRpdXMgaW4gYSBQYWdlX0NvbnRleHQgdGhhdCBkb2VzIG5vdCBzdXBwb3J0IGl0LlxyXG5cclxuRW5oYW5jZWRfRGF0YV9PYmplY3QucmVnaXN0ZXJfZGF0YV90eXBlKCdjb250cm9sX2RvbScsIGpzZ3VpLmRhdGFfdHlwZXNfaW5mb1snY29udHJvbF9kb20nXSk7XHJcbkVuaGFuY2VkX0RhdGFfT2JqZWN0LnJlZ2lzdGVyX2RhdGFfdHlwZSgnZG9tX2F0dHJpYnV0ZXMnLCBqc2d1aS5kYXRhX3R5cGVzX2luZm9bJ2RvbV9hdHRyaWJ1dGVzJ10pO1xyXG4vL2pzZ3VpLnBvcHVsYXRlX2FsbF9kdF9tYXBzKCk7XHJcbi8vICBkYXRhIHR5cGUgbWFwc1xyXG4vLyAgIGxpa2VseSB0byBoYXZlIG1hcHMgY3JlYXRlZCBhcyBuZWVkZWQgYW5kIGNhY2hlZC5cclxuXHJcbi8vIE1heSBoYXZlIGEgRGF0YV9UeXBlX1N5c3RlbSB0aGF0IGVuY2xvc2VzIHRoZXNlIERhdGFfVHlwZXMuXHJcbmVuc3VyZV9kYXRhX3R5cGVfZGF0YV9vYmplY3RfY29uc3RydWN0b3IoJ2NvbnRyb2xfZG9tJyk7XHJcblxyXG5cclxuLy8gYWxzbyBhIHByb2Nlc3NvciBmb3IgZGlzdGFuY2U/XHJcbi8vICBhIGN1cnJpZWQgZnVuY3Rpb24gZm9yIG5fdW5pdHMgYmFzaWNhbGx5P1xyXG5cclxuanNndWkuaW5wdXRfcHJvY2Vzc29yc1snZGlzdGFuY2UnXSA9IGZ1bmN0aW9uIChpbnB1dCkge1xyXG4gICAgLy8gdXNlIHRoZSBuX3VuaXRzIHByb2Nlc3NvciwgYnV0IHdpdGggJ3B4J1xyXG4gICAgcmV0dXJuIGpzZ3VpLmlucHV0X3Byb2Nlc3NvcnNbJ25fdW5pdHMnXSgncHgnLCBpbnB1dCk7XHJcbn07XHJcbi8vIG5vdCBzdXJlIGFib3V0IHVzaW5nIG9sdHJiIHJpZ2h0IG5vdy4gQ291bGQgY29tcHJlc3MgYnkgaGF2aW5nIGEgc2luZ2xlIGFycl9sdHJiIHZhcmlhYmxlLlxyXG5qc2d1aS5pbnB1dF9wcm9jZXNzb3JzWydtYXJnaW4nXSA9IGZ1bmN0aW9uIChpbnB1dCkge1xyXG4gICAgcmV0dXJuIGpzZ3VpLmlucHV0X3Byb2Nlc3NvcnNbJ29wdGlvbmFsX2FycmF5J10oWydsZWZ0JywgJ3RvcCcsICdyaWdodCcsICdib3R0b20nXSwgJ2Rpc3RhbmNlJywgaW5wdXQpO1xyXG59O1xyXG5cclxuanNndWkuaW5wdXRfcHJvY2Vzc29yc1snc2l6ZSddID0gZnVuY3Rpb24gKGlucHV0KSB7XHJcbiAgICAvLyB1c2UgdGhlIG5fdW5pdHMgcHJvY2Vzc29yLCBidXQgd2l0aCAncHgnXHJcbiAgICByZXR1cm4ganNndWkuaW5wdXRfcHJvY2Vzc29yc1snaW5kZXhlZF9hcnJheSddKFsnd2lkdGgnLCAnaGVpZ2h0J10sICdkaXN0YW5jZScsIGlucHV0KTtcclxufTtcclxuXHJcblxyXG4vL2NvbnNvbGUubG9nKFwianNndWkuaW5wdXRfcHJvY2Vzc29yc1snY29sb3InXSBcIiArIGpzZ3VpLmlucHV0X3Byb2Nlc3NvcnNbJ2NvbG9yJ10pO1xyXG5cclxuLy8ganVzdCBhIHN0cmluZyBpbiB0aGUgY29uc3RydWN0b3IgLSBsb29rcyBmaW5lIGZvciB0aGUgdHlwZS5cclxuLy8gIGxpa2VseSB0byBiZSB1c2luZyBzb21lIG5hbWVzcGFjZWQgdHlwZSBzeXN0ZW0gZXZlbnR1YWxseSwgYnV0IHRoaXMgaXMgbXkgbmFtZXNwYWNlIGZvciB0aGUgbW9tZW50LlxyXG5cclxuLy8gYW5kIG91dHB1dCB0aGUgY29sb3IgdG8gSFRNTC5cclxuXHJcbi8vIGFuZCBtYXkgaGF2ZSB0aGUgdmFyaW91cyBvdXRwdXQgcHJvY2Vzc29ycyBmb3IgbWFyZ2luIChvbHRyYnM/KSBhbmQgb3RoZXIgdGhpbmdzLCBvdXRwdXR0aW5nIHRvIEhUTUwuXHJcbi8vICBTb21lIG9mIHRoZW0gbWF5IG91dHB1dCB0byBvdGhlciBzaGltIGNvbnRyb2xzLCBvciBzaW1pbGFyLlxyXG4vLy8gV2lsbCBldmVudHVhbGx5IG91dHB1dCB0byBIVE1MLlxyXG5cclxuLy8gTmVlZCB0aGUgbG93ZXIgbGV2ZWwgc3R5bGUgc3lzdGVtIHdvcmtpbmcuXHJcbi8vICBPbiB0b3Agb2YgdGhhdCwgdGhlIGpzZ3VpIHN0eWxlIHN5c3RlbSB3aWxsIGJlIGJ1aWx0LlxyXG5cclxuXHJcblxyXG5qc2d1aS5vdXRwdXRfcHJvY2Vzc29yc1snc3RyaW5nJ10gPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgIC8vIG5lZWQgdG8gZXNjYXByIGl0XHJcbiAgICByZXR1cm4gdmFsdWU7XHJcbn1cclxuXHJcbi8vIFdpbGwgcmVxdWlyZSBvdGhlciBjb2RlIGFzIHdlbGwuXHJcblxyXG52YXIgZ2V0X2lubGluZV9jc3NfZGljdF9mcm9tX3N0eWxlID0gZnVuY3Rpb24gKHN0eWxlLCBwYWdlX2NvbnRleHQpIHtcclxuICAgIC8vY29uc29sZS5sb2coJ2dldF9pbmxpbmVfY3NzX2RpY3RfZnJvbV9zdHlsZSAnICsgc3RyaW5naWZ5KHN0eWxlKSk7XHJcblxyXG4gICAgdmFyIHN0eWxlX2luZm8gPSBqc2d1aS5kYXRhX3R5cGVzX2luZm9bJ3N0eWxlJ107XHJcblxyXG5cclxuICAgIC8vIHNob3VsZCBoYXZlIHRoZSBzdHlsZSBkYXRhIHR5cGUgaW5mb1xyXG4gICAgLy8gIHRoZW4gZm9yIGVhY2ggcHJvcGVydHkgd2UgZ2V0IHRoZSBkYXRhIHR5cGUgaW5mbyBmb3IgdGhhdCwgYW5kIHRoZW4gdXNlIGl0cyBvdXRwdXQgbWVjaGFuaXNtLlxyXG5cclxuICAgIHZhciBjc3Nfc3R5bGVfZGljdCA9IHt9O1xyXG4gICAgZWFjaChzdHlsZSwgZnVuY3Rpb24gKGksIHYpIHtcclxuICAgICAgICAvL2NvbnNvbGUubG9nKCdzdHlsZSBpICcgKyBpKTtcclxuXHJcbiAgICAgICAgLy8gVE9ETyAtIE1heSBub3QganVzdCBiZSBhIG5hbWUgYnV0IGNvdWxkIGRpcmVjdGx5IGJlIHRoZSBpbmZvLiBDb3VsZCB1c2UgYSBsb2FkZXIgZnVuY3Rpb24gcGVyaGFwcy5cclxuICAgICAgICB2YXIgZHRfaW5mb19zdHlsZV9pdGVtX25hbWUgPSBzdHlsZV9pbmZvW2ldO1xyXG4gICAgICAgIC8vY29uc29sZS5sb2coJ2R0X2luZm9fc3R5bGVfaXRlbV9uYW1lICcgKyBzdHJpbmdpZnkoZHRfaW5mb19zdHlsZV9pdGVtX25hbWUpKTtcclxuXHJcbiAgICAgICAgdmFyIGR0aV9zdHlsZV9pdGVtID0gZGF0YV90eXBlX2luc3RhbmNlKGR0X2luZm9fc3R5bGVfaXRlbV9uYW1lKTtcclxuXHJcbiAgICAgICAgLy9jb25zb2xlLmxvZygnKnYgJyArIHN0cmluZ2lmeSh2KSk7XHJcblxyXG4gICAgICAgIHZhciBzdHlsZV9ydWxlID0gZHRpX3N0eWxlX2l0ZW0ub3V0cHV0KHYpO1xyXG5cclxuICAgICAgICAvL2NvbnNvbGUubG9nKCdzdHlsZV9ydWxlICcgKyBzdHJpbmdpZnkoc3R5bGVfcnVsZSkpO1xyXG4gICAgICAgIC8vY29uc29sZS5sb2coJ3RvZihzdHlsZV9ydWxlKSAnICsgdG9mKHN0eWxlX3J1bGUpKTtcclxuICAgICAgICBpZiAodG9mKHN0eWxlX3J1bGUpID09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIGNzc19zdHlsZV9kaWN0W2ldID0gc3R5bGVfcnVsZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgLy8gY291bGQgcHJvYmFibHkgdXNlIGV4dGVuZCBoZXJlLlxyXG5cclxuICAgICAgICAgICAgZWFjaChzdHlsZV9ydWxlLCBmdW5jdGlvbiAoc3VicnVsZV9uYW1lLCBzdWJydWxlX3ZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBjc3Nfc3R5bGVfZGljdFtzdWJydWxlX25hbWVdID0gc3VicnVsZV92YWx1ZTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9hcHBseV9qc2d1aV9zdHlsZV9ydWxlX3RvX2Nzc19zdHlsZShjc3Nfc3R5bGVfZGljdCwgaSwgdik7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBjc3Nfc3R5bGVfZGljdDtcclxufTtcclxuXHJcbnZhciBhcHBseV9qc2d1aV9zdHlsZV9ydWxlX3RvX2Nzc19zdHlsZSA9IGZ1bmN0aW9uIChzdHlsZSwgc3R5bGVfcnVsZV9uYW1lLCBzdHlsZV9ydWxlX3ZhbHVlKSB7XHJcbiAgICAvL2NvbnNvbGUubG9nKCdhcHBseV9qc2d1aV9zdHlsZV9ydWxlX3RvX2Nzc19zdHlsZSBzdHlsZV9ydWxlX25hbWUgJyArIHN0eWxlX3J1bGVfbmFtZSk7XHJcblxyXG4gICAgLy8gaXQncyBwcm9iYWJseSBnb2luZyB0byB1c2UgZHRpIGFuZCBvdXRwdXQuXHJcblxyXG4gICAgLy8gV2lsbCBiZSBjaGFuZ2luZyB0aGUgd2F5IHRoYXQgc3R5bGVzIGdldCBjYWxjdWxhdGVkLlxyXG4gICAgLy8gR29pbmcgdG8gY3JlYXRlIHNvbWUgbmV3IGZ1bmN0aW9ucyB0aGF0IGdldCB1c2VkIGluIHRoZSByZW5kZXJpbmcuXHJcbiAgICAvLyAgV2lsbCBnZXQgaGVscCBmcm9tIGRhdGFfdHlwZXNfaW5mby5cclxuXHJcbiAgICAvL2NvbnNvbGUubG9nKCdmbnNfanNndWlfc3R5bGVfaXRlbV90b19pbmxpbmVfY3NzX2l0ZW1bc3R5bGVfcnVsZV9uYW1lXSAnICsgZm5zX2pzZ3VpX3N0eWxlX2l0ZW1fdG9faW5saW5lX2Nzc19pdGVtW3N0eWxlX3J1bGVfbmFtZV0pO1xyXG5cclxuICAgIC8vIHRoaXMgd2F5IG9mIGRvaW5nIHRoaW5ncyB3aWxsIGNoYW5nZS5cclxuICAgIC8vICBnb2luZyB0byBkbyBzb21lIGtpbmQgb2YgZ2V0X3N0eWxlLlxyXG5cclxuICAgIC8vIE1vcmUgb2YgaXQgd2lsbCBiZSBjb21wdXRlZCB0aHJvdWdoIGxhbmcgYW5kIHRoZSBkYXRhX3R5cGVzIHN5c3RlbS5cclxuXHJcbiAgICBpZiAoZm5zX2pzZ3VpX3N0eWxlX2l0ZW1fdG9faW5saW5lX2Nzc19pdGVtW3N0eWxlX3J1bGVfbmFtZV0pIHtcclxuICAgICAgICB2YXIgaW5saW5lX3N0eWxlX2RpY3QgPSBmbnNfanNndWlfc3R5bGVfaXRlbV90b19pbmxpbmVfY3NzX2l0ZW1bc3R5bGVfcnVsZV9uYW1lXShzdHlsZV9ydWxlX3ZhbHVlKTtcclxuICAgICAgICAvLyAgYnV0IGNvdWxkIHdlIGdldCBtb3JlIHRoYW4gb25lIHN0eWxlIGl0ZW0gaW4gdGhlIGRpY3Q/XHJcblxyXG4gICAgICAgIGVhY2goaW5saW5lX3N0eWxlX2RpY3QsIGZ1bmN0aW9uIChpMiwgdjIpIHtcclxuXHJcbiAgICAgICAgICAgIHN0eWxlW2kyXSA9IHYyO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59O1xyXG5cclxudmFyIHN0eWxlc19kaWN0X3RvX3N0cmluZyA9IGZ1bmN0aW9uIChzdHlsZXNfZGljdCkge1xyXG5cclxuICAgIC8vIE9LLi4uIHNvbWUgaW1wcm92ZW1lbnRzIHdpbGwgbmVlZCB0byBiZSBtYWRlLlxyXG4gICAgLy8gIHdpbGwgbmVlZCB0byB1cGdyYWRlIHRoZSBzdHlsZXMgLyBzaXplIC8gcG9zIHNldHRpbmcgY29kZS5cclxuICAgIC8vY29uc29sZS5sb2coJ3N0eWxlc19kaWN0ICcgKyBqc2d1aS5zdHJpbmdpZnkoc3R5bGVzX2RpY3QpKTtcclxuXHJcbiAgICB2YXIgcmVzID0gJycsXHJcbiAgICAgICAgZmlyc3QgPSB0cnVlO1xyXG4gICAgZWFjaChzdHlsZXNfZGljdCwgZnVuY3Rpb24gKGksIHYpIHtcclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiB2ID09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgIHYgPSB2ICsgJyc7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodHlwZW9mICh2KSAhPSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAvL3ZhciBzdGFjayA9IG5ldyBFcnJvcigpLnN0YWNrO1xyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdzdGFjayAnICsgc3RhY2spO1xyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdpICcgKyBpKTtcclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygndiAnICsgdik7XHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3R5cGVvZiB2ICcgKyB0eXBlb2Ygdik7XHJcbiAgICAgICAgICAgIHRocm93ICdqc2d1aTogc3R5bGVzX2RpY3RfdG9fc3RyaW5nOiBPbmx5IHN0cmluZyBjc3Mgc3R5bGVzIHN1cHBvcnRlZC4gSnNndWkgc3R5bGVzIG11c3QgYmUgdHJhbnNsYXRlZCB0byBjc3MgYmVmb3JlIHVzZSBoZXJlLic7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmVzID0gcmVzICsgaSArICc6ICcgKyB2ICsgJzsnO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHJlcztcclxufTtcclxuXHJcbi8vIEpTR1VJIGV2ZW50IGJpbmRpbmcgZnVuY3Rpb25zLlxyXG5cclxudmFyIF9iaW5kX2RvbV9ldmVudCA9IGZ1bmN0aW9uIChkb21fbm9kZSwgZXZlbnRfbmFtZSwgZm4pIHtcclxuXHJcbiAgICAvLyByZXR1cm4gdW5iaW5kIGZ1bmN0aW9uLiA/Pz9cclxuXHJcbiAgICB2YXIgdW5iaW5kID0gX3VuYmluZF9kb21fZXZlbnQoZG9tX25vZGUsIGV2ZW50X25hbWUsIGZuKTtcclxuICAgIHJldHVybiB1bmJpbmQ7XHJcbn1cclxuXHJcbnZhciBfdW5iaW5kX2RvbV9ldmVudCA9IGZ1bmN0aW9uIChkb21fbm9kZSwgZXZlbnRfbmFtZSwgZm4pIHtcclxuXHJcbn1cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbi8vIEFuZCBDb3JlLCBvZiBjb3Vyc2VcclxuLy8gIExpa2VseSB0byByZW5hbWUgdGhpcyAnQ29udHJvbCcgb3IgJ2NvbnRyb2wnIC0gcHJvYmFibHkgJ0NvbnRyb2wnLlxyXG5cclxuLy8gTm93IGl0IGlzIGluIHRoaXMgZmlsZSBpdCB3aWxsIGJlIGVhc2llciB0byBtb2RpZnkgYnkgaXRzZWxmLlxyXG4vLyBNb3JlIHJlbmRlcmluZyB0byBiZSBoYW5kbGVkIHRocm91Z2ggdGhlIERhdGFfT2JqZWN0IGNhcGFiaWxpdGllcy5cclxuLy8gIENvdWxkIGJlIHRoZSBvdXRwdXQgdHlwZSBvZiB2YXJpb3VzIGRpZmZlcmVudCB0aGluZ3MuXHJcblxyXG4vLyBNYXliZSB3ZSBuZWVkIG1vcmUgdGVzdGluZyBvZiBjb250cm9scywgdGhlcmUgc2VlbXMgdG8gYmUgYSBwcm9ibGVtIHdoaWNoIEkgbmVlZCB0byBmaXggdG8gZG9cclxuLy8gIHdpdGggZmllbGRzIG5vdCBiZWluZyBmb3VuZCBpbiB0aGUgZmlsZSBzeXN0ZW0gY29udHJvbC5cclxuXHJcbi8vIFBlcmhhcHMgSSBjb3VsZCBpbnZlc3RpZ2F0ZSB0aGF0IGNvbnRyb2wgb3V0c2lkZSBvZiBhIHNlcnZlci5cclxuXHJcbi8vIFRoaXMgbmVlZHMgbW9yZSB3b3JrIG9uIGl0cyBzdHlsZSBzeXN0ZW0uXHJcbi8vICBOZWVkIHRvIHF1aWNrbHkgYW5kIGVhc2lseSBjaGFuZ2UgY29uZm9ybWFudCBzdHlsZSBydWxlcy5cclxuLy8gICBUaGVyZSB3aWxsIGJlIGEgQ1NTIG92ZXJyaWRlcyBzeXN0ZW0sIGJ1dCBnZW5lcmFsbHkgdGhlIENTUyBhbmQgc3R5bGluZyBvZiB0aGUgQ29udHJvbCBzaG91bGQgZm9sbG93IG5vcm1hbCBDU1MuXHJcbi8vICAgIEluIHNvbWUgY2FzZXMgdGhlIG91dHB1dCBDU1Mgd2lsbCBub3QgbWF0Y2ggdGhlIGlucHV0IHN0eWxpbmcgcnVsZXMsXHJcbi8vICAgICB0aGVyZSBtYXkgYmUgc2hvcnRjdXRzIGZvciBjb252ZW5pZW5jZSwgYW5kIGl0IHdpbGwgYWNjZXB0IG1vcmUgZXhwcmVzc2l2ZSBsYW5ndWFnZSB0aGFuIENTUyAoaG9wZWZ1bGx5KVxyXG4vLyAgQnV0IGRvIHdhbnQgZnVsbCBjc3Mgc3VwcG9ydC5cclxuXHJcbi8vIGNvbnRyb2wuc3R5bGUoJ2JhY2tncm91bmQtaW1hZ2UnLCAndXJsKC4uLiknKTtcclxuLy8gIGJ1dCB3aWxsIGhhdmUgaW5wdXQgZmlsdGVycyBpbiBjYXNlIGEgdXJsIGlzIG5vdCBnaXZlbiBpbiB0aGF0IGZvcm1hdD9cclxuXHJcblxyXG4vLyBJIHRoaW5rIHRoaXMgd2lsbCB0YWtlIHF1aXRlIGEgbG90IG1vcmUgd29yayB0byBmdWxseSBtYWtlIHRoZSBDU1MgLyBzdHlsZSBBUEkuXHJcbi8vICBIb3dldmVyLCB3ZSBtb3N0IHdhbnQgdG8gYmUgYWJsZSB0byBzZXQgdGhlIHN0eWxlIHByb3BlcnR5IG9mIGFuIG9iamVjdCB0byBnaXZlIGl0IHN0eWxlcy5cclxuXHJcbi8vIEl0IG5lZWRzIHRvIHdvcmsgd2l0aCBhIHZhcmlldHkgb2Ygc3R5bGVzLlxyXG4vLyAgTmVlZHMgdG8gYWNjZXNzIHRoZSBsb2NhbCBDU1MgaW5saW5lIGRpY3QuLi5cclxuLy8gICB0aG91Z2ggY291bGQgcG9zc2libHkgd29yayB3aXRoIGEgQ29sbGVjdGlvbj9cclxuXHJcbi8vIGRvbS5hdHRyaWJ1dGVzLnN0eWxlXHJcbi8vICBJIHRoaW5rIGl0IG1ha2VzIHNlbnNlIHRvIGhhdmUgdGhhdCBhdmFpbGFibGUgYXMgYSBzdHJpbmcgdG8gc2V0Li4uXHJcbi8vICAgaG93ZXZlciwgSSB0aGluayBkb20uYXR0cmlidXRlcy5fc3R5bGUgbWFrZXMgc2Vuc2UuXHJcblxyXG4vLyB3YW50IHRvIGFjY2VzcyB0aGUgaW5saW5lIHN0eWxlIGRpY3QuXHJcblxyXG4vLyAgd2lsbCBhbHNvIGFwcGx5IGlucHV0IHRyYW5zZm9ybWF0aW9ucyBpbiBzb21lIGNhc2VzLlxyXG4vLyAgbWF5IGFwcGx5IG91dHB1dCB0cmFuc2Zvcm1hdGlvbnMgd2hlbiByZW5kZXJpbmcuXHJcblxyXG4vLyBQb3NzaWJseSB0aGUgc3R5bGUgc3lzdGVtIGNvdWxkIGRvIHdpdGggc29tZSBzZXBhcmF0ZSB3b3JrIGFuZCB0ZXN0aW5nLlxyXG4vLyAgV2Ugd2FudCBpdCBzbyB0aGF0IGluIG9sZCBJRSByb3VuZGVkIGVkZ2VzIGNhbiBiZSBlbXVsYXRlZCB3aXRoIFZNTC5cclxuXHJcblxyXG4vLyBkb20uYXR0cmlidXRlcy5zdHlsZSBpcyBsaXRlcmFsbHkgdGhlIHN0eWxlIGF0dHJpYnV0ZSBhcyBhIHN0cmluZz9cclxuLy8gIG5vIHNwZWNpYWwgY2FzZSB0aGVyZT9cclxuLy8gICBob3dldmVyLCB0aGVyZSB3aWxsIGJlIGEgc3lzdGVtIG9mIGR5bmFtaWNhbGx5IGNyZWF0aW5nIHRoaXMgaW4gYXMgaXRzIG5lZWRlZCBpbiBzb21lIGNhc2VzLlxyXG5cclxudmFyIGVkb19pbml0ID0gRW5oYW5jZWRfRGF0YV9PYmplY3QucHJvdG90eXBlLmluaXQ7XHJcbnZhciBkb19pbml0ID0gRGF0YV9PYmplY3QucHJvdG90eXBlLmluaXQ7XHJcbi8vdmFyIGRvX2luaXRfY2FsbCA9IERhdGFfT2JqZWN0LnByb3RvdHlwZS5pbml0LmNhbGw7XHJcblxyXG4vLyBXaWxsIGFsc28gdXNlIHJldXNhYmxlIGxvY2FsIHZhcmlhYmxlcy5cclxuLy8gIE1heSBiZSBhIGJpdCBleHBlcmltZW50YWwhIFNob3VsZCBkbyBsZXNzIGFzc2lnbm1lbnQgJiBnYXJiYWdlIGNvbGxlY3Rpb24uXHJcblxyXG52YXIgdGhhdCwgZG9tLCBmbGFncywgY3NzX2ZsYWdzLCBzcGVjX2NvbnRlbnQsIHRzYywgYXJyLCByZXMsIGRvbV9hdHRycztcclxuXHJcbi8vIExpbmsgdGFnIG5lZWRzIHRvIGhhdmUgbm8gY2xvc2luZyB0YWcuXHJcblxyXG4vLyBUaGlzIHNob3VsZCBoYXZlIG1vcmUgZm9yIHRoZSBjbGllbnQgc2lkZS5cclxuLy9cclxuXHJcbi8vIEZvciBkcmFnIGFuZCBkcm9wOlxyXG4vLyAgQmVzdCB0byB1c2UgdGhlIGV4aXN0aW5nIEFQSS4gSGF2ZSBhIGxheWVyIG9uIHRvcCBvZiB0aGF0LlxyXG4vLyBUaGVuIGZvciBtb2JpbGUgKGlPUywgQmxhY2tiZXJyeT8gQW5kcm9pZCkgaGF2ZSBhbiBpbXBsZW1lbnRhdGlvbiB0aGF0IGlzIGEgYml0IGxpa2UgdGhlIEhUTUwgaW1wbGVtZW50YXRpb24uXHJcbi8vIFRoZW4gaGF2ZSBhIG5pY2UsIGNvbnZlbmllbnQgbGF5ZXIgb24gdG9wIG9mIGJvdGguXHJcblxyXG4vLyBEcmFnLCByZWFycmFuZ2luZyBzZWVtcyByZWFsbHkgdXNlZnVsLlxyXG4vLyBNYXkgbmVlZCB0byBpbnRlcmFjdCB3aXRoIHNlcnZlciBvYmplY3RzIHdoZW4gZG9pbmcgdGhlIHJlYXJyYW5nZW1lbnQsIG5lZWQgYSBjbGVhciBkaXZpc2lvbiBiZXR3ZWVuIHJlYXJyYW5nZW1lbnRcclxuLy8gIFVJIGFuZCB0aGUgYWN0aW9ucyBpdCBjYXJyaWVzIG91dC5cclxuXHJcbi8vIEJhc2ljYWxseSBzYXkgc29tZXRoaW5nIGlzIGRyYWdnYWJsZVxyXG4vLyBEb24ndCBhc3N1bWUgaXQgZHJhZ3MgaXRzZWxmLCB0aGVyZSBtYXkgYmUgYSBoYW5kbGVcclxuLy8gQWxsb3cgdGhlIGRyYWcgaXRlbSB0byBiZSBzb21ldGhpbmcgcmVwcmVzZW50aW5nIHNvbWUgZGF0YSBpbiB0ZXJtcyBvZiBtb2RlbFxyXG4vLyBBbGxvdyB0aGUgZHJhZyBpdGVtIHRvIGJlIGEgZ2hvc3QgdmlldyBvZiB0aGUgaXRlbSBiZWluZyBkcmFnZ2VkXHJcbi8vIFdvcmsgc28gdGhhdCBleGFtcGxlIHdpdGggdGhlIHNlcGFyYXRlIGl0ZW1zIGdyb3VwaW5nIHRvZ2V0aGVyIHdvcmtzLlxyXG5cclxuXHJcblxyXG5cclxuLy8gUGVyaGFwcyBoYXZlIHNvbWUga2luZCBvZiBodG1sIGVuaGFuY2VtZW50cyBtb2R1bGU/XHJcblxyXG5cclxuXHJcblxyXG4vLyBDb250cm9sIGNvdWxkIGJlbmVmaXQgZnJvbSBjb21wb3NpdGlvbiBtZXRob2RzIGFuZCBkZWZpbml0aW9ucy5cclxuLy8gIFRoZXkgZGVmaW5lIHRoZSBjb21wb3NpdGlvbiBvZiBjb250cm9scy5cclxuLy8gICBNYXkgY29udGFpbiBpbm5lciBjb250cm9scy4gVGhlc2UgZ2V0IGNyZWF0ZWQgd2hlbiBuZWNlc3NhcnkuXHJcblxyXG5cclxuLy8gQWxzbyBuZWVkIGEgZ29vZCBzeXN0ZW0gZm9yIGRyYWcgYW5kIGRyb3AgZXZlbnRzLlxyXG4vLyAgTmVlZCB0byByZWNvZ25pc2UgZHJhZyBzdGFydHMgYXQgZmlyc3QuXHJcblxyXG4vLyBEcmFnZ2luZyBzb21ldGhpbmcgdGhhdCBpcyBhbHJlYWR5IHNlbGVjdGVkLlxyXG5cclxuLy8gU2VsZWN0aW5nIHNvbWV0aGluZyBvbiB0aGUgYmVnaW5uaW5nIG9mIHRoZSBkcmFnLlxyXG5cclxuXHJcblxyXG4vLyBBbHNvIHdhbnQgdG8gYmUgYWJsZSB0byBtYWtlIHNoYWxsb3cgY29waWVzIC8gY2xvbmVzIG9mIGNvbnRyb2xzLlxyXG4vLyAgUHJvYmFibHkgd29uJ3QgaGF2ZSBjb25uZWN0aW9uIHRvIGRhdGEuXHJcbi8vICAgRm9yIHNob3J0IHRlcm0gdXNlIGluIGRyYWdnaW5nLlxyXG5cclxuLy8gd2lsbCBjb3B5IGFsbCB0aGUgZG9tIGF0dHJpYnV0ZXMgYW5kIHRhZ3MsIG5vZGVzLlxyXG4vLyAgY291bGQgYmUgYSBjb250cm9sP1xyXG4vLyAgIGluY2x1ZGluZyBzdWJjb250cm9scy4uLiBjb3VsZCBtYWtlIGEgYnVuY2ggb2YgbmV3IGNvbnRyb2xzIGFzIHRoZSBjb3B5LlxyXG4vLyAgICBUaGF0IG1heSBiZSBiZXN0IHRvIGhhdmUgdGhlIHNhbWUgZWZmZWN0cyAvIHRvIGVuYWJsZSBlZmZlY3RzLlxyXG5cclxuXHJcbnZhciBwYXJzZV9zdHlsZV9hdHRyaWJ1dGVfdG9fbWFwID0gZnVuY3Rpb24oc3RyX3N0eWxlKSB7XHJcbiAgICBzdHJfc3R5bGUgPSBzdHJfc3R5bGUucmVwbGFjZSgvOyAvZywgJzsnKTtcclxuICAgIHN0cl9zdHlsZSA9IHN0cl9zdHlsZS5yZXBsYWNlKC86IC9nLCAnOicpO1xyXG4gICAgdmFyIHJ1bGVzID0gc3RyX3N0eWxlLnNwbGl0KCc7Jyk7XHJcbiAgICB2YXIgcnVsZV9udnBzID0gW107XHJcbiAgICB2YXIgbWFwX3J1bGVzID0ge307XHJcbiAgICBlYWNoKHJ1bGVzLCBmdW5jdGlvbihpLCBydWxlKSB7XHJcbiAgICAgICAgaWYgKHJ1bGUpIHtcclxuICAgICAgICAgICAgdmFyIHNSdWxlID0gcnVsZS5zcGxpdCgnOicpO1xyXG5cclxuICAgICAgICAgICAgcnVsZV9udnBzLnB1c2goc1J1bGUpXHJcbiAgICAgICAgICAgIG1hcF9ydWxlc1tzUnVsZVswXV0gPSBzUnVsZVsxXVxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9KVxyXG5cclxuICAgIC8vY29uc29sZS5sb2coJ3J1bGVfbnZwcyAnICsgc3RyaW5naWZ5KHJ1bGVfbnZwcykpO1xyXG5cclxuICAgIC8vY29uc29sZS5sb2coJ21hcF9ydWxlcyAnICsgc3RyaW5naWZ5KG1hcF9ydWxlcykpO1xyXG5cclxuICAgIHJldHVybiBtYXBfcnVsZXM7XHJcbn1cclxuXHJcbnZhciBzdHlsZV9hdHRyaWJ1dGVfbWFwX3RvX3N0cmluZyA9IGZ1bmN0aW9uKG1hcF9zdHlsZSkge1xyXG4gICAgdmFyIGFycl9yZXMgPSBbXTtcclxuICAgIHZhciBmaXJzdCA9IHRydWU7XHJcbiAgICBlYWNoKG1hcF9zdHlsZSwgZnVuY3Rpb24oaSwgdikge1xyXG4gICAgICAgIGlmICghZmlyc3QpIHtcclxuICAgICAgICAgICAgYXJyX3Jlcy5wdXNoKCc7Jyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBhcnJfcmVzLnB1c2goaSk7XHJcbiAgICAgICAgYXJyX3Jlcy5wdXNoKCc6Jyk7XHJcbiAgICAgICAgYXJyX3Jlcy5wdXNoKHYpO1xyXG5cclxuXHJcbiAgICAgICAgZmlyc3QgPSBmYWxzZTtcclxuICAgIH0pXHJcbiAgICByZXR1cm4gYXJyX3Jlcy5qb2luKCcnKTtcclxufVxyXG5cclxuLy8gRGVmZXJyZWQgcmVuZGVyaW5nIGlzIGdvaW5nIHRvIGJlIGEgZmFpcmx5IG1ham9yIGZlYXR1cmUuXHJcblxyXG5cclxudmFyIGdldFN0eWxlID0gZnVuY3Rpb24gKGVsLCBwcm9wZXJ0eV9uYW1lKSB7XHJcblxyXG4gICAgaWYgKGVsLmN1cnJlbnRTdHlsZSlcclxuICAgICAgICB2YXIgeSA9IGVsLmN1cnJlbnRTdHlsZVtwcm9wZXJ0eV9uYW1lXTtcclxuICAgIGVsc2UgaWYgKHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKTtcclxuICAgICAgICB2YXIgeSA9IGRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUoZWwsIG51bGwpLmdldFByb3BlcnR5VmFsdWUocHJvcGVydHlfbmFtZSk7XHJcbiAgICByZXR1cm4geTtcclxufVxyXG5cclxuXHJcbi8vIE1ha2luZyBpdCBzbyBhIENvbnRyb2wgbmVlZHMgdG8gYmUgaW5pdGlhbGlzZWQgd2l0aCBhIGNvbnRleHQgZXZlcnkgdGltZT9cclxuXHJcblxyXG5cclxudmFyIENvbnRyb2wgPSBqc2d1aS5FbmhhbmNlZF9EYXRhX09iamVjdC5leHRlbmQoe1xyXG5cclxuICAgICdmaWVsZHMnOiBbXHJcbiAgICAvLyBUaGlzIG1heSBiZSBhIGdvb2Qgd2F5IG9mIGV4cHJlc3NpbmcgY29sbGVjdGlvbnMsIHdvcmtzIGluIEpTT04uXHJcbiAgICAvL1snY29udGVudCcsIFsnY29sbGVjdGlvbicsICdjb250cm9sJ11dXHJcblxyXG4gICAgLy8gbmVlZCB0byBtYWtlIHN1cmUgdGhhdCB0aGUgZmllbGRzIG1ha2VzIHRoZXNlIHdpdGggdGhlIHJpZ2h0IGNvbnRleHRzLlxyXG5cclxuICAgIC8vIFNheSBpdCdzIGEgY29sbGVjdGlvbiBvZiBjb250cm9scz9cclxuICAgICAgICAvLyBDb3VsZCBwb3NzaWJseSBoYXZlIGFuIGlubmVyIGNvbnRlbnQ/XHJcbiAgICAgICAgLy8gIElubmVyIGNvbnRyb2w/XHJcbiAgICAgICAgLy8gIEFuZCB0aGF0IGlubmVyIGNvbnRyb2wncyBjb250ZW50IGlzIHRoZSBpbm5lciBjb250ZW50LlxyXG4gICAgICAgIC8vICBOb3QgYWxsIHdpbGwgaGF2ZSBhbiBpbm5lciBjb250cm9sLlxyXG4gICAgICAgIC8vICAgQ291bGQgY2hlY2sgYSBjb250cm9sIHRvIHNlZSBpZiBpdCBoYXMgaXQuXHJcbiAgICAgICAgLy8gICBBZGQgd2lsbCBhZGQgdG8gdGhlIGlubmVyIGNvbnRyb2wuXHJcblxyXG4gICAgICAgIC8vIE1heSBoYXZlIGFjdGl2ZSBmaWVsZHMgYXMgd2VsbC5cclxuICAgICAgICAvLyAgVGhlcmUgd2lsbCBiZSByZWZlcmVuY2VzIHRvIG90aGVyIGNvbnRyb2xzIC0gdGhhdCdzIGhhbmRsZWQgd2l0aCBkYXRhLWpzZ3VpLWN0cmwtZmllbGRzLlxyXG4gICAgICAgIC8vICBUaGUgbm9uLWNvbnRyb2wgZmllbGRzIGFyZSB0cmFuc2ZlcnJlZCB3aXRoIGRhdGEtanNndWktZmllbGRzXHJcbiAgICAgICAgLy8gICBIb3dldmVyLCB3ZSBkb24ndCB3YW50IHRvIGNvbmZ1c2UgdGhlbSB3aXRoIHRoZSBmaWVsZHMgdGhhdCBhcmUgYSBzdGFuZGFyZCBwYXJ0IG9mIHRoZSBjb250cm9sIGluIGEgZGlmZmVyZW50IHBhcnQgb2YgdGhlIGxpZmVjeWNsZS5cclxuXHJcbiAgICAgICAgLy8gTWF5IGJlIHdvcnRoIGV4cGxpY2l0bHkgYnJlYWtpbmcgb3V0IHRoZSBDb21wb3NpdGlvbiBwYXJ0IG9mIHRoZSBDb250cm9sIGxpZmVjeWNsZSBhZ2Fpbi5cclxuICAgICAgICAvLyAgV2hlbiBhIENvbnRyb2wgaXMgaW5pdGlhbGl6ZWQgb24gdGhlIGNsaWVudCwgYmVpbmcgZ2l2ZW4gYSBET00gZWxlbWVudCwgaXQgZG9lcyBub3QgbmVlZCB0byBiZSBjb21wb3NlZC5cclxuICAgICAgICAvLyAgIChJIHRoaW5rKVxyXG5cclxuICAgICAgICBbJ2NvbnRlbnQnLCAnY29sbGVjdGlvbiddLFxyXG4gICAgICAgIFsnZG9tJywgJ2NvbnRyb2xfZG9tJ10vLyxcclxuXHJcbiAgICAgICAgLy8gV2hhdCBhcmUgdGhlIENTUyBmbGFncz9cclxuICAgICAgICAvLyAgU2hvdWxkIHRoaXMgdXNlIHRoZSBmbGFnIHN5c3RlbT9cclxuICAgICAgICAvLyAgV2Ugd2lsbCBoYXZlIGZsYWdzIHRoYXQgZGV0ZXJtaW5lIENTUyBzdHlsaW5nLlxyXG4gICAgICAgIC8vICAgQnV0IGRvIHdlIGhhdmUgZmxhZ3MgdGhhdCBkaXJlY3RseSBhcmUgQ1NTIHByb3BlcnRpZXMgLyBjb25maWd1cmF0aW9ucywgZWl0aGVyIG9uIG9yIG9mZj9cclxuXHJcbiAgICAgICAgLy9bJ2Nzc19mbGFncycsIENvbGxlY3Rpb24oU3RyaW5nKV1cclxuICAgICAgICAvLyBjb250ZXh0IGFzIGEgZmllbGQ/XHJcbiAgICAgICAgLy8gIG9yIGlzIGNvbnRleHQgaGFuZGxlZCBieSBEYXRhX09iamVjdD9cclxuXHJcbiAgICBdLFxyXG5cclxuICAgIC8vIFNldCB1cCBhIGZpZWxkIHdpdGggdHlwZSBDb250cm9sLlxyXG4gICAgLy8gIFRoZW4gaXQgd2lsbCBiZSBzZW50IHRvIHRoZSBjbGllbnQgYXMgYSBjb250cm9sIGZpZWxkLCBhbmQgdGhlIHJlZmVyZW5jZSByZS1vYnRhaW5lZC5cclxuXHJcblxyXG4gICAgLy8gQ29ubmVjdCBhbGwgZmllbGRzPyBKdXN0IHNvbWUgb2YgdGhlbT9cclxuICAgIC8vICBXYW50IHRvIG1ha2UgaXQgZWFzeSBmb3IgdGhlIG5lY2Vzc2FyeSBmaWVsZHMgLyBjb250cm9sIHJlZmVyZW5jZXMgdG8gYmUgc2VudCB0byB0aGUgY2xpZW50LlxyXG4gICAgJ2Nvbm5lY3RfZmllbGRzJzogdHJ1ZSxcclxuXHJcbiAgICAvLyBEb24ndCB3YW50IHRvIHVzZSB0aGlzIG11Y2guIFNob3VsZCBwcm9iYWJseSBvdmVycmlkZSBmdW5jdGlvbnMgaW5zdGVhZC4gPz8/IE9yIGZpbmQgYSB3YXkgbm90IHRvIHVzZSBpdC5cclxuICAgICdtb2RfbGluayc6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4ganNndWk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vIFN0eWxlIGRvZXMgRGF0YV9PYmplY3Quc2V0KCdzdHlsZScpXHJcbiAgICAvLyAgc28gbmVlZCB0byBiZSBjYXJlZnVsIGFib3V0IHRoaXMgc3R5bGUgb2JqZWN0LlxyXG4gICAgLy8gICBXaWxsIG5lZWQgdG8gcmVmZXIgdG8gaXQgd2hlbiByZW5kZXJpbmcuXHJcblxyXG4gICAgLy8gVGhlcmUgd2lsbCBiZSB0aGUganNndWktc3R5bGUsIGJ1dCBJIHRoaW5rIGhhdmluZyBub3JtYWwgc3R5bGUgYXMgdGhlIGRlZmF1bHQgaXMgYmVzdCwgYW5kIHRoYXQgd2lsbCBnZXRcclxuICAgIC8vICBvdmVycmlkZGVuIGluIHNvbWUgY2lyY3Vtc3RhbmNlcy5cclxuXHJcblxyXG4gICAgLy8gV2UgYXJlIGxpa2VseSB0byBuZWVkIGEgYmV0dGVyIHN0eWxlIGZ1bmN0aW9uIGluIEhUTUwuXHJcblxyXG4gICAgLy8gbWF5IGJlIGdvb2QgaW4gc29tZSB3YXlzIGhhdmluZyBpdCB3b3JrIGFzIGEgZmllbGQuXHJcblxyXG4gICAgLy8gS2VlcCBkb20uc3R5bGUuYXR0cmlidXRlcyBhcyBpdCBpcywgYnV0IG1vZGlmeSB0aGF0IHdoZW4gY2hhbmdpbmcgaW5saW5lIHN0eWxlcy5cclxuXHJcbiAgICAnaW5pdCc6IGZ1bmN0aW9uIChzcGVjKSB7XHJcblxyXG4gICAgICAgIC8vIGJ1dCBwcm9jZXNzIC8gbm9ybWFsaXplIHRoZSBzcGVjIGhlcmU/XHJcblxyXG4gICAgICAgIHNwZWMgPSBzcGVjIHx8IHt9O1xyXG4gICAgICAgIC8vc3BlYy5ub2RlVHlwZSA9IHNwZWMubm9kZVR5cGUgfHwgMTtcclxuICAgICAgICAvL2NvbnNvbGUubG9nKCdwcmUgc3VwZXIgaW5pdCcpO1xyXG4gICAgICAgIC8vdGhpcy5fc3VwZXIoc3BlYyk7XHJcblxyXG4gICAgICAgIC8vZG9faW5pdF9jYWxsKHRoaXMsIHNwZWMpO1xyXG4gICAgICAgIHRoaXMubWFwTGlzdGVuZXJzID0ge307XHJcbiAgICAgICAgZG9faW5pdC5jYWxsKHRoaXMsIHNwZWMpO1xyXG5cclxuXHJcbiAgICAgICAgLy9jb25zb2xlLmxvZygncG9zdCBzdXBlciBpbml0Jyk7XHJcblxyXG4gICAgICAgIHRoaXMuX190eXBlX25hbWUgPSAnY29udHJvbCc7XHJcbiAgICAgICAgdGhpcy5fX3R5cGUgPSAnY29udHJvbCc7XHJcblxyXG4gICAgICAgIGlmICghdGhpcy5fYWJzdHJhY3QpIHtcclxuXHJcblxyXG4gICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICB0aGlzLmFkZF9ldmVudF9saXN0ZW5lcignc2V0JywgZnAoZnVuY3Rpb24gKGEsIHNpZykge1xyXG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnY29udHJvbCBldmVudCBzZXQgc2lnICcgKyBzaWcpO1xyXG4gICAgICAgICAgICAgICAgLy90aHJvdyAnc3RvcCc7XHJcbiAgICAgICAgICAgICAgICAvLyBhIGZsYWcgY291bGQgaGF2ZSBiZWVuIHNldC5cclxuICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICAqL1xyXG5cclxuICAgICAgICAgICAgLy8gbmVlZCB0byBsaXN0ZW4gZm9yIGNoYW5nZXMgaW4gdGhlIGZsYWdzIGFuZCBtYXliZSBzb21lIG90aGVyIHByb3BlcnRpZXMuXHJcbiAgICAgICAgICAgIC8vICBjc3MgY2xhc3NlcyB3aWxsIGJlIGFkZGVkIGFuZCByZW1vdmVkIHVzaW5nIHRoZXNlIGZsYWdzLlxyXG5cclxuICAgICAgICAgICAgLy8gd2lsbCBhbHNvIGhhdmUgdGhpcyByZXNwb25kaW5nIHRvIHRoZSBhZGRpdGlvbiBhbmQgcmVtb3ZhbCBvZiBjc3MgZmxhZ3MuXHJcbiAgICAgICAgICAgIC8vICBjc3MgZmxhZ3Mgd2lsbCBjb3JyZXNwb25kIHRvIGEgbm9ybWFsIGZsYWcsIHNvIHNldHRpbmcgYSBjc3MgZmxhZyBjcmVhdGVzIHRoZSBub3JtYWwgZmxhZyB0b29cclxuICAgICAgICAgICAgLy8gIHJlbW92aW5nIHRoZSBub3JtYWwgZmxhZyByZW1vdmVzIHRoZSBjc3MgZmxhZyBpZiB0aGVyZSBpcyBvbmUuXHJcbiAgICAgICAgICAgIC8vICByZW1vdmluZyB0aGUgY3NzIGZsYWcgcmVtb3ZlcyB0aGUgbm9ybWFsIGZsYWcgaWYgdGhlcmUgaXMgb25lLlxyXG5cclxuICAgICAgICAgICAgLy8gIGNvdWxkIGhhdmUgYSBsaXN0IG9mIGNzc19lbmFibGVkX2ZsYWdzIHNvIHRoYXQgd2hlbmV2ZXIgdGhlIG5vcm1hbCBmbGFnIHZlcnNpb24gaXMgc3dpdGNoZWQgb24sIGl0IHN3aXRjaGVzIG9uXHJcbiAgICAgICAgICAgIC8vICAgdGhlIGNzcyBmbGFnIGFzIHdlbGwuXHJcblxyXG4gICAgICAgICAgICAvLyBtYXkgaGF2ZSBhIGZhaXJseSBjb252ZW5pZW50IGludGVyZmFjZSBmb3IgcmVjZWl2aW5nIHRoZXNlIGZsYWdzIChmb3IgaW5zdGFuY2VzIGFucyBmb3IgY2xhc3NlcylcclxuICAgICAgICAgICAgLy8gIGFuZCBoYXZlIHNvbWUgY29tcGxleGl0eSBpbnNpZGUsIGJ1dCBtYWtpbmcgaXQgYXMgc2ltcGxlIGZvciB0aGUgZW5kIGRldmVsb3BlciBhcyBwb3NzaWJsZSwgd2hpbGUgYWxzb1xyXG4gICAgICAgICAgICAvLyAgZW5hYmxpbmcgZXZlbnQgcmVzcG9uc2VzIHRvIHdvcmsgYXMgd2VsbC5cclxuXHJcbiAgICAgICAgICAgIC8vZmxhZ3MgPSB0aGlzLmdldCgnZmxhZ3MnKTtcclxuICAgICAgICAgICAgLy9jc3NfZmxhZ3MgPSB0aGlzLmdldCgnY3NzX2ZsYWdzJyk7XHJcblxyXG4gICAgICAgICAgICAvL3ZhciBmbGFncyA9IHRoaXMuZ2V0KCdmbGFncycpO1xyXG4gICAgICAgICAgICAvL3ZhciBjc3NfZmxhZ3MgPSB0aGlzLmdldCgnY3NzX2ZsYWdzJyk7XHJcblxyXG5cclxuICAgICAgICAgICAgLy92YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgICAgIC8vdGhhdCA9IHRoaXM7XHJcblxyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdwcmUgZ2V0IGRvbScpO1xyXG5cclxuICAgICAgICAgICAgLy8gYWJzdHJhY3QgY29udHJvbHMgZG9uJ3QgaGF2ZSB0aGUgZmllbGQgaW5zdGFuY2VzLlxyXG4gICAgICAgICAgICAvLyAgYnV0IHRoZXkgY291bGQgaGF2ZSBzZXR0aW5ncyBvciBhIHNwZWMuXHJcbiAgICAgICAgICAgIC8vIE1heWJlIGFic3RyYWN0IERhdGFfb2JqZWN0cyBjb3VsZCByZXRhaW4gdGhlaXIgc3BlYyxcclxuICAgICAgICAgICAgLy8gIHRoZW4gbm90IGRvIHRoZSBub3JtYWwgY29uc3RydWN0b3IuXHJcblxyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCd0aGlzLmZpZWxkcygpICcgKyBzdHJpbmdpZnkodGhpcy5maWVsZHMoKSkpO1xyXG4gICAgICAgICAgICAvLyB0aGUgY2hhaW5lZCBmaWVsZHM/XHJcbiAgICAgICAgICAgIC8vICBoYXZlIHRoZSBmaWVsZHMgbm90IGJlZW4gaW5pdGlhbGlzZWQgcHJvcGVybHk/XHJcbiAgICAgICAgICAgIC8vdmFyIGNoYWluZWRfZmllbGRzID0ganNndWkuZ2V0X2NoYWluZWRfZmllbGRzKHRoaXMuY29uc3RydWN0b3IpO1xyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdjaGFpbmVkX2ZpZWxkcyAnICsgc3RyaW5naWZ5KGNoYWluZWRfZmllbGRzKSk7XHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3ByZSBnZXQgZG9tJyk7XHJcbiAgICAgICAgICAgIC8vdmFyIGRvbSA9IHRoaXMuZ2V0KCdkb20nKTtcclxuXHJcbiAgICAgICAgICAgIC8vZG9tID0gdGhpcy5nZXQoJ2RvbScpO1xyXG4gICAgICAgICAgICAvL2RvbS5zZXQoJ3RhZ05hbWUnLCAnZGl2Jyk7IC8vIFRob3VnaCBtYXkgZGVwZW5kIG9uIHNwZWMuLi5cclxuXHJcbiAgICAgICAgICAgIHZhciB0YWdOYW1lID0gc3BlYy50YWdOYW1lIHx8IHNwZWMudGFnX25hbWUgfHwgJ2Rpdic7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnNldCgnZG9tLnRhZ05hbWUnLCB0YWdOYW1lKTtcclxuXHJcbiAgICAgICAgICAgIC8vIHRoaXMuc2V0X3NfcztcclxuICAgICAgICAgICAgLy8gIGRpZmZlcmVudCB2ZXJzaW9ucyBvZiBzZXQsIG9uZSBvZiB3aGljaCB3aWxsIGp1c3Qgc2V0IHVzaW5nIDIgc3RyaW5nIHBhcmFtcy5cclxuXHJcblxyXG5cclxuICAgICAgICAgICAgLy8gIHVzaW5nIHR3byBzdHJpbmdzLlxyXG4gICAgICAgICAgICAvLyAgYSB2ZXJzaW9uIG9mIHRoZSBmdW5jdGlvblxyXG5cclxuICAgICAgICAgICAgLy8gY291bGQgaGF2ZSBpbmxpbmUgY3JlYXRpb24gb2YgdGhlIGRvbSBEYXRhX09iamVjdC5cclxuXHJcbiAgICAgICAgICAgIC8vdmFyIGRvbSA9IHRoaXMuXy5kb20gPSB0aGlzLl8uZG9tIHx8IG5ldyBEYXRhX09iamVjdCh7J2NvbnRleHQnOiB0aGlzLmNvbnRleHR9KTtcclxuICAgICAgICAgICAgLy92YXIgdGFnX25hbWUgPSBkb20uXy50YWdOYW1lID0gbmV3IERhdGFfVmFsdWUoeyd2YWx1ZSc6IHRhZ05hbWV9KTtcclxuICAgICAgICAgICAgLy90YWdfbmFtZS5wYXJlbnQoZG9tKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuX2ljc3MgPSB7fTtcclxuICAgICAgICAgICAgLy90aGlzLl8uZG9tID0geyd0YWdOYW1lJzogJ2Rpdid9O1xyXG5cclxuICAgICAgICAgICAgLy8gQWJzdHJhY3QgY29udHJvbHMgd29uJ3QgaGF2ZVxyXG5cclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnZG9tICcgKyBzdHJpbmdpZnkoZG9tKSk7XHJcblxyXG4gICAgICAgICAgICAvLyBUaGUgRE9NIGlzIGEgZmllbGQgdGhhdCBpdCBzaG91bGQgYmUgZ2V0dGluZyBmcm9tIHRoZSBjb250cm9sLlxyXG4gICAgICAgICAgICBzcGVjX2NvbnRlbnQgPSBzcGVjLmNvbnRlbnQ7XHJcbiAgICAgICAgICAgIGlmIChzcGVjX2NvbnRlbnQpIHtcclxuICAgICAgICAgICAgICAgIHRzYyA9IHRvZihzcGVjX2NvbnRlbnQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRzYyA9PSAnYXJyYXknKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgJ0NvbnRlbnQgYXJyYXkgbm90IHlldCBzdXBwb3J0ZWQgaGVyZS4nXHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRzYyA9PSAnc3RyaW5nJyB8fCB0c2MgPT0gJ2NvbnRyb2wnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZW50KCkuYWRkKHNwZWNfY29udGVudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoc3BlYy5lbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXQoJ2RvbS5lbCcsIHNwZWMuZWwpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcblxyXG4gICAgICAgICAgICBpZiAoc3BlYy5zaXplKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2l6ZSA9IHNwZWMuc2l6ZTtcclxuICAgICAgICAgICAgICAgIHZhciB0X3NpemUgPSB0b2Yoc2l6ZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAodF9zaXplID09ICdhcnJheScpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgd2lkdGggPSBzaXplWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBoZWlnaHQgPSBzaXplWzFdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBmYXIgZnJvbSBpZGVhbFxyXG4gICAgICAgICAgICAgICAgICAgIC8vICBSZWFsbHkgc2hvdWxkIHNldCBpbmxpbmUgc3R5bGVzIHNlcGFyYXRlbHkuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gIEkgaGFkIGxvc3Qgc29tZSBvZiB0aGUgSlNHVUkgc3R5bGUgc3lzdGVtIGJlZm9yZSBiZWNhdXNlIEkgcmVkaWQgY29udHJvbCBiYXNlZCBvbiBEYXRhX09iamVjdCwgaXQgbWF5IGhhdmUgZ290IHRvbyBjb21wbGljYXRlZCBiZWZvcmUgdGhvdWdoLlxyXG4gICAgICAgICAgICAgICAgICAgIC8vXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFdhbnQgdG8gYmUgYWJsZSB0byBhY2Nlc3MgY3NzIHN0eWxlcy5cclxuICAgICAgICAgICAgICAgICAgICAvLyAgV2FudCB0byBiZSBhYmxlIHRvIGFjY2VzcyBzdHlsZXMgb24gYSBkaWZmZXJlbnQgbGV2ZWwgdGhvdWdoIC0gdGhpbmdzIHdoaWNoIG1heSBub3QgYmUgc3VwcG9ydGVkIGJ5IENTUyBkaXJlY3RseS5cclxuICAgICAgICAgICAgICAgICAgICAvLyAgV2lsbCBkbyB0aGluZ3MgbW9yZSBiYXNlZCBvbiB0aGUgQ1NTIHN0YW5kYXJkIHdoZXJlIHBvc3NpYmxlLCBhbmQgc2hpZnRpbmcgdG8gdXNlIG90aGVyIG1ldGhvZHMgd2hlbiBub3QgcG9zc2libGUuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0KCdkb20uYXR0cmlidXRlcy5zdHlsZScsICd3aWR0aDogJyArIHdpZHRoICsgJ3B4OyBoZWlnaHQ6ICcgKyBoZWlnaHQgKyAncHg7Jyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIE5lZWRzIHRvIHNldCBpbmxpbmUgc3R5bGVzLlxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoc3BlY1snY2xhc3MnXSkge1xyXG4gICAgICAgICAgICAgICAgLy90aGlzLnNldCgnZG9tLmF0dHJpYnV0ZXMuY2xhc3MnLCBzcGVjWydjbGFzcyddKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWRkX2NsYXNzKHNwZWNbJ2NsYXNzJ10pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgY29udGV4dCA9IHRoaXMuX2NvbnRleHQ7XHJcbiAgICAgICAgICAgIGlmIChjb250ZXh0KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29udGV4dC5yZWdpc3Rlcl9jb250cm9sKSBjb250ZXh0LnJlZ2lzdGVyX2NvbnRyb2wodGhpcyk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUudHJhY2UoJycpO1xyXG4gICAgICAgICAgICAgICAgLy90aHJvdyAnQ29udHJvbCByZXF1aXJlcyBjb250ZXh0J1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEkgdGhpbmsgdGhlIHZlcnkgZmlyc3QgQ29udHJvbCBvYmplY3QncyBwcm90b3R5cGUgb3Igc29tZXRoaW5nIHRoYXQgaW5oZXJpdHMgZnJvbSBpdCBkb2VzIG5vdCBoYXZlXHJcbiAgICAgICAgICAgICAgICAvLyAgYSBjb250ZXh0IGF0IHNvbWUgc3RhZ2UuXHJcbiAgICAgICAgICAgIH1cclxuXHJcblxyXG5cclxuXHJcbiAgICAgICAgICAgIC8vIFdoZW4gY29udGVudCBnZXRzIGFkZGVkLCBuZWVkIHRvIHVwZGF0ZSB0aGUgcmVsYXRpb25zaGlwcy5cclxuXHJcbiAgICAgICAgICAgIC8vIFBlcmhhcHMgY2hhbmdlIGlzIHRoZSBiZXR0ZXIgZXZlbnQgdG8gdXNlLlxyXG5cclxuICAgICAgICAgICAgLy8gIEFuZCB0aGVuIHdpdGhpbiB0aGUgY2hhbmdlIGV2ZW50IHRoZXJlIGFyZSBtb3JlIGRldGFpbHMuXHJcbiAgICAgICAgICAgIC8vICBGZXdlciBldmVudCBsaXN0ZW5lcnMgdG8gYWRkLlxyXG5cclxuICAgICAgICAgICAgLy9cclxuXHJcbiAgICAgICAgICAgIHZhciBjb250ZW50ID0gdGhpcy5nZXQoJ2NvbnRlbnQnKTtcclxuICAgICAgICAgICAgY29udGVudC5fcGFyZW50ID0gdGhpcztcclxuXHJcbiAgICAgICAgICAgIC8vIFdhbnQgdG8gaGF2ZSB0aGUgbGlzdCBvZiBmaWVsZHNcclxuICAgICAgICAgICAgLy92YXIgY2MgPSAwO1xyXG5cclxuICAgICAgICAgICAgLy8gV2FudCB0byBsaXN0ZW4gdG8gY2hhbmdlcyBpbiBmaWVsZHMuXHJcbiAgICAgICAgICAgIC8vICBDaGFuZ2UgZ2V0cyB0cmlnZ2VyZWQgc28gZnJlcXVlbnRseSFcclxuXHJcbiAgICAgICAgICAgIC8vIFdoeSBpcyB0aGUgZXZlbnQgZ2V0dGluZyBib3VuZCB0b28gbWFueSB0aW1lcz9cclxuICAgICAgICAgICAgLy8gIEhhdmUgYSBzdHJhbmdlIHByb2JsZW0sIHdoZXJlIHRoaXMgZXZlbnQgaXMgZmlyaW5nIG1vcmUgdGhhbiBleHBlY3RlZCBhbmQgbW9yZSBhcHBlYXIgYm91bmQgb24gdGhlIGNvbnRyb2wuXHJcblxyXG4gICAgICAgICAgICAvLyBBcmUgY2hhbmdlIGV2ZW50cyBiZWluZyBidWJibGVkP1xyXG5cclxuICAgICAgICAgICAgLy8gV2h5IGlzIG9uIGNoYW5nZSBzZXR0aW5nIHVwIHNvIG1hbnkgZXZlbnQgaGFuZGxlcnM/XHJcblxyXG5cclxuICAgICAgICAgICAgLy8gQSBjaGFuZ2UgZXZlbnQgaGVyZSBzZWVtcyB0byBiZSBjcmVhdGluZyBsb3RzIG9mIGV2ZW50IGhhbmRsZXJzIG9uIG9uZSBjb250cm9sLlxyXG5cclxuXHJcblxyXG5cclxuICAgICAgICAgICAgLy8gTmVlZCB0byB3b3JrIG91dCB3aHkgZXZlbnQgYmluZGluZyBoZXJlIGNhdXNlcyBwcm9ibGVtcywgd2l0aCBpdCBzZWVtaW5nIHRvIGJpbmQgbG90cyBvZiBldmVudHMgdG8gb25lIGNvbnRyb2wuXHJcblxyXG4gICAgICAgICAgICAvLyBJdCB3aWxsIHByb2JhYmx5IGJlIGJlc3QgdG8gZG8gc21hbGxlciB0ZXN0IGNhc2VzIHRvIGRvIHdpdGggZXZlbnQgYmluZGluZyBhbmQgYnViYmxpbmcsXHJcbiAgICAgICAgICAgIC8vICBwb3NzaWJseSBhbHNvIGJyb3dzZXIgYmFzZWQgY2FzZXMgdGhhdCB3aWxsIGJlIGVhc2llciB0byBmb2xsb3cuXHJcblxyXG5cclxuICAgICAgICAgICAgLy8gT25jaGFuZ2UgaGVyZSBtYWtlcyBpdCBnbyBkcmFzdGljYWxseSB3cm9uZy5cclxuICAgICAgICAgICAgLy8gIEJldHdlZW4gcGFnZSB2aWV3cywgZXZlbnQgaGFuZGxlcnMgYXJlIGJ1aWxkaW5nIHVwIG9uIGEgY29udHJvbC5cclxuICAgICAgICAgICAgLy8gIFNlZW1zIGxpa2Ugc29tZSBEYXRhX09iamVjdHMgb3IgQ29udHJvbHMgbWF5IG5vdCBoYXZlIGNvbnRleHRzIGFwcGxpZWQuXHJcblxyXG5cclxuXHJcbiAgICAgICAgICAgIC8vIFRoZSBjb250cm9sJ3Mgb25jaGFuZ2UgZXZlbnQgaXMgbm90IHdvcmtpbmcuXHJcbiAgICAgICAgICAgIC8vICBJdCBzZWVtcyBsaWtlIG9uY2hhbmdlIGZvciB0aGUgY29udGVudCBpcyB3b3JraW5nIHRob3VnaC5cclxuXHJcbiAgICAgICAgICAgIC8vICBPbiBjaGFuZ2UgYW55IG9mIHRoZSBjb250cm9sIGZpZWxkcy4uLlxyXG4gICAgICAgICAgICAvLyAgIENvdWxkIGNyZWF0ZSBvbmNoYW5nZSBldmVudHMgZm9yIGVhY2ggb2YgdGhlIGNvbnRyb2wgZmllbGRzIGF1dG9tYXRpY2FsbHkuXHJcblxyXG5cclxuXHJcblxyXG4gICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICB0aGlzLm9uKCdjaGFuZ2UnLCBmdW5jdGlvbihlX2NoYW5nZSkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIENoYW5nZSB0YWtlcyBwbGFjZSBpbiB0aGUgY29sbGVjdGlvbj9cclxuICAgICAgICAgICAgICAgIC8vICBTbyB3aGVuIGFuIGl0ZW0gZ2V0cyBhZGRlZCwgaXQncyBhZGRlZCB0byB0aGUgY29sbGVjdGlvbiwgYW5kIHRoZSBjb2xsZWN0aW9uIGNoYW5nZXMuXHJcbiAgICAgICAgICAgICAgICAvLyAgRG9lcyB0aGUgY29sbGVjdGlvbiBoYXZlIHRoZSByaWdodCBjb250ZXh0PyBUaGUgY29sbGVjdGlvbiBpcyBpbml0aWFsaXNlZCBhcyBhIGZpZWxkLlxyXG5cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnZV9jaGFuZ2UnLCBlX2NoYW5nZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVGhlcmUgYXJlIHZlcnkgbWFueSBjaGFuZ2VzLi4uXHJcbiAgICAgICAgICAgICAgICAvLyAgSXQgc2VlbXMgbGlrZSB0b28gbWFueSBjaGFuZ2UgZXZlbnRzIGdldCByZXBvcnRlZC5cclxuICAgICAgICAgICAgICAgIC8vICAgTmVlZCB0byB0ZWxsIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gYSBjaGFuZ2Ugb2Ygc29tZXRoaW5nLCBhbmQgYSBjaGFuZ2UgdG8gc29tZXRoaW5nLlxyXG4gICAgICAgICAgICAgICAgLy8gICBMaWtlIGFuIGlubmVyIGNvbnRyb2wgZ2V0cyByZXBsYWNlZCB3aXRoIHNvbWV0aGluZyBkaWZmZXJlbnQsIG9yIGFuIGlubmVyIGNvbnRyb2wgaGFzIGEgY2hhbmdlIGhhcHBlbiB0byBpdC5cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSXQgbG9va3MgbGlrZSBjaGFuZ2VzIGFyZSBidWJibGluZywgbmVlZCB0byBmaW5kIGEgd2F5IG9mIHRyYWNraW5nIHRoZSBpbml0aWF0b3Igb2YgYSBjaGFuZ2UgZXZlbnQuXHJcblxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoZV9jaGFuZ2UubmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2VfY2hhbmdlLm5hbWUnLCBlX2NoYW5nZS5uYW1lKTtcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlX2NoYW5nZS5uYW1lID09ICdpbm5lcl9jb250cm9sJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnZV9jaGFuZ2UuYnViYmxlZCAnICsgZV9jaGFuZ2UuYnViYmxlZCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCd0aGF0JywgdGhhdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vdmFyIG15X2N0cmxfaWQgPSB0aGF0Ll9pZCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDb250cm9scyBtYXkgbm90IGhhdmUgY29udGV4dHMgeWV0P1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnbXlfY3RybF9pZCcsIG15X2N0cmxfaWQpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnZV9jaGFuZ2UnLCBlX2NoYW5nZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS50cmFjZShcIkhlcmUgSSBhbSFcIilcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9jYysrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdjaGFuZ2Ugc2lnICcgLCBqc2d1aS5nZXRfaXRlbV9zaWcoZV9jaGFuZ2UpKTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgKi9cclxuXHJcblxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcblxyXG4gICAgJ3Bvc3RfaW5pdCc6IGZ1bmN0aW9uIChzcGVjKSB7XHJcbiAgICAgICAgLy90aHJvdyAnc3RvcCc7XHJcbiAgICAgICAgaWYgKHNwZWMgJiYgc3BlYy5pZCA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAvLyBnZXQgdGhlIGlkIGZyb20gdGhlIGNvbnRleHQuXHJcbiAgICAgICAgICAgIC8vaWYgKHQpXHJcbiAgICAgICAgICAgIHRoaXMuc2V0KCdkb20uYXR0cmlidXRlcy5pZCcsIHRoaXMuX2lkKCkpO1xyXG5cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8vIE5vdCBzbyBzdXJlIHRoYXQgY3NzIGZsYWdzIHdpbGwgYmUgdXNlZC5cclxuICAgIC8vICBXZSBoYXZlIGNzcyBjbGFzc2VzIHdoaWNoIGdldCBtYW5pcHVsYXRlZC5cclxuICAgIC8vICBPdGhlciB0eXBlcyBvZiBwcm9wZXJ0aWVzIHdvbid0IGRlcGVuZCBvbiBDU1MgcXVpdGUgeWV0LlxyXG4gICAgLy8gIFdpbGwgaGF2ZSBjb250cm9sIGZpZWxkcyBpbXByb3ZlZCB0byBiZSBtb3JlIGZsZXhpYmxlIGFuZCB0byBjYXJyeSBmcm9tIHRoZSBzZXJ2ZXIgdG8gdGhlIGNsaWVudCBwYXJhbWV0ZXJzIGFuZCBiZWhhdmlvdXJhbCBydWxlcy5cclxuXHJcbiAgICAvKlxyXG4gICAgJ2FkZF9jc3NfZmxhZyc6IGZ1bmN0aW9uIChmbGFnX25hbWUpIHtcclxuICAgICAgICB2YXIgY3NzX2ZsYWdzID0gdGhpcy5nZXQoJ2Nzc19mbGFncycpO1xyXG4gICAgICAgIC8vY29uc29sZS5sb2coJ2Nzc19mbGFncyAnICsgc3RyaW5naWZ5KGNzc19mbGFncykpO1xyXG5cclxuICAgICAgICAvLyBGbGFncyB0aGF0IGFwcGVhciBpbiBDU1MuXHJcbiAgICAgICAgLy8gIEFsc28gaGF2ZSBzb21lIG90aGVyIGVmZmVjdCwgbW9zdCBsaWtlbHkuXHJcblxyXG4gICAgICAgIGlmICghY3NzX2ZsYWdzLmhhcyhmbGFnX25hbWUpKSB7XHJcbiAgICAgICAgICAgIGNzc19mbGFncy5hZGQoZmxhZ19uYW1lKTtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgIH0sXHJcbiAgICAncmVtb3ZlX2Nzc19mbGFnJzogZnVuY3Rpb24gKGZsYWdfbmFtZSkge1xyXG4gICAgICAgIHZhciBjc3NfZmxhZ3MgPSB0aGlzLmdldCgnY3NzX2ZsYWdzJyk7XHJcbiAgICAgICAgaWYgKGNzc19mbGFncy5oYXMoZmxhZ19uYW1lKSkge1xyXG4gICAgICAgICAgICBjc3NfZmxhZ3MucmVtb3ZlKGZsYWdfbmFtZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcbiAgICAnaGFzX2Nzc19mbGFnJzogZnVuY3Rpb24gKGZsYWdfbmFtZSkge1xyXG4gICAgICAgIHZhciBjc3NfZmxhZ3MgPSB0aGlzLmdldCgnY3NzX2ZsYWdzJyk7XHJcbiAgICAgICAgcmV0dXJuIGNzc19mbGFncy5oYXMoZmxhZ19uYW1lKTtcclxuICAgIH0sXHJcblxyXG4gICAgKi9cclxuXHJcbiAgICAvLyBNYXliZSBjb25zaWRlciB0aGVzZSBwYXJ0IG9mIHJlbmRlcmluZywgbW92ZSB0aGVtLlxyXG4gICAgJ19nZXRfYW1hbGdhbWF0ZWRfc3R5bGUnOiBmdW5jdGlvbiAoYXJyX2NvbnRleHRzKSB7XHJcbiAgICAgICAgLy9jb25zb2xlLmxvZygndGhpcy5fLnN0eWxlICcgKyBzdHJpbmdpZnkodGhpcy5fLnN0eWxlKSk7XHJcblxyXG4gICAgICAgIC8vIERvIHdlIGhhdmUgc3R5bGUgYXMgYSBmaWVsZCB0aGF0IHVzZXMgZGF0YSBvYmplY3RzP1xyXG5cclxuICAgICAgICAvL3JlcyA9IGNsb25lKHRoaXMuXy5zdHlsZSk7XHJcbiAgICAgICAgLy90aGF0ID0gdGhpcztcclxuXHJcblxyXG5cclxuXHJcbiAgICAgICAgLy8gbmVlZHMgdG8gYmUgc3Vic3RhbnRpYWxseSByZWRvbmUuXHJcbiAgICAgICAgLy8gIEkgd2FudCB0byBrZWVwIGl0IHNpbXBsZSwgYW5kIGNsb3NlIHRvIHRoZSBIVE1MIEFQSSBieSBkZWZhdWx0LlxyXG4gICAgICAgIC8vICBUaGVyZSB3aWxsIG5lZWQgdG8gYmUgb3ZlcnJpZGVzIGluIHZhcmlvdXMgcGxhY2VzLlxyXG5cclxuICAgICAgICAvLyBTb21ldGltZXMgbmV3IGVsZW1lbnRzIHdvdWxkIG5lZWQgdG8gYmUgcHV0IGluIChtYXliZSBpbnRvIHRoZSBiYWNrZ3JvdW5kKVxyXG5cclxuICAgICAgICAvL2NvbnNvbGUubG9nKCdyZXMgJyArIHN0cmluZ2lmeShyZXMpKTtcclxuICAgICAgICAvLyBPSywgbmVlZHMgdGhlIHN0eWxlIG9iamVjdC5cclxuXHJcbiAgICAgICAgLy8gTGlrZWx5IHRvIGhhdmUgdGhlIHN0eWxlKCkgZnVuY3Rpb24uXHJcblxyXG4gICAgICAgIC8qXHJcbiAgICBcdCAqIG5vdCB1c2luZyBjb250ZXh0cyBhdCB0aGUgbW9tZW50IGFueXdheVxyXG4gICAgXHQgKlxyXG4gICAgXHQkLmVhYyhhcnJfY29udGV4dHMsIGZ1bmN0aW9uKGksIHYpIHtcclxuICAgIFx0XHQvL3ZhciBjcyA9IHRoYXQuXy5jc1t2XTtcclxuICAgIFx0XHRpZiAoZ2xvYmFsLnBhZ2VfY29udGV4dCAmJiBnbG9iYWwucGFnZV9jb250ZXh0LmNvbnRleHRfc3R5bGVbdl0pIHtcclxuICAgIFx0XHRcdC8vY29uc29sZS5sb2coJ2EpIGdldF9hbWFsZ2FtYXRlZF9zdHlsZSByZXMgJyArIGpzZ3VpLnN0cmluZ2lmeShyZXMpKTtcclxuICAgIFx0XHRcdGFwcGx5X3N0eWxlX3RvX3N0eWxlKHJlcywgZ2xvYmFsLnBhZ2VfY29udGV4dC5jb250ZXh0X3N0eWxlW3ZdKTtcclxuICAgIFx0XHRcdC8vY29uc29sZS5sb2coJ2IpIGdldF9hbWFsZ2FtYXRlZF9zdHlsZSByZXMgJyArIGpzZ3VpLnN0cmluZ2lmeShyZXMpKTtcclxuICAgIFx0XHR9XHJcbiAgICBcdH0pO1xyXG4gICAgXHQqL1xyXG4gICAgICAgIC8vcmV0dXJuIHJlcztcclxuXHJcbiAgICAgICAgLy8gTm90IGdvaW5nIHRvIHVzZSB0aGlzLl8uc3R5bGUuXHJcbiAgICAgICAgLy8gIHdpbGwgaGF2ZSB0aGlzLl9pY3NzIGZvciBpbmxpbmUgY3NzXHJcblxyXG5cclxuXHJcblxyXG4gICAgICAgIHJldHVybiBjbG9uZSh0aGlzLl8uc3R5bGUpO1xyXG4gICAgfSxcclxuXHJcbiAgICAnX2dldF9yZW5kZXJlZF9pbmxpbmVfY3NzX2RpY3QnOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIC8vIGFuZCBkb2VzIHNldHRpbmcgdGhlIHN0eWxlIHdvcmsgcmlnaHQ/XHJcblxyXG4gICAgICAgIC8vIHdpbGwgcmVmZXIgdG8gYW4gb2JqZWN0LCB3aWxsIHJldHVybiB0aGlzLl8uaW5saW5lX2Nzc19kaWN0LlxyXG4gICAgICAgIC8vICB3aWxsIHJlbmRlciB0aGF0IGRpY3Qgd2hlbiBuZWNlc3NhcnkgLS0tP1xyXG4gICAgICAgIC8vICBhbWFsZ2FtdGluZyB0aGUgc3R5bGVzXHJcblxyXG4gICAgICAgIC8vIHdoZW4gY2hhbmdpbmcgdGhlIHN0eWxlIG9mIHNvbWV0aGluZyAtIG1heSBiZSBvdmVyd3JpdHRlbiBieSBhbWFsZ2FtYXRlZCBzdHlsZXM/XHJcbiAgICAgICAgLy8gIGhhdmUgYW4gYW1hbGdhbWF0ZWQgc3R5bGUgb3ZlcnJpZGU/XHJcblxyXG4gICAgICAgIC8vdmFyIGNvbnRleHRzID0gdGhpcy5nZXRDb250ZXh0cygpLFxyXG5cclxuICAgICAgICB2YXIgYXN0ID0gdGhpcy5nZXRfYW1hbGdhbWF0ZWRfc3R5bGUoKVxyXG5cclxuXHJcbiAgICAgICAgLy9jb25zb2xlLmxvZygnYXN0ICcgKyBzdHJpbmdpZnkoYXN0KSk7XHJcbiAgICAgICAgdmFyIGlubGluZV9jc3NfZGljdCA9IGdldF9pbmxpbmVfY3NzX2RpY3RfZnJvbV9zdHlsZShhc3QpO1xyXG5cclxuICAgICAgICAvL2NvbnNvbGUubG9nKCdpbmxpbmVfY3NzX2RpY3QgJyArIGpzZ3VpLnN0cmluZ2lmeShpbmxpbmVfY3NzX2RpY3QpKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGlubGluZV9jc3NfZGljdDtcclxuICAgIH0sXHJcblxyXG5cclxuICAgIC8vIFdpbGwgdXNlIGxlc3MgaW5saW5lIHN0eWxlIHJlbmRlcmluZywgd2lsbCBtYWtlIG1vcmUgc3R5bGVzaGVldCBjb21wb25lbnRzLlxyXG4gICAgLy8gIFdpbGwgYWxzbyB3b3JrIG9uIHRvb2xzIGZvciBtYWtpbmcgc3R5bGVzaGVldHMgYW5kIHN0eWxlcy5cclxuXHJcbiAgICAvLyBtYXkgYmUgaG93IHN0eWxlIGdldHMgb3V0cHV0IC0gY291bGQgdXNlIGFuIG91dHB1dCBzeXN0ZW0gdGhhdCBtYWtlcyByZWZlcmVuY2UgdG8gdGhlIHBhZ2VfY29udGV4dC5cclxuICAgIC8vICBpdCBpcyBqdXN0IGRvbS5hdHRyaWJ1dGVzLnN0eWxlXHJcbiAgICAvKlxyXG4gICAgJ19nZXRfcmVuZGVyZWRfaW5saW5lX2Nzcyc6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgY3NzX2RpY3QgPSB0aGlzLmdldF9yZW5kZXJlZF9pbmxpbmVfY3NzX2RpY3QoKSxcclxuICAgICAgICAgICAgc3RyX2NzcyA9ICcnO1xyXG5cclxuICAgICAgICAvLyByZW5kZXJzIHRoZSBqc2d1aSBzdHlsZXMgdGhhdCBoYXZlIGJlZW4gc2V0IHRvIHRoZSBpbmxpbmUgc3R5bGVcclxuICAgICAgICAvLyB0aGVuIHJlbmRlcnMvY29waWVzIHRoZSBDU1MgaW5saW5lIHN0eWxlcyB0byB0aGUgaW5saW5lIHN0eWxlXHJcblxyXG4gICAgICAgIC8vIHdpbGwgYWxyZWFkeSBoYXZlIGEgc3R5bGUgZGljdC5cclxuXHJcblxyXG4gICAgXHQvL2lmICh0eXBlb2YgdGhpcy5kb20uYXR0cmlidXRlcyAhPSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgdGhpcy5kb20uYXR0cmlidXRlcy5zdHlsZSAhPSAndW5kZWZpbmVkJykge1xyXG4gICAgXHQvL1x0dmFyIGRhX3N0eWxlX2RpY3QgPSBzdHJfZ2V0X3N0eWxlc19kaWN0KHRoaXMuZG9tLmF0dHJpYnV0ZXMuc3R5bGUpO1xyXG4gICAgICAvL1x0dmFyIG5zZCA9IHt9O1xyXG4gICAgICAvL1x0JC5leHRlbmQodHJ1ZSwgbnNkLCBkYV9zdHlsZV9kaWN0LCAgY3NzX2RpY3QpO1xyXG4gICAgICAvL1x0c3RyX2NzcyA9IHN0eWxlc19kaWN0X3RvX3N0cmluZyhuc2QpO1xyXG4gICAgXHQvL307XHJcblxyXG5cclxuICAgICAgICAvLyB3aWxsIGJlIGEgZGF0YSB0eXBlIHRoYXQgc3VwcG9ydHMgb3JkZXJpbmcgLyByZW9yZGVyaW5nIHNvb24uXHJcbiAgICAgICAgdmFyIGggPSB0aGlzLmhhcygndGhpcy5kb20uYXR0cmlidXRlcy5fLmRpY3Rfc3R5bGUnKTtcclxuICAgICAgICAvLyBtYXliZSBkb2VzIG5vdCBoYXZlIHRoYXQgYXR0cmlidXRlP1xyXG4gICAgICAgIC8vIHRoZXkgYXJlIGlubGluZSBzdHlsZXMgKHRoYXQgaGF2ZSBiZWVuIHNldClcclxuXHJcbiAgICAgICAgLy9jb25zb2xlLmxvZygnaCAnICsgaCk7XHJcblxyXG4gICAgICAgIGlmIChoKSB7XHJcbiAgICAgICAgICAgIHZhciBkYV9zdHlsZV9kaWN0ID0gaDtcclxuICAgICAgICAgICAgdmFyIG5zZCA9IHt9O1xyXG4gICAgICAgICAgICBleHRlbmQodHJ1ZSwgbnNkLCBkYV9zdHlsZV9kaWN0LCBjc3NfZGljdCk7XHJcblxyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCduc2QgJyArIGpzZ3VpLnN0cmluZ2lmeShuc2QpKTtcclxuXHJcbiAgICAgICAgICAgIHN0cl9jc3MgPSBzdHlsZXNfZGljdF90b19zdHJpbmcobnNkKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdjc3NfZGljdCAnICsganNndWkuc3RyaW5naWZ5KGNzc19kaWN0KSk7XHJcbiAgICAgICAgICAgIHN0cl9jc3MgPSBzdHlsZXNfZGljdF90b19zdHJpbmcoY3NzX2RpY3QpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHN0cl9jc3M7XHJcbiAgICB9LFxyXG4gICAgKi9cclxuXHJcbiAgICAvLyBsaWtlbHkgdG8gYmUgZG9uZSB3aXRoIGFuIGFsaWFzXHJcbiAgICAvLyAgQW5kIHdpbGwgYmUgZG9uZSB1c2luZyB0aGUgZGF0YSB0eXBlIHN5c3RlbS5cclxuXHJcbiAgICAncHJvcGVydHlfY3NzX3RyYW5zaXRpb25fZHVyYXRpb24nOiBmdW5jdGlvbiAoc3R5bGVfcHJvcGVydHlfbmFtZSkge1xyXG4gICAgICAgIC8vIHRoaXMuXy5zXHJcblxyXG4gICAgICAgIC8vIHdpbGwgcmVmZXIgdG8gc3R5bGUgcHJvcGVydGllcyBkaWZmZXJlbnRseVxyXG5cclxuICAgICAgICBpZiAodGhpcy5oYXMoJ18ucy50cmFuc2l0aW9uJykpIHtcclxuICAgICAgICAgICAgLy8gbG9vayB1cCB0aGUgY3NzIHRyYW5zaXRpb24gaW4gdGhlIGpzZ3VpIHN0eWxlXHJcbiAgICAgICAgICAgIC8vaWYodGhpcy5fLnMudHJhbnNpdGlvbikge1xyXG4gICAgICAgICAgICB2YXIgdHIgPSB0aGlzLl8ucy50cmFuc2l0aW9uO1xyXG4gICAgICAgICAgICBpZiAodHJbc3R5bGVfcHJvcGVydHlfbmFtZV0pIHtcclxuICAgICAgICAgICAgICAgIC8vIGFueXRoaW5nIGFib3V0IGR1cmF0aW9uIGV0Yz9cclxuICAgICAgICAgICAgICAgIHZhciBkdXIgPSB0cltzdHlsZV9wcm9wZXJ0eV9uYW1lXVswXTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBkdXI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy99XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvLyAncmV0JyBmdW5jdGlvbiAtIGdldHMgc29tZXRoaW5nIGlmIHBvc3NpYmxlLlxyXG4gICAgJ2hhcyc6IGZ1bmN0aW9uIChpdGVtX25hbWUpIHtcclxuICAgICAgICB2YXIgYXJyID0gaXRlbV9uYW1lLnNwbGl0KCcuJyk7XHJcbiAgICAgICAgLy9jb25zb2xlLmxvZygnYXJyICcgKyBhcnIpO1xyXG4gICAgICAgIHZhciBjID0gMCxcclxuICAgICAgICAgICAgbCA9IGFyci5sZW5ndGg7XHJcbiAgICAgICAgdmFyIGkgPSB0aGlzO1xyXG4gICAgICAgIHZhciBzO1xyXG4gICAgICAgIHdoaWxlIChjIDwgbCkge1xyXG4gICAgICAgICAgICBzID0gYXJyW2NdO1xyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdzICcgKyBzKTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBpW3NdID09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaSA9IGlbc107XHJcbiAgICAgICAgICAgIGMrKztcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyBUaGUgRG9tIGF0dHJpYnV0ZXMgY291bGQgY291bnQgYXMgZmllbGRzLCBhbmQgd2luZCB1cCByZW5kZXJpbmcgdGhlbXNlbHZlcyB1c2luZyBHZXQuXHJcbiAgICAvLyAgRG9tIGF0dHJpYnV0ZXMgbGlrZWx5IHRvIGJlIGEgY29sbGVjdGlvbiBhcyB3ZWxsLCBwZXJoYXBzIGF1dG9tYXRpY2FsbHkgc29ydGVkIGJ5IG5hbWUuXHJcbiAgICAvLyBDb3VsZCB1c2UgY29sbGVjdGlvbiByZW5kZXJpbmcuXHJcbiAgICAncmVuZGVyRG9tQXR0cmlidXRlcyc6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvL2NvbnNvbGUubG9nKCdyZW5kZXJEb21BdHRyaWJ1dGVzJyk7XHJcblxyXG4gICAgICAgIC8vIFByZS1yZW5kZXIgZG9tIGF0dHJpYnV0ZXM/XHJcbiAgICAgICAgLy8gIFRvIHNldCB0aGUgZG9tIGF0dHJpYnV0ZXMgcHJvZ3JhbW1hdGljYWxseSBhY2NvcmRpbmcgdG8gcHJvcGVydGllcy5cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuYmVmb3JlUmVuZGVyRG9tQXR0cmlidXRlcykge1xyXG4gICAgICAgICAgICB0aGlzLmJlZm9yZVJlbmRlckRvbUF0dHJpYnV0ZXMoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIE5lZWQgdG8gc2V0IHVwIHRoZSBkYXRhLWpzZ3VpLWN0cmwtZmllbGRzIGF0dHJpYnV0ZS5cclxuICAgICAgICAvLyAgUHJvYmFibHkgc2hvdWxkIG5vdCBiZSBzZXR0aW5nIGl0IGRpcmVjdGx5LlxyXG4gICAgICAgIC8vICBJdCdzIGp1c3QgYSBzdHJpbmcgcHJvcGVydHkuXHJcbiAgICAgICAgLy8gVGhlIGNvZGUgdGhhdCBJJ20gY3VycmVudGx5IHVzaW5nIGlzIG1lc3N5IGFuZCB3b3VsZCBiZSBiZXR0ZXIgaWYgaXQgd2VyZSBlbmNhcHN1bGF0ZWQuXHJcbiAgICAgICAgLy8gIEp1c3Qgc2V0dGluZyBhIHByb3BlcnR5IG9mIGEgY29udHJvbCB3aXRoIGFub3RoZXIgY29udHJvbCwgb24gdGhlIHNlcnZlciwgc2hvdWxkIGJlIGVub3VnaCB0byBnZXQgdGhpcyBtZWNoYW5pc20gb3BlcmF0aW5nLlxyXG4gICAgICAgIC8vICBJdCB3aWxsIGJlIGF2YWlsYWJsZSBhcyBhIGZpZWxkIG9uIHRoZSBjbGllbnQtc2lkZS5cclxuXHJcbiAgICAgICAgdmFyIGRvbV9hdHRycyA9IHRoaXMuZ2V0KCdkb20uYXR0cmlidXRlcycpO1xyXG5cclxuICAgICAgICBpZiAoIWRvbV9hdHRycykge1xyXG4gICAgICAgICAgdGhyb3cgJ2V4cGVjdGluZyBkb21fYXR0cnMnO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBpZiAodGhpcy5fY3RybF9maWVsZHMpIHtcclxuICAgICAgICAgICAgLy8gZ28gdGhyb3VnaCB0aGUgY29udHJvbCBmaWVsZHMsIHB1dHRpbmcgdG9nZXRoZXIgdGhlIGRhdGEgYXR0cmlidXRlIHRoYXQgd2lsbCBiZSBwZXJzaXRlZCB0byB0aGUgY2xpZW50LlxyXG5cclxuICAgICAgICAgICAgLy8gbmVlZCB0byBjb21wb3NlIHRoZSBzdHJpbmcuXHJcblxyXG4gICAgICAgICAgICB2YXIgb2JqX2N0cmxfZmllbGRzID0ge307XHJcblxyXG4gICAgICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMuX2N0cmxfZmllbGRzKTtcclxuICAgICAgICAgICAgdmFyIGtleTtcclxuICAgICAgICAgICAgZm9yICh2YXIgYyA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgYyA8IGw7IGMrKykge1xyXG4gICAgICAgICAgICAgIGtleSA9IGtleXNbY107XHJcbiAgICAgICAgICAgICAgb2JqX2N0cmxfZmllbGRzW2tleV0gPSB0aGlzLl9jdHJsX2ZpZWxkc1trZXldLl9pZCgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvL2VhY2godGhpcy5fY3RybF9maWVsZHMsIGZ1bmN0aW9uKGN0cmxfZmllbGQsIG5hbWUpIHtcclxuICAgICAgICAgICAgLy8gIG9ial9jdHJsX2ZpZWxkc1tuYW1lXSA9IGN0cmxfZmllbGQuX2lkKCk7XHJcbiAgICAgICAgICAgIC8vfSk7XHJcblxyXG5cclxuICAgICAgICAgICAgLy90aGlzLnNldCgnZG9tLmF0dHJpYnV0ZXMuZGF0YS1qc2d1aS1jdHJsLWZpZWxkcycsIHN0cmluZ2lmeShvYmpfY3RybF9maWVsZHMpLnJlcGxhY2UoL1wiL2csIFwiJ1wiKSk7XHJcbiAgICAgICAgICAgIC8vIGxvd2VyIGxldmVsIHNldCBoZXJlP1xyXG4gICAgICAgICAgICBkb21fYXR0cnMuc2V0KCdkYXRhLWpzZ3VpLWN0cmwtZmllbGRzJywgc3RyaW5naWZ5KG9ial9jdHJsX2ZpZWxkcykucmVwbGFjZSgvXCIvZywgXCInXCIpKVxyXG5cclxuXHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgaWYgKHRoaXMuX2ZpZWxkcykge1xyXG4gICAgICAgICAgICAvLyBnbyB0aHJvdWdoIHRoZSBjb250cm9sIGZpZWxkcywgcHV0dGluZyB0b2dldGhlciB0aGUgZGF0YSBhdHRyaWJ1dGUgdGhhdCB3aWxsIGJlIHBlcnNpdGVkIHRvIHRoZSBjbGllbnQuXHJcblxyXG4gICAgICAgICAgICAvLyBuZWVkIHRvIGNvbXBvc2UgdGhlIHN0cmluZy5cclxuXHJcbiAgICAgICAgICAgIC8vdmFyIG9ial9maWVsZHMgPSB7fTtcclxuICAgICAgICAgICAgLy9lYWNoKHRoaXMuX2N0cmxfZmllbGRzLCBmdW5jdGlvbihjdHJsX2ZpZWxkLCBuYW1lKSB7XHJcbiAgICAgICAgICAgIC8vICBvYmpfY3RybF9maWVsZHNbbmFtZV0gPSBjdHJsX2ZpZWxkLl9pZCgpO1xyXG4gICAgICAgICAgICAvL30pO1xyXG5cclxuICAgICAgICAgICAgLy90aGlzLnNldCgnZG9tLmF0dHJpYnV0ZXMuZGF0YS1qc2d1aS1maWVsZHMnLCBzdHJpbmdpZnkoe1xyXG4gICAgICAgICAgICAvLyAgICAnbnVtX2RheXMnOiBudW1fZGF5c1xyXG4gICAgICAgICAgICAvL30pLnJlcGxhY2UoL1wiL2csIFwiW0RCTF9RVF1cIikucmVwbGFjZSgvJy9nLCBcIltTTkdfUVRdXCIpKTtcclxuXHJcblxyXG4gICAgICAgICAgICAvL3RoaXMuc2V0KCdkb20uYXR0cmlidXRlcy5kYXRhLWpzZ3VpLWZpZWxkcycsIHN0cmluZ2lmeSh0aGlzLl9maWVsZHMpLnJlcGxhY2UoL1wiL2csIFwiW0RCTF9RVF1cIikucmVwbGFjZSgvJy9nLCBcIltTTkdfUVRdXCIpKTtcclxuICAgICAgICAgICAgZG9tX2F0dHJzLnNldCgnZGF0YS1qc2d1aS1maWVsZHMnLCBzdHJpbmdpZnkodGhpcy5fZmllbGRzKS5yZXBsYWNlKC9cIi9nLCBcIltEQkxfUVRdXCIpLnJlcGxhY2UoLycvZywgXCJbU05HX1FUXVwiKSlcclxuXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICB2YXIgYXJyID0gW107XHJcbiAgICAgICAgICAvL3ZhciBhcnJfZG9tID0gZG9tX2F0dHJzLl9hcnI7XHJcblxyXG4gICAgICAgICAgLy9mb3IgKHZhciBjID0gMCwgbCA9IGFycl9kb20ubGVuZ3RoOyBjIDwgbDsgYysrKSB7XHJcbiAgICAgICAgICAvLyAgYXJyLnB1c2goJyAnLCBjLCAnPVwiJywgYXJyX2RvbVtjXSwgJ1wiJyk7XHJcbiAgICAgICAgICAvL31cclxuICAgICAgICAgIHZhciBfID0gZG9tX2F0dHJzLl87XHJcbiAgICAgICAgICB2YXIgZG9tX2F0dHJzX2tleXMgPSBPYmplY3Qua2V5cyhfKTtcclxuICAgICAgICAgIC8vY29uc29sZS5sb2coJ2RvbV9hdHRyc19rZXlzJywgZG9tX2F0dHJzX2tleXMpO1xyXG4gICAgICAgICAgLy90aHJvdyAnc3RvcCc7XHJcblxyXG4gICAgICAgICAgdmFyIGtleSwgaXRlbTtcclxuICAgICAgICAgIGZvciAodmFyIGMgPSAwLCBsID0gZG9tX2F0dHJzX2tleXMubGVuZ3RoOyBjIDwgbDsgYysrKSB7XHJcbiAgICAgICAgICAgIGtleSA9IGRvbV9hdHRyc19rZXlzW2NdO1xyXG4gICAgICAgICAgICBpdGVtID0gX1trZXldO1xyXG4gICAgICAgICAgICBhcnIucHVzaCgnICcsIGtleSwgJz1cIicsIGl0ZW0sICdcIicpO1xyXG4gICAgICAgICAgfVxyXG5cclxuXHJcblxyXG4gICAgICAgICAgLy9kb21fYXR0cnMuZWFjaChmdW5jdGlvbiAoaSwgdikge1xyXG4gICAgICAgICAgLy8gICAgYXJyLnB1c2goJyAnLCBpLCAnPVwiJywgdiwgJ1wiJyk7XHJcbiAgICAgICAgICAvL30pO1xyXG4gICAgICAgICAgcmV0dXJuIGFyci5qb2luKCcnKTtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAvLyBNYWludGFpbmluZyBhIGRpY3QsIG9yIHNvbWUgZGF0YSBzdHJ1Y3R1cmUgb2YgdGhlIGlubGluZSBzdHlsZXMgd2lsbCBoZWxwLlxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG4gICAgICAgIC8vcmVzID0gYXJyLmpvaW4oJycpO1xyXG4gICAgICAgIC8vcmV0dXJuIHJlcztcclxuXHJcbiAgICB9LFxyXG4gICAgJ3JlbmRlckJlZ2luVGFnVG9IdG1sJzogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICAvLyB3aWxsIGJlIGluIF8uZG9tLnRhZ05hbWVcclxuICAgICAgICAvLyAgSSB0aGluayB0aGF0J3Mgd2h5IHdlIG5lZWQgdGhlIGZ1cnRoZXIgbGV2ZWwgcHJvcGVydGllcy5cclxuXHJcbiAgICAgICAgLy8gZG9tLnN0eWxlLnRyYW5zZm9ybTNkLnRyYW5zbGF0ZTNkXHJcbiAgICAgICAgLy8gIHRoZXNlIHByb3BlcnR5IGxldmVscyBjb3VsZCBnbyBxdWl0ZSBkZWVwLiBXYW50IGEgY29udmVuaWVudCB3YXkgb2YgdXNpbmcgdGhlbSB3aXRob3V0IGhhdmluZyB0byBtYW51YWxseSBjb2RlIGxvdHMgb2ZcclxuICAgICAgICAvLyAgaXRlcmF0aW9ucywgbmVzdGVkIGV4aXN0YW5jZSBjaGVja3MuIENvdWxkIGhhdmUgc2hvcnRjdXRzIHNvIGl0IGtub3dzIHdoYXQgZG9tLnRyYW5zbGF0ZTNkIG1lYW5zLlxyXG4gICAgICAgIC8vIGRvIHdlIGhhdmUgJ2dldCc/XHJcbiAgICAgICAgLy92YXIgZG9tID0gdGhpcy5nZXQoJ2RvbScpO1xyXG4gICAgICAgIC8vdmFyIHRhZ05hbWUgPSB0aGlzLmdldCgnZG9tLnRhZ05hbWUnKSxcclxuICAgICAgICB2YXIgdGFnTmFtZSA9IHRoaXMuXy5kb20uXy50YWdOYW1lO1xyXG4gICAgICAgIC8vY29uc29sZS5sb2coJ3RoaXMuXy5kb20nLCB0aGlzLl8uZG9tLl8uYXR0cmlidXRlcyk7XHJcblxyXG4gICAgICAgIC8vY29uc29sZS5sb2coJ3RhZ05hbWUnLCB0YWdOYW1lKTtcclxuICAgICAgICAgICAgcmVzO1xyXG5cclxuICAgICAgICBpZiAodGFnTmFtZSA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgcmVzID0gJyc7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgIC8vdmFyIGRvbV9hdHRyaWJ1dGVzID0gdGhpcy5yZW5kZXJEb21BdHRyaWJ1dGVzKCk7XHJcbiAgICAgICAgICAgIHJlcyA9IFsnPCcsIHRhZ05hbWUsIHRoaXMucmVuZGVyRG9tQXR0cmlidXRlcygpLCAnPiddLmpvaW4oJycpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL3ZhciByZXMgPSBbJzwnLCB0aGlzLl8udGFnTmFtZSwgdGhpcy5yZW5kZXJEb21BdHRyaWJ1dGVzKCksICc+J10uam9pbignJyk7XHJcblxyXG4gICAgICAgIC8vY29uc29sZS5sb2coJ3JlbmRlckJlZ2luVGFnVG9IdG1sIHJlcyAnICsgcmVzKTtcclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfSxcclxuICAgICdyZW5kZXJFbmRUYWdUb0h0bWwnOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gd2lsbCBoYXZlIGRpZmZlcmVudCB3YXkgb2YgcmVmZXJyaW5nIHRvIHRoZSB0YWdOYW1lLCBidXQgdGhhdCBjb3VsZCBiZSBhIHNob3J0Y3V0LlxyXG4gICAgICAgIC8vIGRvbS50YWdOYW1lKCk7XHJcbiAgICAgICAgLy8gIHRocm91Z2ggdGhlIGZpZWxkcyBzeXN0ZW0uXHJcbiAgICAgICAgdmFyIGRvbSA9IHRoaXMuZ2V0KCdkb20nKTtcclxuICAgICAgICB2YXIgdGFnTmFtZSA9IGRvbS5nZXQoJ3RhZ05hbWUnKSxcclxuICAgICAgICAgICAgcmVzO1xyXG5cclxuICAgICAgICB2YXIgbm9DbG9zaW5nVGFnID0gZG9tLmdldCgnbm9DbG9zaW5nVGFnJyk7XHJcblxyXG4gICAgICAgIC8vY29uc29sZS5sb2codG9mKG5vQ2xvc2luZ1RhZykpO1xyXG4gICAgICAgIC8vdGhyb3cgJ3N0b3AnO1xyXG5cclxuICAgICAgICBpZiAodGFnTmFtZSA9PT0gZmFsc2UgfHwgbm9DbG9zaW5nVGFnKSB7XHJcbiAgICAgICAgICAgIHJlcyA9ICcnO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJlcyA9IFsnPC8nLCB0YWdOYW1lLCAnPiddLmpvaW4oJycpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9jb25zb2xlLmxvZygncmVuZGVyQmVnaW5UYWdUb0h0bWwgcmVzICcgKyByZXMpO1xyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9LFxyXG4gICAgJ3JlbmRlckh0bWxBcHBlbmRtZW50JzogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmh0bWxBcHBlbmRtZW50IHx8ICcnO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyBub3QgcmVuZGVyaW5nIGEgalF1ZXJ5IG9iamVjdC4uLi5cclxuICAgIC8vIGNvbnRlbnQgaW5jbHVkaW5nIHRoZSB0YWdzPyBOb3QgZm9yIHRoZSBtb21lbnQuIFRhZ3MgYmVpbmcgZmFsc2UgbWVhbnMgdGhlcmUgYXJlIG5vIHRhZ3MsIGFuZCB0aGlzIHRhZ2xlc3MgY29udHJvbCBhY3RzIGFzIGEgY29udGFpbmVyIGZvciBvdGhlclxyXG4gICAgLy8gIGNvbnRyb2xzIG9yIGNvbnRlbnQuXHJcbiAgICAvLyBUaGF0IHdpbGwgYmUgdXNlZnVsIGZvciBoYXZpbmcgZGlmZmVyZW50IGluc2VydGlvbiBwb2ludHMgaW4gY29udHJvbHMgd2l0aG91dCBoYXZpbmcgdG8gaGF2ZSB0aGVtIGVuY2xvc2VkIGJ5IGFuIEhUTUwgZWxlbWVudC5cclxuXHJcbiAgICAncmVuZGVyRW1wdHlOb2RlSnFvJzogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBbdGhpcy5yZW5kZXJCZWdpblRhZ1RvSHRtbCgpLCB0aGlzLnJlbmRlckVuZFRhZ1RvSHRtbCgpLCB0aGlzLnJlbmRlckh0bWxBcHBlbmRtZW50KCldLmpvaW4oJycpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyBOZWVkIHRvIGltcGxlbWVudCBkZWZlcnJlZCByZW5kZXJpbmcuXHJcbiAgICAvLyAgU29tZSBjb250cm9scyB3aWxsIGdlIHR0aGVpciBkYXRhIGZyb20gYSBSZXNvdXJjZSAvIGZyb20gUmVzb3VyY2VzLlxyXG4gICAgLy8gIFRoaXMgbWVhbnMgdGhlIGRhdGEgaXMgYXZhaWxhYmxlIHRvIHRoZW0gYXN5bmNyb25vdXNseS5cclxuICAgIC8vICBUaGUgY29udHJvbCB3aWxsIG5vdCBiZSByZWFkeSB0byByZW5kZXIgaW1tZWRpYXRlbHkuXHJcblxyXG4gICAgLy8gRm9yIGV4YW1wbGUsIGEgY29udHJvbCBzaG93cyB0aGUgcmVjb3JkcyBpbiBhIERCIHRhYmxlLiBUaGlzIGlzIGRvbmUgdGhyb3VnaCBhY2Nlc3NpbmcgYSBSZXNvdXJjZS5cclxuICAgIC8vICBUaGUgY29udHJvbCB3aWxsIG5vdCBiZSByZWFkeSB0byByZW5kZXIgdW50aWwgaXQgaGFzIGxvYWRlZCB0aGUgZGF0YSBmcm9tIHRoZSBSZXNvdXJjZS5cclxuXHJcbiAgICAvLyBJIHRoaW5rIHNvbWUga2luZCBvZiAnc3RhdHVzJyBpbiB0aGUgQ29udHJvbCB3b3VsZCBtYWtlIHNlbnNlLlxyXG4gICAgLy8gIEFzc3VtZWQgdG8gYmUgcmVhZHksIGJ1dCBjb3VsZCBoYXZlIC5fX3N0YXR1cyA9ICd3YWl0aW5nJ1xyXG4gICAgLy8gQ291bGQgaG9sZCBtb3JlIGluZm8gYWJvdXQgd2FpdGluZyBhbmQgdGltaW5nP1xyXG5cclxuICAgIC8vIEZvciB0aGUgbW9tZW50LCBqdXN0IG5lZWQgdG8gYmUgYWJsZSB0byBkZWxheSByZW5kZXJpbmcgYSBjb250cm9sIHVudGlsIGFsbCBzdWJjb250cm9scyBhcmUgcmVhZHkuXHJcblxyXG4gICAgLy8gV2lsbCBnbyB0aHJvdWdoIHRoZSBjb250cm9sIHRyZWUgbGlrZSB3aXRoIHJlbmRlcmluZywgbm90aW5nIGRvd24gYW55IHRoYXQgYXJlIG5vdCByZWFkeSwgYW5kIHN1YnNjcmliaW5nIHRvIHRoZWlyIHJlYWR5IGV2ZW50cy5cclxuICAgIC8vICBXZSBjb3VudCBkb3duIHRoZSBudW1iZXIgeWV0IHRvIGJlIHJlYWR5LCB3aGVuIHRoYXQgaXMgMCB3ZSBkbyB0aGUgcmVuZGVyaW5nIGxpa2Ugbm9ybWFsLCBleGNlcHQgcmV0dXJuaW5nIHRoZSByZXN1bHQgYXN5bmNyb25vdXNseS5cclxuXHJcblxyXG4gICAgJ2l0ZXJhdGVfdGhpc19hbmRfc3ViY29udHJvbHMnOiBmdW5jdGlvbihjdHJsX2NhbGxiYWNrKSB7XHJcbiAgICAgICAgY3RybF9jYWxsYmFjayh0aGlzKTtcclxuXHJcbiAgICAgICAgdmFyIGNvbnRlbnQgPSB0aGlzLmdldCgnY29udGVudCcpO1xyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuXHJcbiAgICAgICAgY29udGVudC5lYWNoKGZ1bmN0aW9uKGksIHYpIHtcclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygndicsIHYpO1xyXG5cclxuICAgICAgICAgICAgdHYgPSB0b2Yodik7XHJcbiAgICAgICAgICAgIGlmICh0diA9PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgLy8gZXNjYXBlIHRoZSBzdHJpbmcuXHJcblxyXG4gICAgICAgICAgICAgICAgLy92YXIgb3V0cHV0ID0ganNndWkub3V0cHV0X3Byb2Nlc3NvcnNbJ3N0cmluZyddKG4pO1xyXG4gICAgICAgICAgICAgICAgLy9yZXMucHVzaChvdXRwdXQpO1xyXG4gICAgICAgICAgICAgICAgLy9yZXMucHVzaChqc2d1aS5vdXRwdXRfcHJvY2Vzc29yc1snc3RyaW5nJ10obikpO1xyXG5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICBpZiAodG9mKG4pID09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBlc2NhcGUgdGhlIHN0cmluZy5cclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgb3V0cHV0ID0ganNndWkub3V0cHV0X3Byb2Nlc3NvcnNbJ3N0cmluZyddKG4pO1xyXG4gICAgICAgICAgICAgICAgcmVzLnB1c2gob3V0cHV0KTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgaWYgKHR2ID09ICdkYXRhX3ZhbHVlJykge1xyXG4gICAgICAgICAgICAgICAgLy92YXIgb3V0cHV0ID0ganNndWkub3V0cHV0X3Byb2Nlc3NvcnNbJ3N0cmluZyddKG4uZ2V0KCkpO1xyXG4gICAgICAgICAgICAgICAgLy9yZXMucHVzaChqc2d1aS5vdXRwdXRfcHJvY2Vzc29yc1snc3RyaW5nJ10obi5nZXQoKSkpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy9odG0gPSBuLmFsbF9odG1sX3JlbmRlcigpO1xyXG4gICAgICAgICAgICAgICAgLy9yZXMucHVzaChuLmFsbF9odG1sX3JlbmRlcigpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBpdCBzaG91bGQgbm90IGJlIG51bGwsIGJ1dCBjYW4gaWdub3JlIGl0IGZvciB0aGUgbW9tZW50IC8gZm9yZXZlclxyXG5cclxuICAgICAgICAgICAgICAgIGlmICh2ICYmIHYuaXRlcmF0ZV90aGlzX2FuZF9zdWJjb250cm9scykge1xyXG4gICAgICAgICAgICAgICAgICAgIHYuaXRlcmF0ZV90aGlzX2FuZF9zdWJjb250cm9scy5jYWxsKHYsIGN0cmxfY2FsbGJhY2spO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcblxyXG5cclxuICAgICAgICB9KTtcclxuXHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvLyBTaG91bGQgbm93IGluY2x1ZGUgZGVmZXJyZWQgcmVuZGVyaW5nLlxyXG5cclxuICAgICdhbGxfaHRtbF9yZW5kZXInOiBmdW5jdGlvbihjYWxsYmFjaykge1xyXG5cclxuICAgICAgICAvL2NvbnNvbGUubG9nKCdhbGwgcmVuZGVyIGNhbGxiYWNrJywgdG9mKGNhbGxiYWNrKSk7XHJcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XHJcblxyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdkZWZlcnJlZCByZW5kZXJpbmcnKTtcclxuICAgICAgICAgICAgLy90aHJvdyAnc3RvcCc7XHJcblxyXG4gICAgICAgICAgICAvLyBHZXQgdGhlIG1hcCBvZiBhbnkgY29udHJvbHMgdGhhdCBoYXZlIF9fc3RhdHVzID09ICd3YWl0aW5nJy5cclxuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgICAgICAvLyB3YW50IHRvIHJlY3Vyc2l2ZWx5IGl0ZXJhdGUgdGhyb3VnaCBjb250cm9scyBhbmQgc3ViY29uc3Ryb2xzLlxyXG4gICAgICAgICAgICB2YXIgYXJyX3dhaXRpbmdfY29udHJvbHMgPSBbXTtcclxuXHJcbiAgICAgICAgICAgIC8vIFdvcnRoIHNldHRpbmcgdXAgdGhlIGxpc3RlbmVyIG9uIHRoaXMgbG9vcD9cclxuXHJcblxyXG5cclxuICAgICAgICAgICAgdGhpcy5pdGVyYXRlX3RoaXNfYW5kX3N1YmNvbnRyb2xzKGZ1bmN0aW9uKGNvbnRyb2wpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjb250cm9sLl9fc3RhdHVzID09ICd3YWl0aW5nJykgYXJyX3dhaXRpbmdfY29udHJvbHMucHVzaChjb250cm9sKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAvLyB0aGVuIGlmIHdlIGFyZSB3YWl0aW5nIG9uIGFueSBvZiB0aGVtIHdlIGxpc3RlbiBmb3IgdGhlbSB0byBjb21wbGV0ZS5cclxuXHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2Fycl93YWl0aW5nX2NvbnRyb2xzLmxlbmd0aCcsIGFycl93YWl0aW5nX2NvbnRyb2xzLmxlbmd0aCk7XHJcblxyXG4gICAgICAgICAgICBpZiAoYXJyX3dhaXRpbmdfY29udHJvbHMubGVuZ3RoID09IDApIHtcclxuICAgICAgICAgICAgICAgIHZhciBodG1sID0gdGhpcy5hbGxfaHRtbF9yZW5kZXIoKTtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIGh0bWwpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIGMgPSBhcnJfd2FpdGluZ19jb250cm9scy5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGNvbXBsZXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnY29tcGxldGUnKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGF0LnByZV9hbGxfaHRtbF9yZW5kZXIoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRvbSA9IHRoYXQuZ2V0KCdkb20nKTtcclxuICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdkb20nLCBkb20pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoZG9tKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRvZXMgaXQgaGF2ZSBpbm5lckhUTUw/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICBJIHRoaW5rIHRoYXQgd2lsbCBqdXN0IGJlIGEgY29udGVudCBpdGVtIHRoYXQgZ2V0cyByZW5kZXJlZCBhbnl3YXkuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2hhcyBkb20nKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYmVnaW5uaW5nID0gdGhpcy5yZW5kZXJCZWdpblRhZ1RvSHRtbCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWlkZGxlID0gdGhpcy5hbGxfaHRtbF9yZW5kZXJfaW50ZXJuYWxfY29udHJvbHMoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVuZCA9IHRoaXMucmVuZGVyRW5kVGFnVG9IdG1sKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhcHBlbmRtZW50ID0gdGhpcy5yZW5kZXJIdG1sQXBwZW5kbWVudCgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzID0gW2JlZ2lubmluZywgbWlkZGxlLCBlbmQsIGFwcGVuZG1lbnRdLmpvaW4oJycpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3JldHVybiBbdGhhdC5yZW5kZXJCZWdpblRhZ1RvSHRtbCgpLCB0aGF0LmFsbF9odG1sX3JlbmRlcl9pbnRlcm5hbF9jb250cm9scygpLCB0aGF0LnJlbmRlckVuZFRhZ1RvSHRtbCgpLCB0aGF0LnJlbmRlckh0bWxBcHBlbmRtZW50KCldLmpvaW4oJycpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaHRtbCA9IFt0aGF0LnJlbmRlckJlZ2luVGFnVG9IdG1sKCksIHRoYXQuYWxsX2h0bWxfcmVuZGVyX2ludGVybmFsX2NvbnRyb2xzKCksIHRoYXQucmVuZGVyRW5kVGFnVG9IdG1sKCksIHRoYXQucmVuZGVySHRtbEFwcGVuZG1lbnQoKV0uam9pbignJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2h0bWwnLCBodG1sKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgaHRtbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vdGhyb3cgKCdzdG9wJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGVhY2goYXJyX3dhaXRpbmdfY29udHJvbHMsIGZ1bmN0aW9uKGNvbnRyb2wsIGkpIHtcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2wub24oJ3JlYWR5JywgZnVuY3Rpb24oZV9yZWFkeSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdjb250cm9sIHJlYWR5Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGMtLTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnYycpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYyA9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJlX2FsbF9odG1sX3JlbmRlcigpO1xyXG5cclxuICAgICAgICAgICAgdmFyIGRvbSA9IHRoaXMuZ2V0KCdkb20nKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChkb20pIHtcclxuICAgICAgICAgICAgICAgIC8vIGRvZXMgaXQgaGF2ZSBpbm5lckhUTUw/XHJcbiAgICAgICAgICAgICAgICAvLyAgSSB0aGluayB0aGF0IHdpbGwganVzdCBiZSBhIGNvbnRlbnQgaXRlbSB0aGF0IGdldHMgcmVuZGVyZWQgYW55d2F5LlxyXG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnaGFzIGRvbScpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8qXHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGJlZ2lubmluZyA9IHRoaXMucmVuZGVyQmVnaW5UYWdUb0h0bWwoKTtcclxuICAgICAgICAgICAgICAgIHZhciBtaWRkbGUgPSB0aGlzLmFsbF9odG1sX3JlbmRlcl9pbnRlcm5hbF9jb250cm9scygpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGVuZCA9IHRoaXMucmVuZGVyRW5kVGFnVG9IdG1sKCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgYXBwZW5kbWVudCA9IHRoaXMucmVuZGVySHRtbEFwcGVuZG1lbnQoKTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXMgPSBbYmVnaW5uaW5nLCBtaWRkbGUsIGVuZCwgYXBwZW5kbWVudF0uam9pbignJyk7XHJcbiAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFt0aGlzLnJlbmRlckJlZ2luVGFnVG9IdG1sKCksIHRoaXMuYWxsX2h0bWxfcmVuZGVyX2ludGVybmFsX2NvbnRyb2xzKCksIHRoaXMucmVuZGVyRW5kVGFnVG9IdG1sKCksIHRoaXMucmVuZGVySHRtbEFwcGVuZG1lbnQoKV0uam9pbignJyk7XHJcbiAgICAgICAgICAgICAgICAvL3Rocm93ICgnc3RvcCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL2NvbnNvbGUubG9nKCdhbGxfaHRtbF9yZW5kZXIgJyk7XHJcbiAgICAgICAgLy9pZiAodGhpcy5wcmVfYWxsX2h0bWxfcmVuZGVyKSB7XHJcbiAgICAgICAgLy9cclxuICAgICAgICAvL31cclxuXHJcblxyXG4gICAgICAgIC8vcmV0dXJuIHJlcztcclxuICAgIH0sXHJcblxyXG5cclxuXHJcbiAgICAncmVuZGVyX2NvbnRlbnQnOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIC8vY29uc29sZS5sb2coJ3JlbmRlcl9jb250ZW50Jyk7XHJcblxyXG4gICAgICAgIC8vIGl0J3MgY29udHJvbHMoKSBub3csIGdldHMgdGhlIGNvbGxlY3Rpb24gb2YgY29udHJvbHMuXHJcbiAgICAgICAgLy9lYWNoKHRoaXMuXy5jb250cm9scywgZnVuY3Rpb24oaSwgbikge1xyXG5cclxuICAgICAgICAvL3ZhciBmaWVsZHMgPSB0aGlzLmZpZWxkcygpO1xyXG4gICAgICAgIC8vY29uc29sZS5sb2coJ2ZpZWxkcyAnICsgc3RyaW5naWZ5KGZpZWxkcykpO1xyXG5cclxuICAgICAgICAvLyBTb21lIGtpbmQgb2YgZnVsbCBjb250ZW50P1xyXG4gICAgICAgIC8vICBDb250ZW50IHNob3J0Y3V0cz9cclxuXHJcbiAgICAgICAgLy8gT3IgaGF2ZSBhbiBpbnRlcm5hbF9jb250ZW50IHByb3BlcnR5P1xyXG4gICAgICAgIC8vICBQb3NzaWJpbGl0eSBvZiBkaWZmZXJlbnQgcGxhY2VzIGZvciBpbnRlcm5hbCBjb250ZW50P1xyXG4gICAgICAgIC8vICAgT3Igbm90IHJpZ2h0IG5vdz9cclxuXHJcbiAgICAgICAgLy8gSSB0aGluayBhbiBpbnRlcm5hbF9jb250ZW50IHJlZmVyZW5jZSB3b3VsZCBiZSBiZXN0LlxyXG4gICAgICAgIC8vICBvciBqdXN0IC5pbnRlcm5hbFxyXG5cclxuXHJcbiAgICAgICAgLy8gc2hvdWxkIGJlIGFibGUgdG8gZ2V0IHRoZSBjb250ZW50Li4uIGl0J3MgYSBmaWVsZC5cclxuICAgICAgICAvLyAgYnV0IGNvbXBsaWNhdGlvbnMgYmVjYXVzZSBpdCdzIGEgY29sbGVjdGlvbi5cclxuXHJcbiAgICAgICAgLy8gV2hlbiBhZGRpbmcgYSBzdHJpbmcgdG8gdGhlIGNvbGxlY3Rpb24uLi5cclxuXHJcbiAgICAgICAgdmFyIGNvbnRlbnQgPSB0aGlzLmdldCgnY29udGVudCcpO1xyXG5cclxuICAgICAgICAvLyBEb2VzIG5vdCBoYXZlIGNvbnRlbnQ/XHJcbiAgICAgICAgLy8gIFRoYXQncyB2ZXJ5IHN0cmFuZ2UuXHJcblxyXG4gICAgICAgIGlmICghY29udGVudC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJyEhIW5vIGNvbnRlbnQgbGVuZ3RoISEhJyk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCcnKTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2codGhpcyk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCcnKTtcclxuICAgICAgICAgICAgY29uc29sZS50cmFjZSgpO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnY29udGVudCcsIGNvbnRlbnQpO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygndG9mKGNvbnRlbnQpICcgKyB0b2YoY29udGVudCkpO1xyXG4gICAgICAgICAgICB0aHJvdyAnc3RvcCc7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL2NvbnNvbGUubG9nKCdjb250ZW50JywgY29udGVudCk7XHJcbiAgICAgICAgLy9jb25zb2xlLmxvZygndG9mKGNvbnRlbnQpICcgKyB0b2YoY29udGVudCkpO1xyXG5cclxuICAgICAgICAvLyBUaGUgY29udGVudCBzaG91bGQgbm90IGJlIGEgY29udHJvbC5cclxuICAgICAgICAvLyAgQ2FuJ3QgY2FsbCBhIHBhcnQgb2YgYSBjb250cm9sIGl0cyAnY29udGVudCcsIGFzIHRoYXQgYWxyZWFkeSBleGlzdHMuXHJcbiAgICAgICAgLy8gIFNob3VsZCBiZSBjb25zaWRlcmVkIGEgcHJvdGVjdGVkIHdvcmQuXHJcblxyXG4gICAgICAgIHZhciBjb250ZW50TGVuZ3RoID0gY29udGVudC5sZW5ndGgoKTtcclxuXHJcbiAgICAgICAgLy8gdmFyIHJlcyA9IFtdO1xyXG5cclxuICAgICAgICB2YXIgcmVzID0gbmV3IEFycmF5KGNvbnRlbnRMZW5ndGgpO1xyXG5cclxuICAgICAgICAvL2NvbnNvbGUubG9nKCctLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tJyk7XHJcbiAgICAgICAgLy9jb25zb2xlLmxvZygnY29udGVudCAnICsgc3RyaW5naWZ5KGNvbnRlbnQpKTtcclxuICAgICAgICAvL2NvbnNvbGUubG9nKCd0b2YoY29udGVudCkgJyArIHRvZihjb250ZW50KSk7XHJcbiAgICAgICAgLy90aHJvdygnOCkgc3RvcCcpO1xyXG5cclxuICAgICAgICAvKlxyXG4gICAgXHRlYWNoKGNvbnRyb2xzLl9hcnIsIGZ1bmN0aW9uKGksIG4pIHtcclxuICAgICAgICAgICAgaHRtID0gbi5hbGxfaHRtbF9yZW5kZXIoKTtcclxuICAgICAgICAgICAgcmVzLnB1c2goaHRtKTtcclxuICAgICAgICB9KTtcclxuICAgIFx0Ki9cclxuICAgICAgICB2YXIgdG4sIG91dHB1dDtcclxuICAgICAgICAvL2NvbnNvbGUubG9nKCdjb250ZW50JywgY29udGVudCk7XHJcblxyXG4gICAgICAgIC8vIGNvbnRlbnQuX2FyclxyXG5cclxuICAgICAgICB2YXIgYXJyID0gY29udGVudC5fYXJyO1xyXG4gICAgICAgIHZhciBjLCBsID0gYXJyLmxlbmd0aCwgbjtcclxuXHJcbiAgICAgICAgZm9yIChjID0gMDsgYyA8IGw7IGMrKykge1xyXG4gICAgICAgICAgbiA9IGFycltjXTtcclxuICAgICAgICAgIC8vIENvdWxkIHVzZSBmYXN0ZXIgZHVjayB0eXBpbmcgaGVyZS5cclxuICAgICAgICAgIHRuID0gdG9mKG4pO1xyXG4gICAgICAgICAgaWYgKHRuID09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgLy8gZXNjYXBlIHRoZSBzdHJpbmcuXHJcbiAgICAgICAgICAgICAgLy92YXIgb3V0cHV0ID0ganNndWkub3V0cHV0X3Byb2Nlc3NvcnNbJ3N0cmluZyddKG4pO1xyXG4gICAgICAgICAgICAgIC8vcmVzLnB1c2gob3V0cHV0KTtcclxuICAgICAgICAgICAgICByZXMucHVzaChqc2d1aS5vdXRwdXRfcHJvY2Vzc29yc1snc3RyaW5nJ10obikpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgLypcclxuICAgICAgICAgIGlmICh0b2YobikgPT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAvLyBlc2NhcGUgdGhlIHN0cmluZy5cclxuXHJcbiAgICAgICAgICAgICAgdmFyIG91dHB1dCA9IGpzZ3VpLm91dHB1dF9wcm9jZXNzb3JzWydzdHJpbmcnXShuKTtcclxuICAgICAgICAgICAgICByZXMucHVzaChvdXRwdXQpO1xyXG5cclxuICAgICAgICAgIH1cclxuICAgICAgICAgICovXHJcbiAgICAgICAgICBpZiAodG4gPT0gJ2RhdGFfdmFsdWUnKSB7XHJcbiAgICAgICAgICAgICAgLy92YXIgb3V0cHV0ID0ganNndWkub3V0cHV0X3Byb2Nlc3NvcnNbJ3N0cmluZyddKG4uZ2V0KCkpO1xyXG4gICAgICAgICAgICAgIHJlcy5wdXNoKGpzZ3VpLm91dHB1dF9wcm9jZXNzb3JzWydzdHJpbmcnXShuLl8pKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgaWYgKHRuID09ICdkYXRhX29iamVjdCcpIHtcclxuICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnbicsIG4pO1xyXG4gICAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgICB0aHJvdyAnc3RvcCc7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgcmVzLnB1c2gobi5hbGxfaHRtbF9yZW5kZXIoKSk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIC8vaHRtID0gbi5hbGxfaHRtbF9yZW5kZXIoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgY29udGVudC5lYWNoKGZ1bmN0aW9uIChpLCBuKSB7XHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0nKTtcclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygndG9mKG4pICcgKyB0b2YobikpO1xyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCcobikgJyArIHN0cmluZ2lmeShuKSk7XHJcbiAgICAgICAgICAgIC8vdGhyb3cgJ3N0b3AnO1xyXG4gICAgICAgICAgICB0biA9IHRvZihuKTtcclxuICAgICAgICAgICAgaWYgKHRuID09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBlc2NhcGUgdGhlIHN0cmluZy5cclxuICAgICAgICAgICAgICAgIC8vdmFyIG91dHB1dCA9IGpzZ3VpLm91dHB1dF9wcm9jZXNzb3JzWydzdHJpbmcnXShuKTtcclxuICAgICAgICAgICAgICAgIC8vcmVzLnB1c2gob3V0cHV0KTtcclxuICAgICAgICAgICAgICAgIHJlcy5wdXNoKGpzZ3VpLm91dHB1dF9wcm9jZXNzb3JzWydzdHJpbmcnXShuKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRuID09ICdkYXRhX3ZhbHVlJykge1xyXG4gICAgICAgICAgICAgICAgLy92YXIgb3V0cHV0ID0ganNndWkub3V0cHV0X3Byb2Nlc3NvcnNbJ3N0cmluZyddKG4uZ2V0KCkpO1xyXG4gICAgICAgICAgICAgICAgcmVzLnB1c2goanNndWkub3V0cHV0X3Byb2Nlc3NvcnNbJ3N0cmluZyddKG4uZ2V0KCkpKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmICh0biA9PSAnZGF0YV9vYmplY3QnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ24nLCBuKTtcclxuICAgICAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93ICdzdG9wJztcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2gobi5hbGxfaHRtbF9yZW5kZXIoKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvL2h0bSA9IG4uYWxsX2h0bWxfcmVuZGVyKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICAqL1xyXG5cclxuICAgICAgICAvL2NvbnNvbGUubG9nKCdyZXMnLCByZXMpO1xyXG4gICAgICAgIHJldHVybiByZXMuam9pbignJyk7XHJcbiAgICB9LFxyXG5cclxuICAgICdhbGxfaHRtbF9yZW5kZXJfaW50ZXJuYWxfY29udHJvbHMnOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy92YXIgY29udHJvbHMgPSB0aGlzLmNvbnRyb2xzLCByZXMgPSBbXTtcclxuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJfY29udGVudCgpO1xyXG4gICAgfSxcclxuICAgICdwcmVfYWxsX2h0bWxfcmVuZGVyJzogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLy8gTWF5IGhhcHBlbiB0aHJvdWdoIERhdGFfT2JqZWN0IGV2ZW50cyBhcyB3ZWxsLlxyXG5cclxuICAgIC8vIGJpbmQgZG9tIGV2ZW50IHRvIG5vcm1hbCBldmVudHM/XHJcbiAgICAvLyAgQmUgcXVpdGUgZXhwbGljaXQgaW4gd2hpY2ggb25lcyBnZXQgYm91bmQgZm9yIHRoZSBtb21lbnQuXHJcblxyXG4gICAgLy8gV2FudCBpdCBzbyB0aGF0IHRoZSBkb20gYXR0cmlidXRlcyBzdHlsZSBnZXRzIGNoYW5nZWQgd2l0aCB0aGUgY3NzX2ZsYWdzLlxyXG4gICAgLypcclxuXHJcbiAgICAnYmluZF9kb21fZXZlbnQnOiBmdW5jdGlvbiAoZXZ0X25hbWUsIGV2dF9oYW5kbGVyKSB7XHJcblxyXG4gICAgICAgIC8vIGJ1dCBtYWtlIHRoaXMgcmFpc2UgYSBqc2d1aSBldmVudCB0b29cclxuICAgICAgICB2YXIgbiA9IHRoaXMuZG9tTm9kZSgpO1xyXG5cclxuICAgICAgICAvLyB0aGlzLl9lbD9cclxuICAgICAgICBpZiAobikge1xyXG4gICAgICAgICAgICBuLmFkZEV2ZW50TGlzdGVuZXIoZXZ0X25hbWUsIGV2dF9oYW5kbGVyLCBmYWxzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAndW5iaW5kX2RvbV9ldmVudCc6IGZ1bmN0aW9uIChldnRfbmFtZSwgZXZ0X2hhbmRsZXIpIHtcclxuXHJcbiAgICAgICAgLy9qc2d1aS5fZG9tX3JlbW92ZUV2ZW50TGlzdGVuZXIoZG9tX25vZGUsIGV2dF9uYW1lLCBldnRfaGFuZGxlciwgZmFsc2UpO1xyXG4gICAgICAgIC8vIGpzZ3VpLl9kb21fdW5iaW5kX2V2ZW50KGRvbV9ub2RlLCBldnRfbmFtZSwgZXZ0X2hhbmRsZXIpIC0gcGhhc2UgYXNzdW1lZCwgbm8gYm9vbGVhbiBoZXJlLCBkaWZmZXJlbnQgQVBJLlxyXG4gICAgICAgIC8vIGEgKGpzZ3VpKSBhcGkgb3V0c2lkZSBvZiB0aGUgY29udHJvbHMuXHJcblxyXG4gICAgICAgIHZhciBuID0gdGhpcy5kb21Ob2RlKCk7XHJcbiAgICAgICAgaWYgKG4pIHtcclxuICAgICAgICAgICAgbi5yZW1vdmVFdmVudExpc3RlbmVyKGV2dF9uYW1lLCBldnRfaGFuZGxlciwgZmFsc2UpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLy8gZXZlbnQgaGFuZGxpbmcgLSBsaWtlbHkgdG8gYmUgbW92ZWQgdG8gRGF0YU9iamVjdC4gQ29udHJvbHMgd2lsbCBzdGlsbCBoYW5kbGUgZXZlbnRzIVxyXG5cclxuICAgICdiaW5kX2N0cmxfZXZlbnQnOiBmdW5jdGlvbiAoZXZ0X25hbWUsIGV2dF9oYW5kbGVyKSB7XHJcblxyXG4gICAgICAgIC8vIGNvdWxkIHVzZSBhIGxsX2Vuc3VyZSBmdW5jdGlvbi4uLlxyXG4gICAgICAgIC8vICBjbGVhcmVyIG5hbWluZyB0aGF0IGl0J3Mgc2ltcGxlLlxyXG4gICAgICAgIC8vICB3aWxsIGNvbXByZXNzIGJldHRlci5cclxuXHJcbiAgICAgICAgLy92YXIgY2VlbiA9IHRoaXMuZW5zdXJlKCdfLmJvdW5kX2N0cmxfZXZlbnRzLicgKyBldnRfbmFtZSwgW10pO1xyXG4gICAgICAgIHZhciBjZWVuID0gbGxfZW5zdXJlKHRoaXMsICdfLmJvdW5kX2N0cmxfZXZlbnRzLicgKyBldnRfbmFtZSwgW10pO1xyXG5cclxuICAgICAgICBjZWVuLnB1c2goZXZ0X2hhbmRsZXIpO1xyXG4gICAgfSxcclxuXHJcbiAgICAndHJpZ2dlcl9jdHJsX2V2ZW50JzogZnVuY3Rpb24gKGV2dF9uYW1lKSB7XHJcbiAgICAgICAgLy9jb25zb2xlLmxvZygndHJpZ2dlcl9jdHJsX2V2ZW50ICcgKyBldnRfbmFtZSk7XHJcblxyXG4gICAgICAgIHZhciBhID0gYXJyX2xpa2VfdG9fYXJyKGFyZ3VtZW50cyksXHJcbiAgICAgICAgICAgIHAgPSBbXTtcclxuICAgICAgICBpZiAoYS5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgIHAgPSBhLnNsaWNlKDEpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdmFyIGNlID0gdGhpcy5fLmJvdW5kX2N0cmxfZXZlbnRzLFxyXG4gICAgICAgICAgICB0aGF0ID0gdGhpcztcclxuICAgICAgICAvL2NvbnNvbGUubG9nKCdjZSAnICsgY2UpO1xyXG4gICAgICAgIGlmIChjZSkge1xyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdjZVtldnRfbmFtZV0gJyArIGNlW2V2dF9uYW1lXSk7XHJcbiAgICAgICAgICAgIGlmIChjZVtldnRfbmFtZV0pIHtcclxuICAgICAgICAgICAgICAgIGVhY2goY2VbZXZ0X25hbWVdLCBmdW5jdGlvbiAoaSwgdikge1xyXG4gICAgICAgICAgICAgICAgICAgIHYuYXBwbHkodGhhdCwgcCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9O1xyXG4gICAgfSxcclxuICAgICovXHJcblxyXG4gICAgJ2NvbXBvc2UnOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIC8vIEkgdGhpbmsgaGF2aW5nIHRoaXMgYXZvaWRzIGEgcmVjdXJzaW9uIHByb2JsZW0gd2l0aCBfc3VwZXIgY2FsbGluZyBpdHNlbGYuXHJcbiAgICB9LFxyXG5cclxuICAgICd3YWl0JzogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgLy9jb25zb2xlLmxvZygnd2FpdCcpO1xyXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgIH0sIDApO1xyXG4gICAgfSxcclxuICAgIC8vIGNvdWxkIHVzZSBhbGlhc2VzIGZvciBzdHlsZSBwcm9wZXJ0aWVzLlxyXG5cclxuICAgICd2aXNpYmxlJzogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XHJcblxyXG4gICAgICAgIC8vY29uc29sZS5sb2coJ3ZpcycpO1xyXG5cclxuICAgICAgICAvL3JldHVybiB0aGlzLnN0eWxlKCdkaXNwbGF5JywgJ2Jsb2NrJywgY2FsbGJhY2spO1xyXG4gICAgICAgIHRoaXMuc3R5bGUoJ2Rpc3BsYXknLCAnYmxvY2snLCBjYWxsYmFjayk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vIFRoZXNlIGtpbmQgb2YgZnVuY3Rpb25zLCB0aGF0IHNldCBhIHByb3BlcnR5IHRvIGEgdmFsdWUsIGNvdWxkIGJlIG1hZGUgaW4gYSBtb3JlIGVmZmljaWVudCB3YXkuXHJcblxyXG4gICAgLy8gaGF2ZSB0aGlzIGluIGEgZnVuY3Rpb24gY2hhaW4/XHJcbiAgICAndHJhbnNwYXJlbnQnOiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcclxuICAgICAgICAvLyBtYWtlIGJsb2NrIG9yIGlubGluZSBkaXNwbGF5LCBtYXliZSBkZXBlbmRpbmcgb24gd2hhdCBpdCB3YXMgYmVmb3JlIGJlaW5nIG1hZGUgaGlkZGVuXHJcbiAgICAgICAgLy9jb25zb2xlLmxvZygndHJhbnNwJyk7XHJcbiAgICAgICAgLy8gaWYgZGlzcGxheSBpcyBub25lIHRoZW4gZGlzcGxheSBpdC5cclxuICAgICAgICAvLyAgbWF5IGhhdmUgdGhlIHByZXZpb3VzIGRpc3BsYXkgdmFsdWUgc3RvcmVkLlxyXG4gICAgICAgIC8vcmV0dXJuIHRoaXMuc3R5bGUoeydvcGFjaXR5JzogMH0sIGNhbGxiYWNrKTtcclxuICAgICAgICB0aGlzLnN0eWxlKCdvcGFjaXR5JywgMCwgY2FsbGJhY2spO1xyXG4gICAgICAgIC8qXHJcblxyXG5cdHRoaXMuc3R5bGUoe1xyXG5cdFx0J2Rpc3BsYXknOiAnYmxvY2snLFxyXG5cdFx0J29wYWNpdHknOiAwXHJcblx0fSk7XHJcblxyXG5cdGlmIChjYWxsYmFjaykge1xyXG5cdFx0c2V0VGltZW91dChmdW5jdGlvbigpIHtcclxuXHRcdFx0Y2FsbGJhY2soKTtcclxuXHRcdH0sIDApO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcblx0Ki9cclxuICAgIH0sXHJcbiAgICAnb3BhcXVlJzogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3R5bGUoe1xyXG4gICAgICAgICAgICAnb3BhY2l0eSc6IDFcclxuICAgICAgICB9LCBjYWxsYmFjayk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvLyBwb3NzaWJseSBjaGFuZ2UgbmFtZVxyXG4gICAgJ2NoYWluJzogZnVuY3Rpb24gKGFycl9jaGFpbiwgY2FsbGJhY2spIHtcclxuICAgICAgICAvLyBlYWNoIGl0ZW0gaW4gdGhlIGFycmF5IGlzIGEgZnVuY3Rpb24gY2FsbCAocmVmZXJlbmNlKSB0aGF0IG5lZWRzIHRvIGJlIGV4ZWN1dGVkLlxyXG4gICAgICAgIC8vIGFzc3VtaW5nIHRoZSBsYXN0IHBhcmFtIGluIGVhY2ggZnVuY3Rpb24gaXMgdGhlIGNhbGxiYWNrLlxyXG5cclxuICAgICAgICB2YXIgcG9zX2luX2NoYWluID0gMDtcclxuXHJcbiAgICAgICAgLy9zZXRUaW1lb3V0KClcclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHByb2Nlc3NfY2hhaW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3Byb2Nlc3NfY2hhaW4gYXJyX2NoYWluLmxlbmd0aCAnICsgYXJyX2NoYWluLmxlbmd0aCArICcsIHBvc19pbl9jaGFpbiAnICsgcG9zX2luX2NoYWluKTtcclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnYXJyX2NoYWluLmxlbmd0aCAnICsgYXJyX2NoYWluLmxlbmd0aCk7XHJcbiAgICAgICAgICAgIGlmIChwb3NfaW5fY2hhaW4gPCBhcnJfY2hhaW4ubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IGFycl9jaGFpbltwb3NfaW5fY2hhaW5dO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIHdoYXQgdHlwZXMgY2FuIGl0ZW0gYmVcclxuICAgICAgICAgICAgICAgIC8vIGFuIGFycmF5Li4uIHRoYXQgbWVhbnMgbW9yZSB0aGFuIG9uZSB0aGluZyBnZXRzIGFwcGxpZWQgYXQgdGhpcyBwb2ludCBpbiB0aGUgY2hhaW4uXHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHRfaXRlbSA9IHRvZihpdGVtKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCd0X2l0ZW0gJyArIHRfaXRlbSk7XHJcbiAgICAgICAgICAgICAgICBpZiAodF9pdGVtID09ICdhcnJheScpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBkbyBtb3JlIHRoYW4gb25lIGl0ZW0gYXQgb25jZS5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gd2lsbCB3YWl0IGZvciB0aGVtIGFsbCB0byBiZSBjb21wbGV0ZSB0b28uXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvdW50ID0gaXRlbS5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNiID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudC0tO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY291bnQgPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9pZiAoY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vXHRjYWxsYmFjaygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy99XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NfaW5fY2hhaW4rKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3NfY2hhaW4oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgZWFjaChpdGVtLCBmdW5jdGlvbiAoaSwgdikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmZuX2NhbGwodiwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2IoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnYXJyIGl0ZW0gJyArIHN0cmluZ2lmeShpdGVtKSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGZvciBhIHN0cmluZyBJIHRoaW5rLlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvdWxkIGJlIGEgbWFwLCBhbmQgbmVlZCB0byBjYWxsIHRoZSBpdGVtKHMpIGluIHRoZSBtYXAuXHJcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5mbl9jYWxsKGl0ZW0sIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnY2IxJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc19pbl9jaGFpbisrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9jZXNzX2NoYWluKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKHRoYXQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHByb2Nlc3NfY2hhaW4oKTtcclxuICAgIH0sXHJcbiAgICAnZm5fY2FsbCc6IGZ1bmN0aW9uIChjYWxsLCBjYWxsYmFjaykge1xyXG4gICAgICAgIC8vIGFuZCBjYWxsYmFja3Mgd2l0aGluIHRoZSByaWdodCB3YXk/XHJcbiAgICAgICAgLy9jb25zb2xlLmxvZygnZm5fY2FsbCAnICsgY2FsbCk7XHJcbiAgICAgICAgdmFyIHQgPSB0b2YoY2FsbCk7XHJcbiAgICAgICAgLy9jb25zb2xlLmxvZygndCAnICsgdCk7XHJcbiAgICAgICAgLy8gYnV0IGNhbGwgbWF5IGJlIGFuIG9iamVjdC4uLlxyXG4gICAgICAgIHZhciBmbiwgcGFyYW1zLCB0aGF0ID0gdGhpcztcclxuICAgICAgICBpZiAodCA9PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICBmbiA9IHRoaXNbY2FsbF07XHJcbiAgICAgICAgICAgIHBhcmFtcyA9IFtdO1xyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdjYWxsYmFjayAnICsgY2FsbGJhY2spO1xyXG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmbi5jYWxsKHRoaXMsIGNhbGxiYWNrKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmbi5jYWxsKHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAodCA9PSAnYXJyYXknKSB7XHJcbiAgICAgICAgICAgIC8vIHRoZSAwdGggaXRlbSBpbiB0aGUgYXJyIHNob3VsZCBiZSB0aGUgZnVuY3Rpb24gbmFtZSwgdGhlIHJlc3QgdGhlIHBhcmFtc1xyXG4gICAgICAgICAgICAvLyBidXQgZG9lcyB0aGUgZnVuY3Rpb24gaGF2ZSBhICdjYWxsYmFjaycgcGFyYW0gdGhhdCB3ZSBrbm93IGFib3V0IGhlcmU/IG5vdCBub3cuXHJcbiAgICAgICAgICAgIGZuID0gdGhpc1tjYWxsWzBdXTtcclxuICAgICAgICAgICAgcGFyYW1zID0gY2FsbC5zbGljZSgxKTtcclxuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSBwYXJhbXMucHVzaChjYWxsYmFjayk7XHJcbiAgICAgICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBwYXJhbXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodCA9PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICAvLyBob3cgbWFueT9cclxuICAgICAgICAgICAgdmFyIGNvdW50ID0gMDtcclxuICAgICAgICAgICAgZWFjaChjYWxsLCBmdW5jdGlvbiAoaSwgdikge1xyXG4gICAgICAgICAgICAgICAgY291bnQrKztcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBlYWNoKGNhbGwsIGZ1bmN0aW9uIChpLCB2KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY2IgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY291bnQtLTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY291bnQgPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKHRoYXQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB0aGF0LmZuX2NhbGwoW2ksIHZdLCBjYik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLy8gSSB0aGluayAuYW5pbWF0ZSBzeW50YXggd291bGQgYmUgdmVyeSBoZWxwZnVsLlxyXG4gICAgLy8gIHN5bnRheCBzaW1pbGFyIHRvIGpRdWVyeSBidXQgbGlrZWx5IHRvIGFsbG93IG1vcmUgcG9zc2libGUgb3B0aW9ucz8/P1xyXG4gICAgLy8gICBtb3JlIHdheXMgb2YgZXhwcmVzc2luZyB0aGUgb3B0aW9ucy5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuICAgIC8vIFRoaXMgY291bGQgcHJvYmFibHkgYmUgZGVmaW5lZCBhcyBhbiBhbGlhcy5cclxuXHJcbiAgICAvLyB0cmFuc2l0aW9uIC0+IHN0eWxlLnRyYW5zaXRpb25cclxuICAgIC8vICBJbnRlZ3JhdGluZyBjYWxsYmFja3Mgd2l0aCB0aGVzZSBwcm9wZXJ0eSBjaGFuZ2VzP1xyXG4gICAgLy8gIE1heWJlIHNob3VsZCBub3QgZG8gc28gbXVjaCBtb3JlIG9uIGNvbXByZXNzaW5nICYgZ2VuZXJhbGl6aW5nIHlldC5cclxuXHJcbiAgICAvLyBIb3Jpem9udGFsX0Nhcm91c2VsX1NlbGVjdG9yXHJcbiAgICAvLyAgT3IganVzdCBzaG93IHRoZXNlIHZhcmlvdXMgc2VsZWN0YWJsZSBpdGVtcyBpbiB0aGUgaG9yaXpvbnRhbCBjYXJvdXNlbC5cclxuXHJcbiAgICAvLyBXaWxsIG1heWJlIG1ha2UgdGhlIGNhcm91c2VsIGNvbnRpbnVvdXMsIHNvIGNvdWxkIGdvIGZyb20gRGVjZW1iZXIgdG8gSmFudWFyeSwgYW5kIGl0IHdvdWxkIHJhaXNlIGFuIGV2ZW50XHJcbiAgICAvLyAgc2lnbmlmeWluZyB0aGUgY29udGludWF0aW9uIGFuZCBkaXJlY3Rpb24sIHNvIHRoaXMgY291bGQgbWFrZSB0aGUgeWVhciBjaGFuZ2UuXHJcbiAgICAvLyBXb3VsZCBoYXZlIGEgaG9yaXpvbnRhbCBjYXJvdXNlbCBzZWxlY3RvciBmb3Igc2VsZWN0aW5nIHRoZSB5ZWFyLCB3aXRoIGl0IGNvbnRpbnVpbmcuXHJcbiAgICAvLyAgQ291bGQgbWFrZSBpdCBhIGNvbWJvIHNlbGVjdG9yIHNvIHRoZSB2YWx1ZSBjYW4gYmUgdHlwZWQgaW4gYXMgd2VsbC4gJ0onIHdvdWxkIGJyaW5nIHVwICdKYW51YXJ5JywgJ0p1bmUnIGFuZCAnSnVseScgYXMgYXV0b3NlbGVjdCBpdGVtcy5cclxuICAgIC8vIFB1dHRpbmcgdGhlc2UgR1VJIGZlYXR1cmVzIGluIHBsYWNlIHdpbGwgbm90IHRha2Ugc28gbG9uZywgYW5kIHdpbGwgaGVscCB0aGlzIHRvIGJlIGEgcG93ZXJmdWwgdG9vbGtpdC5cclxuXHJcbiAgICAvLyBNYXkgYmUgd29ydGggZG9pbmcgbW9yZSBvbiBkYXRhYmFzZXMgYW5kIGF1dGhlbnRpY2F0aW9uIHRob3VnaC5cclxuXHJcblxyXG5cclxuICAgICd0cmFuc2l0aW9uJzogZnVuY3Rpb24gKHZhbHVlLCBjYWxsYmFjaykge1xyXG4gICAgICAgIC8vdmFyIGkgPSB7fTtcclxuICAgICAgICAvL2lbXVxyXG5cclxuICAgICAgICAvLyBtYXkgaW5jbHVkZSBtdWx0aXBsZSB0cmFuc2l0aW9ucyBpbiBhbiBhcnJheS5cclxuICAgICAgICByZXR1cm4gdGhpcy5zdHlsZSh7XHJcbiAgICAgICAgICAgICd0cmFuc2l0aW9uJzogdmFsdWVcclxuICAgICAgICB9LCBjYWxsYmFjayk7XHJcbiAgICB9LFxyXG5cclxuICAgICd0cmFuc2l0JzogZnAoZnVuY3Rpb24gKGEsIHNpZykge1xyXG5cclxuICAgICAgICAvLyBhcnJfZHVyYXRpb25fYW5kX3RpbWluZ19mdW5jdGlvbiwgbWFwX3ZhbHVlcywgY2FsbGJhY2tcclxuICAgICAgICAvLyB0cmFuc2l0LCBjYWxsYmFja1xyXG4gICAgICAgIC8vY29uc29sZS5sb2coJ3RyYW5zaXQgc2lnICcgKyBzaWcpO1xyXG4gICAgICAgIC8vIFtbbixzXSxvXSAgYSBkdXJhdGlvbiB3aXRoIHRpbWluZyBmdW5jdGlvbiwgdGhlbiBhIHRyYW5zaXQgbWFwLiBubyBjYWxsYmFja1xyXG4gICAgICAgIC8vICB3aGF0IGFib3V0IGV4dHJhY3RpbmcgZnJvbSB0aGUgbW9zdCBpbm5lciBhcnJheSwgc28gYWxzbyByZXNwb25kaW5nIHRvIFtbW24sc10sb11dLlxyXG4gICAgICAgIC8vIHNlZWluZyB0aGF0IHRoZSByZXF1aXJlZCB0aGluZyBpcyBpbnNpZGUgYW4gYXJyYXkgc2hlbGwuXHJcblxyXG4gICAgICAgIC8vIGV4dHJhY3Rfc2lnX2Zyb21fYXJyYXlfc2hlbGxcclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgLy8gIFtbW24sc10sbyxdLGZdIGluY2x1ZGluZyBjYWxsYmFjayBmdW5jdGlvblxyXG5cclxuICAgICAgICAvLyBbW1tuLHNdLG9dXVxyXG4gICAgICAgIHZhciB1bnNoZWxsZWRfc2lnID0gcmVtb3ZlX3NpZ19mcm9tX2Fycl9zaGVsbChzaWcpO1xyXG4gICAgICAgIC8vaWYgKHJlbW92ZV9zaWdfZnJvbV9hcnJfc2hlbGwoc2lnKSlcclxuICAgICAgICAvL2NvbnNvbGUubG9nKCd1bnNoZWxsZWRfc2lnICcgKyB1bnNoZWxsZWRfc2lnKTtcclxuICAgICAgICBpZiAodW5zaGVsbGVkX3NpZyA9PSAnW1tuLHNdLG9dJykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc2l0KGFbMF1bMF0sIGFbMF1bMV0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHNpZyA9PSAnW1tbbixzXSxvXSxmXScpIHtcclxuXHJcbiAgICAgICAgICAgIHZhciB0cmFuc2l0ID0gYVswXTtcclxuICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gYVsxXTtcclxuXHJcbiAgICAgICAgICAgIHZhciBkdXJhdGlvbl9hbmRfdGYgPSB0cmFuc2l0WzBdO1xyXG4gICAgICAgICAgICB2YXIgbWFwX3ZhbHVlcyA9IHRyYW5zaXRbMV07XHJcblxyXG4gICAgICAgICAgICB0aGlzLnRyYW5zaXQoZHVyYXRpb25fYW5kX3RmLCBtYXBfdmFsdWVzLCBjYWxsYmFjayk7XHJcblxyXG4gICAgICAgIH0gZWxzZSBpZiAoc2lnID09ICdbW24sc10sbyxmXScpIHtcclxuICAgICAgICAgICAgdmFyIGR1cmF0aW9uX2FuZF90ZiA9IGFbMF07XHJcbiAgICAgICAgICAgIHZhciBtYXBfdmFsdWVzID0gYVsxXTtcclxuICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gYVsyXTtcclxuICAgICAgICAgICAgdmFyIHRyYW5zaXRpb24gPSB7fTtcclxuICAgICAgICAgICAgZWFjaChtYXBfdmFsdWVzLCBmdW5jdGlvbiAoaSwgdikge1xyXG4gICAgICAgICAgICAgICAgLy8gc2V0IHRoZSB0cmFuc2l0aW9uIHN0eWxlXHJcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uW2ldID0gZHVyYXRpb25fYW5kX3RmO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhhdC50cmFuc2l0aW9uKHRyYW5zaXRpb24pO1xyXG5cclxuICAgICAgICAgICAgZWFjaChtYXBfdmFsdWVzLCBmdW5jdGlvbiAoaSwgdikge1xyXG4gICAgICAgICAgICAgICAgLy8gc2V0IHRoZSB0cmFuc2l0aW9uIHN0eWxlXHJcbiAgICAgICAgICAgICAgICAvL3RyYW5zaXRpb25baV0gPSBhcnJfZHVyYXRpb25fYW5kX3RpbWluZ19mdW5jdGlvbjtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyB1c2UgdGhlIHN0eWxlIGZ1bmN0aW9uIHRvIHNldCB0aGUgdmFsdWVcclxuICAgICAgICAgICAgICAgIC8vIGFuZCB1c2UgYSBjYWxsYmFjayBzeXN0ZW0gaGVyZSBmb3Igd2hlbiB0aGV5IGFyZSBhbGwgZG9uZS5cclxuXHJcbiAgICAgICAgICAgICAgICB0aGF0LnN0eWxlKGksIHYpO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIC8vdGhpcy50cmFuc2l0KGR1cmF0aW9uX2FuZF90ZiwgbWFwX3ZhbHVlcywgY2FsbGJhY2spO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoYS5sZW5ndGggPT0gMikge1xyXG4gICAgICAgICAgICB2YXIgZHVyYXRpb25fYW5kX3RmID0gYVswXTtcclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnYSAnICsgc3RyaW5naWZ5KGEpKTtcclxuXHJcbiAgICAgICAgICAgIC8vIHRyYW5zaXQgaW5jbHVkZXMgdGhlIG1hcCB2YWx1ZXNcclxuXHJcbiAgICAgICAgICAgIHZhciBkdXJhdGlvbl9hbmRfdGYgPSBhWzBdO1xyXG4gICAgICAgICAgICB2YXIgbWFwX3ZhbHVlcyA9IGFbMV07XHJcbiAgICAgICAgICAgIC8vdmFyIHRyYW5zaXRfbWFwID0gYVsxXTtcclxuICAgICAgICAgICAgdmFyIHRyYW5zaXRpb24gPSB7fTtcclxuXHJcbiAgICAgICAgICAgIGVhY2gobWFwX3ZhbHVlcywgZnVuY3Rpb24gKGksIHYpIHtcclxuICAgICAgICAgICAgICAgIC8vIHNldCB0aGUgdHJhbnNpdGlvbiBzdHlsZVxyXG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbltpXSA9IGR1cmF0aW9uX2FuZF90ZjtcclxuXHJcblxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhhdC50cmFuc2l0aW9uKHRyYW5zaXRpb24pO1xyXG5cclxuICAgICAgICAgICAgZWFjaChtYXBfdmFsdWVzLCBmdW5jdGlvbiAoaSwgdikge1xyXG4gICAgICAgICAgICAgICAgLy8gc2V0IHRoZSB0cmFuc2l0aW9uIHN0eWxlXHJcbiAgICAgICAgICAgICAgICAvL3RyYW5zaXRpb25baV0gPSBhcnJfZHVyYXRpb25fYW5kX3RpbWluZ19mdW5jdGlvbjtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyB1c2UgdGhlIHN0eWxlIGZ1bmN0aW9uIHRvIHNldCB0aGUgdmFsdWVcclxuICAgICAgICAgICAgICAgIC8vIGFuZCB1c2UgYSBjYWxsYmFjayBzeXN0ZW0gaGVyZSBmb3Igd2hlbiB0aGV5IGFyZSBhbGwgZG9uZS5cclxuXHJcbiAgICAgICAgICAgICAgICB0aGF0LnN0eWxlKGksIHYpO1xyXG5cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3RyYW5zaXRfbWFwICcgKyBzdHJpbmdpZnkodHJhbnNpdF9tYXApKTtcclxuICAgICAgICAgICAgLy90aGlzLnRyYW5zaXQoZHVyYXRpb25fYW5kX3RmLCB0cmFuc2l0X21hcCk7XHJcbiAgICAgICAgICAgIC8vdGhhdC50cmFuc2l0aW9uKClcclxuICAgICAgICB9IC8vIGVsc2UgaWYgKGEubGVuZ3RoID09IDMpIHtcclxuICAgICAgICAvL1x0dmFyIGFycl9kdXJhdGlvbl9hbmRfdGltaW5nX2Z1bmN0aW9uID0gYVswXSwgbWFwX3ZhbHVlcyA9IGFbMV0sIGNhbGxiYWNrID0gYVsyXTtcclxuICAgICAgICAvL1x0Y29uc29sZS5sb2coJ2EgJyArIHN0cmluZ2lmeShhKSk7XHJcblxyXG5cclxuICAgICAgICAvL31cclxuXHJcbiAgICB9KSxcclxuXHJcbiAgICAvLyBhbmQgYWxzbyB3YW50IHRvIGJlIGFibGUgdG8gb3V0cHV0IHRoZSBwcm9wZXJ0eS5cclxuXHJcbiAgICAnb3V0JzogZnVuY3Rpb24gKHByb3BlcnR5X25hbWUpIHtcclxuICAgICAgICB2YXIgZHRpX2NvbnRyb2wgPSBkYXRhX3R5cGVfaW5zdGFuY2UoJ2NvbnRyb2wnKTtcclxuXHJcbiAgICAgICAgLy92YXIgcHJvcF9yZWYgPSBnZXRfcHJvcGVydHlfcmVmZXJlbmNlKHRoaXMsIHByb3BlcnR5X25hbWUsIGZhbHNlKTtcclxuICAgICAgICB2YXIgcHJvcF9yZWYgPSBkdGlfY29udHJvbC5uZXN0ZWRfZ2V0X3Byb3BlcnR5X3JlZmVyZW5jZShbdGhpcywgJ18nXSwgcHJvcGVydHlfbmFtZSwgdHJ1ZSk7XHJcblxyXG4gICAgICAgIHZhciBpdGVtX3R5cGUgPSBwcm9wX3JlZlsyXTtcclxuICAgICAgICB2YXIgZHRpX2l0ZW0gPSBkYXRhX3R5cGVfaW5zdGFuY2UoaXRlbV90eXBlKTtcclxuXHJcbiAgICAgICAgdmFyIG91dF92YWwgPSBkdGlfaXRlbS5vdXRwdXQocHJvcF9yZWZbMF1bcHJvcF9yZWZbMV1dKTtcclxuXHJcbiAgICAgICAgLy9jb25zb2xlLmxvZygnb3V0IHByb3BfcmVmICcgKyBzdHJpbmdpZnkocHJvcF9yZWYpKTtcclxuICAgICAgICAvL2NvbnNvbGUubG9nKCdvdXQgb3V0X3ZhbCAnICsgc3RyaW5naWZ5KG91dF92YWwpKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIG91dF92YWw7XHJcbiAgICB9LFxyXG5cclxuICAgICdwYWdlX2NvbnRleHQnOiBmdW5jdGlvbiAodmFsKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgLy8gXy5wYWdlX2NvbnRleHQgc2hvdWxkIG5vdCBiZSBhIGZ1bmN0aW9uLlxyXG5cclxuICAgICAgICAgICAgLy8gaG93IGZyZXF1ZW50bHkgZG9lcyBpdCBuZWVkIHRvIGJlIGNhbGxlZD9cclxuICAgICAgICAgICAgLy8gIGlzIGl0IGJlaW5nIGNhbGxlZCB0b28gbXVjaD9cclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygn77+9IHRoaXMuXy5wYWdlX2NvbnRleHQgJyArIHRoaXMuXy5wYWdlX2NvbnRleHQpO1xyXG4gICAgICAgICAgICBpZiAoaXNfZGVmaW5lZCh0aGlzLl8ucGFnZV9jb250ZXh0KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuXy5wYWdlX2NvbnRleHQ7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoanNndWkucGFnZV9jb250ZXh0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGpzZ3VpLnBhZ2VfY29udGV4dDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuXy5wYWdlX2NvbnRleHQgPSB2YWw7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvLyBtYXkgY2hhbmdlIHRoZSBjb250cm9scyBhY2Nlc3MgZnVuY3Rpb25zLCBidXQgc2VlbXMgc2ltcGxlIGFuZCBPSyBmb3IgdGhlIG1vbWVudCB0byB3cmFwIHRoZW0gbGlrZSB0aGlzLlxyXG5cclxuICAgIC8vIHdpbGwganVzdCBiZSBhZGRpbmcgdG8gdGhlIGNvbnRlbnQuXHJcblxyXG4gICAgJ2FkZF9jb250cm9sJzogZnVuY3Rpb24gKG5ld19jb250ZW50KSB7XHJcbiAgICAgICAgLy92YXIgY29udGVudCA9IHRoaXMuZ2V0KCdjb250ZW50Jyk7XHJcblxyXG5cclxuICAgICAgICAvLyBUaGUgY29udHJvbHMgYXJyYXkgYmVpbmcgYW4gSUQnZCBhbmQgaW5kZXhlZCBjb2xsZWN0aW9uLlxyXG4gICAgICAgIC8vICBFdmVyeXRoaW5nIGluIHRoZXJlIGhhcyBhbiBJRC5cclxuICAgICAgICAvLyAgU28gbmVlZHMgYSBwYWdlX2NvbnRleHQuXHJcbiAgICAgICAgLy8gIFNlZW1zIGEgbGl0dGxlIGluY29udmVuaWVudC5cclxuICAgICAgICAvLyAgQnV0IHdpbGwgc29sdmUgdGhlIHByb2JsZW0gZm9yIHRoZSBtb21lbnQuXHJcblxyXG5cclxuXHJcbiAgICAgICAgLy9yZXR1cm4gY29udGVudC5hZGQobmV3X2NvbnRlbnQpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldCgnY29udGVudCcpLmFkZChuZXdfY29udGVudCk7XHJcbiAgICB9LFxyXG4gICAgJ2FkZCc6IGZ1bmN0aW9uKG5ld19jb250ZW50KSB7XHJcblxyXG4gICAgICAgIC8vIFdpbGwgYWxzbyB0dXJuIFhNTCBzdHJpbmdzIGRlc2NyaWJpbmcganNndWkgY29udHJvbHMvY29udGVudCBpbnRvIGNvbnRyb2xzL2NvbnRlbnQuXHJcblxyXG4gICAgICAgIHZhciB0bmMgPSB0b2YobmV3X2NvbnRlbnQpO1xyXG4gICAgICAgIC8vY29uc29sZS5sb2coJ2NvbnRyb2wgYWRkIGNvbnRlbnQgdG5jJywgdG5jKTtcclxuXHJcbiAgICAgICAgaWYgKHRuYyA9PSAnYXJyYXknKSB7XHJcbiAgICAgICAgICAgIHZhciByZXMgPSBbXSwgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgICAgIGVhY2gobmV3X2NvbnRlbnQsIGZ1bmN0aW9uKGksIHYpIHtcclxuICAgICAgICAgICAgICAgIHJlcy5wdXNoKHRoYXQuYWRkKHYpKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXM7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKCFuZXdfY29udGVudC5fY29udGV4dCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2NvbnRleHQpIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXdfY29udGVudC5fY29udGV4dCA9IHRoaXMuX2NvbnRleHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdhZGQgY29udGV4dDogJyArIHRoaXMuX2NvbnRleHQpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fY29udGV4dCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRvZihuZXdfY29udGVudCkgPT0gJ3N0cmluZycpIHtcclxuXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld19jb250ZW50Ll9jb250ZXh0ID0gdGhpcy5fY29udGV4dDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAqL1xyXG5cclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygncHJlIGNvbnRlbnQgYWRkJyk7XHJcbiAgICAgICAgICAgIC8vcmV0dXJuIGNvbnRlbnQuYWRkKG5ld19jb250ZW50KTtcclxuXHJcbiAgICAgICAgICAgIC8vIGFsc28sIHdhbnQgdG8gc2V0IHRoZSBpbmRleCBvZiB0aGUgbmV3X2NvbnRlbnQuXHJcbiAgICAgICAgICAgIC8vICBUaGUgY29udGVudCBjb3VsZCBiZSBhIHN0cmluZy4uLlxyXG4gICAgICAgICAgICAvLyAgIG5vIG5lZWQgdG8gc2V0IHRoZSBpbmRleCB0aGVuLlxyXG5cclxuICAgICAgICAgICAgLy8gIElmIHRoZSBjb250ZW50IGlzIGEgY29udHJvbCwgd2Ugd2FudCB0byBzZXQgYSBwcm9wZXJ0eSBmb3IgdGhhdCBjb250cm9sLlxyXG4gICAgICAgICAgICAvLyAgIENvbnRyb2wgc2hvdWxkIGtub3cgd2hhdCBpdHMgcGFyZW50IGNvbnRyb2wgaXMuXHJcblxyXG5cclxuXHJcbiAgICAgICAgICAgIC8vIE9LLCBidXQgZG9lcyBwdXR0aW50IGl0IGludG8gdGhhdCBjb2xsZWN0aW9uIGF1dG9tYXRpY2FsbHkgc2V0IGl0cyBwYXJlbnQgaW4gc29tZSB3YXk/XHJcblxyXG4gICAgICAgICAgICAvLyBNYXliZSBsaXN0ZW4gb3V0IGZvciBjb250ZW50IGJlaW5nIGFkZGVkLlxyXG4gICAgICAgICAgICAvLyAgU28gd2UgY2FuIGRvIGNvbnRlbnQuYWRkIHJhdGhlciB0aGFuIGp1c3QgLmFkZCwgYW5kIGl0IHVwZGF0ZXMgdGhlIHBhcmVudCBhbmQgaW5kZXggdmFsdWVzLlxyXG5cclxuICAgICAgICAgICAgLy8gQ291bGQgY2hlY2sgZm9yIGFuIGlubmVyIGNvbnRyb2wuXHJcblxyXG4gICAgICAgICAgICAvLyBBbHNvIGNvdWxkIGluc3RhbnRpYXRlIHRoZSBjb250ZW50IGlmIGl0IGlzIGFic3RyYWN0LlxyXG4gICAgICAgICAgICAvLyBBbHNvIGNvdWxkIGV4cHJlc3MgY29udGVudCBhcyBKU09OIGluIHNvbWUgY2FzZXMuXHJcbiAgICAgICAgICAgIC8vICBQb3NzaWJseSBjb3VsZCBhZGQgWE1MLlxyXG5cclxuXHJcblxyXG5cclxuICAgICAgICAgICAgdmFyIGlubmVyX2NvbnRyb2wgPSB0aGlzLmdldCgnaW5uZXJfY29udHJvbCcpO1xyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdpbm5lcl9jb250cm9sJywgaW5uZXJfY29udHJvbCk7XHJcblxyXG4gICAgICAgICAgICAvLyBEb2VzIGl0IGFkZCBhIERhdGFfT2JqZWN0IHN1Y2Nlc3NmdWxseT9cclxuXHJcbiAgICAgICAgICAgIC8vIENvdWxkIGFkZGluZyB0aGlzIGNhdXNlIGNvbnRlbnQgaW5zaWRlIHRoZSBjb250ZW50IHRoYXQncyBiZWluZyBhZGRlZCB0byBkdXBsaWNhdGU/XHJcblxyXG4gICAgICAgICAgICBpZiAoaW5uZXJfY29udHJvbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGlubmVyX2NvbnRyb2wuZ2V0KCdjb250ZW50JykuYWRkKG5ld19jb250ZW50KTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldCgnY29udGVudCcpLmFkZChuZXdfY29udGVudCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcblxyXG5cclxuICAgICAgICAgICAgLy8gdGhlbiBpdCBzaG91bGQga25vdyBpdCdzIGJlZW4gYWRkZWQsIGFuZCB1cGRhdGUgdGhlIERPTS5cclxuICAgICAgICAgICAgLy8gIHNob3VsZCByZW5kZXIgdGhlIGNvbnRyb2wgdG8gdGhlIERPTSB0b28uXHJcblxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vdmFyIGNvbnRlbnQgPSB0aGlzLmdldCgnY29udGVudCcpO1xyXG5cclxuICAgICAgICAvLyBidXQgdGhlIGNvbnRleHQgb2YgdGhlIG5ldyBjb250cm9sIHNob3VsZCBiZSBzZXQuXHJcblxyXG4gICAgICAgIC8vIENhcm91c2VsIEJ1dHRvblxyXG4gICAgICAgIC8vICBDYXJvdXNlbCBidXR0b24gU2VsZWN0b3JcclxuICAgICAgICAvLyAgSW4gaG9yaXpvbnRhbCBtb2RlLlxyXG5cclxuICAgICAgICAvL3Rocm93ICdzdG9wJztcclxuXHJcbiAgICAgICAgLy8gd29uJ3QgbmVlZCB0byBhcHBseSB0aGUgY29udGV4dCBhdXRvbWF0aWNhbGx5Li4uIGJ1dCBtYXliZSBpZiB0aGUgb2JqZWN0IGRvZXMgbm90IGFscmVhZHkgaGF2ZSBvbmUuXHJcblxyXG5cclxuICAgICAgICAvL2NvbnNvbGUubG9nKCdwb3N0IGNvbnRlbnQgYWRkJyk7XHJcbiAgICB9LFxyXG5cclxuICAgICdpbnNlcnRfYmVmb3JlJzogZnVuY3Rpb24odGFyZ2V0KSB7XHJcbiAgICAgICAgLy9jb25zb2xlLmxvZygndGFyZ2V0JywgdGFyZ2V0KTtcclxuXHJcbiAgICAgICAgLy9jb25zb2xlLmxvZygncHJlIGZpbmQgcGFyZW50Jyk7XHJcbiAgICAgICAgLy90aHJvdyAnc3RvcCc7XHJcblxyXG4gICAgICAgIC8vIFRoZSBwYXJlbnQgb2YgYSBjb250ZW50IENvbGxlY3Rpb24gYmVpbmcgYSBDb250cm9sP1xyXG4gICAgICAgIC8vICBQcm9iYWJseSBtYWtlcyBzZW5zZS5cclxuXHJcblxyXG4gICAgICAgIHZhciB0YXJnZXRfcGFyZW50ID0gdGFyZ2V0LnBhcmVudCgpLnBhcmVudCgpO1xyXG5cclxuICAgICAgICAvL2NvbnNvbGUubG9nKCd0YXJnZXRfcGFyZW50JywgdGFyZ2V0X3BhcmVudCk7XHJcblxyXG4gICAgICAgIHZhciB0YXJnZXRfaW5kZXggPSB0YXJnZXQuX2luZGV4O1xyXG5cclxuICAgICAgICAvL2NvbnNvbGUubG9nKCd0YXJnZXRfaW5kZXgnLCB0YXJnZXRfaW5kZXgpO1xyXG5cclxuICAgICAgICAvLyBpbnNlcnQgaW50byB0aGUgY29udGVudCBjb2xsZWN0aW9uLlxyXG5cclxuICAgICAgICB2YXIgY29udGVudCA9IHRhcmdldF9wYXJlbnQuZ2V0KCdjb250ZW50Jyk7XHJcblxyXG4gICAgICAgIGNvbnRlbnQuaW5zZXJ0KHRoaXMsIHRhcmdldF9pbmRleCk7XHJcblxyXG4gICAgICAgIC8vIEFuIGVuaGFuY2VkIC8gYWN0aXZhdGVkIGNvbnRyb2wgbmVlZHMgdG8gbGlzdGVuIGZvciBjb250ZW50IGNoYW5nZSBpbiBwYXJ0aWN1bGFyLlxyXG5cclxuXHJcblxyXG5cclxuXHJcbiAgICAgICAgLy9jb25zb2xlLmxvZygnJyk7XHJcbiAgICAgICAgLy9jb25zb2xlLmxvZygndGFyZ2V0JywgdGFyZ2V0KTtcclxuXHJcbiAgICAgICAgLy8gQ29udHJvbHMgbmVlZCB0byBiZXR0ZXIga2VlcCB0cmFjayBvZiB0aGVpciBpbmRleCB3aXRoaW4gdGhlIHBhcmVudCwgYW5kIHdoYXQgdGhlaXIgcGFyZW50IGNvbnRyb2wgaXMuXHJcbiAgICAgICAgLy8gIEFkZHMgYSBiaXQgb2YgZWZmb3J0IHRvIGtlZXAgdHJhY2sgb2Ygd2hhdCB0aGUgaW5kZXhlcyBhcmUuXHJcbiAgICAgICAgLy8gIEl0J3Mgd29ydGggaGF2aW5nIHRoZSBjb250cm9scyBzdGF5IGF3YXJlIG9mIHdoYXQgdGhlaXIgaW5kZXggaXMgd2hlcmUgcG9zc2libGUuXHJcblxyXG4gICAgICAgIC8vIFRoaXMgJ3BhcmVudCcgYW5kIHJlbGF0aW9uc2hpcCBpbmZvIGNvdWxkIGJlIGludGVncmFsIHRvIERhdGFfT2JqZWN0cyBhbmQgQ29sbGVjdGlvbnMsIG5vdCBqdXN0IENvbnRyb2xzLlxyXG5cclxuICAgICAgICAvL3Rocm93ICdzdG9wJztcclxuICAgIH0sXHJcblxyXG4gICAgJ3N0cmluZ2lmeSc6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcmVzID0gW107XHJcbiAgICAgICAgcmVzLnB1c2goJ0NvbnRyb2woJyArIHN0cmluZ2lmeSh0aGlzLl8pICsgJyknKTtcclxuICAgICAgICByZXR1cm4gcmVzLmpvaW4oJycpO1xyXG4gICAgfSxcclxuICAgICdzdHlsZSc6IGZwKGZ1bmN0aW9uKGEsIHNpZykge1xyXG4gICAgICAgIC8vIEZvciB0aGUgbW9tZW50LCB0aGlzIHNob3VsZCBiZSBhIGNvbnZlbmllbnQgd2F5IG9mIHVwZGF0aW5nIHRoZSBkb20gYXR0cmlidXRlcyBzdHlsZS5cclxuXHJcbiAgICAgICAgLy8gIFRoaXMgY291bGQgZG8gdGhlIGRvY3VtZW50IHVwZGF0ZSBvciBub3QuLi4uXHJcblxyXG4gICAgICAgIHZhciBzdHlsZV9uYW1lLCBzdHlsZV92YWx1ZSwgbW9kaWZ5X2RvbSA9IHRydWU7XHJcblxyXG4gICAgICAgIGlmIChzaWcgPT0gJ1tzXScpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIEJlc3Qgbm90IHRvIHJlZmVyIHRvIHRoZSBjb21wdXRlZCBzdHlsZXMgcHJvYmFibHk/XHJcbiAgICAgICAgICAgIC8vICBSZWFsbHkgd2FudCB0byBpbnRlcmFjdCB3aXRoIGlubGluZSBzdHlsZXMgaGVyZS5cclxuXHJcbiAgICAgICAgICAgIC8vIG1heWJlIGhhdmUgc29tZSBzeW50YXggZm9yIGNvbXB1dGVkIHN0eWxlcywgc3VjaCBhcyAuc3R5bGUoJ2NvbXB1dGVkJywgc3R5bGVfbmFtZSk7XHJcbiAgICAgICAgICAgIC8vICBPciBqdXN0IGRvbid0IGhhdmUgaXQsIGdldCBpdCBmcm9tIHRoZSBlbGVtZW50IGlmIG5lZWRlZC5cclxuXHJcblxyXG5cclxuXHJcbiAgICAgICAgICAgIC8vIFdhbnQgdG8gZ2V0IGEgc3R5bGUgdmFsdWUuXHJcbiAgICAgICAgICAgIC8vICBUaGlzIGNvdWxkIGdldCBmYWlybHkgY29tcGxpY2F0ZWQgd2hlbiBnZXRDb21wdXRlZFN0eWxlIGlzIG5vdCBhcm91bmQsIGluIG9sZGVyIGJyb3dzZXJzLlxyXG5cclxuICAgICAgICAgICAgLy8gTWF5IGhhdmUgYSBzeXN0ZW0gdG8gcmVhZCB0aHJvdWdoIGEgc3R5bGVzaGVldCBhbmQgd29yayBvdXQgd2hhdCB3b3VsZCBnZXQgYXBwbGllZCB0byBhbiBlbGVtZW50XHJcblxyXG4gICAgICAgICAgICAvLyBGb3IgdGhlIG1vbWVudCwgd2lsbCBsb29rIGF0IHN0eWxlIG9mIGNvbnRyb2wgcHJvcGVydHkgKG5lZWQgdG8gZGV2ZWxvcCB0aGF0IG1vcmUpLlxyXG5cclxuICAgICAgICAgICAgdmFyIHN0eWxlTmFtZSA9IGFbMF07XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdnZXQgc3R5bGUgJyArIHN0eWxlTmFtZSk7XHJcblxyXG4gICAgICAgICAgICB2YXIgZWwgPSB0aGlzLmdldCgnZG9tLmVsJyk7XHJcblxyXG4gICAgICAgICAgICAvLyBTaG91bGQgcHJvYmFibHkgcmV0dXJuIGEgY29weSBvZiB0aGUgc3R5bGUsIG5vdCByZWFkIGZyb20gdGhlIERPTS5cclxuXHJcbiAgICAgICAgICAgIHZhciByZXMgPSBnZXRDb21wdXRlZFN0eWxlKGVsKVtzdHlsZU5hbWVdO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzO1xyXG5cclxuXHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgLy9jb25zb2xlLmxvZygnc3R5bGUgc2lnICcgKyBzaWcpO1xyXG5cclxuICAgICAgICBpZiAoc2lnID09ICdbcyxzLGJdJykge1xyXG4gICAgICAgICAgICB2YXIgc3R5bGVOYW1lID0gYVswXTtcclxuICAgICAgICAgICAgdmFyIHN0eWxlVmFsdWUgPSBhWzFdO1xyXG5cclxuICAgICAgICAgICAgLy8gTW9kaWZ5IGRvbSBieSBkZWZhdWx0IGlmIHRoZXJlIGlzIGEgRE9NLlxyXG5cclxuXHJcbiAgICAgICAgICAgIHZhciBtb2RpZnlEb20gPSBhWzJdO1xyXG5cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBpZiAoc2lnID09ICdbcyxzXScgfHwgc2lnID09ICdbcyxuXScpIHtcclxuICAgICAgICAgICAgdmFyIHN0eWxlTmFtZSA9IGFbMF07XHJcbiAgICAgICAgICAgIHZhciBzdHlsZVZhbHVlID0gYVsxXTtcclxuXHJcbiAgICAgICAgICAgIC8vIHJlYnVpbGQgdGhlIGNzcyBzdHlsZT8/P1xyXG4gICAgICAgICAgICAvLyAgTWF5IGp1c3QgYmUgaW4gdGhlIGRvbSBhdHRyaWJ1dGVzIGFzIHdlbGwuXHJcblxyXG4gICAgICAgICAgICAvL3ZhciBkYXMgPSB0aGlzLl8uZG9tX2F0dHJpYnV0ZXMuXy5zdHlsZTtcclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnZGFzJywgZGFzKTtcclxuXHJcbiAgICAgICAgICAgIC8vdmFyIGRhID0gdGhpcy5fLmRvbS5fLmF0dHJpYnV0ZXM7XHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2RhJywgZGEpO1xyXG5cclxuXHJcblxyXG5cclxuICAgICAgICAgICAgLy8gTW9kaWZ5IGRvbSBieSBkZWZhdWx0IGlmIHRoZXJlIGlzIGEgRE9NLlxyXG4gICAgICAgICAgICAvL3ZhciBtb2RpZnlEb20gPSBhWzJdO1xyXG5cclxuICAgICAgICB9O1xyXG5cclxuXHJcblxyXG5cclxuICAgICAgICAvKlxyXG4gICAgICAgIGlmIChzaWcgPT0gJ1tzLHMsYl0nKSB7XHJcbiAgICAgICAgICAgIHZhciBzdHlsZU5hbWUgPSBhWzBdO1xyXG4gICAgICAgICAgICB2YXIgc3R5bGVWYWx1ZSA9IGFbMV07XHJcblxyXG4gICAgICAgICAgICAvLyBNb2RpZnkgZG9tIGJ5IGRlZmF1bHQgaWYgdGhlcmUgaXMgYSBET00uXHJcblxyXG5cclxuICAgICAgICAgICAgdmFyIG1vZGlmeURvbSA9IGFbMl07XHJcblxyXG4gICAgICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLmdldCgnZG9tLmF0dHJpYnV0ZXMuc3R5bGUnKTtcclxuXHJcblxyXG4gICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdzdHlsZSAnICsgc3R5bGUpO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFzdHlsZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXQoJ2RvbS5hdHRyaWJ1dGVzLnN0eWxlJywgc3R5bGVOYW1lICsgJzonICsgc3R5bGVWYWx1ZSArICc7Jyk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBwYXJzZSB0aGUgc3R5bGUgYXR0cmlidXRlXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gY2FuJ3QgZG8gc3VjaCBhIHNpbXBsZSBzcGxpdCwgbmVlZCB0byBzcGxpdCBpbiBhIHdheSB0aGF0IGF2b2lkcyBzZW1pY29sb25zIHN1Y2ggYXMgaW4gYSB1cmw/XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gdHJ5IHNlbWljb2xvbiBzcGxpdC5cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAodG9mKHN0eWxlKSA9PSAnZGF0YV92YWx1ZScpIHN0eWxlID0gc3R5bGUudmFsdWUoKTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgbWFwX3N0eWxlID0gcGFyc2Vfc3R5bGVfYXR0cmlidXRlX3RvX21hcChzdHlsZSk7XHJcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdtYXBfc3R5bGUgJyArIHN0cmluZ2lmeShtYXBfc3R5bGUpKTtcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgbWFwX3N0eWxlW3N0eWxlTmFtZV0gPSBzdHlsZVZhbHVlO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBzdHJfc3R5bGUgPSBzdHlsZV9hdHRyaWJ1dGVfbWFwX3RvX3N0cmluZyhtYXBfc3R5bGUpO1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0KCdkb20uYXR0cmlidXRlcy5zdHlsZScsIHN0cl9zdHlsZSk7XHJcblxyXG5cclxuICAgICAgICAgICAgICAgIC8vdGhyb3cgJ3N0b3AnO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBTaG91bGQgbW9kaWd5IHRoZSBET00gYnkgZGVmYXVsdCBJIHRoaW5rLlxyXG4gICAgICAgICAgICBpZiAobW9kaWZ5RG9tKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLmdldCgnZG9tLmF0dHJpYnV0ZXMuc3R5bGUnKTtcclxuICAgICAgICAgICAgICAgIHZhciBlbCA9IHRoaXMuZ2V0KCdkb20uZWwnKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbC5zdHlsZS5jc3NUZXh0ID0gc3R5bGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG4gICAgICAgICovXHJcblxyXG4gICAgICAgIGlmIChzdHlsZU5hbWUgJiYgdHlwZW9mIHN0eWxlVmFsdWUgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIC8vdmFyIHN0eWxlTmFtZSA9IGFbMF07XHJcbiAgICAgICAgICAgIC8vdmFyIHN0eWxlVmFsdWUgPSBhWzFdO1xyXG5cclxuICAgICAgICAgICAgLy8gZG9tLmF0dHJpYnV0ZXMuc3R5bGUgLSBhcyBhIG5vcm1hbCBkYXRhX29iamVjdD9cclxuICAgICAgICAgICAgLy8gIE9yIGEgcGFydGljdWxhciB0eXBlIG9mIGF0dHJpYnV0ZSB0aGF0IGlzIGRlYWx0IHdpdGggZGlmZmVyZW50bHk/XHJcblxyXG5cclxuICAgICAgICAgICAgLy8gTmVlZCB0byBzZXQgdGhlIGlubGluZSBjc3MgZGljdFxyXG5cclxuICAgICAgICAgICAgLy8gd2lsbCB1cGRhdGUgdGhlIGRvbSBhdHRyaWJ1dGVzIHN0cmluZyBmcm9tIHRoZSBzdHlsZT9cclxuICAgICAgICAgICAgLy8gIHdpbGwgc2V0IGFuIGl0ZW0gaW4gdGhlIGlubGluZV9jc3NfZGljdFxyXG5cclxuICAgICAgICAgICAgdGhpcy5faWNzc1tzdHlsZU5hbWVdID0gc3R5bGVWYWx1ZTtcclxuXHJcbiAgICAgICAgICAgIC8vIHRoZW4gcmVidWlsZCB0aGUgZG9tIGF0dHJpYnV0ZXMgc3R5bGUgZnJvbSB0aGF0IG9uZS5cclxuXHJcbiAgICAgICAgICAgIC8vIHByb2R1Y2UgdGhlIGlubGluZSBjc3MgZnJvbSB0aGF0IGRpY3QuLi5cclxuXHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3N0eWxlTmFtZScsIHN0eWxlTmFtZSk7XHJcblxyXG4gICAgICAgICAgICB2YXIgc3RyX2NzcyA9ICcnO1xyXG4gICAgICAgICAgICAvL3ZhciBmaXJzdCA9IHRydWU7XHJcbiAgICAgICAgICAgIGVhY2godGhpcy5faWNzcywgZnVuY3Rpb24oaXRlbV9zdHlsZV92YWx1ZSwgaXRlbV9zdHlsZV9uYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAvL2lmICghZmlyc3QpIHtcclxuICAgICAgICAgICAgICAgIC8vICAgIHN0cl9jc3MgPSBzdHJfY3NzICsgJyc7XHJcbiAgICAgICAgICAgICAgICAvL31cclxuICAgICAgICAgICAgICAgIHN0cl9jc3MgPSBzdHJfY3NzICsgaXRlbV9zdHlsZV9uYW1lICsgJzonICsgaXRlbV9zdHlsZV92YWx1ZSArICc7JztcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnc3RyX2NzcycsIHN0cl9jc3MpO1xyXG5cclxuXHJcbiAgICAgICAgICAgIGlmIChtb2RpZnlfZG9tKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldCgnZG9tLmF0dHJpYnV0ZXMuc3R5bGUnLCBzdHJfY3NzKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG5cclxuXHJcbiAgICAgICAgaWYgKHNpZyA9PSAnW29dJykge1xyXG5cclxuICAgICAgICAgICAgLy8gY291bGQgcmVjb21wdXRlIHRoZSB3aG9sZSBzdHlsZSBzdHJpbmcgaW4gYSBtb3JlIG9wdGltaXplZCB3YXkuXHJcbiAgICAgICAgICAgIC8vICB0aGVyZSBjb3VsZCBhbHNvIGJlIGEgc3R5bGUgbWFwLCB0aGF0IHdvdWxkIGhlbHAgaW4gc3RvcmluZyBhbmQgY2hlY2tpbmcgcGFydGljdWxhciBzdHlsZXMuXHJcblxyXG5cclxuXHJcbiAgICAgICAgICAgIGVhY2goYVswXSwgZnVuY3Rpb24odiwgaSkge1xyXG4gICAgICAgICAgICAgICAgdGhhdC5zdHlsZShpLCB2LCBmYWxzZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgdmFyIHN0eWxlID0gdGhpcy5nZXQoJ2RvbS5hdHRyaWJ1dGVzLnN0eWxlJyk7XHJcblxyXG4gICAgICAgICAgICB2YXIgZWwgPSB0aGlzLmdldCgnZG9tLmVsJyk7XHJcblxyXG4gICAgICAgICAgICBpZiAoZWwpIHtcclxuICAgICAgICAgICAgICAgIGVsLnN0eWxlLmNzc1RleHQgPSBzdHlsZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICB9KSxcclxuICAgICdhY3RpdmUnOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAvLyBvbmx5IG9uIHRoZSBzZXJ2ZXIuXHJcbiAgICAgICAgLy8gIE5vdCBuZWNlc3NhcmlseSFcclxuICAgICAgICAvLyAgUGVyaGFwcyBjbGllbnQtc2lkZSByZW5kZXJpbmcgc2hvdWxkIHJlbmRlciB0aGUganNndWkgaWQuIFRoYXQgaXMgcmVhbGx5IG5lY2Vzc2FyeS5cclxuICAgICAgICAvLyAgSG93ZXZlciwgcGVyaGFwcyBzaG91bGQgbm90IHVzZSBhY3RpdmUgdG8gZG8gdGhpcy5cclxuXHJcblxyXG4gICAgICAgIC8vY29uc29sZS5sb2coJycpO1xyXG4gICAgICAgIC8vY29uc29sZS5sb2coJ2FjdGl2ZScpO1xyXG4gICAgICAgIHZhciBpZCA9IHRoaXMuX2lkKCk7XHJcblxyXG4gICAgICAgIC8vdmFyIGRvbUF0dHJpYnV0ZXMgPSB0aGlzLmdldCgnZG9tLmF0dHJpYnV0ZXMnKTtcclxuXHJcbiAgICAgICAgLy9kb21BdHRyaWJ1dGVzLnNldCgnZGF0YS1qc2d1aS1pZCcsIGlkKTtcclxuICAgICAgICAvL2RvbUF0dHJpYnV0ZXMuc2V0KCdkYXRhLWpzZ3VpLXR5cGUnLCB0aGlzLl9fdHlwZV9uYW1lKTtcclxuXHJcblxyXG4gICAgICAgIC8vIExvbmdlciBjb2RlIHZlcnNpb24uLi5cclxuICAgICAgICB2YXIgZG9tID0gdGhpcy5fLmRvbTtcclxuXHJcblxyXG4gICAgICAgIC8vY29uc29sZS5sb2coJ3RoaXMnLCB0aGlzKTtcclxuXHJcbiAgICAgICAgdmFyIGRvbV9hdHRyaWJ1dGVzID0gdGhpcy5fLmRvbS5fLmF0dHJpYnV0ZXM7XHJcbiAgICAgICAgaWYgKCFkb21fYXR0cmlidXRlcykge1xyXG4gICAgICAgICAgZG9tX2F0dHJpYnV0ZXMgPSBkb20uZ2V0KCdhdHRyaWJ1dGVzJyk7XHJcbiAgICAgICAgICAvL2RvbV9hdHRyaWJ1dGVzLnNldCgnZGF0YS1qc2d1aS1pZCcsIGlkKTtcclxuICAgICAgICAgIC8vZG9tX2F0dHJpYnV0ZXMuc2V0KCdkYXRhLWpzZ3VpLXR5cGUnLCB0aGlzLl9fdHlwZV9uYW1lKTtcclxuICAgICAgICAgIC8vY29uc29sZS5sb2coJ2RvbV9hdHRyaWJ1dGVzJywgZG9tX2F0dHJpYnV0ZXMpO1xyXG4gICAgICAgICAgLy9kb21fYXR0cmlidXRlcy5fWydkYXRhLWpzZ3VpLWlkJ10gPSBuZXcgRGF0YV9WYWx1ZSh7J3ZhbHVlJzogaWR9KTtcclxuICAgICAgICAgIC8vZG9tX2F0dHJpYnV0ZXMuX1snZGF0YS1qc2d1aS10eXBlJ10gPSBuZXcgRGF0YV9WYWx1ZSh7J3ZhbHVlJzogdGhpcy5fX3R5cGVfbmFtZX0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgIH1cclxuICAgICAgICAvL2NvbnNvbGUubG9nKCdkb21fYXR0cmlidXRlcycsIGRvbV9hdHRyaWJ1dGVzKTtcclxuICAgICAgICAvL3Rocm93ICdzdG9wJztcclxuICAgICAgICBkb21fYXR0cmlidXRlcy5fWydkYXRhLWpzZ3VpLWlkJ10gPSBuZXcgRGF0YV9WYWx1ZSh7J3ZhbHVlJzogaWR9KTtcclxuICAgICAgICBkb21fYXR0cmlidXRlcy5fWydkYXRhLWpzZ3VpLXR5cGUnXSA9IG5ldyBEYXRhX1ZhbHVlKHsndmFsdWUnOiB0aGlzLl9fdHlwZV9uYW1lfSk7XHJcbiAgICAgICAgLy92YXIgZWwgPSB0aGlzLl8uZWwgfHwgZG9tLl8uZWw7XHJcbiAgICAgICAgdmFyIGVsID0gZG9tLl8uZWw7XHJcbiAgICAgICAgaWYgKGVsKSB7XHJcbiAgICAgICAgICAvL2NvbnNvbGUubG9nKCdlbCcsIGVsKTtcclxuICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZSgnZGF0YS1qc2d1aS1pZCcsIGlkKTtcclxuICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZSgnZGF0YS1qc2d1aS10eXBlJywgdGhpcy5fX3R5cGVfbmFtZSk7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG4gICAgICAgIC8vIFRoZW4gdXBkYXRlIHRoZSBET00/XHJcblxyXG5cclxuXHJcblxyXG4gICAgICAgIC8vIENhbGxzIGFjdGl2ZSBvbiB0aGUgaW5uZXIgY29udHJvbHMuXHJcblxyXG4gICAgICAgIC8vXHJcblxyXG4gICAgICAgIHRoaXMuZ2V0KCdjb250ZW50JykuZWFjaChmdW5jdGlvbihpLCBjdHJsKSB7XHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2FjdGl2ZSBpJywgaSk7XHJcblxyXG4gICAgICAgICAgICB2YXIgdEN0cmwgPSB0b2YoY3RybCk7XHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3RDdHJsJywgdEN0cmwpO1xyXG4gICAgICAgICAgICBpZiAodEN0cmwgPT09ICdjb250cm9sJykge1xyXG4gICAgICAgICAgICAgICAgY3RybC5hY3RpdmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvLyBuZWVkIHRvIGxpc3RlbiB0byBjb250ZW50IGNoYW5nZS5cclxuXHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvLyBTbyBJIHRoaW5rIHRoZSByZXNvdXJjZS1wb29sIHdpbGwgaGF2ZSBhIHNlbGVjdGlvbiBzY29wZS5cclxuICAgICdmaW5kX3NlbGVjdGlvbl9zY29wZSc6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIC8vY29uc29sZS5sb2coJ2ZpbmRfc2VsZWN0aW9uX3Njb3BlJyk7XHJcblxyXG4gICAgICAgIHZhciByZXMgPSB0aGlzLmdldCgnc2VsZWN0aW9uX3Njb3BlJyk7XHJcbiAgICAgICAgaWYgKHJlcykgcmV0dXJuIHJlcztcclxuXHJcbiAgICAgICAgLy8gbG9vayBhdCB0aGUgYW5jZXN0b3IuLi5cclxuXHJcbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMuZ2V0KCdwYXJlbnQnKTtcclxuICAgICAgICAvL2NvbnNvbGUubG9nKCdwYXJlbnQgJyArIHRvZihwYXJlbnQpKTtcclxuXHJcblxyXG4gICAgICAgIGlmIChwYXJlbnQpIHJldHVybiBwYXJlbnQuZmluZF9zZWxlY3Rpb25fc2NvcGUoKTtcclxuXHJcbiAgICB9LFxyXG5cclxuXHJcbiAgICAvLyBUaGlzIHNob3VsZCBub3QganVzdCBhZGQgdGhlIGxpc3RlbmVyIHRvIHRoZSBET00gZXZlbnQuXHJcbiAgICAvLyAgVGhpcyBzaG91bGQgbGlzdGVuIHRvIHRoZSByZWxldmFudCBET00gZXZlbnQsIGFuZCB0aGVuIGFwcGx5IHRoZSBzdXBlcmNsYXNzJ3MgZnVuY3Rpb25cclxuICAgIC8vICAgKG1lYW5pbmcgaXQgZ2V0cyByYWlzZWQgYXMgYSBjb250cm9sIGV2ZW50KS5cclxuXHJcbiAgICAvLyBJdCBnZXRzIHJhaXNlZCBhcyBhIGNvbnRyb2wgZXZlbnQgYW55d2F5LlxyXG4gICAgLy8gIElmIGl0IG1hdGNoZXMgYSBkb20gZXZlbnQgdGhlbiBpdCBnZXRzIHJhaXNlZCBhcyBhIGNvbnRyb2wgZXZlbnQgd2hlbiB0aGF0IGRvbSBldmVudCBoYXBwZW5zLlxyXG5cclxuICAgIC8qXHJcblxyXG4gICAgJ2FkZF9ldmVudF9saXN0ZW5lcic6IGZ1bmN0aW9uKGV2ZW50X25hbWUsIGhhbmRsZXIpIHtcclxuICAgICAgICB2YXIgZWwgPSB0aGlzLmdldCgnZG9tLmVsJyk7XHJcbiAgICAgICAgaWYgKGVsKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgZWxlbWVudCBoYXMgdGhhdCBldmVudCBsaXN0ZW5lci4uLlxyXG4gICAgICAgICAgICAvLyAgTWF5YmUgbWFpbnRhaW4gYSBtYXAgd2l0aGluIHRoZSBjb250cm9sIG9mIHdoaWNoIERPTSBmdW5jdGlvbnMgaGF2ZSBiZWVuIGJvdW5kIHRvIHRoZSBlbGVtZW50LlxyXG5cclxuXHJcblxyXG4gICAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50X25hbWUsIGhhbmRsZXIsIGZhbHNlKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgKi9cclxuXHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAnX2FkZF9ldmVudF9saXN0ZW5lcic6IGZwKGZ1bmN0aW9uKGEsIHNpZykge1xyXG5cclxuICAgICAgICAvLyBkZXBlbmRpbmcgb24gd2hhdCB0aGUgZXZlbnQgaXMsIHdlIGFsc28gYmluZCBpdCB0byB0aGUgRE9NLlxyXG4gICAgICAgIC8vICBjYW4gdXNlIGFkZEV2ZW50TGlzdGVuZXIuXHJcblxyXG4gICAgICAgIGlmIChzaWcgPT0gJ1tzLGZdJykge1xyXG4gICAgICAgICAgICB2YXIgZXZlbnRfbmFtZSA9IGFbMF07XHJcblxyXG4gICAgICAgICAgICB2YXIgbGlzdGVuZXIgPSB0aGlzLm1hcExpc3RlbmVyc1tldmVudF9uYW1lXTtcclxuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG5cclxuICAgICAgICAgICAgdmFyIGVsID0gdGhpcy5nZXQoJ2RvbS5lbCcpO1xyXG5cclxuXHJcbiAgICAgICAgICAgIC8vaWYgKGVsKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGVsZW1lbnQgaGFzIHRoYXQgZXZlbnQgbGlzdGVuZXIuLi5cclxuICAgICAgICAgICAgICAgIC8vICBNYXliZSBtYWludGFpbiBhIG1hcCB3aXRoaW4gdGhlIGNvbnRyb2wgb2Ygd2hpY2ggRE9NIGZ1bmN0aW9ucyBoYXZlIGJlZW4gYm91bmQgdG8gdGhlIGVsZW1lbnQuXHJcblxyXG4gICAgICAgICAgICAvLyAgICBpZiAoIWxpc3RlbmVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYSBzaW5nbGUgbGlzdGVuZXIgY2FsbGVkIHdoZW4gYSBib3VuZCBkb20gZXZlbnQgZmlyZXMuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gIHRoaXMgd2lsbCB0aGVuIHNwbGl0IHVwIHRoZSBldmVudCBjYWxscyB0byBldmVyeXRoaW5nIHRoYXQgaXMgbGlzdGVuaW5nIHRvIHRoaXMuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZm9yIHRoZSBET00gZXZlbnQgb24gdGhlIG9iamVjdCwgd2UgcmFpc2UgdGhlIGV2ZW50IG9uIHRoZSBjb250cm9sLlxyXG5cclxuICAgICAgICAgICAgLy8gICAgICAgIGxpc3RlbmVyID0gdGhpcy5tYXBMaXN0ZW5lcnNbZXZlbnRfbmFtZV0gPSBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgIC8vICAgICAgICAgICAgdGhhdC5yYWlzZShldmVudF9uYW1lLCBlKTtcclxuICAgICAgICAgICAgLy8gICAgICAgIH07XHJcbiAgICAgICAgICAgIC8vICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50X25hbWUsIGxpc3RlbmVyLCBmYWxzZSk7XHJcblxyXG4gICAgICAgICAgICAvLyAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgICAgIC8vZWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudF9uYW1lLCBoYW5kbGVyLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIC8vfVxyXG5cclxuXHJcbiAgICAgICAgICAgIC8vIFRoaXMgY2F1c2VzIGFuIGluZmluaXRlIGxvb3AgZm9yIHNvbWUgcmVhc29uLlxyXG4gICAgICAgICAgICAvLyAgTWF5YmUgd2hlbiB0aGUgZXZlbnQgdGFrZXMgcGxhY2UuLi4uXHJcblxyXG4gICAgICAgICAgICBFbmhhbmNlZF9EYXRhX09iamVjdC5wcm90b3R5cGUuYWRkX2V2ZW50X2xpc3RlbmVyLmFwcGx5KHRoaXMsIGEpO1xyXG5cclxuXHJcbiAgICAgICAgICAgIC8vdGhpcy5fc3VwZXIuYXBwbHkodGhpcywgYSk7XHJcblxyXG5cclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnaHRtbCBjb3JlIGFkZF9ldmVudF9saXN0ZW5lciBldmVudF9uYW1lJywgZXZlbnRfbmFtZSk7XHJcblxyXG4gICAgICAgICAgICAvLyBBbmQgdGhlIGJhc2UgZXZlbnQgbGlzdGVuZXIgYXMgd2VsbD9cclxuICAgICAgICAgICAgLy8gIERvZXMgaXQgbWFrZSBhbiBpbmZpbml0ZSByZWN1cnNpdmUgbG9vcCB3aGVuIEkgdHJ5P1xyXG5cclxuICAgICAgICAgICAgLy9cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0pLFxyXG4gICAgKi9cclxuXHJcbiAgICAnY2xpY2snOiBmdW5jdGlvbihoYW5kbGVyKSB7XHJcbiAgICAgICAgLy8gQWRkaW5nIHRoZSBjbGljayBldmVudCBsaXN0ZW5lci4uLiBkb2VzIHRoYXQgYWRkIGl0IHRvIHRoZSBET00/XHJcblxyXG4gICAgICAgIHRoaXMuYWRkX2V2ZW50X2xpc3RlbmVyKCdjbGljaycsIGhhbmRsZXIpO1xyXG4gICAgfSxcclxuICAgICdob3Zlcic6IGZ1bmN0aW9uKGZuX2luLCBmbl9vdXQpIHtcclxuICAgICAgICB0aGlzLmFkZF9ldmVudF9saXN0ZW5lcignbW91c2VvdmVyJywgZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdob3ZlciBtb3VzZW92ZXInKTtcclxuICAgICAgICAgICAgZm5faW4oKTtcclxuICAgICAgICB9KVxyXG5cclxuICAgICAgICB0aGlzLmFkZF9ldmVudF9saXN0ZW5lcignbW91c2VvdXQnLCBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2hvdmVyIG1vdXNlb3V0Jyk7XHJcbiAgICAgICAgICAgIGZuX291dCgpO1xyXG4gICAgICAgIH0pXHJcbiAgICB9LFxyXG5cclxuXHJcblxyXG4gICAgJ2FkZF9jbGFzcyc6IGZ1bmN0aW9uKGNsYXNzX25hbWUpIHtcclxuICAgICAgICAvLyBTaG91bGQgaGF2ZSBhbHJlYWR5IHNldCB0aGVzZSB1cCBvbiBhY3RpdmF0aW9uLlxyXG4gICAgICAgIC8vY29uc29sZS5sb2coJ0NvbnRyb2wgYWRkX2NsYXNzICcgKyBjbGFzc19uYW1lKTtcclxuICAgICAgICB2YXIgY2xzID0gdGhpcy5nZXQoJ2RvbS5hdHRyaWJ1dGVzLmNsYXNzJyk7XHJcbiAgICAgICAgLy9jb25zb2xlLmxvZygnY2xzICcgKyBjbHMpO1xyXG4gICAgICAgIHZhciBlbCA9IHRoaXMuZ2V0KCdkb20uZWwnKTtcclxuXHJcbiAgICAgICAgLy9jb25zb2xlLmxvZygnYWRkX2NsYXNzIGVsICcgKyBlbCk7XHJcbiAgICAgICAgaWYgKCFjbHMpIHtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuc2V0KCdkb20uYXR0cmlidXRlcy5jbGFzcycsIGNsYXNzX25hbWUpO1xyXG5cclxuXHJcbiAgICAgICAgICAgIC8vIGFzIHdlbGwgYXMgdGhhdCwgbmVlZCB0byBoYXZlIHRoZSBjbGFzcyBpbiB0aGUgZG9jIHJlc3BvbmQgdG8gdGhpcyBjaGFnaW5nLlxyXG4gICAgICAgICAgICAvLyAgZXZlbnQgbGlzdGVuZXIgbGlzdGVuaW5nIGZvciBkb20gY2hhbmdlcyB3aWxsIHVwZGF0ZSB0aGlzLlxyXG5cclxuICAgICAgICAgICAgLy9pZiAoZWwpIGVsLmNsYXNzTmFtZSA9IGNsYXNzX25hbWU7XHJcblxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciB0Q2xzID0gdG9mKGNscyk7XHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3RDbHMgJyArIHRDbHMpO1xyXG4gICAgICAgICAgICBpZiAodENscyA9PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICAgICAgLy9jbHNcclxuICAgICAgICAgICAgICAgIGNsc1tjbGFzc19uYW1lXSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAvLyB0aGVuIGdldCB0aGUgY2xhc3NlcyBmcm9tIHRoZSBvYmpcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgYXJyX2NsYXNzID0gW107XHJcbiAgICAgICAgICAgICAgICBlYWNoKGNscywgZnVuY3Rpb24oaSwgdikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh2KSBhcnJfY2xhc3MucHVzaChpKTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICB2YXIgc3RyX2NsYXNzID0gYXJyX2NsYXNzLmpvaW4oJyAnKTtcclxuICAgICAgICAgICAgICAgIGVsLmNsYXNzTmFtZSA9IHN0cl9jbGFzcztcclxuICAgICAgICAgICAgfSBlbHNlIGlmICh0Q2xzID09ICdkYXRhX3ZhbHVlJykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHZhbCA9IGNscy52YWx1ZSgpO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBhcnJfY2xhc3NlcyA9IHZhbC5zcGxpdCgnICcpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGFscmVhZHlfaGFzX2NsYXNzID0gZmFsc2UsIGwgPSBhcnJfY2xhc3Nlcy5sZW5ndGgsIGMgPSAwO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGMgPCBsICYhIGFscmVhZHlfaGFzX2NsYXNzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFycl9jbGFzc2VzW2NdID09IGNsYXNzX25hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWxyZWFkeV9oYXNfY2xhc3MgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjKys7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIWFscmVhZHlfaGFzX2NsYXNzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXJyX2NsYXNzZXMucHVzaChjbGFzc19uYW1lKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBzdHJfY2xzID0gYXJyX2NsYXNzZXMuam9pbignICcpO1xyXG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnc3RyX2NscycsIHN0cl9jbHMpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXQoJ2RvbS5hdHRyaWJ1dGVzLmNsYXNzJywgc3RyX2Nscyk7XHJcblxyXG4gICAgICAgICAgICAgICAvL3RoaXMuYWRkX2NsYXNzKHZhbCk7XHJcbiAgICAgICAgICAgICAgICAvLyBBbmQgdGhlIERPTSBzaG91bGQgdXBkYXRlIGl0c2VsZiB3aGVuIG9uZSBvZiB0aGVzZSAnbW9kZWwnIG9iamVjdHMgZ2V0cyBjaGFuZ2VkIC0gZGVwZW5kaW5nIG9uIGlmIGl0cyBhY3RpdmF0ZWQgb3Igbm90LlxyXG5cclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodENscyA9PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGFycl9jbGFzc2VzID0gY2xzLnNwbGl0KCcgJyk7XHJcbiAgICAgICAgICAgICAgICB2YXIgYWxyZWFkeV9oYXNfY2xhc3MgPSBmYWxzZSwgbCA9IGFycl9jbGFzc2VzLmxlbmd0aCwgYyA9IDA7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoYyA8IGwgJiEgYWxyZWFkeV9oYXNfY2xhc3MpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYXJyX2NsYXNzZXNbY10gPT0gY2xhc3NfbmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbHJlYWR5X2hhc19jbGFzcyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGMrKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICghYWxyZWFkeV9oYXNfY2xhc3MpIHtcclxuICAgICAgICAgICAgICAgICAgICBhcnJfY2xhc3Nlcy5wdXNoKGNsYXNzX25hbWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIHN0cl9jbHMgPSBhcnJfY2xhc3Nlcy5qb2luKCcgJyk7XHJcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdzdHJfY2xzJywgc3RyX2Nscyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldCgnZG9tLmF0dHJpYnV0ZXMuY2xhc3MnLCBzdHJfY2xzKTtcclxuICAgICAgICAgICAgICAgIC8vIEFuZCB0aGUgRE9NIHNob3VsZCB1cGRhdGUgaXRzZWxmIHdoZW4gb25lIG9mIHRoZXNlICdtb2RlbCcgb2JqZWN0cyBnZXRzIGNoYW5nZWQgLSBkZXBlbmRpbmcgb24gaWYgaXRzIGFjdGl2YXRlZCBvciBub3QuXHJcblxyXG5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvL3Rocm93ICdzdG9wJztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgICdyZW1vdmVfY2xhc3MnOiBmdW5jdGlvbihjbGFzc19uYW1lKSB7XHJcbiAgICAgICAgLy9jb25zb2xlLmxvZygncmVtb3ZlX2NsYXNzICcgKyBjbGFzc19uYW1lKTtcclxuXHJcblxyXG4gICAgICAgIHZhciBjbHMgPSB0aGlzLmdldCgnZG9tLmF0dHJpYnV0ZXMuY2xhc3MnKTtcclxuICAgICAgICAvL2NvbnNvbGUubG9nKCdjbHMgJyArIHN0cmluZ2lmeShjbHMpKTtcclxuICAgICAgICB2YXIgZWwgPSB0aGlzLmdldCgnZG9tLmVsJyk7XHJcbiAgICAgICAgLy9jb25zb2xlLmxvZygnZWwnLCBlbCk7XHJcbiAgICAgICAgaWYgKGNscykge1xyXG4gICAgICAgICAgICB2YXIgdENscyA9IHRvZihjbHMpO1xyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCd0Q2xzJywgdENscyk7XHJcbiAgICAgICAgICAgIC8vdGhyb3cgJ3N0b3AnO1xyXG4gICAgICAgICAgICBpZiAodENscyA9PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICAgICAgLy9lbC5cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBnbyB0aHJvdWdoIGl0IGFnYWluLCBidWlsZGluZyB0aGUgY2xhc3Mgc3RyaW5nLi4uXHJcbiAgICAgICAgICAgICAgICB2YXIgYXJyX2NsYXNzID0gW107XHJcbiAgICAgICAgICAgICAgICBlYWNoKGNscywgZnVuY3Rpb24oaSwgdikge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vaWYgKHYpIGFycl9jbGFzcy5wdXNoKGkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpID09IGNsYXNzX25hbWUpIGNsc1tpXSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjbHNbaV0pIGFycl9jbGFzcy5wdXNoKGkpO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIHZhciBzdHJfY2xhc3MgPSBhcnJfY2xhc3Muam9pbignICcpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXQoJ2RvbS5hdHRyaWJ1dGVzLmNsYXNzJywgc3RyX2Nscyk7XHJcbiAgICAgICAgICAgICAgICAvL2VsLmNsYXNzTmFtZSA9IHN0cl9jbGFzcztcclxuXHJcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdzdHJfY2xhc3MgJyArIHN0cl9jbGFzcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRDbHMgPT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2NscycsIGNscyk7XHJcbiAgICAgICAgICAgICAgICB2YXIgYXJyX2NsYXNzZXMgPSBjbHMuc3BsaXQoJyAnKTtcclxuICAgICAgICAgICAgICAgIHZhciBhcnJfcmVzID0gW107XHJcbiAgICAgICAgICAgICAgICB2YXIgbCA9IGFycl9jbGFzc2VzLmxlbmd0aCwgYyA9IDA7XHJcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdhcnJfY2xhc3NlcycsIGFycl9jbGFzc2VzKTtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChjIDwgbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhcnJfY2xhc3Nlc1tjXSAhPSBjbGFzc19uYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vYWxyZWFkeV9oYXNfY2xhc3MgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJfcmVzLnB1c2goYXJyX2NsYXNzZXNbY10pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjKys7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdhcnJfcmVzJywgYXJyX3Jlcyk7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3RyX2NscyA9IGFycl9yZXMuam9pbignICcpO1xyXG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnc3RyX2NscyAnLCBzdHJfY2xzKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0KCdkb20uYXR0cmlidXRlcy5jbGFzcycsIHN0cl9jbHMpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3N0cl9jbHMgJyArIHN0cl9jbHMpO1xyXG4gICAgICAgICAgICAgICAgLy90aHJvdyAnc3RvcCc7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIGFuZCBpZiBpdCdzIGEgZGF0YSB2YWx1ZSwgZG8gc2ltaWxhci4uLlxyXG5cclxuICAgICAgICAgICAgaWYgKHRDbHMgPT0gJ2RhdGFfdmFsdWUnKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY2xzMiA9IGNscy52YWx1ZSgpO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBhcnJfY2xhc3NlcyA9IGNsczIuc3BsaXQoJyAnKTtcclxuICAgICAgICAgICAgICAgIHZhciBhcnJfcmVzID0gW107XHJcbiAgICAgICAgICAgICAgICB2YXIgbCA9IGFycl9jbGFzc2VzLmxlbmd0aCwgYyA9IDA7XHJcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdhcnJfY2xhc3NlcycsIGFycl9jbGFzc2VzKTtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChjIDwgbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhcnJfY2xhc3Nlc1tjXSAhPSBjbGFzc19uYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vYWxyZWFkeV9oYXNfY2xhc3MgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJfcmVzLnB1c2goYXJyX2NsYXNzZXNbY10pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjKys7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdhcnJfcmVzJywgYXJyX3Jlcyk7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3RyX2NscyA9IGFycl9yZXMuam9pbignICcpO1xyXG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnc3RyX2NscyAnLCBzdHJfY2xzKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0KCdkb20uYXR0cmlidXRlcy5jbGFzcycsIHN0cl9jbHMpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3N0cl9jbHMgJyArIHN0cl9jbHMpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgJ2hvdmVyX2NsYXNzJzogZnVuY3Rpb24oY2xhc3NfbmFtZSkge1xyXG4gICAgICAgIC8vIFRob3VnaCB0aGlzIGlzIGEgYmVoYXZpb3VyLi4uXHJcbiAgICAgICAgLy8gIGNvdWxkIG1ha2UgdGhpcyB3b3JrIHRocm91Z2ggdGhlIGJlaGF2aW91ciBzeXN0ZW0/XHJcbiAgICAgICAgLy8gIGNvdWxkIG1ha2UgdGhlIGJlaGF2aW91ciBzeXN0ZW0gd29yayB3aXRoIHRoaXMuXHJcbiAgICAgICAgLy8gICBUaGlzIG9uZSBzZWVtcyBmYWlybHkgc2ltcGxlLCBsb3dlciBsZXZlbCB0aGFuIGJlaGF2aW91ciBzeXN0ZW0uXHJcblxyXG4gICAgICAgIC8vIGJ1dCBpbiB0aGUgZ3JvdXAuLi4gd2hlbiBob3Zlcl9jbGFzcyBnZXRzIGNhbGxlZCBmb3IgdGhlIGdyb3VwLCBpdCBuZWVkcyB0byBiZSBhY3RpdmUgb24gdGhlIGdyb3VwLi4uLlxyXG5cclxuICAgICAgICAvLyBXaGVuIHRhcmdldGluZyBhIGdyb3VwIGFzIHdlbGwuLi5cclxuICAgICAgICAvLyAgTWF5IG5lZWQgdG8gZ2l2ZSBncm91cHMgYSBiaXQgbW9yZSB0aG91Z2h0LlxyXG5cclxuICAgICAgICAvLyBCdXQgaG92ZXJfY2xhc3Mgc2VlbXMgdXNlZnVsIGF0IGxlYXN0LlxyXG5cclxuXHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgIHRoYXQuaG92ZXIoZnVuY3Rpb24oZV9pbikge1xyXG4gICAgICAgICAgICB0aGF0LmFkZF9jbGFzcyhjbGFzc19uYW1lKTtcclxuICAgICAgICAgICAgLy9jdHJsX2tleV9jbG9zZV9xdW90ZS5hZGRfY2xhc3MoaG92ZXJfY2xhc3MpO1xyXG4gICAgICAgIH0sIGZ1bmN0aW9uKGVfb3V0KSB7XHJcbiAgICAgICAgICAgIHRoYXQucmVtb3ZlX2NsYXNzKGNsYXNzX25hbWUpO1xyXG4gICAgICAgICAgICAvL2N0cmxfa2V5X2Nsb3NlX3F1b3RlLnJlbW92ZV9jbGFzcyhob3Zlcl9jbGFzcyk7XHJcbiAgICAgICAgfSlcclxuXHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAnZmluZCc6IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XHJcblxyXG4gICAgfSxcclxuICAgICdjaGlsZHJlbic6IGZwKGZ1bmN0aW9uKGEsIHNpZykge1xyXG4gICAgICAgIHZhciBzZWxlY3RvcjtcclxuXHJcbiAgICAgICAgaWYgKHNpZyA9PSAnW3NdJykge1xyXG4gICAgICAgICAgICBzZWxlY3RvciA9IGFbMF07XHJcbiAgICAgICAgfVxyXG5cclxuXHJcblxyXG5cclxuICAgIH0pLFxyXG5cclxuICAgICdtYXRjaGVzX3NlbGVjdG9yJzogZnVuY3Rpb24oc2VsZWN0b3IpIHtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8vIFdhbnQgdG8gc2VlIGlmIGFuIGVsZW1lbnQgKG9yIGNvbnRyb2wpIGlzIGEgZGVzY2VuZGFudCBvZiB0aGlzLlxyXG4gICAgLy8gIElmIHRoaXMgaXMgYW4gYW5jZXN0b3Igb2YgZWxlbWVudCBvciBjb250cm9sLiBpc19hbmNlc3Rvcl9vZlxyXG4gICAgLy8gd2lsbCBnbyB0aHJvdWdoIERPTSBwYXJlbnQgbm9kZXMgb3IgY29udHJvbCBwYXJlbnRzLlxyXG5cclxuICAgICdpc19hbmNlc3Rvcl9vZic6IGZ1bmN0aW9uKHRhcmdldCkge1xyXG4gICAgICAgIHZhciB0X3RhcmdldCA9IHRvZih0YXJnZXQpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCd0X3RhcmdldCcsIHRfdGFyZ2V0KTtcclxuXHJcbiAgICAgICAgdmFyIGVsID0gdGhpcy5nZXQoJ2RvbS5lbCcpO1xyXG5cclxuICAgICAgICB2YXIgaW5uZXIgPSBmdW5jdGlvbih0YXJnZXQyKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAodGFyZ2V0MiA9PSBlbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHBhcmVudCA9IHRhcmdldDIucGFyZW50Tm9kZTtcclxuICAgICAgICAgICAgaWYgKCFwYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfSAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5uZXIocGFyZW50KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0X3RhcmdldCA9PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICBpZiAoZWwgIT0gdGFyZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gdGFyZ2V0LnBhcmVudE5vZGU7XHJcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlubmVyKHBhcmVudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAnZmluZF9zZWxlY3RlZF9hbmNlc3Rvcl9pbl9zY29wZSc6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIC8vIHNhbWUgc2VsZWN0aW9uIHNjb3BlXHJcbiAgICAgICAgLy8gaXMgdGhpcyBvbmUgYWxyZWFkeSBzZWxlY3RlZD9cclxuICAgICAgICAvLyBiZXN0IG5vdCB0byBjaGVjay4uLi5cclxuXHJcbiAgICAgICAgdmFyIHMgPSB0aGlzLmdldCgnc2VsZWN0aW9uX3Njb3BlJyk7XHJcblxyXG5cclxuICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy5nZXQoJ3BhcmVudCcpO1xyXG4gICAgICAgIC8vY29uc29sZS5sb2coJ3BhcmVudCAnICsgcGFyZW50KTtcclxuXHJcbiAgICAgICAgdmFyIHBzID0gcGFyZW50LmdldCgnc2VsZWN0aW9uX3Njb3BlJyk7XHJcblxyXG4gICAgICAgIGlmIChzID09IHBzKSB7XHJcbiAgICAgICAgICAgIC8vIFByb2JhYmx5IHdvdWxkIGJlIG11Y2ggbW9yZSBjb252ZW5pZW50IHRvIGdldCBhIGRhdGEgdmFsdWUganVzdCBhcyBpdHMgdmFsdWUsXHJcbiAgICAgICAgICAgIC8vICBvciBoYXZlIGEgbW9yZSBjb252ZW5pZW50IGRhdGEgdmFsdWUgaWRpb20uXHJcbiAgICAgICAgICAgIHZhciBwc2VsID0gcGFyZW50LmdldCgnc2VsZWN0ZWQnKTtcclxuICAgICAgICAgICAgaWYgKHBzZWwgJiYgcHNlbC52YWx1ZSAmJiBwc2VsLnZhbHVlKCkgPT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgLy90aHJvdyAnc3RvcCc7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcmVudDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJlbnQuZmluZF9zZWxlY3RlZF9hbmNlc3Rvcl9pbl9zY29wZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgLy90aHJvdyAnc3RvcCc7XHJcblxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgJ3JlbW92ZSc6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBlbCA9IHRoaXMuZ2V0KCdkb20uZWwnKTtcclxuICAgICAgICBpZiAoZWwpIHtcclxuICAgICAgICAgICAgaWYgKGVsLnBhcmVudE5vZGUpIHtcclxuICAgICAgICAgICAgICAgIGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAnc2hhbGxvd19jb3B5JzogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ0NvbnRyb2wgc2hhbGxvd19jb3B5Jyk7XHJcblxyXG4gICAgICAgIHZhciByZXMgPSBuZXcgQ29udHJvbCh7XHJcbiAgICAgICAgICAgICdjb250ZXh0JzogdGhpcy5fY29udGV4dFxyXG4gICAgICAgIH0pO1xyXG5cclxuXHJcbiAgICAgICAgLy8gbmVlZCB0byBnZXQgc2V0dGluZyBvZiBvbmUgZGF0YSBvYmplY3QgdG8gYW5vdGhlciBjb3JyZWN0LlxyXG4gICAgICAgIC8vICBUaGF0IGxvb2tzIGxpa2UgYSBsb3dlciBsZXZlbCBwaWVjZSBvZiBmdW5jdGlvbmFsaXR5IHRoYXQgbmVlZHMgYXR0ZW50aW9uLlxyXG5cclxuICAgICAgICAvLyBGb3IgdGhlIG1vbWVudCwgd2FudCB0byBnZXQgc29tZSBraW5kIG9mIHNoYWxsb3cgY29weSB3b3JraW5nLlxyXG5cclxuICAgICAgICAvL3Jlcy5zZXQoJ2RvbS5hdHRyaWJ1dGVzJywgdGhpcy5nZXQoJ2RvbS5hdHRyaWJ1dGVzJykpO1xyXG5cclxuICAgICAgICB2YXIgZGEgPSB0aGlzLmdldCgnZG9tLmF0dHJpYnV0ZXMnKTtcclxuICAgICAgICB2YXIgY2wgPSBkYS5nZXQoJ2NsYXNzJyk7XHJcblxyXG4gICAgICAgIGNvbnNvbGUubG9nKCdjbCAnICsgc3RyaW5naWZ5KGNsKSk7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ2NsICcgKyB0b2YoY2wpKTtcclxuXHJcbiAgICAgICAgdmFyIG1hcF9jbGFzc19leGNsdWRlID0ge1xyXG4gICAgICAgICAgICAnYmctbGlnaHQteWVsbG93JzogdHJ1ZSxcclxuICAgICAgICAgICAgJ3NlbGVjdGVkJzogdHJ1ZVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZWFjaChjbCwgZnVuY3Rpb24oaSwgdikge1xyXG4gICAgICAgICAgICBpZiAoaSAmJiAhbWFwX2NsYXNzX2V4Y2x1ZGVbaV0pIHJlcy5hZGRfY2xhc3MoaSk7XHJcbiAgICAgICAgfSlcclxuXHJcbiAgICAgICAgdmFyIHJlc19jb250ZW50ID0gcmVzLmdldCgnY29udGVudCcpO1xyXG5cclxuICAgICAgICB0aGlzLmdldCgnY29udGVudCcpLmVhY2goZnVuY3Rpb24oaSwgdikge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygndiAnICsgdik7XHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3YgJyArIHN0cmluZ2lmeSh2KSk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCd0b2YgdiAnICsgdG9mKHYpKTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0b2YodikgPT0gJ2RhdGFfdmFsdWUnKSB7XHJcbiAgICAgICAgICAgICAgICByZXNfY29udGVudC5hZGQodi52YWx1ZSgpKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJlc19jb250ZW50LmFkZCh2LnNoYWxsb3dfY29weSgpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgfSlcclxuXHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH0sXHJcblxyXG4gICAgLy8gTWF5IGJlIGdvb2QgaGF2aW5nIF9zaXplXHJcbiAgICAvLyAgb3IgX21lYXN1cmVkU2l6ZVxyXG4gICAgLy8gIHdhbnQgdG8gbWVhc3VyZSB0aGUgY29udHJvbCBhdCBhIHN1aXRhYmxlIHRpbWUuXHJcblxyXG4gICAgLy8gU2hvdWxkIHByb2JhYmx5IGJlIGluIGh0bWwtZW5oIGluc3RlYWQuXHJcblxyXG4gICAgJ3NpemUnOiBmcChmdW5jdGlvbihhLCBzaWcpIHtcclxuICAgICAgICAvL2NvbnNvbGUubG9nKCdzaWcnLCBzaWcpO1xyXG4gICAgICAgIGlmIChzaWcgPT0gJ1tdJykge1xyXG4gICAgICAgICAgICB2YXIgZWwgPSB0aGlzLmdldCgnZG9tLmVsJyk7XHJcblxyXG4gICAgICAgICAgICB2YXIgdyA9IHBhcnNlSW50KGdldFN0eWxlKGVsLCAnd2lkdGgnKSwgMTApO1xyXG4gICAgICAgICAgICB2YXIgaCA9IHBhcnNlSW50KGdldFN0eWxlKGVsLCAnaGVpZ2h0JyksIDEwKTtcclxuICAgICAgICAgICAgdmFyIHJlcyA9IFt3LCBoXTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlcztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNpZyA9PSAnW2FdJykge1xyXG4gICAgICAgICAgICAvLyBzZXQgdGhlIHNpemUuXHJcbiAgICAgICAgICAgIC8vICB3aWxsIGJlIGRvbmUgdGhyb3VnaCBDU1MgaGVpZ2h0IGFuZCB3aWR0aC5cclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnYVswXScsIGFbMF0pO1xyXG4gICAgICAgICAgICB0aGlzLnN0eWxlKHtcclxuICAgICAgICAgICAgICAgICd3aWR0aCc6IGFbMF1bMF0gKyAncHgnLFxyXG4gICAgICAgICAgICAgICAgJ2hlaWdodCc6IGFbMF1bMV0gKyAncHgnXHJcbiAgICAgICAgICAgIH0pXHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9KSxcclxuXHJcbiAgICAnb2Zmc2V0JzogZnAoZnVuY3Rpb24oYSwgc2lnKSB7XHJcbiAgICAgICAgaWYgKHNpZyA9PSAnW10nKSB7XHJcbiAgICAgICAgICAgIHZhciBlbCA9IHRoaXMuZ2V0KCdkb20uZWwnKTtcclxuICAgICAgICAgICAgdmFyIHJlcyA9IFtlbC5vZmZzZXRMZWZ0LCBlbC5vZmZzZXRUb3BdO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc2lnID09ICdbYV0nKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3R5bGUoe1xyXG4gICAgICAgICAgICAgICAgJ2xlZnQnOiBhWzBdICsgJ3B4JyxcclxuICAgICAgICAgICAgICAgICd0b3AnOiBhWzFdICsgJ3B4J1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH1cclxuICAgIH0pLFxyXG5cclxuICAgICdjbGVhcic6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIC8vIGNsZWFyIGFsbCB0aGUgY29udGVudHMuXHJcbiAgICAgICAgLy8gdWkgc2hvdWxkIHJlYWN0IHRvIHRoZSBjaGFuZ2UuXHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLmdldCgnY29udGVudCcpLmNsZWFyKCk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAnYWN0aXZhdGUnOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAvLyBEbyBub3RoaW5nIGZvciBiYXNpYyBjb250cm9sIEkgdGhpbmsuXHJcbiAgICAgICAgLy8gIFBvc3NpYmx5IHdpbGwgYmUgZG9pbmcgc29tZSB0aGluZ3MgZGVwZW5kaW5nIG9uIGRpc2NvdmVyZWQgcHJvcGVydGllcy5cclxuXHJcbiAgICAgICAgLy8gTmVlZCB0byB3b3JrIG1vcmUgb24gaGVpcmFjaHkgaW4gYWN0aXZhdGlvbi5cclxuICAgICAgICAvLyAgV2FudCBodG1sIGRvY3VtZW50cyAoYW5kIHByZXR0eSBtdWNoIGV2ZXJ5dGhpbiBlbHNlKSB0byB1c2UgdGhlIGVuaGFuY2VkIGFjdGl2YXRpb24uXHJcbiAgICAgICAgLy8gIFNob3VsZCBiZSBPSyBoYXZpbmcgdGhhdCBpbiB0aGUgZGVwZW5kZW5jeSBjaGFpbiBvbiB0aGUgc2VydmVyLCBtdWNoIG9mIHRoZSBjb2RlIHdvbid0IGJlIGNhbGxlZCB0aG91Z2guXHJcblxyXG4gICAgICAgIC8vIE9yLCBlbmhhbmNlIHRoZSBhY3RpdmF0aW9ucyBvZiB0aGUgcHJvdG90eXBlcz9cclxuICAgICAgICAvLyAgSSdkIHByZWZlciB0byBoYXZlIHRoZSBlbmhhbmNlbWVudHMgYmVjb21lIGhpZ2hlciB1cCB0aGUgY2hhaW4uXHJcblxyXG5cclxuXHJcblxyXG5cclxuICAgIH1cclxuXHJcbiAgICAvLyBzaGFsbG93X2NvcHlcclxuICAgIC8vICB3b3VsZCBtYWtlIGEgY29weSBvZiB0aGUgY29udHJvbHMgYW5kIGl0cyBjb250ZW50cy5cclxuXHJcblxyXG5cclxuXHJcblxyXG4gICAgLy8gYWRkIGV2ZW50IGxpc3RlbmVyLi4uXHJcbiAgICAvLyAgd2lsbCBiZSBmb3IgdGhlIGRvbSBldmVudHMuXHJcbiAgICAvLyBkb20ubGlzdGVuZXJzP1xyXG5cclxuXHJcblxyXG5cclxuICAgIC8vXHJcblxyXG5cclxuXHJcblxyXG5cclxufSk7XHJcblxyXG5cclxudmFyIHAgPSBDb250cm9sLnByb3RvdHlwZTtcclxuLy9wLl8gPSBwLl8gfHwge307XHJcbi8vcC5fLnR5cGVfbmFtZSA9ICdjb250cm9sJztcclxuXHJcbnAuX2RhdGFfZ2VuZXJhdG9ycyA9IHtcclxuICAgICdjb250ZXh0X2lkJzogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIHRoaXMgaXMgdGhlIGNvbnRyb2xcclxuICAgICAgICAvLyAgdGhlIGNvbnRyb2wgc2hvdWxkIGhhdmUgYWNjZXNzIHRvIGEgcGFnZV9jb250ZXh0P1xyXG5cclxuICAgICAgICAvLyBDb250cm9scyBvbiB0aGUgc2VydmVyIGFyZSBsaWtlbHkgdG8gbmVlZCB0aGlzIGZvciByZW5kZXJpbmcgcmlnaHQgKGRpZmZlcmVudCBjb250ZXh0cykuXHJcblxyXG4gICAgICAgIC8vIE9uIHRoZSBjbGllbnQgY291bGQgcmVmZXIgdG8ganNndWkucGFnZV9jb250ZXh0XHJcblxyXG4gICAgICAgIC8vIGNvdWxkIHJlZmVyIHRvIGpzZ3VpLnBhZ2VfY29udGV4dCwgaWYgaXQgaXMgdGhlcmUuXHJcbiAgICAgICAgLy8gIE90aGVyd2lzZSBpdCB3b3VsZCBoYXZlIHRvIGJlIGEgcHJvcGVydHkgb2YgdGhlIGNvbnRyb2wuXHJcbiAgICAgICAgLy9jb25zb2xlLmxvZygndGhpcy5zZXQgJyArIHRoaXMuc2V0KTtcclxuICAgICAgICB2YXIgcGFnZV9jb250ZXh0ID0gdGhpcy5wYWdlX2NvbnRleHQoKTtcclxuICAgICAgICB2YXIgaWQgPSBwYWdlX2NvbnRleHQuZW5zdXJlX2N0cmxfaWQodGhpcyk7XHJcbiAgICAgICAgcmV0dXJuIGlkO1xyXG4gICAgfSxcclxuICAgICdjb250cm9sX2NvbGxlY3Rpb24nOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHJlcyA9IG5ldyBqc2d1aS5EYXRhQ29sbGVjdGlvbigpO1xyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9XHJcbn07XHJcblxyXG52YXIgaW5pdGlhbGl6aW5nID0gZmFsc2UsIGZuVGVzdCA9IC94eXovLnRlc3QoZnVuY3Rpb24oKSB7XHJcbiAgICB4eXo7XHJcbn0pID8gL1xcYl9zdXBlclxcYi8gOiAvLiovO1xyXG5cclxuQ29udHJvbC5wcm90b3R5cGUuX21vZHVsZV9qc2d1aSA9IGpzZ3VpO1xyXG5cclxuQ29udHJvbC5leHRlbmQgPSBmdW5jdGlvbihwcm9wLCBwb3N0X2luaXQpIHtcclxuICAgIHZhciBfc3VwZXIgPSB0aGlzLnByb3RvdHlwZTtcclxuICAgIGluaXRpYWxpemluZyA9IHRydWU7XHJcbiAgICB2YXIgcHJvdG90eXBlID0gbmV3IHRoaXMoKTtcclxuICAgIHZhciBmb3JfY2xhc3MgPSB7fTtcclxuICAgIGluaXRpYWxpemluZyA9IGZhbHNlO1xyXG4gICAgaWYgKHR5cGVvZiBwcm9wID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHZhciBkYXRhX3R5cGVfbmFtZSA9IHByb3A7XHJcbiAgICAgICAgdmFyIGR0aXMgPSBqc2d1aS5kYXRhX3R5cGVzX2luZm87XHJcbiAgICAgICAgdmFyIGRhdGFfdHlwZV9pbmZvID0gZHRpc1tkYXRhX3R5cGVfbmFtZV07XHJcbiAgICAgICAgZm9yX2NsYXNzW2RhdGFfdHlwZV9uYW1lXSA9IGRhdGFfdHlwZV9uYW1lO1xyXG4gICAgICAgIGZvcl9jbGFzc1tkYXRhX3R5cGVfaW5mb10gPSBkYXRhX3R5cGVfaW5mbztcclxuICAgICAgICBwcm90b3R5cGVbJ19fdHlwZV9uYW1lJ10gPSBkYXRhX3R5cGVfbmFtZTtcclxuICAgICAgICBwcm90b3R5cGVbJ19fZGF0YV90eXBlX2luZm8nXSA9IGRhdGFfdHlwZV9pbmZvO1xyXG4gICAgICAgIHByb3AgPSB7fTtcclxuICAgIH1cclxuICAgIHZhciBwcm9wX2l0ZW0sIHRfcHJvcF9pdGVtLCB0bXAsIG5hbWUsIHJlcztcclxuICAgIGZvciAobmFtZSBpbiBwcm9wKSB7XHJcbiAgICAgICAgcHJvcF9pdGVtID0gcHJvcFtuYW1lXTtcclxuICAgICAgICBpZiAobmFtZS5jaGFyQXQoMCkgPT09ICcjJykge1xyXG4gICAgICAgICAgICBwcm90b3R5cGVbbmFtZS5zdWJzdHJpbmcoMSldID0gcHJvdG90eXBlW3Byb3BfaXRlbV07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdF9wcm9wX2l0ZW0gPSB0eXBlb2YgcHJvcF9pdGVtO1xyXG4gICAgICAgICAgICBpZiAodF9wcm9wX2l0ZW0gPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgIHByb3RvdHlwZVtuYW1lXSA9IHR5cGVvZiBfc3VwZXJbbmFtZV0gPT09ICdmdW5jdGlvbicgJiYgZm5UZXN0LnRlc3QocHJvcF9pdGVtKSA/XHJcbiAgICAgICAgICAgICAgICAoZnVuY3Rpb24obmFtZSwgZm4pIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRtcCA9IHRoaXMuX3N1cGVyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdXBlciA9IF9zdXBlcltuYW1lXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3VwZXIgPSB0bXA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH0pKG5hbWUsIHByb3BbbmFtZV0pIDogcHJvcFtuYW1lXTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICh0X3Byb3BfaXRlbSA9PT0gJ29iamVjdCcgfHwgdF9wcm9wX2l0ZW0gPT09ICdib29sZWFuJykge1xyXG4gICAgICAgICAgICAgICAgaWYgKG5hbWUgPT0gJ2NsYXNzX25hbWUnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yX2NsYXNzWydfY2xhc3NfbmFtZSddID0gcHJvcF9pdGVtO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChuYW1lID09ICdmaWVsZHMnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yX2NsYXNzWydfZmllbGRzJ10gPSBwcm9wX2l0ZW07XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5hbWUgPT0gJ2Nvbm5lY3RfZmllbGRzJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvcl9jbGFzc1snX2Nvbm5lY3RfZmllbGRzJ10gPSBwcm9wX2l0ZW07XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHByb3RvdHlwZVtuYW1lXSA9IHByb3BbbmFtZV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcHJvdG90eXBlW25hbWVdID0gcHJvcFtuYW1lXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgdmFyIENsYXNzID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKCFpbml0aWFsaXppbmcpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaW5pdCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgdmFyIHRoZV9tYWtlX2Z1bmN0aW9uID0gZnVuY3Rpb24oYWJzdHJhY3RfY29udHJvbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIG5lZWRzIHRvIGNyZWF0ZSBhIHJlYWwgY29udHJvbCBvdXQgb2YgYW4gYWJzdHJhY3Qgb25lLlxyXG4gICAgICAgICAgICAgICAgICAgLy8gdmFyIGluc3RhbmNlID0gbmV3IGFic3RyYWN0X2NvbnRyb2xcclxuXHJcbiAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCd0aGUgbWFrZSBmdW5jdGlvbicpO1xyXG4gICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnYWJzdHJhY3RfY29udHJvbCcsIGFic3RyYWN0X2NvbnRyb2wpO1xyXG4gICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnYWJzdHJhY3RfY29udHJvbC5jb25zdHJ1Y3RvcicsIGFic3RyYWN0X2NvbnRyb2wuY29uc3RydWN0b3IpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgIHZhciBzcGVjID0gYWJzdHJhY3RfY29udHJvbC5fc3BlYztcclxuICAgICAgICAgICAgICAgICAgIHNwZWMuYWJzdHJhY3QgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgc3BlYy5fYWJzdHJhY3QgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgc3BlYy5jb250ZXh0ID0gdGhhdC5fY29udGV4dDtcclxuICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3RoYXQuX2NvbnRleHQnLCB0aGF0Ll9jb250ZXh0KTtcclxuICAgICAgICAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IG5ldyBhYnN0cmFjdF9jb250cm9sLmNvbnN0cnVjdG9yKHNwZWMpO1xyXG4gICAgICAgICAgICAgICAgICAgLy90aHJvdyAnc3RvcCc7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xyXG5cclxuXHJcbiAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciB0aGVfYWRkX2Z1bmN0aW9uID0gZnVuY3Rpb24oYWJzdHJhY3RfY29udHJvbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IHRoZV9tYWtlX2Z1bmN0aW9uKGFic3RyYWN0X2NvbnRyb2wpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGF0LmFkZChpbnN0YW5jZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGwgPSBhcmd1bWVudHMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgdmFyIGEyID0gbmV3IEFycmF5KGwgKyAyKTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgbDsgYysrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYTJbY10gPSBhcmd1bWVudHNbY107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBhMltsXSA9IHRoZV9hZGRfZnVuY3Rpb247XHJcbiAgICAgICAgICAgICAgICBhMltsICsgMV0gPSB0aGVfbWFrZV9mdW5jdGlvbjtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLmluaXQuYXBwbHkodGhpcywgYTIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucG9zdF9pbml0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy90aGlzLnBvc3RfaW5pdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucG9zdF9pbml0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAocG9zdF9pbml0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9zdF9pbml0LmNhbGwodGhpcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3BlYyA9IGFyZ3VtZW50c1swXSB8fCB7fTtcclxuICAgICAgICAgICAgICAgIHNwZWMuYWJzdHJhY3QgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDbGFzcyhzcGVjKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBDbGFzcy5wcm90b3R5cGUgPSBwcm90b3R5cGU7XHJcbiAgICBDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDbGFzcztcclxuICAgIENsYXNzLmV4dGVuZCA9IGFyZ3VtZW50cy5jYWxsZWU7XHJcbiAgICBmb3IgKGkgaW4gZm9yX2NsYXNzKSB7XHJcbiAgICAgICAgQ2xhc3NbaV0gPSBmb3JfY2xhc3NbaV07XHJcbiAgICB9XHJcbiAgICBpZiAoQ2xhc3NbJ2NsYXNzX25hbWUnXSkge1xyXG4gICAgICAgIGpzZ3VpLm1hcF9jbGFzc2VzW0NsYXNzWydjbGFzc19uYW1lJ11dID0gQ2xhc3M7XHJcbiAgICB9XHJcbiAgICBDbGFzcy5fc3VwZXJjbGFzcyA9IHRoaXM7XHJcbiAgICByZXR1cm4gQ2xhc3M7XHJcbn07XHJcblxyXG5cclxuXHJcbi8vIGZ1bmN0aW9uIHRvIHNldCB1cCBhY2Nlc3MgZnVuY3Rpb25zIG9uIGEgcHJvdG90eXBlP1xyXG4vLyAgYWxpYXNlcz9cclxuLy8gIGFjY2VzcyBmdW5jdGlvbnMgaW4gcGFydGljdWxhciBoZXJlLlxyXG5cclxuLy8gTmVlZCB0byBkbyBtb3JlIGFib3V0IHJlYnVpbGRpbmcgdGhlIGZyYW1ld29yayB3aXRoIHRoZSBuZXcgcHJvcGVydHkgc3lzdGVtLlxyXG4vLyAgV2lsbCBoYXZlIGVuY2Fwc3VsYXRlZCBhIGxvdCBpbnRvIGxhbmcgZnJvbSBodG1sLCBtYWtpbmcgdGhpbmdzIGVhc2llciBoZXJlLlxyXG5cclxuLy8gbGFuZy9wcm90b3R5cGVfYWNjZXNzXHJcblxyXG4vLyBMaWtlbHkgdG8gYmUgY2hhbmdlZCB0aHJvdWdoIHVzZSBvZiB0aGUgRGF0YV9PYmplY3RcclxuXHJcbi8vIERvIHdlIGhhdmUgYSBzdHlsZSB2YXJpYWJsZT9cclxuXHJcbnZhciBwcm90b3R5cGVfYWNjZXNzID0gZnVuY3Rpb24gKHAsIHZhcmlhYmxlX25hbWUsIGZuX25hbWUpIHtcclxuXHJcbiAgICBwW2ZuX25hbWVdID0gZnAoZnVuY3Rpb24gKGEpIHtcclxuXHJcbiAgICAgICAgLy9jb25zb2xlLmxvZygndGhpcy4gJyArIHN0cmluZ2lmeSh0aGlzLl8pKTtcclxuXHJcbiAgICAgICAgaWYgKGEubCA9PSAxKSB7XHJcbiAgICAgICAgICAgIC8vdmFyIHZhbCA9IGFbMF07XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldCh2YXJpYWJsZV9uYW1lLCBhWzBdKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXQodmFyaWFibGVfbmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cclxuXHJcbnZhciBwID0gQ29udHJvbC5wcm90b3R5cGU7XHJcblxyXG4vLyBUaGlzIHN5c3RlbSB3b3JrcyBxdWl0ZSBuaWNlbHkgbm93LlxyXG4vLyAgQWxsb3dzIHNpbXBsZSBmdW5jdGlvbmFsIGFjY2VzcyB0byB0aGVzZSBwcm9wZXJ0aWVzLlxyXG5cclxuLy8gcHJvdG90eXBlX2FjY2VzcyhwLCAnaW5kZXgnLCAnaW5kZXgnKTtcclxuLy9wcm90b3R5cGVfYWNjZXNzKHAsICdpZCcsICdpZCcpO1xyXG5wcm90b3R5cGVfYWNjZXNzKHAsICdkb20udGFnTmFtZScsICd0YWdOYW1lJyk7XHJcbnByb3RvdHlwZV9hY2Nlc3MocCwgJ2RvbS5hdHRyaWJ1dGVzJywgJ2RvbUF0dHJpYnV0ZXMnKTtcclxuLy9wcm90b3R5cGVfYWNjZXNzKHAsICdjb250cm9scycsICdjb250cm9scycpO1xyXG5cclxuXHJcbi8vcHJvdG90eXBlX2FjY2VzcyhwLCAnc3R5bGUnLCAnc3R5bGUnKTtcclxuXHJcbi8vIGFjY2VzcyB0byB0aGUgZG9tIG5vZGUgYXMgd2VsbC5cclxuXHJcbi8vIGRvbUF0dHJpYnV0ZXNcclxuXHJcbi8vcC5fdGFnX25hbWUgPSAnZGl2JztcclxuXHJcbnZhciBtYXBfQ29udHJvbHMgPSB7fTtcclxuXHJcblxyXG5cclxuLy9qc2d1aSA9IHt9O1xyXG4vL2pzZ3VpLkNvcmUgPSBDb3JlO1xyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG4vLyBPd24gdG9mIGZ1bmN0aW9uIGZvciB0aGlzIHNlY3Rpb24gdGhhdCBjaGVja3MgaW5zdGFuY2VPZiBDb250cm9sLlxyXG5cclxuLypcclxudmFyIG9sZF90b2YgPSBqc2d1aS50b2Y7XHJcblxyXG5qc2d1aS50b2YgPSBmdW5jdGlvbiAob2JqKSB7XHJcbiAgICB2YXIgcmVzID0gb2xkX3RvZihvYmopO1xyXG4gICAgaWYgKG9iaiBpbnN0YW5jZW9mIENvbnRyb2wpIHJlcyA9ICdjb250cm9sJztcclxuICAgIHJldHVybiByZXM7XHJcblxyXG59O1xyXG4qL1xyXG5cclxuLy8gQWxzbyBuZWVkIHRvIGdldCB0aGlzIGxvYWRpbmcgKGF1dG9tYXRpY2FsbHkpIGFzIGEgY2xpZW50LXNpZGUgY29tcG9uZW50LlxyXG5cclxuXHJcblxyXG4vLyBtYWtlIGl0IHNvIHRoYXQgdGhlcmUgaXMgaGVhZC50aXRsZSgpLFxyXG4vLyBhbHNvIHRpdGxlKCkgbWV0aG9kIGZvciBhIGJhc2ljIEhUTUwgZG9jdW1lbnQuXHJcblxyXG4vLyB0aGVzZSBzaG91bGQgc3VwcG9ydCB0ZXh0IGluc2lkZSB0aGVtLlxyXG4vLyB0aGUgJ3RleHQnIHByb3BlcnR5IGNvdWxkIGRvIHNvbWV0aGluZyBkaWZmZXJlbnQgZm9yIGRpZmZlcmVudCB0aGluZ3MuXHJcblxyXG4vLyB0ZXh0X3Byb3BlcnR5KCdkaXYgc3BhbiBoMSBoMicpXHJcbi8vIGEgcHJvcGVydHkgdGhhdCByZXByZXNlbnRzIGEgdGV4dE5vZGUgaW5zaWRlLlxyXG5cclxuLy8gdGV4dCBwcm9wZXJ0eSAtIHdpbGwgd29yayBhcyBhIHByb3BlcnR5IGNhbGxlZCB0ZXh0LlxyXG4vLyAgaG93ZXZlciwgd2hlbiB0aGUgdGV4dCBoYXMgYmVlbiBzZXQvY2hhbmdlZCwgaXQgY2hhbmdlcyB0ZXh0IGluIGEgdGV4dE5vZGUuXHJcbi8vIFRoaXMgdGV4dCBwcm9wZXJ0eSBzaG91bGQgYmUgYSBjb252ZW5pZW50IGludGVyZmFjZSB0byB0aGF0IHRleHQgbm9kZS5cclxuXHJcbi8vIEkgdGhpbmsgdGhhdCBtZWFucyB3ZSBuZWVkIGEgdGV4dE5vZGUuXHJcblxyXG4vLyBXaWxsIGhhdmUgYSBkb20ubm9kZVR5cGUgcHJvcGVydHkuXHJcbi8vICBNb3N0IHRoaW5ncyB3aWxsIGJlIDEgKGVsZW1lbnQpXHJcbi8vICBBdHRyaWJ1dGUgbm9kZSAyXHJcbi8vICBUZXh0IG5vZGUgM1xyXG5cclxuLy8gVGhlIHByb3BlcnRpZXMgaW5kZWVkIGhhdmUgZ3JlYXRseSBzaG9ydGVuZWQgdGhpcyBjb2RlLlxyXG4vLyAgTGlrZWx5IHRvIHB1dCB0aGUgbmV3IHByb3BlcnR5IHN5c3RlbSBpbnRvIHRoZSBmdWxsIGxpYnJhcnkgd2hlbiBtb3JlIGZ1bGx5IGRlZmluZWQuXHJcbi8vICBPciBsaWtlbHkgdG8gcHV0IHRoZSBmdWxsIGxpYidzIGNhcGFiaWxpdGllcyBpbnRvIHRoaXMsIGEgbmV3IHZlcnNpb24gb2YgaXQ/XHJcblxyXG4vLyBUaGUgbmV3IHByb3BlcnR5IHN5c3RlbSBsb29rcyBzZXQgdG8gc2F2ZSBvbiBhIGxvdCBvZiBjb2RlLiBTbyBtdWNoIG9mIHRoZSBjb2RlIGlzIGN1cnJlbnRseSBkZWFsaW5nIHdpdGggdGhlIG1lY2hhbmljcyBvZiBwcm9wZXJ0eSB2YWx1ZXMuXHJcblxyXG4vLyBBZ2Fpbiwgd2lsbCBjaGFuZ2UgdGhyb3VnaCB1c2Ugb2YgdGhlIERhdGFfT2JqZWN0XHJcbi8vIGFuZCB0aGUgY29udHJvbCBpbml0IGZ1bmN0aW9uP1xyXG4vLyAgaXQncyBjYWxsXHJcblxyXG52YXIgY3RybF9pbml0ID0gQ29udHJvbC5wcm90b3R5cGUuaW5pdDtcclxudmFyIGN0cmxfaW5pdF9jYWxsID0gQ29udHJvbC5wcm90b3R5cGUuaW5pdC5jYWxsO1xyXG5cclxudmFyIGVzY2FwZV9odG1sX3JlcGxhY2VtZW50cyA9IFtcclxuICAgICAgICBbLyYvZywgJyZhbXA7J10sXHJcbiAgICAgICAgWy88L2csICcmbHQ7J10sXHJcbiAgICAgICAgWy8+L2csICcmZ3Q7J10sXHJcbiAgICAgICAgWy9cIi9nLCAnJnF1b3Q7J10sIC8vXCJcclxuICAgICAgICBbLycvZywgJyYjeDI3OyddLCAvLydcclxuICAgICAgICBbL1xcLy9nLCAnJiN4MkY7J11cclxuICAgIF07XHJcbi8vdmFyIHNpbmdsZV9yZXBsYWNlbWVudDtcclxuXHJcbnZhciBlc2NhcGVfaHRtbCA9IGZ1bmN0aW9uIChzdHIpIHtcclxuXHJcbiAgICAvL2NvbnNvbGUubG9nKCd0b2Yoc3RyKSAnICsgdG9mKHN0cikpO1xyXG5cclxuICAgIC8vY29uc29sZS5sb2coJ2VzY2FwZV9odG1sIHN0ciAnICsgc3RyKTtcclxuICAgIC8vY29uc29sZS5sb2coJ3RvZiBzdHIgJyArIHRvZihzdHIpKTtcclxuXHJcblxyXG4gICAgaWYgKHRvZihzdHIpID09PSAnZGF0YV92YWx1ZScpIHN0ciA9IHN0ci5nZXQoKTtcclxuICAgIGlmICh0b2Yoc3RyKSA9PT0gJ251bWJlcicpIHN0ciA9IHN0ciArICcnO1xyXG5cclxuICAgIC8vY29uc29sZS5sb2coJ3RvZihzdHIpJywgdG9mKHN0cikpO1xyXG5cclxuICAgIGlmICh0eXBlb2Ygc3RyID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICBzdHIgPSAnJztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHZhciBzaW5nbGVfcmVwbGFjZW1lbnQ7XHJcbiAgICAgIGZvciAodmFyIGMgPSAwLCBsID0gZXNjYXBlX2h0bWxfcmVwbGFjZW1lbnRzLmxlbmd0aDsgYyA8IGw7IGMrKykge1xyXG4gICAgICAgICAgc2luZ2xlX3JlcGxhY2VtZW50ID0gZXNjYXBlX2h0bWxfcmVwbGFjZW1lbnRzW2NdXHJcbiAgICAgICAgICBzdHIgPSBzdHIucmVwbGFjZShzaW5nbGVfcmVwbGFjZW1lbnRbMF0sIHNpbmdsZV9yZXBsYWNlbWVudFsxXSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvL1xyXG5cclxuICAgIC8vIHN0ci5yZXBsYWNlKC9taWNyb3NvZnQvZ2ksIFwiVzNTY2hvb2xzXCIpXHJcbiAgICAvKlxyXG4gICAgdmFyIHJlcyA9IHN0ci5yZXBsYWNlKC8mL2csICcmYW1wOycpO1xyXG4gICAgcmVzID0gcmVzLnJlcGxhY2UoLzwvZywgJyZsdDsnKTtcclxuICAgIHJlcyA9IHJlcy5yZXBsYWNlKC8+L2csICcmZ3Q7Jyk7XHJcbiAgICByZXMgPSByZXMucmVwbGFjZSgvXCIvZywgJyZxdW90OycpO1xyXG4gICAgcmVzID0gcmVzLnJlcGxhY2UoLycvZywgJyYjeDI3OycpO1xyXG4gICAgcmVzID0gcmVzLnJlcGxhY2UoL1xcLy9nLCAnJiN4MkY7Jyk7XHJcbiAgICAqL1xyXG5cclxuICAgIC8vdmFyIHJlcGxhY2VtZW50cyA9XHJcblxyXG4gICAgLy9lYWNoKGVzY2FwZV9odG1sX3JlcGxhY2VtZW50cywgZnVuY3Rpb24gKGksIHYpIHtcclxuICAgIC8vICAgIHN0ciA9IHN0ci5yZXBsYWNlKHZbMF0sIHZbMV0pO1xyXG4gICAgLy99KTtcclxuXHJcbiAgICByZXR1cm4gc3RyO1xyXG59O1xyXG5cclxuXHJcbmpzZ3VpLnRleHROb2RlID0gQ29udHJvbC5leHRlbmQoe1xyXG4gICAgJ2luaXQnOiBmdW5jdGlvbiAoc3BlYykge1xyXG5cclxuXHJcbiAgICAgICAgc3BlYyA9IHNwZWMgfHwge307XHJcbiAgICAgICAgdGhpcy5fc3VwZXIoc3BlYyk7XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2Ygc3BlYyA9PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAvL3RoaXMuXy50ZXh0ID0gc3BlYztcclxuICAgICAgICAgICAgLy90aGlzLmlubmVySHRtbCA9IHNwZWM7XHJcbiAgICAgICAgICAgIHNwZWMgPSB7XHJcbiAgICAgICAgICAgICAgICAndGV4dCc6IHNwZWNcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHNwZWMubm9kZVR5cGUgPSAzO1xyXG4gICAgICAgIC8vdGhpcy5lbnN1cmUoJ18nKTtcclxuXHJcbiAgICAgICAgLypcclxuICBcdGlmIChzcGVjLnRleHQpIHtcclxuXHRcdHRoaXMuXy50ZXh0ID0gc3BlYy50ZXh0O1xyXG5cdFx0Ly90aGlzLmlubmVySHRtbCA9IHNwZWMudGV4dDtcclxuXHRcdHNwZWMgPSB7fTtcclxuXHR9XHJcbiAgXHQqL1xyXG4gICAgICAgIC8vdGhpcy5ub19lc2NhcGUgPSBzcGVjLm5vX2VzY2FwZSB8fCBmYWxzZTtcclxuICAgICAgICAvLyBhbm90aGVyIHByb3BlcnR5IGZyb20gdGhlIHNwZWM/IEkgdGhpbmsgdGhpcyBwcm9wZXJ0eSBjb3VsZCBmaXQgaW4gd2l0aCBhbiBNVkMgKG9yIE1NVkMpIHBhdHRlcm4gd2hlcmUgY2hhbmdlcyBsZWFkIHRvIHVwZGF0ZXMgaW4gdGhlIEhUTUwgd2l0aG91dFxyXG4gICAgICAgIC8vIG5lZWRpbmcgbXVjaCBwcm9ncmFtbWluZyBmb3IgZWFjaCBjaGFuZ2UuIDIvMyBvZiB0aGlzIGNsYXNzIGNvdWxkIGJlIHJlbW92ZWQgaWYgdXNpbmcgZGlmZmVyZW50IE9PLlxyXG5cclxuICAgICAgICAvKlxyXG4gIFx0aWYgKHNwZWMubm9fZXNjYXBlKSB7XHJcbiAgXHRcdHRoaXMuZW5zdXJlKCdfJyk7XHJcbiAgXHRcdHRoaXMuXy5ub19lc2NhcGUgPSBzcGVjLm5vX2VzY2FwZTtcclxuICBcdH1cclxuICBcdCovXHJcbiAgICAgICAgLy9jdHJsX2luaXRfY2FsbCh0aGlzLCBzcGVjKTtcclxuXHJcbiAgICAgICAgLy90aGlzLl9zdXBlcihzcGVjKTtcclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBzcGVjLnRleHQgIT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgdGhpcy5fLnRleHQgPSBzcGVjLnRleHQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL3RoaXMudHlwZU5hbWUgPSBwci50eXBlTmFtZTtcclxuICAgICAgICAvL3RoaXMudGFnTmFtZSA9ICdwJztcclxuXHJcbiAgICB9LFxyXG4gICAgLy8gd2lsbCB1c2UgYSBuby1lc2NhcGUgcHJvcGVydHkuXHJcbiAgICAvKlxyXG4gICdub19lc2NhcGUnOiBmcChmdW5jdGlvbihhLCBzaWcpIHtcclxuICBcdGlmIChhLmwgPT0gMCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5yZXQoJ18ubm9fZXNjYXBlJyk7XHJcbiAgXHR9XHJcbiAgXHRpZiAoYS5sID09IDEpIHtcclxuICBcdFx0dGhpcy5lbnN1cmUoJ18nKTtcclxuICBcdFx0dGhpcy5fLm5vX2VzY2FwZSA9IGFbMF07XHJcbiAgXHR9XHJcbiAgfSksXHJcbiAgKi9cclxuICAgICdhbGxfaHRtbF9yZW5kZXInOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gbmVlZCB0byBlc2NhcGUgdGhlIEhUTUwgaXQgb3V0cHV0cy5cclxuXHJcblxyXG5cclxuICAgICAgICAvL3ZhciB0ZXh0ID0gdGhpcy5fLnRleHQgfHwgJyc7XHJcbiAgICAgICAgdmFyIHRleHQgPSB0aGlzLmdldCgndGV4dCcpO1xyXG4gICAgICAgIC8vIFRoZXNlIGdldCBhbmQgc2V0IG9wZXJhdGlvbnMgc2hvdWxkIG5vdCByZWx5IG9uIHRoZSBwYWdlX2NvbnRleHQuXHJcblxyXG4gICAgICAgIC8vY29uc29sZS5sb2coJ3RleHQgJyArIHRleHQpO1xyXG5cclxuICAgICAgICB2YXIgbnggPSB0aGlzLmdldCgnbm9fZXNjYXBlJyk7XHJcblxyXG5cclxuICAgICAgICAvL2NvbnNvbGUubG9nKCdueCAnICsgbngpO1xyXG5cclxuICAgICAgICBpZiAobngpIHtcclxuICAgICAgICAgICAgcmVzID0gdGV4dCB8fCAnJztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCd0ZXh0JywgdGV4dCk7XHJcbiAgICAgICAgICAgIHJlcyA9IGVzY2FwZV9odG1sKHRleHQgfHwgJycpIHx8ICcnO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH1cclxuICAgIC8qLFxyXG5cclxuICAgIC8vIHdpbGwgaGF2ZSBhIHRleHQgcHJvcGVydHkuXHJcblxyXG4gICAgJ3RleHQnOiBmdW5jdGlvbih0ZXh0KSB7XHJcbiAgICBcdC8vIG5lZWQgdG8gdXBkYXRlIHRoZSB0ZXh0IGluIHRoZSBkb20uXHJcbiAgICBcdHRoaXMuXy50ZXh0ID0gdGV4dDtcclxuICAgIFx0Ly8gdXNlIGpRdWVyeSBmb3IgdGhpcz9cclxuICAgIFx0Ly8gb3IgRE9NP1xyXG4gICAgXHQvLyBub3Qgc3VyZSBqUXVlcnkgaGFuZGxlcyB0ZXh0IG5vZGVzIGRpcmVjdGx5IHNvIHdlbGwuXHJcblxyXG4gICAgXHQvLyBpcyB0aGVyZSB0aGlzLiQ/XHJcblxyXG4gICAgXHQvLyBkbyB0aGVzZSB0ZXh0IG5vZGVzIGdldCByZWNyZWF0ZWQ/XHJcbiAgICBcdC8vICB0aGV5IGNhbid0IGhhdmUgdGhlIGpzZ3VpIGV4cGFuZG8gbGlrZSBlbGVtZW50cy5cclxuXHJcbiAgICBcdC8vIGNhbiBub3Qgc28gZWFzaWx5IGdldCB0aGlzIHRleHQgbm9kZSBhY3RpdmF0ZWQgb24gdGhlIGNsaWVudC5cclxuXHJcbiAgICBcdC8vICB3aGF0IGFib3V0IHRoZSBhYmlsaXR5IHRvIGdldCAvIGlkZW50aWZ5IHRleHQgbm9kZXMgZnJvbSB0aGVpciBwYXJlbnQ/XHJcbiAgICBcdC8vICBzbyB0aGF0IGEgcGFyZW50IGNvdWxkIGJlIHRvbGQgd2hhdCBhY3RpdmUgdGV4dCBub2RlIGl0IGNvbnRhaW5zLlxyXG5cclxuICAgIFx0Ly8gY2FuIHRlbGwgYSBzcGFuIGNvbnRyb2wgdG8gY2hhbmdlIHRoZSB0ZXh0IGl0IGNvbnRhaW5zLlxyXG5cclxuICAgIFx0Ly8udGV4dF9ub2RlcygwKS50ZXh0Li4uXHJcbiAgICBcdC8vICBoYXZpbmcgYSBjdHJsIGtlZXAgdHJhY2sgb2YgYW55IHRleHQgbm9kZXMgaW5zaWRlIHRoZW1cclxuICAgIFx0Ly8gICBtb2RlbGxpbmcgdGhlbSwgaGF2aW5nIGNvbnRyb2xzLlxyXG4gICAgXHQvLyAgIGhvd2V2ZXIsIGRvbid0IHdhbnQgbG90cyBvZiBjb21wbGljYXRpb25zLlxyXG5cclxuXHJcblxyXG4gICAgXHQvLyBqdXN0IGlubmVySFRNTD9cclxuXHJcbiAgICB9XHJcbiAgICAqL1xyXG59KTtcclxuXHJcblxyXG5cclxuLy8gQW5kIHRoZXJlIGlzIHNvbWUgY2xpZW50IGNvZGUgdGhhdCBsb2FkcyB0aGUgbmVjZXNzYXJ5IGpzZ3VpIHRvb2xzIGFuZCB0aGVuIGFjdGl2YXRlcyBhbGwgdGhlIGNvbnRyb2xzIGluIHRoZSBET00uXHJcbi8vICBXaWxsIGRvIGEgRE9NIHRyYXZlcnNlLCBleGNlcHQgc3RhcnQgd2l0aCB0aGUgZGVlcGVzdCBuZXN0ZWQgZWxlbWVudHMuXHJcbi8vICAgVGhlbiBpdCB3aWxsIGJlIGFibGUgdG8gZmluZCBjb250cm9scyBpbnNpZGUgY29udHJvbHMuXHJcbi8vICAgQSBsb3Qgb2YgZWxlbWVudHMgd2lsbCBoYXZlIEpTR1VJIElEcy5cclxuLy8gICAgQnV0IHNvbWUgdGhpbmdzIGNvdWxkIGJlIGluZmVycmVkIHRvIGJlIGNvbnRyb2xzIGJlY2F1c2UgdGhleSBmb2xsb3cgYSBwYXR0ZXJuLlxyXG5cclxuXHJcbi8vIFBhZ2VfQ29udGV4dCBuZWVkcyBhIG5ld19pZCBtZXRob2QuXHJcblxyXG5cclxuLy8gSSB0aGluayBzb21lIG9mIHRoaXMgc2hvdWxkIGJlIGluIENsaWVudF9QYWdlX0NvbnRleHRcclxuLy8gIFBlcmhhcHMgUGFnZV9Db250ZXh0IGluIGl0cyBvd24gbW9kdWxlLlxyXG5cclxuLy8gU2hvdWxkIHRoaXMgb25seSBiZSBpbiBlbmhhbmNlZD9cclxuLy8gIFNvIGl0IGNyZWF0ZXMgZW5oYW5jZWQgY29udHJvbHM/XHJcbi8vICAgV2lsbCB0aGF0IGJlIE9LIGZvciB0aGUgc2VydmVyIHBhZ2UgY29udGV4dD9cclxuXHJcblxyXG4vLyBNYXliZSBzaG91bGQgbm90IG5lZWQgdG8gZ2V0IGJyb3dzZXIgaW5mbyB5ZXQ/IEtlZXAgaXQgZ2VuZXJhbD8/P1xyXG4vLyBQZXJoYXBzIHRoZXJlIHdpbGwgYmUgaHRtbC1jbGllbnQuXHJcbi8vICBXaWxsIGhhdmUgdGhlIGN0cmxzX2J5X2lkPyBUaGUgcGFnZV9jb250ZXh0LlxyXG4vLyBBY3RpdmF0aW5nIGV4aXN0aW5nIERPTSBub2RlcyBpcyBlYXN5IGVub3VnaCB3aXRob3V0IHRoaXMgYWN0aXZhdGlvbiBzeXN0ZW0gLSBqdXN0IG5lZWRzIGNvZGUgdG8gZG8gaXQuXHJcbi8vICBCdXQgaGF2aW5nIHRoZSBub2RlcyBjcmVhdGVkIG9uIHRoZSBzZXJ2ZXIsIHRoZW4gc2VudCB0byB0aGUgY2xpZW50IC0gcmVxdWlyZXMgdGhlIEpTR1VJIElEcyBvciBvdGhlciByZWNvbnN0cnVjdGlvbiBjb2RlLlxyXG4vLyBUaGlzIGRvZXMgc2VlbSBhbG1vc3QgZG9uZSBmb3IgbWFueSB1c2VzIC0gd2FudCB0byBwb2xpc2ggaXQgdGhvdWdoLlxyXG4vLyBXYW50IHRvIG1ha2UgYSBibG9nIHNpdGUgZmFpcmx5IHNvb24uXHJcblxyXG4vLyBBbHNvIGEgc3lzdGVtIGZvciBkaXNwbGF5aW5nIGNvbnRlbnQgYW5kIHByb2dyYW1taW5nIHNuaXBwZXRzLlxyXG4vLyBNdWNoIG9mIGl0IHdvdWxkIGJlIHNlcnZlciBzaWRlLCBub3QgbmVlZGluZyBjbGllbnQgc2lkZSBhY3RpdmF0aW9uLlxyXG4vLyAgTG9naW4gY291bGQgdXNlIGl0IGZvciBlbmhhbmNlbWVudC5cclxuXHJcbi8vIENhbiBzZXQgdGhlIGRhdGFfb2JqZWN0IGNvbnN0cnVjdG9yIGZvciBib29sZWFuLi4uXHJcbi8vICBhbmQgaXQgaXMgYSBEYXRhX1ZhbHVlLlxyXG5cclxuLy8gU2VlbXMgbGlrZSBpdCBzaG91bGQgYmUgd2l0aGluIGEgY2xpZW50IHNpZGUgcGFnZSBjb250ZXh0LlxyXG5cclxuLy8gRG8gdGhpcyB3aXRoaW4gdGhlIFBhZ2VfQ29udGV4dC5cclxuLypcclxudmFyIG1hcF9jb250cm9sc19ieV90eXBlID0ge307XHJcblxyXG5cclxudmFyIHVwZGF0ZV9jdHJsX2xvb2t1cCA9IGZwKGZ1bmN0aW9uKGEsIHNpZykge1xyXG4gICAgY29uc29sZS5sb2coJ3VwZGF0ZV9jdHJsX2xvb2t1cCBzaWcgJyArIHNpZyk7XHJcbiAgICB2YXIgTW9kdWxlO1xyXG4gICAgaWYgKGEubCA9PSAxKSB7XHJcbiAgICAgICAgTW9kdWxlID0gYVswXTtcclxuICAgICAgICBlYWNoKE1vZHVsZSwgZnVuY3Rpb24oY3RybF9uYW1lLCBDdHJsKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdjdHJsX25hbWUgJyArIGN0cmxfbmFtZSk7XHJcbiAgICAgICAgICAgIHZhciBsTmFtZSA9IGN0cmxfbmFtZS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICBtYXBfY29udHJvbHNfYnlfdHlwZVtsTmFtZV0gPSBDdHJsO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnKiogbWFwX2NvbnRyb2xzX2J5X3R5cGUgJyArIEpTT04uc3RyaW5naWZ5KG1hcF9jb250cm9sc19ieV90eXBlKSk7XHJcbiAgICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICBpZiAoc2lnID09ICdbcyxmXScpIHtcclxuICAgICAgICB2YXIgbmFtZSA9IGFbMF07XHJcbiAgICAgICAgdmFyIEN0cmwgPSBhWzFdO1xyXG4gICAgICAgIG1hcF9jb250cm9sc19ieV90eXBlW25hbWVdID0gQ3RybDtcclxuICAgIH1cclxuICAgIGNvbnNvbGUubG9nKCcqIG1hcF9jb250cm9sc19ieV90eXBlICcgKyBKU09OLnN0cmluZ2lmeShtYXBfY29udHJvbHNfYnlfdHlwZSkpO1xyXG5cclxufSk7XHJcbiovXHJcblxyXG5cclxuLy8gTWF5YmUgdGhlIGpzZ3VpIHBhZ2UgY29udGV4dCB3aWxsIGJlIHRoZSBrZXkgdG8gZ2V0dGluZyB0aGlzIHJ1bm5pbmcgb24gdGhlIGNsaWVudC5cclxuLy8gIENvdWxkIHBhY2thZ2Ugc29tZSB0aGluZ3MgYXMganF1ZXJ5IHBsdWdpbnMuIE1heWJlIGhhdmUgYSBzdGFuZGFsb25lIGJ1aWxkIG9mIGpzZ3VpLlxyXG5cclxuXHJcblxyXG4vLyBQZXJoYXBzIGl0IHdpbGwgYmUgY29udGV4dC5hY3RpdmF0ZT9cclxuXHJcblxyXG4vLyBjb250ZXh0LmFjdGl2YXRlP1xyXG4vLyAgdGhhdCBtYXkgd29yayBiZXR0ZXIuXHJcblxyXG4vLyBOZWVkIG1vcmUgZ2VuZXJhbGlzZWQgcmVjdXJzaXZlIGRvbSBhY3RpdmF0aW9uLlxyXG4vLyAgV2hlbiBhY3RpdmF0aW5nIGEgY29udHJvbCByZWN1cnNpdmVseSwgbmVlZCB0byBnbyB0aHJvdWdoIGFsbCBvZiB0aGUgc3ViLWVsZW1lbnRzXHJcbi8vICAgYWN0aXZhdGUgdGhlbSBmcm9tIHRoZSBpbnNpZGUuXHJcblxyXG5cclxuXHJcbnZhciBzaGFsbG93X2NvcHkgPSBmcChmdW5jdGlvbihhLCBzaWcpIHtcclxuICAgIGlmIChzaWcgPT0gJ1thXScpIHtcclxuICAgICAgICB2YXIgYXJyX2N0cmxzID0gYVswXTtcclxuXHJcbiAgICAgICAgdmFyIHJlcyA9IFtdO1xyXG4gICAgICAgIGVhY2goYXJyX2N0cmxzLCBmdW5jdGlvbihpLCB2KSB7XHJcbiAgICAgICAgICAgIHJlcy5wdXNoKHYuc2hhbGxvd19jb3B5KCkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9XHJcbn0pO1xyXG5cclxudmFyIGNvbnN0cnVjdG9yX2Zyb21fdHlwZSA9IGZ1bmN0aW9uKHR5cGUpIHtcclxuICAgIGNvbnNvbGUubG9nKCdjb25zdHJ1Y3Rvcl9mcm9tX3R5cGUgdHlwZSAnICsgdHlwZSk7XHJcbiAgICBjb25zb2xlLmxvZygnbWFwX2NvbnRyb2xzX2J5X3R5cGUgJyArIHN0cmluZ2lmeShtYXBfY29udHJvbHNfYnlfdHlwZSkpO1xyXG59XHJcbi8vXHJcblxyXG5qc2d1aSA9IGpzZ3VpLmV4dGVuZChqc2d1aSwge1xyXG4gICAgJ2dldF9pbmxpbmVfY3NzX2RpY3RfZnJvbV9zdHlsZSc6IGdldF9pbmxpbmVfY3NzX2RpY3RfZnJvbV9zdHlsZSxcclxuICAgICdhcHBseV9qc2d1aV9zdHlsZV9ydWxlX3RvX2Nzc19zdHlsZSc6IGFwcGx5X2pzZ3VpX3N0eWxlX3J1bGVfdG9fY3NzX3N0eWxlLFxyXG4gICAgJ3N0eWxlc19kaWN0X3RvX3N0cmluZyc6IHN0eWxlc19kaWN0X3RvX3N0cmluZyxcclxuICAgICdDb250cm9sJzogQ29udHJvbCxcclxuICAgIC8vJ1BhZ2VfQ29udGV4dCc6IFBhZ2VfQ29udGV4dCxcclxuICAgIC8vJ0JsYW5rX0hUTUxfRG9jdW1lbnQnOiBCbGFua19IVE1MX0RvY3VtZW50LFxyXG4gICAgLy8nQ2xpZW50X0hUTUxfRG9jdW1lbnQnOiBDbGllbnRfSFRNTF9Eb2N1bWVudCxcclxuICAgIC8vJ3JlY3Vyc2l2ZV9kb21faXRlcmF0ZSc6IHJlY3Vyc2l2ZV9kb21faXRlcmF0ZSxcclxuICAgICdtYXBfQ29udHJvbHMnOiBtYXBfQ29udHJvbHMsXHJcbiAgICAvLyd1cGRhdGVfY3RybF9sb29rdXAnOiB1cGRhdGVfY3RybF9sb29rdXAsXHJcbiAgICAvLydhY3RpdmF0ZSc6IGFjdGl2YXRlLFxyXG4gICAgJ3NoYWxsb3dfY29weSc6IHNoYWxsb3dfY29weVxyXG4gICAgLy8nY29uc3RydWN0b3JfZnJvbV90eXBlJzogY29uc3RydWN0b3JfZnJvbV90eXBlLFxyXG4gICAgLy8nbWFwX2NvbnRyb2xzX2J5X3R5cGUnOiBtYXBfY29udHJvbHNfYnlfdHlwZVxyXG59KTtcclxuLy9hbGVydCgnMiAnICsganNndWkpO1xyXG4vL3JldHVybiBqc2d1aTtcclxubW9kdWxlLmV4cG9ydHMgPSBqc2d1aTtcclxuIiwiLy9pZiAodHlwZW9mIGRlZmluZSAhPT0gJ2Z1bmN0aW9uJykge1xyXG4vLyAgICB2YXIgZGVmaW5lID0gcmVxdWlyZSgnYW1kZWZpbmUnKShtb2R1bGUpO1xyXG4vL307XHJcblxyXG4vLyBOZWVkcyBhIGdlbmVyYWwgUGFnZV9Db250ZXh0XHJcblxyXG4vLyBzbyBlbmggaW5jbHVkZXMgdGhlIHBhZ2VfY29udGV4dD9cclxuXHJcbi8vIFJlYWxseSBub3Qgc3VyZSBhYm91dCB3aGVyZSBpbiB0aGUgaGVpcmFjaHkgdGhlIFBhZ2VfQ29udGV4dCBpcy4gTWFueSBjb250cm9scyBuZWVkIGl0LlxyXG5cclxuLy8gTWF5IGJlIGVhc2llciBpZiB0aGVzZSBlbmhhbmNlbWVudHMgZGlkIGF3YXkgd2l0aCB0aGUgcGFnZSBjb250ZXh0LiBNYXkgbmVlZCB0byB3b3JrIG9uIHRoZSBzZXJ2ZXIgdG9vLlxyXG5cclxuLy8gSG93ZXZlciwgdGhpcyBJIHRoaW5rIHdhcyBpbnRlbmRlZCBvbmx5IGZvciB0aGUgY2xpZW50IGFueXdheS5cclxuXHJcbi8vIEhhbmRsZSBjaXJjdWxhciBkZXBlbmRlbmNpZXMuLi5cclxuXHJcblxyXG52YXIganNndWkgPSByZXF1aXJlKCcuL2pzZ3VpLWh0bWwtY29yZScpO1xyXG5cclxuLy8gZG9uJ3QgdGhpbmsgdGhpcyBjYW4gaGF2ZSBjb250ZXh0IG1lbnUgc28gZWFzaWx5IGhlcmUuXHJcbi8vdmFyIENvbnRleHRfTWVudSA9IHJlcXVpcmUoJy4vY29udHJvbHMvYWR2YW5jZWQvY29udGV4dC1tZW51Jyk7XHJcblxyXG52YXIgc3RyaW5naWZ5ID0ganNndWkuc3RyaW5naWZ5LCBlYWNoID0ganNndWkuZWFjLCB0b2YgPSBqc2d1aS50b2YsIGlzX2RlZmluZWQgPSBqc2d1aS5pc19kZWZpbmVkO1xyXG52YXIgQ29udHJvbCA9IGpzZ3VpLkNvbnRyb2w7XHJcbnZhciBTZWxlY3Rpb25fU2NvcGUgPSByZXF1aXJlKCcuL3NlbGVjdGlvbi1zY29wZScpO1xyXG52YXIgZnAgPSBqc2d1aS5mcDtcclxudmFyIGdyb3VwID0ganNndWkuZ3JvdXA7XHJcbnZhciBzdHJfYXJyX21hcGlmeSA9IGpzZ3VpLnN0cl9hcnJfbWFwaWZ5O1xyXG52YXIgbWFwX0NvbnRyb2xzID0ganNndWkubWFwX0NvbnRyb2xzO1xyXG52YXIgZXh0ZW5kID0ganNndWkuZXh0ZW5kO1xyXG52YXIgaXNfY3RybCA9IGpzZ3VpLmlzX2N0cmw7XHJcblxyXG4vL3ZhciBDb250ZXh0X01lbnU7XHJcblxyXG4vLyBEb24ndCBpbmNsdWRlIGNvbnRleHQtbWVudSBpbiBlbmguLi5cclxuLy8gIE9yIGZpbmQgYSBkaWZmZXJlbnQgd2F5IHRvIGluY2x1ZGUgaXRcclxuLy8gIEhhdmUgZGlmZmVyZW50IGVuaC1sZXZlbHMsIGVnIG1vc3Qgb2YgaXQgaXMgZW5oLTFcclxuLy8gIHRoZW4gY29udGV4dC1tZW51IGlzIGluIGVuaC0yLlxyXG4vLyAgaHRtbC1lbmggY29udGFpbnMgYm90aCAxIGFuZCAyLCBhbmQgZnV0dXJlIGxldmVscyBpZiB0aGV5IGFyZSBtYWRlLlxyXG5cclxuXHJcbi8vIERvbid0IGxpa2Ugd2hhdCBmb2xsb3dzIC0gaXQncyB0cmlja3kuIE1heSBtYWtlIGl0IGhhcmQgdG8gcmVjb21waWxlIC8gYnVpbGQgdGhlIGNvZGUuXHJcbi8vICBBbmQgd291bGQgYmUgdW5uZWNlc3Nhcnkgd2hlbiB0aGUgY29udGV4dCBtZW51IGhhcyBiZWVuIGxvY2FsaXNlZC5cclxuXHJcblxyXG52YXIgaG92ZXJfY2xhc3MgPSBmcChmdW5jdGlvbihhLCBzaWcpIHtcclxuICAgIC8vY29uc29sZS5sb2coJ2hvdmVyX2NsYXNzIHNpZyAnICsgc2lnKTtcclxuICAgIGlmIChzaWcgPT0gJ1tjLHNdJykge1xyXG4gICAgICAgIHZhciBjdHJsID0gYVswXTtcclxuICAgICAgICB2YXIgaG92ZXJfY2xhc3MgPSBhWzFdO1xyXG4gICAgICAgIGN0cmwuaG92ZXIoZnVuY3Rpb24oZV9pbikge1xyXG4gICAgICAgICAgICBjdHJsLmFkZF9jbGFzcyhob3Zlcl9jbGFzcyk7XHJcbiAgICAgICAgfSwgZnVuY3Rpb24oZV9vdXQpIHtcclxuICAgICAgICAgICAgY3RybC5yZW1vdmVfY2xhc3MoaG92ZXJfY2xhc3MpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59KTtcclxuXHJcbi8vIHRoaXMgaXMgdGhlIGVuaGFuY2VkIEhUTUwgbW9kdWxlLlxyXG5cclxudmFyIGdyb3VwX2hvdmVyX2NsYXNzID0gZnAoZnVuY3Rpb24oYSwgc2lnKSB7XHJcbiAgICAvLyBDb3VsZCBwb3NzaWJseSByZWNhdGVnb3Jpc2UgaW50byBoYXZpbmcgYW4gYXJyYXkgaWYgdGhlIHNpZyBhcyBhIGJ1bmNoIG9mIG9iamVjdHMgb2Ygb25lIHR5cGUgYW5kIHRoZW5cclxuICAgIC8vICBhIHN0cmluZy5cclxuXHJcbiAgICAvL3BvbHkyKGEsIHNpZyk7XHJcblxyXG4gICAgaWYgKHNpZyA9PSAnW2Esc10nKSB7XHJcbiAgICAgICAgLy8gQW4gYXJyYXkgb2YgaXRlbXMgdG8gcHV0IGludG8gdGhlIGdyb3VwLlxyXG5cclxuICAgICAgICB2YXIgcmVzID0gZ3JvdXAoYVswXSk7XHJcbiAgICAgICAgLy9jb25zb2xlLmxvZygncmVzICcgKyB0b2YocmVzKSk7XHJcblxyXG4gICAgICAgIHZhciBob3Zlcl9jbGFzcyA9IGFbMV07XHJcbiAgICAgICAgcmVzLmhvdmVyKGZ1bmN0aW9uKGVfaW4pIHtcclxuICAgICAgICAgICAgcmVzLmFkZF9jbGFzcyhob3Zlcl9jbGFzcyk7XHJcbiAgICAgICAgfSwgZnVuY3Rpb24oZV9vdXQpIHtcclxuICAgICAgICAgICAgcmVzLnJlbW92ZV9jbGFzcyhob3Zlcl9jbGFzcyk7XHJcbiAgICAgICAgfSlcclxuXHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH1cclxuXHJcbn0pO1xyXG5cclxuXHJcbnZhciBnZXRfd2luZG93X3NpemUgPSBmdW5jdGlvbigpIHtcclxuICAgIHZhciB3aW5XLCB3aW5IO1xyXG4gICAgaWYgKGRvY3VtZW50LmJvZHkgJiYgZG9jdW1lbnQuYm9keS5vZmZzZXRXaWR0aCkge1xyXG4gICAgICAgIHdpblcgPSBkb2N1bWVudC5ib2R5Lm9mZnNldFdpZHRoO1xyXG4gICAgICAgIHdpbkggPSBkb2N1bWVudC5ib2R5Lm9mZnNldEhlaWdodDtcclxuICAgIH1cclxuICAgIGlmIChkb2N1bWVudC5jb21wYXRNb2RlPT0nQ1NTMUNvbXBhdCcgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5vZmZzZXRXaWR0aCApIHtcclxuICAgICAgICB3aW5XID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50Lm9mZnNldFdpZHRoO1xyXG4gICAgICAgIHdpbkggPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQub2Zmc2V0SGVpZ2h0O1xyXG4gICAgfVxyXG4gICAgaWYgKHdpbmRvdy5pbm5lcldpZHRoICYmIHdpbmRvdy5pbm5lckhlaWdodCkge1xyXG4gICAgICAgIHdpblcgPSB3aW5kb3cuaW5uZXJXaWR0aDtcclxuICAgICAgICB3aW5IID0gd2luZG93LmlubmVySGVpZ2h0O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFt3aW5XLCB3aW5IXTtcclxufVxyXG5cclxuXHJcbnZhciBmaW5kUG9zID0gZnVuY3Rpb24ob2JqKSB7XHJcbiAgICB2YXIgY3VybGVmdCA9IGN1cnRvcCA9IDA7XHJcbiAgICBpZiAob2JqLm9mZnNldFBhcmVudCkge1xyXG4gICAgICAgIGRvIHtcclxuICAgICAgICAgICAgY3VybGVmdCArPSBvYmoub2Zmc2V0TGVmdDtcclxuICAgICAgICAgICAgY3VydG9wICs9IG9iai5vZmZzZXRUb3A7XHJcbiAgICAgICAgfSB3aGlsZSAob2JqID0gb2JqLm9mZnNldFBhcmVudCk7XHJcbiAgICAgICAgcmV0dXJuIFtjdXJsZWZ0LGN1cnRvcF07XHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG5cclxuXHJcbi8vIFNlbGVjdGlvbl9TY29wZSBzaG91bGQgcG9zc2libHkgYmUgaW4gaXRzIG93biBtb2R1bGUuXHJcbi8vICBJdCB3aWxsIGJlIHVzZWQgYnkgY2xpZW50LXBhZ2UtY29udGV4dCBhcyB3ZWxsLlxyXG5cclxuXHJcblxyXG5cclxuLy8gU29tZSBvZiB0aGVzZSB3aWxsIG5lZWQgdG8gZ2V0IGEgYml0IG1vcmUgY29tcGxleCB3aXRoIG9wdGlvbnMsIGJ1dCB0aGV5IHdpbGwgYWxzbyBnZW5lcmFsbHkgYmUgdHJhbnNmZXJyYWJsZSBhbW9uZyBqc2d1aSBjb250cm9scy5cclxuXHJcbi8vIFRoZSBvdXRlcm1vc3Qgb2JqZWN0IHdpbGwgaGF2ZSBzZWxlY3Rpb24gc2NvcGVcclxuLy8gIFRoYXQgbWVhbnMgdGhhdCB3aXRoaW4gaXQgd2hlbiB0aGVyZSBpcyBhIGRlc2VsZWN0X2FsbCBjb21tYW5kIGl0IGRlc2VsZWN0cyB3aXRoaW4gdGhhdCBzY29wZS5cclxuXHJcbi8vIFdlIGNvdWxkIGhhdmUgYW4gZW5oYW5jZWQgY29udHJvbCB0b28uXHJcblxyXG4vLyBQZXJoYXBzIHJlcGxhY2UgdGhlIGJhc2ljIGNvbnRyb2wgaW4gdGhpcyBjYXNlLCBzbyBhbiB1cGdyYWRlZCBjb250cm9sIGlzIGFsd2F5cyB1c2VkLlxyXG4vLyAgV291bGQgaGF2ZSBtb3JlIGZ1bmN0aW9uYWxpdHkgdG8gZG8gd2l0aCB3aW5kb3dzLCBzZXR0aW5nIHVwIGEgY29udHJvbCBzbyB0aGF0IGl0J3MgYSB3aW5kb3csIHdpdGggZG9ja2luZyBjYXBhYmlsaXR5LlxyXG5cclxuLy8gUGVyaGFwcyBtb3JlIGNsaWVudC1zaWRlIGNhcGFiaWxpdGllcyBzaG91bGQgYmUgaGVyZSwgbGlrZSBhY3RpdmF0ZS5cclxuXHJcbnZhciBtYXBEb21FdmVudE5hbWVzID0ge1xyXG4gICAgJ2NoYW5nZSc6IHRydWUsXHJcblxyXG4gICAgJ2NsaWNrJzogdHJ1ZSxcclxuICAgICdtb3VzZWRvd24nOiB0cnVlLFxyXG4gICAgJ21vdXNldXAnOiB0cnVlLFxyXG4gICAgJ21vdXNlbW92ZSc6IHRydWUsXHJcbiAgICAnbW91c2VvdmVyJzogdHJ1ZSxcclxuICAgICdtb3VzZW91dCc6IHRydWUsXHJcbiAgICAnYmx1cic6IHRydWUsXHJcbiAgICAnZm9jdXMnOiB0cnVlLFxyXG4gICAgJ2tleWRvd24nOiB0cnVlLFxyXG4gICAgJ2tleXVwJzogdHJ1ZSxcclxuICAgICdrZXlwcmVzcyc6IHRydWUsXHJcbiAgICAnY29udGV4dG1lbnUnOiB0cnVlLFxyXG5cclxuICAgICd0b3VjaHN0YXJ0JzogdHJ1ZSxcclxuICAgICd0b3VjaG1vdmUnOiB0cnVlLFxyXG4gICAgJ3RvdWNoZW5kJzogdHJ1ZSxcclxuXHJcbiAgICAnYWJvcnQnOiB0cnVlLFxyXG4gICAgJ2NhbnBsYXknOiB0cnVlLFxyXG4gICAgJ2NhbnBsYXl0aHJvdWdoJzogdHJ1ZSxcclxuICAgICdkdXJhdGlvbmNoYW5nZSc6IHRydWUsXHJcbiAgICAnZW1wdGllZCc6IHRydWUsXHJcbiAgICAnZW5kZWQnOiB0cnVlLFxyXG4gICAgJ2Vycm9yJzogdHJ1ZSxcclxuICAgICdsb2FkZWRkYXRhJzogdHJ1ZSxcclxuICAgICdsb2FkZWRtZXRhZGF0YSc6IHRydWUsXHJcbiAgICAnbG9hZHN0YXJ0JzogdHJ1ZSxcclxuICAgICdwYXVzZSc6IHRydWUsXHJcbiAgICAncGxheSc6IHRydWUsXHJcbiAgICAncGxheWluZyc6IHRydWUsXHJcbiAgICAncHJvZ3Jlc3MnOiB0cnVlLFxyXG4gICAgJ3JhdGVjaGFuZ2UnOiB0cnVlLFxyXG4gICAgJ3NlZWtlZCc6IHRydWUsXHJcbiAgICAnc2Vla2luZyc6IHRydWUsXHJcbiAgICAnc3RhbGxlZCc6IHRydWUsXHJcbiAgICAnc3VzcGVuZCc6IHRydWUsXHJcbiAgICAndGltZXVwZGF0ZSc6IHRydWUsXHJcbiAgICAndm9sdW1lY2hhbmdlJzogdHJ1ZSxcclxuICAgICd3YWl0aW5nJzogdHJ1ZVxyXG5cclxufTtcclxuXHJcblxyXG4vL3ZhciB0X2NvbnRlbnQ7XHJcbnZhciBkZXNjID0gZnVuY3Rpb24oY3RybCwgY2FsbGJhY2spIHtcclxuICBpZiAoY3RybC5nZXQpIHtcclxuXHJcblxyXG4gICAgdmFyIGNvbnRlbnQgPSBjdHJsLmdldCgnY29udGVudCcpO1xyXG4gICAgLy9jb25zb2xlLmxvZygnY29udGVudCcsIGNvbnRlbnQpO1xyXG4gICAgdmFyIHRfY29udGVudCA9IHR5cGVvZiBjb250ZW50O1xyXG4gICAgLy9jb25zb2xlLmxvZygndF9jb250ZW50JywgdF9jb250ZW50KTtcclxuXHJcbiAgICBpZiAodF9jb250ZW50ID09PSAnc3RyaW5nJyB8fCB0X2NvbnRlbnQgPT09ICdudW1iZXInKSB7XHJcblxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gaXQncyBhIENvbGxlY3Rpb25cclxuXHJcbiAgICAgIHZhciBhcnIgPSBjb250ZW50Ll9hcnI7XHJcbiAgICAgIHZhciBjLCBsID0gYXJyLmxlbmd0aDtcclxuXHJcbiAgICAgIC8vY29uc29sZS5sb2coJ2wnLCBsKTtcclxuICAgICAgdmFyIGl0ZW0sIHRfaXRlbTtcclxuXHJcbiAgICAgIGZvciAoYyA9IDA7IGMgPCBsOyBjKyspIHtcclxuICAgICAgICBpdGVtID0gYXJyW2NdO1xyXG4gICAgICAgIHRfaXRlbSA9IHR5cGVvZiBpdGVtO1xyXG4gICAgICAgIGlmICh0X2l0ZW0gPT09ICdzdHJpbmcnIHx8IHRfaXRlbSA9PT0gJ251bWJlcnMnKSB7XHJcblxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBjYWxsYmFjayhhcnJbY10pO1xyXG4gICAgICAgICAgZGVzYyhhcnJbY10sIGNhbGxiYWNrKTtcclxuICAgICAgICB9XHJcblxyXG5cclxuXHJcbiAgICAgIH1cclxuXHJcblxyXG5cclxuXHJcbiAgICB9XHJcblxyXG5cclxuICAgICAgLypcclxuICAgICAgdmFyIGNvbnRlbnQgPSBjdHJsLmdldCgnY29udGVudCcpO1xyXG4gICAgICBjb25zb2xlLmxvZygnY29udGVudCcsIGNvbnRlbnQpO1xyXG4gICAgICBlYWNoKGNvbnRlbnQsIGZ1bmN0aW9uKHYsIGkpIHtcclxuICAgICAgICAgIGlmICh0eXBlb2YgaSAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICBjYWxsYmFjayh2KTtcclxuICAgICAgICAgICAgICBkZXNjKHYsIGNhbGxiYWNrKTtcclxuICAgICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICAgICovXHJcblxyXG4gIH1cclxufVxyXG5cclxudmFyIGRvbV9kZXNjID0gZnVuY3Rpb24oZWwsIGNhbGxiYWNrKSB7XHJcbiAgLy8gUG9zc2libHkgbmVlZCB0byBsb29rIGF0IHRoZSBlbGVtZW50J3Mgbm9kZSB0eXBlLlxyXG5cclxuICAvL1xyXG4gIGNhbGxiYWNrKGVsKTtcclxuXHJcbiAgdmFyIGNucyA9IGVsLmNoaWxkTm9kZXM7XHJcblxyXG4gIHZhciBsID0gY25zLmxlbmd0aDtcclxuXHJcbiAgZm9yICh2YXIgYyA9IDA7IGMgPCBsOyBjKyspIHtcclxuICAgIGRvbV9kZXNjKGNuc1tjXSwgY2FsbGJhY2spO1xyXG5cclxuICB9XHJcblxyXG5cclxufVxyXG5cclxuXHJcbkNvbnRyb2wgPSBqc2d1aS5Db250cm9sID0ganNndWkuQ29udHJvbC5leHRlbmQoe1xyXG4gICAgJ2ZpZWxkcyc6IHtcclxuICAgICAgICAnc2VsZWN0aW9uX3Njb3BlJzogT2JqZWN0LFxyXG4gICAgICAgICdpc19zZWxlY3RhYmxlJzogQm9vbGVhblxyXG4gICAgfSxcclxuXHJcbiAgICAnaW5pdCc6IGZ1bmN0aW9uKHNwZWMpIHtcclxuICAgICAgICAvLyBUaGUgZW5oYW5jZWQgY29udHJvbCBjYW4gbG9vayBhdCB0aGUgZWxlbWVudCBmb3IgZGF0YS1qc2d1aS1maWVsZHNcclxuICAgICAgICAvLyAgVGhvc2UgZmllbGRzIHdpbGwgYmUgZmVkIGJhY2sgaW50byB0aGUgaW5pdGlhbGl6YXRpb24uXHJcblxyXG5cclxuICAgICAgICBpZiAoc3BlYy5lbCkge1xyXG4gICAgICAgICAgdmFyIGpnZiA9IHNwZWMuZWwuZ2V0QXR0cmlidXRlKCdkYXRhLWpzZ3VpLWZpZWxkcycpO1xyXG5cclxuICAgICAgICAgIGlmIChqZ2YpIHtcclxuXHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3N0cl9jdHJsX2ZpZWxkcyAnICsgc3RyX2N0cmxfZmllbGRzKTtcclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnc3RyX3Byb3BlcnRpZXMnLCBzdHJfcHJvcGVydGllcyk7XHJcbiAgICAgICAgICAgIC8vdmFyIHNfcHJlX3BhcnNlID0gc3RyX3Byb3BlcnRpZXMucmVwbGFjZSgvJy9nLCAnXCInKS5yZXBsYWNlKC/imaUvZywgJ1xcJycpLnJlcGxhY2UoL+KYui9nLCAnXCInKTtcclxuICAgICAgICAgICAgdmFyIHNfcHJlX3BhcnNlID0gamdmLnJlcGxhY2UoL1xcW0RCTF9RVFxcXS9nLCAnXCInKS5yZXBsYWNlKC9cXFtTTkdfUVRcXF0vZywgJ1xcJycpO1xyXG4gICAgICAgICAgICBzX3ByZV9wYXJzZSA9IHNfcHJlX3BhcnNlLnJlcGxhY2UoL1xcJy9nLCAnXCInKTtcclxuXHJcbiAgICAgICAgICAgIC8vIERCTF9RVFxyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdzX3ByZV9wYXJzZScsIHNfcHJlX3BhcnNlKTtcclxuXHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3NfcHJlX3BhcnNlJywgdG9mKHNfcHJlX3BhcnNlKSk7XHJcblxyXG4gICAgICAgICAgICB2YXIgcHJvcHMgPSBKU09OLnBhcnNlKHNfcHJlX3BhcnNlKTtcclxuXHJcbiAgICAgICAgICAgIGV4dGVuZChzcGVjLCBwcm9wcyk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIHRoaXMuX3N1cGVyKHNwZWMpO1xyXG5cclxuICAgICAgICAvLyBUaGVuIHRoZXJlIG1heSBiZSBhIHNlbGVjdGlvbiBzY29wZSBzcGVjaWZpZWQuXHJcbiAgICAgICAgLy8gIFRoZSBzZWxlY3Rpb24gc2NvcGUgbWF5IGhhdmUgYmVlbiBzcGVjaWZpZWQgYXMgYSBudW1iZXJcclxuXHJcbiAgICAgICAgLy9jb25zb2xlLmxvZygnc3BlYy5zZWxlY3Rpb25fc2NvcGUnLCBzcGVjLnNlbGVjdGlvbl9zY29wZSk7XHJcblxyXG4gICAgICAgIGNvbnNvbGUubG9nKCdzcGVjLnNlbGVjdGlvbl9zY29wZScsIHNwZWMuc2VsZWN0aW9uX3Njb3BlKTtcclxuXHJcblxyXG4gICAgICAgIGlmICh0eXBlb2Ygc3BlYy5zZWxlY3Rpb25fc2NvcGUgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAvL2NvbnNvbGUubG9nKCdzcGVjLnNlbGVjdGlvbl9zY29wZScsIHNwZWMuc2VsZWN0aW9uX3Njb3BlKTtcclxuXHJcbiAgICAgICAgICB2YXIgc2VsZWN0aW9uX3Njb3BlID0gdGhpcy5fY29udGV4dC5nZXRfc2VsZWN0aW9uX3Njb3BlX2J5X2lkKHNwZWMuc2VsZWN0aW9uX3Njb3BlKTtcclxuICAgICAgICAgIC8vICBEbyB3ZSBuZWVkIHRvIHNldCB0aGUgY29udHJvbCBvZiB0aGUgc2VsZWN0aW9uIHNjb3BlP1xyXG5cclxuICAgICAgICAgIGNvbnNvbGUubG9nKCdzZWxlY3Rpb25fc2NvcGUnLCBzZWxlY3Rpb25fc2NvcGUpO1xyXG5cclxuXHJcbiAgICAgICAgICB0aGlzLnNldCgnc2VsZWN0aW9uX3Njb3BlJywgc2VsZWN0aW9uX3Njb3BlKTtcclxuXHJcbiAgICAgICAgICAvLyB0aGVuIGlmIHdlIGhhdmUgdGhlIHNlbGVjdGlvbiBzY29wZSwgd2Ugc2hvdWxkIHNldCBpdCB1cCBmb3IgdGhlIGNvbnRyb2wuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHNwZWMuaXNfc2VsZWN0YWJsZSkge1xyXG4gICAgICAgICAgdGhpcy5zZWxlY3RhYmxlKCk7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAnYmNyJzogZnAoZnVuY3Rpb24oYSwgc2lnKSB7XHJcbiAgICAgICAgLy9jb25zb2xlLmxvZygnc2lnJywgc2lnKTtcclxuICAgICAgICBpZiAoc2lnID09ICdbXScpIHtcclxuICAgICAgICAgICAgdmFyIGVsID0gdGhpcy5nZXQoJ2RvbS5lbCcpO1xyXG5cclxuXHJcbiAgICAgICAgICAgIHZhciBiY3IgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgICAgICAgICAgdmFyIHJlcyA9IFtbYmNyLmxlZnQsIGJjci50b3BdLCBbYmNyLnJpZ2h0LCBiY3IuYm90dG9tXSwgW2Jjci53aWR0aCwgYmNyLmhlaWdodF1dO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHJlcztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEhvd2V2ZXIsIG5lZWQgdG8gdGFrZSBhY2NvdW50IG9mIHRoZSBwYWRkaW5nIGFuZCB0aGUgY2xhc3MuXHJcblxyXG4gICAgICAgIC8vIGluc3RlYWQgb2YgZ2V0dGluZyB0aGUgYmNyLCB3ZSBjb3VsZCBnZSB0aGUgc3R5bGUoJ3dpZHRoJyk/XHJcbiAgICAgICAgLy8gIHdoaWNoIHdvdWxkIGFjdHVhbGx5IGdldCB0aGUgd2lkdGggc3R5bGUgdmFsdWU/XHJcblxyXG4gICAgICAgIC8vIE9yIHdlIGNvdWxkIGdldCB0aGUgYmNyLCBhbmQgdGhlbiBzdWJ0cmFjdCB0aGUgcGFkZGluZyBhcyB3ZWxsLlxyXG5cclxuICAgICAgICAvLyBjdHJsLnBhZGRpbmdcclxuICAgICAgICAvLyAgc2VlbXMgbGlrZSBhIHVzZWZ1bCBlbmhhbmNlbWVudCBzeW50YXggdG8gaGF2ZVxyXG4gICAgICAgIC8vICB3b3VsZCBiZSB1c2VmdWwgaW4ga2VlcGluZyB0aGluZ3MgaW4gcHJvcG9ydGlvbiBhbmQgYWNjb3VudGluZyBmb3IgdGhlIHBhZGRpbmcuXHJcblxyXG4gICAgICAgIC8vIFByb2JhYmx5IHdhbnQgdG8gYmUgZ2V0dGluZyB0aGUgY29tcHV0ZWQgc3R5bGUgZnJvbSB0aGUgYnJvd3Nlci5cclxuICAgICAgICAvLyAgU29tZSBpbmZvIGlzIHdpdGhpbiBDU1MgYW5kIGVmZmVjdHMgdGhpbmdzIHRocm91Z2ggdGhhdC5cclxuICAgICAgICAvLyAgU29tZXRpbWVzIGluIHRoZSBKUyB3ZSBuZWVkIHRvIHJlYWQgZnJvbSB0aGUgc2NyZWVuIGJlY2F1c2UgdmFsdWVzIGhhdmUgYmVlbiBjYWxjdWxhdGVkIGJ5IHRoZSBjc3Mgc3lzdGVtLlxyXG4gICAgICAgIC8vICBXYW50IHRoaXMgdG8gYmUgc29tZXdoYXQgcmVzcG9uc2l2ZSB0byB0aGUgQ1NTIHRoYXQgaXMgd3JpdHRlbi5cclxuXHJcbiAgICAgICAgaWYgKHNpZyA9PSAnW2FdJykge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnYmNyIHNpZyBhcnInKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBiY3JfZGVmID0gYVswXTtcclxuICAgICAgICAgICAgdmFyIHBvcyA9IGJjcl9kZWZbMF07XHJcbiAgICAgICAgICAgIHZhciBicl9wb3MgPSBiY3JfZGVmWzFdO1xyXG4gICAgICAgICAgICB2YXIgc2l6ZSA9IGJjcl9kZWZbMl07XHJcblxyXG4gICAgICAgICAgICAvLyB0aGVuIHdlIGFjdHVhbGx5IHdhbnQgdG8gc2V0IHRoZSBjc3MuXHJcblxyXG4gICAgICAgICAgICB0aGlzLnN0eWxlKHtcclxuICAgICAgICAgICAgICAgICdwb3NpdGlvbic6ICdhYnNvbHV0ZScsXHJcbiAgICAgICAgICAgICAgICAnbGVmdCc6IHBvc1swXSArICdweCcsXHJcbiAgICAgICAgICAgICAgICAndG9wJzogcG9zWzFdICsgJ3B4JyxcclxuICAgICAgICAgICAgICAgICd3aWR0aCc6IHNpemVbMF0gKyAncHgnLFxyXG4gICAgICAgICAgICAgICAgJ2hlaWdodCc6IHNpemVbMV0gKyAncHgnXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAvL3Rocm93ICdzdG9wJztcclxuICAgICAgICB9XHJcbiAgICB9KSxcclxuXHJcbiAgICAnY29tcHV0ZWRfc3R5bGUnOiBmcChmdW5jdGlvbihhLCBzaWcpIHtcclxuICAgICAgICBpZiAoc2lnID09ICdbc10nKSB7XHJcbiAgICAgICAgICAgIC8vIFNob3VsZCBvbmx5IHdvcmsgb24gdGhlIGNsaWVudC5cclxuICAgICAgICAgICAgdmFyIHByb3BlcnR5X25hbWUgPSBhWzBdO1xyXG4gICAgICAgICAgICB2YXIgeCA9IHRoaXMuZ2V0KCdkb20uZWwnKTtcclxuICAgICAgICAgICAgaWYgKHguY3VycmVudFN0eWxlKVxyXG4gICAgICAgICAgICAgICAgdmFyIHkgPSB4LmN1cnJlbnRTdHlsZVtzdHlsZVByb3BdO1xyXG4gICAgICAgICAgICBlbHNlIGlmICh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSlcclxuICAgICAgICAgICAgICAgIHZhciB5ID0gZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZSh4LG51bGwpLmdldFByb3BlcnR5VmFsdWUocHJvcGVydHlfbmFtZSk7XHJcbiAgICAgICAgICAgIHJldHVybiB5O1xyXG4gICAgICAgIH1cclxuICAgIH0pLFxyXG5cclxuICAgICdwYWRkaW5nJzogZnAoZnVuY3Rpb24oYSwgc2lnKSB7XHJcbiAgICAgICAgaWYgKHNpZyA9PSAnW10nKSB7XHJcbiAgICAgICAgICAgIC8vIHJlYWQgdGhlIHBhZGRpbmcuXHJcbiAgICAgICAgICAgIC8vICB0aGUgY29tcHV0ZWQgc3R5bGUgaXMgcHJvYmFibHkgd2hhdCB3ZSBhcmUgYWZ0ZXIuXHJcbiAgICAgICAgICAgIC8vIFBlcmhhcHMgYSBjb21wdXRlZF9zdHlsZSBmdW5jdGlvbiB3b3VsZCBoZWxwIHRvbywgbWFraW5nIHRoZSBjb2RlIGNsZWFyZXIgdGhhdCB0aGlzIHBhZGRpbmcgZnVuY3Rpb24gdXNlcyB0aGF0LlxyXG4gICAgICAgICAgICAvLyBQZXJoYXBzIGp1c3QgY2FsbGluZyAnc3R5bGUnIHNob3VsZCBnZXQgdGhlIGNvbXB1dGVkIHN0eWxlIHdoaWxlIGl0J3MgaW4gdGhlIGJyb3dzZXIuXHJcbiAgICAgICAgICAgIC8vICBUaGVyZSB3b3VsZCBiZSBib3RoIHRoZSBjb21wdXRlZCBwcm9wZXJ0aWVzIGFuZCB0aGUgc2V0IHByb3BlcnRpZXMuXHJcbiAgICAgICAgICAgIC8vIFBlcmhhcHMgd2Ugc2hvdWxkIGFsd2F5cyByZWZlciB0byBjb21wdXRlZCBzdHlsZSBvciBjc3R5bGVcclxuICAgICAgICAgICAgLy8gIEF2b2lkIGNvbmZ1c2lvbiB3aXRoIHRoZSBwYWRkaW5nIHByb3BlcnR5IHRoYXQgY2FuIGJlIHNldFxyXG4gICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICB2YXIgbGVmdCwgdG9wLCByaWdodCwgYm90dG9tO1xyXG5cclxuICAgICAgICAgICAgdmFyIGNfcGFkZGluZyA9IHRoaXMuY29tcHV0ZWRfc3R5bGUoJ3BhZGRpbmcnKTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ2NfcGFkZGluZycsIGNfcGFkZGluZyk7XHJcblxyXG4gICAgICAgICAgICB2YXIgc19jX3BhZGRpbmcgPSBjX3BhZGRpbmcuc3BsaXQoJyAnKTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ3NfY19wYWRkaW5nLmxlbmd0aCcsIHNfY19wYWRkaW5nLmxlbmd0aCk7XHJcblxyXG4gICAgICAgICAgICBpZiAoc19jX3BhZGRpbmcubGVuZ3RoID09IDMpIHtcclxuICAgICAgICAgICAgICAgIC8vIHRvcCwgcmlnaHQsIGJvdHRvbVxyXG4gICAgICAgICAgICAgICAgdG9wID0gcGFyc2VJbnQoc19jX3BhZGRpbmdbMF0sIDEwKTtcclxuICAgICAgICAgICAgICAgIHJpZ2h0ID0gcGFyc2VJbnQoc19jX3BhZGRpbmdbMV0sIDEwKTtcclxuICAgICAgICAgICAgICAgIGJvdHRvbSA9IHBhcnNlSW50KHNfY19wYWRkaW5nWzJdLCAxMCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gWzAsIHRvcCwgcmlnaHQsIGJvdHRvbV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KSxcclxuXHJcbiAgICAnYm9yZGVyJzogZnAoZnVuY3Rpb24oYSwgc2lnKSB7XHJcbiAgICAgICAgaWYgKHNpZyA9PSAnW10nKSB7XHJcbiAgICAgICAgICAgIC8vIHJlYWQgdGhlIHBhZGRpbmcuXHJcbiAgICAgICAgICAgIC8vICB0aGUgY29tcHV0ZWQgc3R5bGUgaXMgcHJvYmFibHkgd2hhdCB3ZSBhcmUgYWZ0ZXIuXHJcblxyXG4gICAgICAgICAgICAvLyBQZXJoYXBzIGEgY29tcHV0ZWRfc3R5bGUgZnVuY3Rpb24gd291bGQgaGVscCB0b28sIG1ha2luZyB0aGUgY29kZSBjbGVhcmVyIHRoYXQgdGhpcyBwYWRkaW5nIGZ1bmN0aW9uIHVzZXMgdGhhdC5cclxuXHJcbiAgICAgICAgICAgIC8vIFBlcmhhcHMganVzdCBjYWxsaW5nICdzdHlsZScgc2hvdWxkIGdldCB0aGUgY29tcHV0ZWQgc3R5bGUgd2hpbGUgaXQncyBpbiB0aGUgYnJvd3Nlci5cclxuICAgICAgICAgICAgLy8gIFRoZXJlIHdvdWxkIGJlIGJvdGggdGhlIGNvbXB1dGVkIHByb3BlcnRpZXMgYW5kIHRoZSBzZXQgcHJvcGVydGllcy5cclxuXHJcbiAgICAgICAgICAgIC8vIFBlcmhhcHMgd2Ugc2hvdWxkIGFsd2F5cyByZWZlciB0byBjb21wdXRlZCBzdHlsZSBvciBjc3R5bGVcclxuICAgICAgICAgICAgLy8gIEF2b2lkIGNvbmZ1c2lvbiB3aXRoIHRoZSBwYWRkaW5nIHByb3BlcnR5IHRoYXQgY2FuIGJlIHNldFxyXG4gICAgICAgICAgICAvL1xyXG5cclxuICAgICAgICAgICAgdmFyIGxlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbTtcclxuXHJcbiAgICAgICAgICAgIHZhciBjX2JvcmRlciA9IHRoaXMuY29tcHV0ZWRfc3R5bGUoJ2JvcmRlcicpO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnY19ib3JkZXInLCBjX2JvcmRlcik7XHJcblxyXG4gICAgICAgICAgICB0aHJvdyAnc3RvcCc7XHJcblxyXG4gICAgICAgICAgICAvKlxyXG5cclxuICAgICAgICAgICAgdmFyIHNfY19wYWRkaW5nID0gY19wYWRkaW5nLnNwbGl0KCcgJyk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdzX2NfcGFkZGluZy5sZW5ndGgnLCBzX2NfcGFkZGluZy5sZW5ndGgpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHNfY19wYWRkaW5nLmxlbmd0aCA9PSAzKSB7XHJcbiAgICAgICAgICAgICAgICAvLyB0b3AsIHJpZ2h0LCBib3R0b21cclxuICAgICAgICAgICAgICAgIHRvcCA9IHBhcnNlSW50KHNfY19wYWRkaW5nWzBdLCAxMCk7XHJcbiAgICAgICAgICAgICAgICByaWdodCA9IHBhcnNlSW50KHNfY19wYWRkaW5nWzFdLCAxMCk7XHJcbiAgICAgICAgICAgICAgICBib3R0b20gPSBwYXJzZUludChzX2NfcGFkZGluZ1syXSwgMTApO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIHJldHVybnMgYXMgbCwgdCwgciwgYlxyXG5cclxuICAgICAgICAgICAgICAgIC8vcmV0dXJuIFswLCB0b3AsIHJpZ2h0LCBib3R0b21dO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBbMCwgdG9wLCByaWdodCwgYm90dG9tXTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgKi9cclxuXHJcblxyXG5cclxuXHJcblxyXG4gICAgICAgIH1cclxuICAgIH0pLFxyXG4gICAgJ2JvcmRlcl90aGlja25lc3MnOiBmcChmdW5jdGlvbihhLCBzaWcpIHtcclxuICAgICAgICBpZiAoc2lnID09ICdbXScpIHtcclxuICAgICAgICAgICAgLy8gcmVhZCB0aGUgcGFkZGluZy5cclxuICAgICAgICAgICAgLy8gIHRoZSBjb21wdXRlZCBzdHlsZSBpcyBwcm9iYWJseSB3aGF0IHdlIGFyZSBhZnRlci5cclxuXHJcbiAgICAgICAgICAgIC8vIFBlcmhhcHMgYSBjb21wdXRlZF9zdHlsZSBmdW5jdGlvbiB3b3VsZCBoZWxwIHRvbywgbWFraW5nIHRoZSBjb2RlIGNsZWFyZXIgdGhhdCB0aGlzIHBhZGRpbmcgZnVuY3Rpb24gdXNlcyB0aGF0LlxyXG5cclxuICAgICAgICAgICAgLy8gUGVyaGFwcyBqdXN0IGNhbGxpbmcgJ3N0eWxlJyBzaG91bGQgZ2V0IHRoZSBjb21wdXRlZCBzdHlsZSB3aGlsZSBpdCdzIGluIHRoZSBicm93c2VyLlxyXG4gICAgICAgICAgICAvLyAgVGhlcmUgd291bGQgYmUgYm90aCB0aGUgY29tcHV0ZWQgcHJvcGVydGllcyBhbmQgdGhlIHNldCBwcm9wZXJ0aWVzLlxyXG5cclxuICAgICAgICAgICAgLy8gUGVyaGFwcyB3ZSBzaG91bGQgYWx3YXlzIHJlZmVyIHRvIGNvbXB1dGVkIHN0eWxlIG9yIGNzdHlsZVxyXG4gICAgICAgICAgICAvLyAgQXZvaWQgY29uZnVzaW9uIHdpdGggdGhlIHBhZGRpbmcgcHJvcGVydHkgdGhhdCBjYW4gYmUgc2V0XHJcbiAgICAgICAgICAgIC8vXHJcblxyXG4gICAgICAgICAgICB2YXIgbGVmdCwgdG9wLCByaWdodCwgYm90dG9tO1xyXG5cclxuICAgICAgICAgICAgdmFyIGNfYm9yZGVyID0gdGhpcy5jb21wdXRlZF9zdHlsZSgnYm9yZGVyJyk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdjX2JvcmRlcicsIGNfYm9yZGVyKTtcclxuXHJcbiAgICAgICAgICAgIC8vdmFyIHNfY19ib3JkZXIgPSBjX2JvcmRlci5zcGxpdCgnICcpO1xyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdzX2NfYm9yZGVyJywgc19jX2JvcmRlcik7XHJcblxyXG4gICAgICAgICAgICAvLyBDYW4ndCByZWFsbHkgc3BsaXQgaXQgYnkgc3BhY2UuXHJcbiAgICAgICAgICAgIC8vICBzb21lIG9mIHRoZSB0ZXJtcyBpbiB0aGUgYnJhY2tldCBpbmNsdWRlIGEgc3BhY2UuXHJcbiAgICAgICAgICAgIC8vICBjb3VsZCBmaXJzdCBkbyBhIHJlZ2V4IHRvIGNoYW5nZSAnLCAnIHRvICcsJ1xyXG5cclxuICAgICAgICAgICAgdmFyIGIyID0gY19ib3JkZXIuc3BsaXQoJywgJykuam9pbignJyk7XHJcbiAgICAgICAgICAgIHZhciBzX2NfYm9yZGVyID0gYjIuc3BsaXQoJyAnKTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ3NfY19ib3JkZXInLCBzX2NfYm9yZGVyKTtcclxuXHJcbiAgICAgICAgICAgIC8vIHRoZW4gY2FuIGdldCB0aGUgdGhpY2tuZXNzIGZyb20gdGhlIGZpcnN0IG9uZS5cclxuXHJcbiAgICAgICAgICAgIHZhciB0aGlja25lc3MgPSBwYXJzZUludChzX2NfYm9yZGVyWzBdLCAxMCk7XHJcblxyXG4gICAgICAgICAgICAvLyB0aGUgNCBkaWZmZXJlbnQgdGhpY2tuZXNzZXM/XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpY2tuZXNzO1xyXG5cclxuXHJcbiAgICAgICAgICAgIC8vdGhyb3cgJ3N0b3AnO1xyXG5cclxuICAgICAgICAgICAgLypcclxuXHJcbiAgICAgICAgICAgICB2YXIgc19jX3BhZGRpbmcgPSBjX3BhZGRpbmcuc3BsaXQoJyAnKTtcclxuICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdzX2NfcGFkZGluZy5sZW5ndGgnLCBzX2NfcGFkZGluZy5sZW5ndGgpO1xyXG5cclxuICAgICAgICAgICAgIGlmIChzX2NfcGFkZGluZy5sZW5ndGggPT0gMykge1xyXG4gICAgICAgICAgICAgLy8gdG9wLCByaWdodCwgYm90dG9tXHJcbiAgICAgICAgICAgICB0b3AgPSBwYXJzZUludChzX2NfcGFkZGluZ1swXSwgMTApO1xyXG4gICAgICAgICAgICAgcmlnaHQgPSBwYXJzZUludChzX2NfcGFkZGluZ1sxXSwgMTApO1xyXG4gICAgICAgICAgICAgYm90dG9tID0gcGFyc2VJbnQoc19jX3BhZGRpbmdbMl0sIDEwKTtcclxuXHJcbiAgICAgICAgICAgICAvLyByZXR1cm5zIGFzIGwsIHQsIHIsIGJcclxuXHJcbiAgICAgICAgICAgICAvL3JldHVybiBbMCwgdG9wLCByaWdodCwgYm90dG9tXTtcclxuXHJcbiAgICAgICAgICAgICByZXR1cm4gWzAsIHRvcCwgcmlnaHQsIGJvdHRvbV07XHJcblxyXG4gICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgKi9cclxuXHJcblxyXG5cclxuXHJcblxyXG4gICAgICAgIH1cclxuICAgIH0pLFxyXG5cclxuICAgICdjb3Zlcic6IGZwKGZ1bmN0aW9uKGEsIHNpZykge1xyXG4gICAgICAgIC8vIE1ha2VzIGEgY292ZXIgdG8gdGhpcyBjb250cm9sLlxyXG4gICAgICAgIC8vICBSZWxhdGl2ZWx5IHBvc2l0aW9uZWQgZGl2IGFzIGZpcnN0IGNoaWxkIChpZiBpdCBpcyBub3QgdGhlcmUgYWxyZWFkeSlcclxuICAgICAgICAvLyAgQWJzb2x1dGVseSBwb3NpdGlvbmVkIHdpdGhpbiB0aGF0IHJlbGF0aXZlIGRpdi5cclxuXHJcbiAgICAgICAgLy8gaW5zZXJ0IGEgbmV3IHJlbGF0aXZlIGRpdj9cclxuICAgICAgICAvLyAgcmVsYXRpdmUgZm9yIGxheW91dD9cclxuXHJcblxyXG5cclxuXHJcblxyXG4gICAgfSksXHJcblxyXG4gICAgJ2dob3N0JzogZnAoZnVuY3Rpb24oYSwgc2lnKSB7XHJcblxyXG4gICAgfSksXHJcblxyXG4gICAgLy8gYWJzb2x1dGVfZ2hvc3RfY2xvbmVcclxuICAgICdhYnNvbHV0ZV9naG9zdF9jbG9uZSc6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIC8vIGZpbmQgb3V0IHdoYXQgdHlwZSB0aGUgY29udHJvbCBpcy4uLlxyXG5cclxuICAgICAgICAvLyBBbmQgd291bGQgZWl0aGVyIGhhdmUgbG93ZXIgb3BhY2l0eSAtIG9yIGJlICdnaG9zdGVkJyBvdXQgd2l0aCBhIGNvdmVyLlxyXG4gICAgICAgIC8vICBDb3VsZCBoYXZlIGFuIGludGVybmFsIGNvdmVyIHRoYXQgdGFrZXMgdXAgdGhlIHNwYWNlLlxyXG4gICAgICAgIC8vICBBYnNvbHV0ZSBwb3NpdGlvbmluZywgbWVhc3VyZWQgdG8gdGFrZSB1cCB0aGUgaW50ZXJuYWwgc3BhY2UuXHJcbiAgICAgICAgLy8gIFdvdWxkIHJlcXVpcmUgYSByZWxhdGl2ZSBkaXYgaW5zaWRlP1xyXG4gICAgICAgIC8vICBDb3VsZCBjcmVhdGUgYSByZWxhdGl2ZSBkaXYgYXMgdGhlIGZpcnN0IGNoaWxkLlxyXG4gICAgICAgIC8vICAgcmVsYXRpdmUgc2l6ZSAwLCBpbiB0aGUgdG9wIGxlZnQsIHRoZW4gdXNlZCBmb3IgYWJzb2x1dGUgcG9zaXRpb25pbmcgb2YgdGhlIGNvdmVyIGxheWVyLlxyXG5cclxuXHJcbiAgICAgICAgLy8gdGhpcy5jb3ZlclxyXG4gICAgICAgIC8vICBhbmQgd291bGQgZ2V0IGFjY2VzcyB0byB0aGUgY292ZXIgY29udHJvbCBhcyB3ZWxsLlxyXG4gICAgICAgIC8vICBzaG91bGQgYmUgYWJzb2x1dGVseSBwb3NpdGlvbmVkLCBhbmQgYWJvdmUgdGhlIG90aGVyIGl0ZW1zIGluIHRoZSBjb250cm9sLlxyXG5cclxuICAgICAgICAvLyB0aGlzLmNvdmVyKGZhbHNlKTtcclxuXHJcbiAgICAgICAgLy8gdGhpcy5naG9zdCgpXHJcbiAgICAgICAgLy8gIG1ha2VzIGEgZ2hvc3QgY292ZXIuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuICAgICAgICB2YXIgdHlwZV9uYW1lID0gdGhpcy5fX3R5cGVfbmFtZTtcclxuICAgICAgICB2YXIgaWQgPSB0aGlzLl9pZCgpO1xyXG4gICAgICAgIHZhciBjb250ZXh0ID0gdGhpcy5fY29udGV4dDtcclxuXHJcbiAgICAgICAgLy8gc3BpbiB1cCBhIG5ldyBjb250cm9sLCB1c2luZyB0aGV5IHR5cGUgb2YgY29udHJvbHMuXHJcblxyXG4gICAgICAgIGNvbnNvbGUubG9nKCdjb250ZXh0JywgY29udGV4dCk7XHJcblxyXG4gICAgICAgIHZhciBjdHJsX2RvY3VtZW50ID0gY29udGV4dC5jdHJsX2RvY3VtZW50O1xyXG5cclxuICAgICAgICBjb25zb2xlLmxvZygnY3RybF9kb2N1bWVudCcsIGN0cmxfZG9jdW1lbnQpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCd0eXBlX25hbWUnLCB0eXBlX25hbWUpO1xyXG5cclxuICAgICAgICB2YXIgQ3N0ciA9IGNvbnRleHQubWFwX0NvbnRyb2xzW3R5cGVfbmFtZV07XHJcbiAgICAgICAgY29uc29sZS5sb2coJ0NzdHInLCBDc3RyKTtcclxuXHJcbiAgICAgICAgLy8gV2UgY2FuIGNyZWF0ZSBhIG5ldyBvbmUsIHdpdGggYSBuZXcgSUQuXHJcblxyXG4gICAgICAgIHZhciBuZXdfaWQgPSBpZCArICdfY2xvbmUnO1xyXG4gICAgICAgIHZhciBtYXBfY29udHJvbHMgPSBjb250ZXh0Lm1hcF9jb250cm9scztcclxuXHJcbiAgICAgICAgLy8gV2FudCB0aGUgYm9keSBjb250cm9sIGFzIHdlbGwuXHJcblxyXG5cclxuXHJcbiAgICAgICAgaWYgKCFtYXBfY29udHJvbHNbbmV3X2lkXSkge1xyXG4gICAgICAgICAgICAvLyBjcmVhdGUgaXQuXHJcblxyXG4gICAgICAgICAgICB2YXIgbmV3X2N0cmwgPSBuZXcgQ3N0cih7XHJcbiAgICAgICAgICAgICAgICAnY29udGV4dCc6IGNvbnRleHQsXHJcbiAgICAgICAgICAgICAgICAnaWQnOiBuZXdfaWRcclxuICAgICAgICAgICAgfSlcclxuXHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCduZXdfY3RybCcsIG5ld19jdHJsKTtcclxuXHJcbiAgICAgICAgICAgIC8vdmFyIGJvZHkgPSBjdHJsX2RvY3VtZW50LmJvZHkoKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBib2R5ID0gY3RybF9kb2N1bWVudC5jb250ZW50KCkuZ2V0KDEpO1xyXG5cclxuICAgICAgICAgICAgdmFyIGNzc19jbGFzcyA9IHRoaXMuZ2V0KCdkb20uYXR0cmlidXRlcy5jbGFzcycpO1xyXG4gICAgICAgICAgICBuZXdfY3RybC5zZXQoJ2RvbS5hdHRyaWJ1dGVzLmNsYXNzJywgY3NzX2NsYXNzKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFNob3VsZCBjb3B5IHRoZSBjb250cm9scyBpbnNpZGUgdGhlIG9uZSBiZWluZyBjbG9uZWQuXHJcbiAgICAgICAgICAgIHZhciBteV9jb250ZW50cyA9IHRoaXMuZ2V0KCdjb250ZW50Jyk7XHJcblxyXG4gICAgICAgICAgICAvLyBzaG91bGQgYmUgYWJsZSB0byBjbG9uZSBhIERhdGFfVmFsdWUgdG9vLlxyXG5cclxuXHJcblxyXG4gICAgICAgICAgICBlYWNoKG15X2NvbnRlbnRzLCBmdW5jdGlvbih2LCBpKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnaScsIGkpO1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ3YnLCB2KTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBBZGRpbmcgYSBEYXRhX1ZhbHVlIG5vdCB3b3JraW5nP1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciB2X2Nsb25lID0gdi5jbG9uZSgpO1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ3ZfY2xvbmUnLCB2X2Nsb25lKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBjb3VsZCBnZXQgdGhlIHZhbHVlIGlmIGl0J3MgYSBEYXRhX1ZhbHVlIGZvciB0aGUgbW9tZW50Li4uXHJcbiAgICAgICAgICAgICAgICAvLyAgQWRkaW5nIGEgRGF0YV9WYWx1ZSB0byBhXHJcblxyXG4gICAgICAgICAgICAgICAgLy9pZiAodl9jbG9uZS52YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHZfY2xvbmUgaW5zdGFuY2VvZiBqc2d1aS5EYXRhX1ZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3X2N0cmwuYWRkKHZfY2xvbmUudmFsdWUoKSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld19jdHJsLmFkZCh2X2Nsb25lKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG5cclxuICAgICAgICAgICAgfSlcclxuXHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCd0aGlzJywgdGhpcyk7XHJcblxyXG4gICAgICAgICAgICAvLyBjb3VsZCBnZXQgdGhlIGNvbXB1dGVkIHdpZHRoP1xyXG5cclxuICAgICAgICAgICAgLy8gY29tcHV0ZWQgcGFkZGluZyB0b28/XHJcblxyXG5cclxuXHJcbiAgICAgICAgICAgIHZhciBteV9iY3IgPSB0aGlzLmJjcigpO1xyXG5cclxuXHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdteV9iY3InLCBteV9iY3IpO1xyXG5cclxuICAgICAgICAgICAgLy8gYW5kIGdldCB0aGUgYm9yZGVyIHRoaWNrbmVzcyB0b28uXHJcbiAgICAgICAgICAgIC8vICBtYXkgYmUgYSBiaXQgbW9yZSBjb21wbGV4IGdldHRpbmcgdGhlbSBhbGxcclxuICAgICAgICAgICAgLy8gIGFuZCBtYWtpbmcgc3VyZSBpdCB3b3JrcyBpbiBhbGwgYnJvd3NlcnMuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG4gICAgICAgICAgICB2YXIgbXlfcGFkZGluZyA9IHRoaXMucGFkZGluZygpO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnbXlfcGFkZGluZycsIG15X3BhZGRpbmcpO1xyXG5cclxuICAgICAgICAgICAgbXlfYmNyWzJdWzBdID0gbXlfYmNyWzJdWzBdIC0gbXlfcGFkZGluZ1swXTtcclxuICAgICAgICAgICAgbXlfYmNyWzJdWzFdID0gbXlfYmNyWzJdWzFdIC0gbXlfcGFkZGluZ1sxXTtcclxuICAgICAgICAgICAgbXlfYmNyWzJdWzBdID0gbXlfYmNyWzJdWzBdIC0gbXlfcGFkZGluZ1syXTtcclxuICAgICAgICAgICAgbXlfYmNyWzJdWzFdID0gbXlfYmNyWzJdWzFdIC0gbXlfcGFkZGluZ1szXTtcclxuXHJcblxyXG5cclxuICAgICAgICAgICAgLy92YXIgbXlfYm9yZGVyID0gdGhpcy5ib3JkZXIoKTtcclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnbXlfYm9yZGVyJywgbXlfYm9yZGVyKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBteV9ib3JkZXJfdGhpY2tuZXNzID0gdGhpcy5ib3JkZXJfdGhpY2tuZXNzKCk7XHJcblxyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnbXlfYm9yZGVyX3RoaWNrbmVzcycsIG15X2JvcmRlcl90aGlja25lc3MpO1xyXG5cclxuXHJcbiAgICAgICAgICAgIHZhciB0X215X2JvcmRlcl90aGlja25lc3MgPSB0b2YobXlfYm9yZGVyX3RoaWNrbmVzcyk7XHJcblxyXG4gICAgICAgICAgICBpZiAodF9teV9ib3JkZXJfdGhpY2tuZXNzID09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgICAgICBteV9iY3JbMl1bMF0gPSBteV9iY3JbMl1bMF0gLSAyICogbXlfYm9yZGVyX3RoaWNrbmVzcztcclxuICAgICAgICAgICAgICAgIG15X2JjclsyXVsxXSA9IG15X2JjclsyXVsxXSAtIDIgKiBteV9ib3JkZXJfdGhpY2tuZXNzO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gTm90IHN1cmUgaG93IHRoZSBib3JkZXIgd291bGQgYmUgcmVwb3J0ZWQgaW4gYSBidW5jaCBvZiBkaWZmZXJlbnQgYnJvd3NlcnMgb3IgYm9yZGVyIHZhbHVlc1xyXG5cclxuICAgICAgICAgICAgLy8gY291bGQgYmUgJzFweCBzb2xpZCByZ2IoMjIxLCAyMjEsIDIyMSknXHJcbiAgICAgICAgICAgIC8vIGNvdWxkIGhhdmUgcmVnZXhlcyB0ZXN0aW5nIGZvciB2YXJpb3VzIGJvcmRlcnMgYW5kIGdldHRpbmcgdGhlIHZhbHVlcyBiYWNrIGZyb20gdGhlbS5cclxuXHJcbiAgICAgICAgICAgIC8vICBzbyB3ZSBrbm93IHRoZSB0aGlja25lc3Mgb2YgdGhlIGluZGl2aWR1YWwgbGVmdCwgdG9wLCByaWdodCwgYm90dG9tIGJlY2F1c2Ugd2UgZ2V0IHRoZW0gYWxsIGF0IG9uY2UuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG4gICAgICAgICAgICAvLyBhbmQgc3VidHJhY3QgdGhlIHBhZGRpbmcuXHJcblxyXG5cclxuXHJcbiAgICAgICAgICAgIC8vIGFuZCB1c2UgdGhlIGJjciB2YWx1ZXMgdG8gc2V0IHRoZSBwb3NpdGlvbiBhbmQgc2l6ZSBvZiB0aGUgbmV3IGNvbnRyb2wuXHJcblxyXG4gICAgICAgICAgICAvLyAuYm91bmRzP1xyXG4gICAgICAgICAgICAvLyAgIHNldHMgdGhlIHBvc2l0aW9uIChzY3JlZW4gbG9jYXRpb24pIGFuZCB0aGUgc2l6ZT9cclxuICAgICAgICAgICAgLy8gICBnZXRzIHRoZSBib3VuZGluZyBjbGllbnQgcmVjdD9cclxuXHJcblxyXG5cclxuICAgICAgICAgICAgbmV3X2N0cmwuYmNyKG15X2Jjcik7XHJcblxyXG5cclxuXHJcblxyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnbmV3X2N0cmwnLCBuZXdfY3RybCk7XHJcblxyXG5cclxuXHJcblxyXG5cclxuICAgICAgICAgICAgLy90aHJvdyAnc3RvcCc7XHJcblxyXG4gICAgICAgICAgICAvLyBuZWVkIHRvIG1ha2UgdGhlIG5ldyBjb250cm9sIGFic29sdXRlXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG4gICAgICAgICAgICAvL2N0cmxfZG9jdW1lbnQuYm9keSgpLmFkZChuZXdfY3RybCk7XHJcbiAgICAgICAgICAgIGJvZHkuYWRkKG5ld19jdHJsKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBuZXdfZWwgPSBuZXdfY3RybC5nZXQoJ2RvbS5lbCcpO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnbmV3X2VsJywgbmV3X2VsKTtcclxuXHJcblxyXG4gICAgICAgICAgICAvL3Rocm93ICdzdG9wJztcclxuXHJcbiAgICAgICAgfVxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG4gICAgICAgIC8vdGhyb3cgJ3N0b3AnO1xyXG5cclxuXHJcblxyXG5cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8qXHJcblxyXG4gICAgJ2NyZWF0ZV9naG9zdF9jb3B5JzogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgLy8gTmVlZHMgdG8gY2xvbmUgdGhlIGNvbnRyb2wsIGFuZCBwdXQgaXQgaW50byB0aGUgYm9keS5cclxuXHJcbiAgICAgICAgLy8gTWF5IG5lZWQgdG8gZG8gc29tZSBpbi1kZXB0aCB3b3JrIG9uIGNsb25pbmcgYSBjb250cm9sLlxyXG4gICAgICAgIC8vICBEb24ndCB3YW50IHRvIGNvbXBsaWNhdGUgdGhlIGNvZGUgdG9vIG11Y2ggdGhvdWdoLlxyXG4gICAgICAgIC8vICBDb3VsZCBqdXN0IGFkZCB0aGUgSFRNTCBmcm9tIGluc2lkZSB0aGUgb3RoZXIgb25lLlxyXG5cclxuICAgICAgICB2YXIgZ2hvc3RfY29weSA9IG5ldyBDb250cm9sKHtcclxuICAgICAgICAgICAgJ2NvbnRleHQnOiB0aGlzLl9jb250ZXh0XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHZhciBlbCA9IHRoaXMuZ2V0KCdkb20uZWwnKTtcclxuXHJcbiAgICAgICAgLy8gQ2FuJ3QgcmV1c2UgSURzXHJcbiAgICAgICAgLy8gIEkgdGhpbmsgd2UgbmVlZCBhIG1lYW5zIG9mIGNsb25pbmcgY29udHJvbHMgKHByb3Blcmx5KS5cclxuICAgICAgICAvLyAgTmVlZCB0byBydW4gYSBjbG9uZSBwcm9jZWR1cmUgb24gdGhlIENvbnRyb2wgYW5kIGl0cyBzdWJjb250cm9scy5cclxuICAgICAgICAvLyAgV291bGQgbWFrZSBhIGNsb25lIHdpdGhpbiB0aGUgc2FtZSBjb250ZXh0IGJ1dCBpdCB3b3VsZCBnZXQgYSBuZXcgSUQuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbiAgICAgICAgaWYgKGVsKSB7XHJcbiAgICAgICAgICAgIC8vZ2hvc3RfY29weS5hZGQoZWwuaW5uZXJIVE1MKVxyXG5cclxuICAgICAgICAgICAgdmFyIG15X2Nsb25lID0gdGhpcy5jbG9uZSgpO1xyXG5cclxuICAgICAgICAgICAgLy8gdGhlbiBwdXQgdGhlIGNsb25lIGluIHRoZSBib2R5LlxyXG5cclxuICAgICAgICAgICAgdmFyIGJvZHkgPSB0aGlzLl9jb250ZXh0LmJvZHkoKTtcclxuICAgICAgICAgICAgYm9keS5hZGQobXlfY2xvbmUpO1xyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgfSxcclxuICAgICovXHJcblxyXG4gICAgLy8gY2FuIGhhdmUgZGlmZmVyZW50IG1vbm9tb3JwaGljIHZlcnNpb25zLlxyXG5cclxuICAgICdzZXQnOiBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xyXG4gICAgICAvLyBVc2VkIGZvciBzZXR0aW5nIGNvbnRyb2xzLCBvbiB0aGUgc2VydmVyLCB0aGF0IGdldCBwZXJzaXN0ZWQgdG8gdGhlIGNsaWVudC5cclxuXHJcbiAgICAgIC8vIHdoZW4gdGhlIHZhbHVlIGlzIGEgY29udHJvbCwgd2UgYWxzbyB3YW50IHRvIHNldCB0aGUgLl9qc2d1aV9jdHJsX2ZpZWxkc1xyXG5cclxuXHJcblxyXG4gICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgLy92YXIgdF92YWwgPSB0b2YodmFsdWUpO1xyXG4gICAgICAgICAgLy9jb25zb2xlLmxvZygndF92YWwnLCB0X3ZhbCk7XHJcblxyXG4gICAgICAgICAgaWYgKGlzX2N0cmwodmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgdmFyIGNmID0gdGhpcy5fY3RybF9maWVsZHMgPSB0aGlzLl9jdHJsX2ZpZWxkcyB8fCB7fTtcclxuXHJcbiAgICAgICAgICAgICAgLy9leHRlbmQoY2YsIHtcclxuICAgICAgICAgICAgICAvLyAgJ2J0bl9zaW5nbGVfYm91bmQnOiB0Yl9zaW5nbGVfYm91bmQsXHJcbiAgICAgICAgICAgICAgLy8gICdidG5fZHVhbF9ib3VuZCc6IHRiX2R1YWxfYm91bmQsXHJcbiAgICAgICAgICAgICAgLy8gICdidG5fZ2EnOiB0Yl9nZW5ldGljLFxyXG4gICAgICAgICAgICAgIC8vICAncGFuZWxfc2luZ2xlX2JvdW5kJzogcGFuZWxfc2luZ2xlX2JvdW5kLFxyXG4gICAgICAgICAgICAgIC8vICAncGFuZWxfZHVhbF9ib3VuZCc6IHBhbmVsX2R1YWxfYm91bmQsXHJcbiAgICAgICAgICAgICAgLy8gICdwYW5lbF9nYSc6IHBhbmVsX2dhXHJcbiAgICAgICAgICAgICAgLy99KTtcclxuXHJcbiAgICAgICAgICAgICAgY2ZbbmFtZV0gPSB2YWx1ZTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N1cGVyKG5hbWUsIHZhbHVlKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fc3VwZXIobmFtZSk7XHJcbiAgICAgIH1cclxuXHJcblxyXG5cclxuXHJcbiAgICAgIC8qXHJcblxyXG5cclxuXHJcbiAgICAgICovXHJcblxyXG5cclxuICAgIH0sXHJcblxyXG5cclxuXHJcblxyXG4gICAgJ29uZV9tb3VzZWRvd25fYW55d2hlcmUnOiBmdW5jdGlvbihjYWxsYmFjaykge1xyXG4gICAgICAgIC8vdmFyIGN0cmxfaHRtbF9yb290ID0gdGhpcy5fY29udGV4dC5jdHJsX2RvY3VtZW50O1xyXG4gICAgICAgIC8vY29uc29sZS5sb2coJ3RoaXMuX2NvbnRleHQnLCB0aGlzLl9jb250ZXh0KTtcclxuICAgICAgICB2YXIgYm9keSA9IHRoaXMuX2NvbnRleHQuYm9keSgpO1xyXG5cclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcblxyXG4gICAgICAgIGJvZHkub25lKCdtb3VzZWRvd24nLCBmdW5jdGlvbihlX21vdXNlZG93bikge1xyXG4gICAgICAgICAgICAvLyBNYXliZSBzZWUgaWYgaXQncyBpbnRlcm5hbCBvciBleHRlcm5hbCB0byB0aGUgY29udHJvbFxyXG5cclxuICAgICAgICAgICAgLy8gV291bGQgYmUgZ29vZCB0byBoYXZlIHRoYXQgaW4gdGhlIGV2ZW50LlxyXG5cclxuICAgICAgICAgICAgdmFyIGVsID0gdGhhdC5nZXQoJ2RvbS5lbCcpO1xyXG5cclxuICAgICAgICAgICAgdmFyIGVfZWwgPSBlX21vdXNlZG93bi5zcmNFbGVtZW50IHx8IGVfbW91c2Vkb3duLnRhcmdldDtcclxuXHJcblxyXG5cclxuXHJcblxyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnb25lIG1vdXNlZG93bicsIGVfbW91c2Vkb3duKTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ2VfZWwnLCBlX2VsKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFdhbnQgdG8gc2VlIGlmIHRoZSBlbGVtZW50IGNsaWNrZWQgb24gaXMgYSBkZXNjZW5kYW50IG9mIHRoaXMncyBlbC5cclxuXHJcbiAgICAgICAgICAgIHZhciBpYW8gPSB0aGF0LmlzX2FuY2VzdG9yX29mKGVfZWwpO1xyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdpYW8nLCBpYW8pO1xyXG5cclxuICAgICAgICAgICAgZV9tb3VzZWRvd24ud2l0aGluX3RoaXMgPSBpYW87XHJcblxyXG4gICAgICAgICAgICBjYWxsYmFjayhlX21vdXNlZG93bik7XHJcblxyXG4gICAgICAgIH0pO1xyXG4gICAgfSxcclxuXHJcblxyXG4gICAgLy8gVGhpcyBtYXkgbmVlZCB0byBzZWFyY2ggaW5zaWRlIGZvciBjb250cm9scyB0byBiZSBhY3RpdmF0ZWQuXHJcbiAgICAvLyAgTmVlZCB0byBnZXQgdGhpcyB0byB3b3JrIHdpdGggY2xpZW50LXJlbmRlcmVkIGNvbnRlbnQuXHJcblxyXG5cclxuICAgICdhY3RpdmF0ZV9yZWN1cnNpdmUnOiBmdW5jdGlvbigpIHtcclxuICAgICAgICBjb25zb2xlLmxvZygnYWN0aXZhdGVfcmVjdXJzaXZlJyk7XHJcbiAgICAgICAgdmFyIGVsID0gdGhpcy5nZXQoJ2RvbS5lbCcpO1xyXG5cclxuICAgICAgICB2YXIgY29udGV4dCA9IHRoaXMuX2NvbnRleHQ7XHJcbiAgICAgICAgdmFyIG1hcF9jb250cm9scyA9IGNvbnRleHQubWFwX2NvbnRyb2xzO1xyXG5cclxuICAgICAgICB2YXIgcGFyZW50X2NvbnRyb2w7XHJcblxyXG4gICAgICAgIC8vIGRvZXMgdGhlIGNvbnRyb2wgaGF2ZSBhIERPTSBub2RlP1xyXG5cclxuXHJcbiAgICAgICAgcmVjdXJzaXZlX2RvbV9pdGVyYXRlX2RlcHRoKGVsLCBmdW5jdGlvbihlbDIpIHtcclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnZWwgJyArIGVsKTtcclxuICAgICAgICAgICAgdmFyIG50ID0gZWwyLm5vZGVUeXBlO1xyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdudCAnICsgbnQpO1xyXG4gICAgICAgICAgICBpZiAobnQgPT0gMSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGpzZ3VpX2lkID0gZWwyLmdldEF0dHJpYnV0ZSgnZGF0YS1qc2d1aS1pZCcpO1xyXG5cclxuXHJcblxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdqc2d1aV9pZCAnICsganNndWlfaWQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGpzZ3VpX2lkKSB7XHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBOb3Qgc28gc3VyZSB0aGUgY29udHJvbCB3aWxsIGV4aXN0IHdpdGhpbiBhIG1hcCBvZiBjb250cm9scy5cclxuICAgICAgICAgICAgICAgICAgICAvLyAgSWYgd2UgaGF2ZSBhY3RpdmF0ZWQgdGhlIHdob2xlIHBhZ2UsIHRoZW4gdGhleSB3aWxsIGV4aXN0LlxyXG4gICAgICAgICAgICAgICAgICAgIC8vICBIb3dldmVyLCB3ZSBtYXkganVzdCB3YW50IHRvIGRvIGFjdGl2YXRlIG9uIHNvbWUgY29udHJvbHMuXHJcbiAgICAgICAgICAgICAgICAgICAgLy90aHJvdyAnc3RvcCc7XHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgY3RybCA9IG1hcF9jb250cm9sc1tqc2d1aV9pZF07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudF9jb250cm9sKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnc2V0dGluZyBjdHJsIHBhcmVudCcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgY3RybC5wYXJlbnQocGFyZW50X2NvbnRyb2wpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAqL1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdjdHJsICcgKyBjdHJsKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZG9uJ3Qgd2FudCB0byBhY3RpdmF0ZSB0d2ljZS5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gc3BlY2lmaWNhbGx5IGF2b2lkIGFjdGl2YXRpbmcgdHdpY2U/XHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL2lmIChlbDIgIT0gZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyAgICAvL2N0cmwuYWN0aXZhdGUoZWwyKTtcclxuICAgICAgICAgICAgICAgICAgICAvL31cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjdHJsLl9fYWN0aXZlKSBjdHJsLmFjdGl2YXRlKGVsMik7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9wYXJlbnRfY29udHJvbCA9IGN0cmw7XHJcblxyXG5cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2pzZ3VpX3R5cGUgJyArIGpzZ3VpX3R5cGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgIH0sXHJcblxyXG4gICAgLy8gZnAgcmVtb3ZhbCBjYW5kaWRhdGVcclxuXHJcbiAgICAnYWRkX2V2ZW50X2xpc3RlbmVyJzogZnAoZnVuY3Rpb24oYSwgc2lnKSB7XHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgdmFyIGVsID0gdGhpcy5nZXQoJ2RvbS5lbCcpO1xyXG4gICAgICAgIGlmIChlbCkge1xyXG5cclxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGVsZW1lbnQgaGFzIHRoYXQgZXZlbnQgbGlzdGVuZXIuLi5cclxuICAgICAgICAgICAgLy8gIE1heWJlIG1haW50YWluIGEgbWFwIHdpdGhpbiB0aGUgY29udHJvbCBvZiB3aGljaCBET00gZnVuY3Rpb25zIGhhdmUgYmVlbiBib3VuZCB0byB0aGUgZWxlbWVudC5cclxuXHJcblxyXG5cclxuICAgICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudF9uYW1lLCBoYW5kbGVyLCBmYWxzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgICovXHJcblxyXG4gICAgICAgIC8vIEluIGVuaCAtIHdpdGggdGhpcyBvbmx5IHdvcmtpbmcgcG9zdC1hY3RpdmF0aW9uP1xyXG5cclxuICAgICAgICAvLyBzZWUgaHR0cDovL3d3dy53M3NjaG9vbHMuY29tL3RhZ3MvcmVmX2F2X2RvbS5hc3BcclxuICAgICAgICAvKlxyXG4gICAgICAgIGFib3J0XHRGaXJlcyB3aGVuIHRoZSBsb2FkaW5nIG9mIGFuIGF1ZGlvL3ZpZGVvIGlzIGFib3J0ZWRcclxuICAgICAgICBjYW5wbGF5XHRGaXJlcyB3aGVuIHRoZSBicm93c2VyIGNhbiBzdGFydCBwbGF5aW5nIHRoZSBhdWRpby92aWRlb1xyXG4gICAgICAgIGNhbnBsYXl0aHJvdWdoXHRGaXJlcyB3aGVuIHRoZSBicm93c2VyIGNhbiBwbGF5IHRocm91Z2ggdGhlIGF1ZGlvL3ZpZGVvIHdpdGhvdXQgc3RvcHBpbmcgZm9yIGJ1ZmZlcmluZ1xyXG4gICAgICAgIGR1cmF0aW9uY2hhbmdlXHRGaXJlcyB3aGVuIHRoZSBkdXJhdGlvbiBvZiB0aGUgYXVkaW8vdmlkZW8gaXMgY2hhbmdlZFxyXG4gICAgICAgIGVtcHRpZWRcdEZpcmVzIHdoZW4gdGhlIGN1cnJlbnQgcGxheWxpc3QgaXMgZW1wdHlcclxuICAgICAgICBlbmRlZFx0RmlyZXMgd2hlbiB0aGUgY3VycmVudCBwbGF5bGlzdCBpcyBlbmRlZFxyXG4gICAgICAgIGVycm9yXHRGaXJlcyB3aGVuIGFuIGVycm9yIG9jY3VycmVkIGR1cmluZyB0aGUgbG9hZGluZyBvZiBhbiBhdWRpby92aWRlb1xyXG4gICAgICAgIGxvYWRlZGRhdGFcdEZpcmVzIHdoZW4gdGhlIGJyb3dzZXIgaGFzIGxvYWRlZCB0aGUgY3VycmVudCBmcmFtZSBvZiB0aGUgYXVkaW8vdmlkZW9cclxuICAgICAgICBsb2FkZWRtZXRhZGF0YVx0RmlyZXMgd2hlbiB0aGUgYnJvd3NlciBoYXMgbG9hZGVkIG1ldGEgZGF0YSBmb3IgdGhlIGF1ZGlvL3ZpZGVvXHJcbiAgICAgICAgbG9hZHN0YXJ0XHRGaXJlcyB3aGVuIHRoZSBicm93c2VyIHN0YXJ0cyBsb29raW5nIGZvciB0aGUgYXVkaW8vdmlkZW9cclxuICAgICAgICBwYXVzZVx0RmlyZXMgd2hlbiB0aGUgYXVkaW8vdmlkZW8gaGFzIGJlZW4gcGF1c2VkXHJcbiAgICAgICAgcGxheVx0RmlyZXMgd2hlbiB0aGUgYXVkaW8vdmlkZW8gaGFzIGJlZW4gc3RhcnRlZCBvciBpcyBubyBsb25nZXIgcGF1c2VkXHJcbiAgICAgICAgcGxheWluZ1x0RmlyZXMgd2hlbiB0aGUgYXVkaW8vdmlkZW8gaXMgcmVhZHkgdG8gcGxheSBhZnRlciBoYXZpbmcgYmVlbiBwYXVzZWQgb3Igc3RvcHBlZCBmb3IgYnVmZmVyaW5nXHJcbiAgICAgICAgcHJvZ3Jlc3NcdEZpcmVzIHdoZW4gdGhlIGJyb3dzZXIgaXMgZG93bmxvYWRpbmcgdGhlIGF1ZGlvL3ZpZGVvXHJcbiAgICAgICAgcmF0ZWNoYW5nZVx0RmlyZXMgd2hlbiB0aGUgcGxheWluZyBzcGVlZCBvZiB0aGUgYXVkaW8vdmlkZW8gaXMgY2hhbmdlZFxyXG4gICAgICAgIHNlZWtlZFx0RmlyZXMgd2hlbiB0aGUgdXNlciBpcyBmaW5pc2hlZCBtb3Zpbmcvc2tpcHBpbmcgdG8gYSBuZXcgcG9zaXRpb24gaW4gdGhlIGF1ZGlvL3ZpZGVvXHJcbiAgICAgICAgc2Vla2luZ1x0RmlyZXMgd2hlbiB0aGUgdXNlciBzdGFydHMgbW92aW5nL3NraXBwaW5nIHRvIGEgbmV3IHBvc2l0aW9uIGluIHRoZSBhdWRpby92aWRlb1xyXG4gICAgICAgIHN0YWxsZWRcdEZpcmVzIHdoZW4gdGhlIGJyb3dzZXIgaXMgdHJ5aW5nIHRvIGdldCBtZWRpYSBkYXRhLCBidXQgZGF0YSBpcyBub3QgYXZhaWxhYmxlXHJcbiAgICAgICAgc3VzcGVuZFx0RmlyZXMgd2hlbiB0aGUgYnJvd3NlciBpcyBpbnRlbnRpb25hbGx5IG5vdCBnZXR0aW5nIG1lZGlhIGRhdGFcclxuICAgICAgICB0aW1ldXBkYXRlXHRGaXJlcyB3aGVuIHRoZSBjdXJyZW50IHBsYXliYWNrIHBvc2l0aW9uIGhhcyBjaGFuZ2VkXHJcbiAgICAgICAgdm9sdW1lY2hhbmdlXHRGaXJlcyB3aGVuIHRoZSB2b2x1bWUgaGFzIGJlZW4gY2hhbmdlZFxyXG4gICAgICAgIHdhaXRpbmdcdEZpcmVzIHdoZW4gdGhlIHZpZGVvIHN0b3BzIGJlY2F1c2UgaXQgbmVlZHMgdG8gYnVmZmVyIHRoZSBuZXh0IGZyYW1lXHJcblxyXG4gICAgICAgIGFib3J0XHJcbiAgICAgICAgY2FucGxheVxyXG4gICAgICAgIGNhbnBsYXl0aHJvdWdoXHJcbiAgICAgICAgZHVyYXRpb25jaGFuZ2VcclxuICAgICAgICBlbXB0aWVkXHJcbiAgICAgICAgZW5kZWRcclxuICAgICAgICBlcnJvclxyXG4gICAgICAgIGxvYWRlZGRhdGFcclxuICAgICAgICBsb2FkZWRtZXRhZGF0YVxyXG4gICAgICAgIGxvYWRzdGFydFxyXG4gICAgICAgIHBhdXNlXHJcbiAgICAgICAgcGxheVxyXG4gICAgICAgIHBsYXlpbmdcclxuICAgICAgICBwcm9ncmVzc1xyXG4gICAgICAgIHJhdGVjaGFuZ2VcclxuICAgICAgICBzZWVrZWRcclxuICAgICAgICBzZWVraW5nXHJcbiAgICAgICAgc3RhbGxlZFxyXG4gICAgICAgIHN1c3BlbmRcclxuICAgICAgICB0aW1ldXBkYXRlXHJcbiAgICAgICAgdm9sdW1lY2hhbmdlXHJcbiAgICAgICAgd2FpdGluZ1xyXG4gICAgICAgICovXHJcblxyXG5cclxuXHJcblxyXG4gICAgICAgIC8vIFNvLCBpdCBzaG91bGQgYWxzbyBiaW5kIHRoZSBldmVudCB0byB0aGUgY29udHJvbCwgc28gYSBsaXN0ZW5lciB3aWxsIGhlYXIgdGhhdC5cclxuXHJcbiAgICAgICAgLy8gQnV0IGRvZXMgdGhpcyBhcHBseSBpdHNlbGY/Pz9cclxuICAgICAgICB0aGlzLl9zdXBlci5hcHBseSh0aGlzLCBhKTtcclxuXHJcbiAgICAgICAgLy8gdGhlbiBpZiBpdCBhcHBlYXJzIGluIHRoZSBkb20gZXZlbnRzLCBhdHRhY2ggaXQuXHJcblxyXG4gICAgICAgIGlmIChzaWcgPT0gJ1tzLGZdJykge1xyXG4gICAgICAgICAgICB2YXIgZXZlbnRfbmFtZSA9IGFbMF07XHJcblxyXG4gICAgICAgICAgICAvLyBjaGFuZ2UgaXMgYWxzbyBhIERPTSBldmVudFxyXG4gICAgICAgICAgICAvLyAgdGhhdCdzIGEgdHJpY2t5IG9uZS5cclxuICAgICAgICAgICAgLy8gIHNob3VsZCBtYWtlIGl0IGVhc3kgdG8gbGlzdGVuIG91dCBmb3IgRE9NIGNoYW5nZXMuXHJcbiAgICAgICAgICAgIC8vIGxldCdzIGluY2x1ZGUgaXQgZm9yIHRoZSBtb21lbnQuXHJcblxyXG5cclxuXHJcbiAgICAgICAgICAgIGlmIChtYXBEb21FdmVudE5hbWVzW2FbMF1dKSB7XHJcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCd3ZSBoYXZlIGEgRE9NIGV2ZW50OiAnICsgZXZlbnRfbmFtZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGxpc3RlbmVyID0gdGhpcy5tYXBMaXN0ZW5lcnNbZXZlbnRfbmFtZV07XHJcbiAgICAgICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICB2YXIgZWwgPSB0aGlzLmdldCgnZG9tLmVsJyk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnZWwnICsgZWwpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghbGlzdGVuZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYSBzaW5nbGUgbGlzdGVuZXIgY2FsbGVkIHdoZW4gYSBib3VuZCBkb20gZXZlbnQgZmlyZXMuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICB0aGlzIHdpbGwgdGhlbiBzcGxpdCB1cCB0aGUgZXZlbnQgY2FsbHMgdG8gZXZlcnl0aGluZyB0aGF0IGlzIGxpc3RlbmluZyB0byB0aGlzLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmb3IgdGhlIERPTSBldmVudCBvbiB0aGUgb2JqZWN0LCB3ZSByYWlzZSB0aGUgZXZlbnQgb24gdGhlIGNvbnRyb2wuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lciA9IHRoaXMubWFwTGlzdGVuZXJzW2V2ZW50X25hbWVdID0gZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnZXZlbnRfbmFtZSBoZWFyZCAnICsgZXZlbnRfbmFtZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmFpc2luZyBhbiBldmVudCwgdGhlcmUgY291bGQgYmUgbXVsdGlwbGUgbGlzdGVuZXJzLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gIHdvdWxkIGJlIGdvb2QgdG8gZ2V0IGFuIGFycmF5IG9mIHdoYXQgdGhlIGxpc3RlbmVycyByZXR1cm5lZC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICBSZXR1cm4gZmFsc2UgaGVyZSBpZiBhbnkgb2YgdGhlbSByZXR1cm4gZmFsc2U/XHJcblxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzX3JhaXNlID0gdGhhdC5yYWlzZShldmVudF9uYW1lLCBlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3Jlc19yYWlzZScsIHJlc19yYWlzZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlbiBpZiBhbnkgcmVzdWx0cyBhcmUgZmFsc2UsIHdlIHJldHVybiBmYWxzZS5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYW55X2FyZV9mYWxzZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGMgPSAwLCBsID0gcmVzX3JhaXNlLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIWFueV9hcmVfZmFsc2UgJiYgYyA8IGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzX3JhaXNlW2NdID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbnlfYXJlX2ZhbHNlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMrKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdhbnlfYXJlX2ZhbHNlJywgYW55X2FyZV9mYWxzZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFueV9hcmVfZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV291bGQgbGlrZSB0byByZXNwb25kIHRvIHRoZSBldmVudC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICBFZyBpZiB0aGUgZG9tIGV2ZW50IGhhbmRsZXIgcmV0dXJucyBmYWxzZSwgaXQgd291bGQgYmUgZ29vZCB0byByZXR1cm4gZmFsc2UgaW4gdGhlIGxpc3RlbmVyLlxyXG5cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50X25hbWUsIGxpc3RlbmVyLCBmYWxzZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pLFxyXG5cclxuICAgIC8vIG5vdCByZWN1cnNpdmVcclxuICAgIC8vICBtYXliZSBjYWxsIGFjdGl2YXRlX2luZGl2aWR1YWw/XHJcblxyXG4gICAgLy9cclxuXHJcbiAgICAnYWN0aXZhdGUnOiBmdW5jdGlvbihlbCkge1xyXG5cclxuICAgICAgLy8gTmVlZCB0byBwcmV2ZW50IGFjdGl2YXRpb24gd2hpbGUgaXQncyBhY3RpdmF0aW5nIGFscmVhZHkuXHJcbiAgICAgIC8vIEZvciB0aGUgbW9tZW50LCBpdCB3b3VsZCB0YWtlIHF1aXRlIGEgbG90IG9mIGJvaWxlcnBsYXRlLlxyXG4gICAgICAvLyAgUGVyaGFwcyBzb21lIGZ1bmN0aW9uYWwgcHJvZ3JhbW1pbmcgd291bGQgc29sdmUgdGhhdC5cclxuXHJcbiAgICAgIC8vIE9yIGhhdmUgYW4gaW5uZXIgYWN0aXZhdGUgZnVuY3Rpb24uIEF0IGVhY2ggbGV2ZWwsIGl0IGNhbGxzIHRoZSBpbm5lciBmdW5jdGlvbiBpZiBuZWNlc3NhcnkuXHJcbiAgICAgIC8vICBBIHNpbXBsZSBmdW5jdGlvbiBsb2NraW5nIHN5c3RlbSwgd2hlcmUgaXQgb25seSBydW5zIGlmIG5vbi1hY3RpdmU/XHJcblxyXG4gICAgICAvLyBjb3VsZCBoYXZlIGEgbm9uLWFjdGl2ZSBmdW5jdGlvbiB3cmFwcGVyIHRoYXQgb25seSBydW5zIHRoZSBmdW5jdGlvbiBpZiB0aGUgY29udHJvbCBpcyBub24tYWN0aXZlLlxyXG4gICAgICAvLyAgT25seSBzZXQgYWN0aXZlIHRvIGJlIHRydWUgb24gQ29udHJvbC5cclxuXHJcblxyXG5cclxuXHJcbiAgICAgIC8vY29uc29sZS5sb2coJ2VuaCBjdHJsIGFjdGl2YXRlJyk7XHJcblxyXG4gICAgICBpZiAoIXRoaXMuX19hY3RpdmUpIHtcclxuICAgICAgICB0aGlzLl9fYWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICBpZiAoZWwpIHtcclxuICAgICAgICAgICAgdGhpcy5zZXQoJ2RvbS5lbCcsIGVsKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMucmVjX2Rlc2NfZW5zdXJlX2N0cmxfZWxfcmVmcygpO1xyXG5cclxuICAgICAgICAvL2NvbnNvbGUubG9nKCdhY3RpdmF0ZSAnICsgdGhpcy5faWQoKSk7XHJcbiAgICAgICAgLy8gYWN0aXZhdGUgY29udGVudCBjb250cm9scy5cclxuICAgICAgICAvL2NvbnNvbGUubG9nKCcxKSAnICsgdGhpcy5fLmNvbnRlbnQuX2Fyci5sZW5ndGgpO1xyXG5cclxuICAgICAgICAvLyBCdXQgaGF2ZSB0aGlzIGRvbmUgYmVmb3JlIGluaXRpYWxpemF0aW9uP1xyXG4gICAgICAgIC8vICBQcm9iYWJseSB3YW50IHRvIHVzZSBzb21lIHZhbHVlcyB0aGF0IGhhdmUgYmVlbiByZWFkIGluIGZvciBpbml0aWFsaXphdGlvbi5cclxuICAgICAgICAvLyAgIE1heSBkaXNhYmxlIHRoaXMgbGF0ZXIsIG9uY2UgdGhlIGRhdGEgaXMgYmVpbmcgcmVhZCBvbiBpbml0aWFsaXphdGlvbi5cclxuICAgICAgICB0aGlzLmFjdGl2YXRlX2RvbV9hdHRyaWJ1dGVzKCk7XHJcblxyXG5cclxuICAgICAgICAvL2NvbnNvbGUubG9nKCcyKSAnICsgdGhpcy5fLmNvbnRlbnQuX2Fyci5sZW5ndGgpO1xyXG5cclxuICAgICAgICB0aGlzLmFjdGl2YXRlX2NvbnRlbnRfY29udHJvbHMoKTtcclxuICAgICAgICAvL2NvbnNvbGUubG9nKCczKSAnICsgdGhpcy5fLmNvbnRlbnQuX2Fyci5sZW5ndGgpO1xyXG5cclxuICAgICAgICAvLyB0aGVuIGlzIHRoZXJlIGlzIGEgc2VsZWN0aW9uX3Njb3BlIGFzIHRydWUsIGNyZWF0ZSBhIG5ldyBTZWxlY3Rpb25fU2NvcGUgb2JqZWN0LCB0aGVuIHNldCBpdCBzbyB0aGF0IHN1YmNvbnRyb2xzIHBvaW50XHJcbiAgICAgICAgLy8gIHRvIGl0IHdpdGggdGhlaXIgc2VsZWN0aW9uX3Njb3BlIHByb3BlcnR5LlxyXG5cclxuICAgICAgICAvLyBzbyBhZnRlciB0aGUgZmllbGRzIGhhdmUgYmVlbiBzZXQgdXAuXHJcblxyXG4gICAgICAgIHRoaXMuYWN0aXZhdGVfY29udGVudF9saXN0ZW4oKTtcclxuICAgICAgICAvL2NvbnNvbGUubG9nKCc0KSAnICsgdGhpcy5fLmNvbnRlbnQuX2Fyci5sZW5ndGgpO1xyXG5cclxuICAgICAgICAvLyBBY3RpdmF0ZSBzdHlsZSBjaGFuZ2UgbGlzdGVuP1xyXG4gICAgICAgIC8vICBPciBnZW5lcmFsbHkgZG9tIGF0dHJpYnV0ZXMgY2hhbmdlIGxpc3Rlbj9cclxuXHJcbiAgICAgICAgdGhpcy5hY3RpdmF0ZV9vdGhlcl9jaGFuZ2VzX2xpc3RlbigpO1xyXG4gICAgICAgIC8vY29uc29sZS5sb2coJzUpICcgKyB0aGlzLl8uY29udGVudC5fYXJyLmxlbmd0aCk7XHJcbiAgICAgIH1cclxuXHJcblxyXG5cclxuXHJcbiAgICB9LFxyXG4gICAgJ2FjdGl2YXRlX290aGVyX2NoYW5nZXNfbGlzdGVuJzogZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgdmFyIHN0eWxlID0gdGhpcy5nZXQoJ2RvbS5hdHRyaWJ1dGVzLnN0eWxlJyk7XHJcblxyXG4gICAgICAgIGNvbnNvbGUubG9nKCdzdHlsZScsIHN0eWxlKTtcclxuXHJcbiAgICAgICAgc3R5bGUub24oJ2NoYW5nZScsIGZ1bmN0aW9uKGVfY2hhbmdlKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdzdHlsZSBjaGFuZ2UnLCBlX2NoYW5nZSk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAqL1xyXG4gICAgICAgIHZhciBkb21fYXR0cmlidXRlcyA9IHRoaXMuZ2V0KCdkb20uYXR0cmlidXRlcycpO1xyXG4gICAgICAgIC8vY29uc29sZS5sb2coJ2RvbV9hdHRyaWJ1dGVzJywgZG9tX2F0dHJpYnV0ZXMpO1xyXG5cclxuICAgICAgICB2YXIgZWwgPSB0aGlzLmdldCgnZG9tLmVsJyk7XHJcblxyXG4gICAgICAgIGRvbV9hdHRyaWJ1dGVzLm9uKCdjaGFuZ2UnLCBmdW5jdGlvbihlX2NoYW5nZSkge1xyXG4gICAgICAgICAgICB2YXIgcHJvcGVydHlfbmFtZSA9IGVfY2hhbmdlLm5hbWUsIGR2YWwgPSBlX2NoYW5nZS52YWx1ZTtcclxuXHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2RvbV9hdHRyaWJ1dGVzIGNoYW5nZScsIHByb3BlcnR5X25hbWUsIGR2YWwpO1xyXG5cclxuICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgaWYgKHByb3BlcnR5X25hbWUgPT0gJ3N0eWxlJykge1xyXG4gICAgICAgICAgICAgICAgLy8gbmVlZCB0byB1cGRhdGUgaXQgb24gdGhlIGVsZW1lbnQuXHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHRvZihkdmFsKSA9PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCBkdmFsKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKCdzdHlsZScsIGR2YWwudmFsdWUoKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocHJvcGVydHlfbmFtZSA9PSAnY2xhc3MnKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBuZWVkIHRvIHVwZGF0ZSBpdCBvbiB0aGUgZWxlbWVudC5cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAodG9mKGR2YWwpID09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIGR2YWwpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgZHZhbC52YWx1ZSgpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAqL1xyXG5cclxuICAgICAgICAgICAgLy8gSSB0aGluayB0aGlzIHdvcmtzIGJldHRlciwgMDIvMDUvMTRcclxuXHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3RvZihkdmFsKScsIHRvZihkdmFsKSk7XHJcblxyXG4gICAgICAgICAgICB2YXIgdF9kdmFsID0gdG9mKGR2YWwpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRfZHZhbCA9PSAnc3RyaW5nJyB8fCB0X2R2YWwgPT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgICAgIC8vZWwuc2V0QXR0cmlidXRlKCdzdHlsZScsIGR2YWwpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy9lbC5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgZHZhbC52YWx1ZSgpKTtcclxuXHJcbiAgICAgICAgICAgICAgICBkdmFsID0gZHZhbC52YWx1ZSgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoZWwpIHtcclxuICAgICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUocHJvcGVydHlfbmFtZSwgZHZhbCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIH0pO1xyXG5cclxuXHJcbiAgICB9LFxyXG4gICAgJ2FjdGl2YXRlX2NvbnRlbnRfbGlzdGVuJzogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgLy9jb25zb2xlLmxvZygnYWN0aXZhdGVfY29udGVudF9saXN0ZW4nKTtcclxuXHJcbiAgICAgICAgdmFyIGNvbnRlbnQgPSB0aGlzLmdldCgnY29udGVudCcpO1xyXG5cclxuICAgICAgICAvL2NvbnNvbGUubG9nKCcxKSBjb250ZW50Lmxlbmd0aCgpJywgY29udGVudC5sZW5ndGgoKSk7XHJcblxyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICB2YXIgY29udGV4dCA9IHRoaXMuX2NvbnRleHQ7XHJcbiAgICAgICAgdmFyIG1hcF9jb250cm9scyA9IGNvbnRleHQubWFwX2NvbnRyb2xzO1xyXG5cclxuXHJcbiAgICAgICAgY29udGVudC5vbignY2hhbmdlJywgZnVuY3Rpb24oZV9jaGFuZ2UpIHtcclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnYWN0aXZhdGVkIGNvbnRyb2wgY29udGVudCBjaGFuZ2UnKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBlbCA9IHRoYXQuZ2V0KCdkb20uZWwnKTtcclxuICAgICAgICAgICAgdmFyIHR5cGUgPSBlX2NoYW5nZS50eXBlO1xyXG5cclxuICAgICAgICAgICAgaWYgKHR5cGUgPT0gJ2luc2VydCcpIHtcclxuICAgICAgICAgICAgICAgIHZhciBpdGVtID0gZV9jaGFuZ2UuaXRlbTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgaXRlbURvbUVsID0gaXRlbS5nZXQoJ2RvbS5lbCcpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIG5lZWQgdG8gcmVuZGVyIHRoZSBpdGVtIElEIGluIHRoZXJlIHRvby5cclxuICAgICAgICAgICAgICAgIC8vdmFyIGlkID0gaXRlbS5faWQoKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIWl0ZW1Eb21FbCkge1xyXG4gICAgICAgICAgICAgICAgICBpZiAoY29udGV4dC5tYXBfZWxzW2l0ZW0uX2lkKCldKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaXRlbURvbUVsID0gY29udGV4dC5tYXBfZWxzW2l0ZW0uX2lkKCldO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCFpdGVtRG9tRWwpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbV90YWdfbmFtZSA9ICdkaXYnO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkdl90YWdfbmFtZSA9IGl0ZW0uZ2V0KCd0YWdfbmFtZScpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkdl90YWdfbmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgaXRlbV90YWdfbmFtZSA9IGR2X3RhZ19uYW1lLnZhbHVlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZW1wX2VsO1xyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW1fdGFnX25hbWUgPT0gJ2NpcmNsZScgfHwgaXRlbV90YWdfbmFtZSA9PSAnbGluZScgfHwgaXRlbV90YWdfbmFtZSA9PSAncG9seWxpbmUnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhbiBtYWtlIFNWRyBpbnNpZGUgYW4gZWxlbWVudCwgd2l0aCB0aGUgcmlnaHQgbmFtZXNwYWNlLlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRlbXBfc3ZnX2NvbnRhaW5lciA9IGVfY2hhbmdlLml0ZW0uX2NvbnRleHQuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBfc3ZnX2NvbnRhaW5lci5pbm5lckhUTUwgPSAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgdmVyc2lvbj1cIjEuMVwiPicgKyBlX2NoYW5nZS5pdGVtLmFsbF9odG1sX3JlbmRlcigpICsgJzwvc3ZnPic7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1Eb21FbCA9IHRlbXBfc3ZnX2NvbnRhaW5lci5jaGlsZE5vZGVzWzBdLmNoaWxkTm9kZXNbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vXHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wX2VsID0gZV9jaGFuZ2UuaXRlbS5fY29udGV4dC5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcF9lbC5pbm5lckhUTUwgPSBlX2NoYW5nZS5pdGVtLmFsbF9odG1sX3JlbmRlcigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtRG9tRWwgPSB0ZW1wX2VsLmNoaWxkTm9kZXNbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uXy5lbCA9IGl0ZW1Eb21FbDtcclxuICAgICAgICAgICAgICAgICAgICBlX2NoYW5nZS5pdGVtLnNldCgnZG9tLmVsJywgaXRlbURvbUVsKTtcclxuICAgICAgICAgICAgICAgICAgICBpdGVtLmFjdGl2ZSgpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2l0ZW1Eb21FbCcsIGl0ZW1Eb21FbCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgdF9pdGVtX2RvbV9lbCA9IHRvZihpdGVtRG9tRWwpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICh0X2l0ZW1fZG9tX2VsID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgICBpdGVtRG9tRWwgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShpdGVtRG9tRWwpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vZWwuaW5zZXJ0QmVmb3JlKGl0ZW1Eb21FbCwgZWwuY2hpbGROb2Rlc1swXSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnaXRlbScsIGl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygndGhhdCcsIHRoYXQpO1xyXG5cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIWVsKSB7XHJcbiAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJyoqKiB0aGF0Ll9pZCgpJywgdGhhdC5faWQoKSk7XHJcbiAgICAgICAgICAgICAgICAgIHRoYXQucGFyZW50KCkucGFyZW50KCkucmVjX2Rlc2NfZW5zdXJlX2N0cmxfZWxfcmVmcygpO1xyXG4gICAgICAgICAgICAgICAgICBlbCA9IGNvbnRleHQubWFwX2Vsc1t0aGF0Ll9pZCgpXTtcclxuICAgICAgICAgICAgICAgICAgdGhhdC5zZXQoJ2RvbS5lbCcsIGVsKTtcclxuICAgICAgICAgICAgICAgICAgdGhhdC5fLmVsID0gZWw7XHJcbiAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJyogZWwnLCBlbCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgICAgIGVsLmFwcGVuZENoaWxkKGl0ZW1Eb21FbCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gTWF5IG5vdCBoYXZlIGFjdHVhbGx5IGdvbmUgaW50byB0aGUgRE9NIHlldCFcclxuXHJcbiAgICAgICAgICAgICAgICAvL3NldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAvLyAgdGhhdC5yZWNfZGVzY19lbnN1cmVfY3RybF9lbF9yZWZzKCk7XHJcbiAgICAgICAgICAgICAgICAvLyAgaWYgKGl0ZW0uYWN0aXZhdGUpIGl0ZW0uYWN0aXZhdGUoKTtcclxuICAgICAgICAgICAgICAgIC8vfSwgMCk7XHJcblxyXG5cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgLy9pZiAoaXRlbS5yZWNfZGVzY19lbnN1cmVfY3RybF9lbF9yZWZzKSBpdGVtLnJlY19kZXNjX2Vuc3VyZV9jdHJsX2VsX3JlZnMoaXRlbURvbUVsKTtcclxuXHJcblxyXG5cclxuXHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAodHlwZSA9PSAnY2xlYXInKSB7XHJcbiAgICAgICAgICAgICAgICBlbC5pbm5lckhUTUwgPSAnJztcclxuICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vY29uc29sZS5sb2coJzIpIGNvbnRlbnQubGVuZ3RoKCknLCBjb250ZW50Lmxlbmd0aCgpKTtcclxuICAgIH0sXHJcblxyXG4gICAgJ3JlY19kZXNjX2Vuc3VyZV9jdHJsX2VsX3JlZnMnOiBmdW5jdGlvbihlbCkge1xyXG4gICAgICBlbCA9IGVsIHx8IHRoaXMuZ2V0KCdkb20uZWwnKSB8fCB0aGlzLl8uZWw7XHJcblxyXG4gICAgICAvL2lmICghZWwpIHtcclxuICAgICAgLy8gIGVsID0gdGhpcy5fY29udGV4dC5tYXBcclxuICAgICAgLy99XHJcblxyXG4gICAgICB2YXIgY29udGV4dCA9IHRoaXMuX2NvbnRleHQ7XHJcblxyXG5cclxuICAgICAgaWYgKGVsKSB7XHJcbiAgICAgICAgdmFyIGMsIGwsIGNucztcclxuXHJcblxyXG4gICAgICAgIHZhciBqc2d1aV9pZDtcclxuXHJcbiAgICAgICAgdmFyIG1hcF9lbHMgPSB7fTtcclxuXHJcbiAgICAgICAgZG9tX2Rlc2MoZWwsIGZ1bmN0aW9uKGVsKSB7XHJcbiAgICAgICAgICAvL2NvbnNvbGUubG9nKCdkb21fZGVzYyBlbCcsIGVsKTtcclxuICAgICAgICAgIGlmIChlbC5nZXRBdHRyaWJ1dGUpIHtcclxuICAgICAgICAgICAganNndWlfaWQgPSBlbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtanNndWktaWQnKTtcclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnZm91bmQganNndWlfaWQnLCBqc2d1aV9pZCk7XHJcblxyXG4gICAgICAgICAgICBpZiAoanNndWlfaWQpIHtcclxuXHJcbiAgICAgICAgICAgICAgLy9tYXBfY29udHJvbHNbanNndWlfaWRdID0gZWw7XHJcblxyXG4gICAgICAgICAgICAgIC8vIE1ha2UgYSBtYXAgb2YgZWxlbWVudHMuLi4/XHJcbiAgICAgICAgICAgICAgbWFwX2Vsc1tqc2d1aV9pZF0gPSBlbDtcclxuICAgICAgICAgICAgICBjb250ZXh0Lm1hcF9lbHNbanNndWlfaWRdID0gZWw7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgZGVzYyh0aGlzLCBmdW5jdGlvbihjdHJsKSB7XHJcbiAgICAgICAgICAvLyBlbnN1cmUgdGhlIGNvbnRyb2wgaXMgcmVnaXN0ZXJlZCB3aXRoIHRoZSBjb250ZXh0LlxyXG4gICAgICAgICAgLy9jb25zb2xlLmxvZygnZGVzYyBjdHJsJywgY3RybCk7XHJcblxyXG4gICAgICAgICAgdmFyIHRfY3RybCA9IHRvZihjdHJsKTtcclxuICAgICAgICAgIC8vY29uc29sZS5sb2coJ3RfY3RybCcsIHRfY3RybCk7XHJcblxyXG4gICAgICAgICAgaWYgKGN0cmwgIT09IHRoaXMgJiYgdF9jdHJsID09PSAnY29udHJvbCcpIHtcclxuICAgICAgICAgICAgdmFyIGlkID0gY3RybC5faWQoKTtcclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnaWQnLCBpZCk7XHJcblxyXG4gICAgICAgICAgICAvLyBTZWVtcyBsaWtlIGl0J3Mgbm90IGluIHRoZSBtYXAuXHJcblxyXG4gICAgICAgICAgICBpZiAobWFwX2Vsc1tpZF0pIHtcclxuICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdtYXBfZWxzW2lkXScsIG1hcF9lbHNbaWRdKTtcclxuXHJcbiAgICAgICAgICAgICAgY3RybC5zZXQoJ2RvbS5lbCcsIG1hcF9lbHNbaWRdKTtcclxuICAgICAgICAgICAgICBjdHJsLl8uZWwgPSBtYXBfZWxzW2lkXTtcclxuICAgICAgICAgICAgfVxyXG5cclxuXHJcblxyXG4gICAgICAgICAgICAvL2N0cmwuYWN0aXZhdGUoKTtcclxuXHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH0pO1xyXG5cclxuXHJcblxyXG4gICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgICdyZWNfZGVzY19hY3RpdmF0ZSc6IGZ1bmN0aW9uKCkge1xyXG4gICAgICBkZXNjKHRoaXMsIGZ1bmN0aW9uKGN0cmwpIHtcclxuICAgICAgICAvLyBlbnN1cmUgdGhlIGNvbnRyb2wgaXMgcmVnaXN0ZXJlZCB3aXRoIHRoZSBjb250ZXh0LlxyXG4gICAgICAgIC8vY29uc29sZS5sb2coJ2Rlc2MgY3RybCcsIGN0cmwpO1xyXG5cclxuICAgICAgICB2YXIgdF9jdHJsID0gdG9mKGN0cmwpO1xyXG5cclxuICAgICAgICBpZiAodF9jdHJsID09PSAnY29udHJvbCcpIHtcclxuXHJcblxyXG4gICAgICAgICAgY3RybC5hY3RpdmF0ZSgpO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICB9KTtcclxuICAgIH0sXHJcblxyXG4gICAgJ2FjdGl2YXRlX2NvbnRlbnRfY29udHJvbHMnOiBmdW5jdGlvbigpIHtcclxuICAgICAgLy8gVGhpcyBjb3VsZCBkbyB3aXRoIHNvbWUgZW5oYW5jZW1lbnQsIHNvIHRoYXQgaXQgYXV0b21hdGljYWxseSBkb2VzIGEgcmVjdXJzaXZlIGFjdGl2YXRpb24uXHJcbiAgICAgIC8vIGVuc3VyZSBjb250ZW50IGRvbSBlbCByZWZzXHJcbiAgICAgIC8vICByZWN1cnNpdmVseSBlbnN1cmVzIHRoZSBET00gbm9kZSByZWZlcmVuY2VzIGZvciB0aGUgZWxlbWVudHMgaW5zaWRlLlxyXG4gICAgICB2YXIgZWwgPSB0aGlzLmdldCgnZG9tLmVsJyk7XHJcblxyXG5cclxuXHJcbiAgICAgIGlmIChlbCkge1xyXG4gICAgICAgIHZhciBjb250ZXh0ID0gdGhpcy5fY29udGV4dDtcclxuXHJcbiAgICAgICAgdmFyIGN0cmxfZmllbGRzID0ge307XHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgIHZhciBjLCBsO1xyXG5cclxuICAgICAgICB2YXIgbXlfY29udGVudCA9IHRoaXMuZ2V0KCdjb250ZW50Jyk7XHJcblxyXG4gICAgICAgIHZhciBzdHJfY3RybF9maWVsZHMgPSBlbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtanNndWktY3RybC1maWVsZHMnKTtcclxuICAgICAgICBpZiAoc3RyX2N0cmxfZmllbGRzKSB7XHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3N0cl9jdHJsX2ZpZWxkcyAnICsgc3RyX2N0cmxfZmllbGRzKTtcclxuICAgICAgICAgICAgY3RybF9maWVsZHMgPSBKU09OLnBhcnNlKHN0cl9jdHJsX2ZpZWxkcy5yZXBsYWNlKC8nL2csICdcIicpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBjdHJsX2ZpZWxkc19rZXlzID0gT2JqZWN0LmtleXMoY3RybF9maWVsZHMpO1xyXG5cclxuICAgICAgICB2YXIgbF9jdHJsX2ZpZWxkc19rZXlzID0gY3RybF9maWVsZHNfa2V5cy5sZW5ndGg7XHJcbiAgICAgICAgdmFyIGtleSwgdmFsdWU7XHJcbiAgICAgICAgZm9yIChjID0gMDsgYyA8IGxfY3RybF9maWVsZHNfa2V5czsgYysrKSB7XHJcbiAgICAgICAgICBrZXkgPSBjdHJsX2ZpZWxkc19rZXlzW2NdO1xyXG4gICAgICAgICAgdmFsdWUgPSBjdHJsX2ZpZWxkc1trZXldO1xyXG5cclxuICAgICAgICAgIHZhciByZWZlcnJlZF90b19jb250cm9sID0gY29udGV4dC5tYXBfY29udHJvbHNbdmFsdWVdO1xyXG4gICAgICAgICAgLy9jb25zb2xlLmxvZygncmVmZXJyZWRfdG9fY29udHJvbCcsIHJlZmVycmVkX3RvX2NvbnRyb2wpO1xyXG4gICAgICAgICAgdGhhdC5zZXQoa2V5LCByZWZlcnJlZF90b19jb250cm9sKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vZWFjaChjdHJsX2ZpZWxkcywgZnVuY3Rpb24odiwgaSkge1xyXG4gICAgICAgICAgICAvL2ZpZWxkc19jdHJsLnNldChpLCB2KTtcclxuXHJcbiAgICAgICAgICAgIC8vZmllbGRzX2N0cmxbdl0gPSBpO1xyXG4gICAgICAgIC8vICAgIHZhciByZWZlcnJlZF90b19jb250cm9sID0gY29udGV4dC5tYXBfY29udHJvbHNbdl07XHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3JlZmVycmVkX3RvX2NvbnRyb2wnLCByZWZlcnJlZF90b19jb250cm9sKTtcclxuICAgICAgICAvLyAgICB0aGF0LnNldChpLCByZWZlcnJlZF90b19jb250cm9sKTtcclxuICAgICAgICAvL30pO1xyXG5cclxuXHJcbiAgICAgICAgdmFyIGNucyA9IGVsLmNoaWxkTm9kZXM7XHJcbiAgICAgICAgdmFyIGNvbnRlbnQgPSB0aGlzLmdldCgnY29udGVudCcpO1xyXG4gICAgICAgIC8vIEFkZGluZyB0aGUgY29udGVudCBhZ2Fpbj9cclxuICAgICAgICAvL2NvbnNvbGUubG9nKCdjbnMnLCBjbnMpO1xyXG4gICAgICAgIC8vY29uc29sZS5sb2coJ2Nucy5sZW5ndGgnLCBjbnMubGVuZ3RoKTtcclxuICAgICAgICBmb3IgKGMgPSAwLCBsID0gY25zLmxlbmd0aDsgYyA8IGw7IGMrKykge1xyXG4gICAgICAgICAgICB2YXIgY24gPSBjbnNbY107XHJcblxyXG4gICAgICAgICAgICBpZiAoY24pIHtcclxuICAgICAgICAgICAgICB2YXIgbnQgPSBjbi5ub2RlVHlwZTtcclxuICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCcqIG50ICcgKyBudCk7XHJcbiAgICAgICAgICAgICAgaWYgKG50ID09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgdmFyIGNuX2pzZ3VpX2lkID0gY24uZ2V0QXR0cmlidXRlKCdkYXRhLWpzZ3VpLWlkJyk7XHJcbiAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2NuX2pzZ3VpX2lkICcgKyBjbl9qc2d1aV9pZCk7XHJcbiAgICAgICAgICAgICAgICAgIHZhciBjY3RybCA9IGNvbnRleHQubWFwX2NvbnRyb2xzW2NuX2pzZ3VpX2lkXTtcclxuICAgICAgICAgICAgICAgICAgLy8gcXVpY2sgY2hlY2sgdG8gc2VlIGlmIHRoZSBjb250cm9sIGlzIG5vdCBhbHJlYWR5IHRoZXJlLlxyXG4gICAgICAgICAgICAgICAgICB2YXIgZm91bmQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgaWYgKGNjdHJsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgY3RybF9pZCA9IGNjdHJsLl9faWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCcqIGN0cmxfaWQnLCBjdHJsX2lkKTtcclxuICAgICAgICAgICAgICAgICAgICAgIGlmIChjdHJsX2lkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudC5lYWNoKGZ1bmN0aW9uKHYsIGkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHYuX19pZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHYuX19pZCA9PSBjdHJsX2lkKSBmb3VuZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoIWZvdW5kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG15X2NvbnRlbnQuYWRkKGNjdHJsKTtcclxuICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgIC8vY2N0cmwuYWN0aXZhdGUoKTtcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBpZiAobnQgPT0gMykge1xyXG4gICAgICAgICAgICAgICAgICAvLyB0ZXh0XHJcbiAgICAgICAgICAgICAgICAgIHZhciB2YWwgPSBjbi5ub2RlVmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3ZhbCAnICsgdmFsKTtcclxuICAgICAgICAgICAgICAgICAgY29udGVudC5wdXNoKHZhbCk7XHJcblxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnY24nLCBjbik7XHJcblxyXG4gICAgICAgICAgICAvLyB3ZSBjYW4gZ2V0IHRoZSBjdHJsIHJlZmVyZW5jZVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICB9XHJcbiAgICAgIHRoaXMucmVjX2Rlc2NfYWN0aXZhdGUoKTtcclxuICAgIH0sXHJcblxyXG4gICAgJ2FjdGl2YXRlX2RvbV9hdHRyaWJ1dGVzJzogZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICAgIC8vIE5lZWRzIHRvIGdldCB0aGUgY2xhc3Mgb3V0IG9mIHRoZSBET00gcHJvcGVybHkuXHJcblxyXG4gICAgICAgIC8vY29uc29sZS5sb2coJ2FjdGl2YXRlX2RvbV9hdHRyaWJ1dGVzJyk7XHJcblxyXG4gICAgICAgIHZhciBlbCA9IHRoaXMuZ2V0KCdkb20uZWwnKTtcclxuXHJcbiAgICAgICAgLy8gbWF5IG5vdCBoYXZlIGVsLi4uLj9cclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGRvbV9hdHRyaWJ1dGVzID0gdGhpcy5nZXQoJ2RvbS5hdHRyaWJ1dGVzJyk7XHJcblxyXG4gICAgICAgIGlmIChlbCkge1xyXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGF0dHJzID0gZWwuYXR0cmlidXRlcywgbCA9IGF0dHJzLmxlbmd0aDsgaSA8IGw7IGkrKyl7XHJcbiAgICAgICAgICAgICAgLy9hcnIucHVzaChhdHRycy5pdGVtKGkpLm5vZGVOYW1lKTtcclxuICAgICAgICAgICAgICB2YXIgaXRlbSA9IGF0dHJzLml0ZW0oaSk7XHJcbiAgICAgICAgICAgICAgdmFyIG5hbWUgPSBpdGVtLm5hbWU7XHJcbiAgICAgICAgICAgICAgdmFyIHZhbHVlID0gaXRlbS52YWx1ZTtcclxuXHJcbiAgICAgICAgICAgICAgaWYgKG5hbWUgPT0gJ2RhdGEtanNndWktaWQnKSB7XHJcbiAgICAgICAgICAgICAgICAgIC8vIEhhbmRsZWQgZWxzZXdoZXJlIC0gbm90IHNvIHN1cmUgaXQgc2hvdWxkIGJlIGJ1dCB3b24ndCBjaGFuZ2UgdGhhdCByaWdodCBub3cuXHJcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChuYW1lID09ICdkYXRhLWpzZ3VpLXR5cGUnKSB7XHJcbiAgICAgICAgICAgICAgICAgIC8vIF5cclxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5hbWUgPT0gJ3N0eWxlJykge1xyXG5cclxuICAgICAgICAgICAgICAgICAgdmFyIG1hcF9pbmxpbmVfY3NzID0gdGhpcy5faWNzcztcclxuXHJcbiAgICAgICAgICAgICAgICAgIHZhciBhcnJfc3R5bGVfaXRlbXMgPSB2YWx1ZS5zcGxpdCgnOycpO1xyXG4gICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdhcnJfc3R5bGVfaXRlbXMnLCBhcnJfc3R5bGVfaXRlbXMpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgLy9lYWNoKGFycl9zdHlsZV9pdGVtcylcclxuICAgICAgICAgICAgICAgICAgZm9yICh2YXIgYyA9IDAsIGwyID0gYXJyX3N0eWxlX2l0ZW1zLmxlbmd0aDsgYyA8IGwyOyBjKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgIC8vbWFwX2lubGluZV9jc3NbXVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgIHZhciBzdHlsZV9pdGVtID0gYXJyX3N0eWxlX2l0ZW1zW2NdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgLy92YXIgc3R5bGVfaXRlbV9uYW1lID1cclxuICAgICAgICAgICAgICAgICAgICAgIHZhciBhcnJfc3R5bGVfaXRlbSA9IHN0eWxlX2l0ZW0uc3BsaXQoJzonKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoYXJyX3N0eWxlX2l0ZW1bMF0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBtYXBfaW5saW5lX2Nzc1thcnJfc3R5bGVfaXRlbVswXV0gPSBhcnJfc3R5bGVfaXRlbVsxXTtcclxuICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIC8vfSBlbHNlIGlmIChuYW1lID09ICdkYXRhLWpzZ3VpLWZpZWxkcycpIHtcclxuICAgICAgICAgICAgICAgIC8vIFNob3VsZCBwcm9iYWJseSByZWx5IG9uIHVzaW5nIGluaXQgYSBsb3QgbW9yZSBub3cuXHJcblxyXG5cclxuICAgICAgICAgICAgICAvLyAgICB2YXIgc3RyX3Byb3BlcnRpZXMgPSB2YWx1ZTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gICAgaWYgKHN0cl9wcm9wZXJ0aWVzKSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vICAgIH1cclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAvLyBzZXQgdGhlIGRvbSBhdHRyaWJ1dGVzIHZhbHVlLi4uIHNpbGVudCBzZXQ/XHJcblxyXG4gICAgICAgICAgICAgICAgICBkb21fYXR0cmlidXRlcy5zZXQobmFtZSwgdmFsdWUpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgJ2hpZGUnOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAvLyBzZXQgdGhlIHN0eWxlIHRvIGhpZGRlbi5cclxuICAgICAgICAvLyAgQ291bGQgYWRkIGEgaGlkZGVuIGNsYXNzLlxyXG5cclxuICAgICAgICAvLyAgSSB0aGluayBhIHZhcmlldHkgb2YgdGVzdHMgb24gc3R5bGluZyB3b3VsZCBtYWtlIHNlbnNlLlxyXG5cclxuICAgICAgICAvLyBXYW50IHRvIHNldCBzdHlsZXMgd2l0aCBlYXN5IHN5bnRheC5cclxuXHJcbiAgICAgICAgLy8gY3RybC5zdHlsZShzdHlsZV9uYW1lLCB2YWx1ZSk7XHJcbiAgICAgICAgLy8gIEkgdGhpbmsgdGhlIENvbnRyb2wgbmVlZHMgdG8gbWFpbnRhaW4gaXRzIG93biBkaWN0IG9yIGRhdGEgc3RydWN0dXJlIG9mIGl0cyBpbmxpbmUgc3R5bGVzLlxyXG4gICAgICAgIC8vICAgVGhlc2UgY291bGQgZ2V0IHJlbmRlcmVkIGRpZmZlcmVudGx5IHRvIGRvbS5hdHRyaWJ1dGVzLnN0eWxlLlxyXG5cclxuICAgICAgICAvLyBPciwgdGhlIGRvbS5zdHRyaWJ1dGVzLnN0eWxlIGdldHMgcHJvZHVjdGVkIGZyb20gdGhlIGpzZ3VpIHN0eWxlcyB0aGF0IGFyZSBzZXQuXHJcbiAgICAgICAgLy8gIFRoZXNlIHN0eWxlcyBjb3VsZCBhbHNvIG9wZXJhdGUgYSBiaXQgZGlmZmVyZW50bHksIG9yIGJlIHJlbmRlcmVkIGRpZmZlcmVudGx5IHRvIGFjY291bnQgZm9yIGJyb3dzZXIgZGlmZmVyZWNlcy5cclxuICAgICAgICAvLyBFZyB3aXRoIHJvdW5kZWQgY29ybmVycywgY291bGQgdXNlIGEgcG9seWZpbGwgZm9yIGVhcmxpZXIgYnJvd3NlcnMuXHJcblxyXG4gICAgICAgIC8vIFdpbGwgaW50ZXJhY3Qgd2l0aCBkb20uYXR0cmlidXRlcy5zdHlsZS5cclxuXHJcbiAgICAgICAgLy8gV2hlbiBhY3RpdmUsIG5lZWRzIHRvIHJlc3BvbmQgdG8gY2hhbmdlcyBpbiBkb20uYXR0cmlidXRlcyBldGNcclxuICAgICAgICAvLyAgV2lsbCBuZWVkIHRvIGxpc3RlbiBmb3IgdGhvc2UgY2hhbmdlcyBhbmQgcmUtcmVuZGVyIGFzIGFwcHJvcHJpYXRlLlxyXG5cclxuXHJcbiAgICAgICAgdGhpcy5hZGRfY2xhc3MoJ2hpZGRlbicpO1xyXG4gICAgICAgIC8vIFByb2JhYmx5IG5lZWRzIGEgbG93ZXIgbGV2ZWwgaW5kZXggLyBzeXN0ZW0gb2YgbWFpbnRhaW5pbmcgdGhlIGNsYXNzZXMgLSB0aGluayBpdCBoYXMgb25lIG5vdyBhcHIgMjAxNFxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuICAgIH0sXHJcbiAgICAnc2hvdyc6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIC8vY29uc29sZS5sb2coJ3Nob3cnKTtcclxuXHJcbiAgICAgICAgdGhpcy5yZW1vdmVfY2xhc3MoJ2hpZGRlbicpO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgJ2Rlc2NlbmRhbnRzJzogZnVuY3Rpb24oc2VhcmNoKSB7XHJcbiAgICAgICAgLy8gYXNzZW1ibGVzIGEgbGlzdCBvZiB0aGUgZGVzY2VuZGVudHMgdGhhdCBtYXRjaCB0aGUgc2VhcmNoXHJcbiAgICAgICAgLy8gIChzZWFyY2ggYnkgLl9fdHlwZV9uYW1lKVxyXG5cclxuICAgICAgICAvLyBlZyBnZXQgYSBsaXN0IG9mIG1lbnVfbm9kZSBvYmplY3RzLlxyXG5cclxuICAgICAgICAvLyBiYXNpY2FsbHkgbmVlZCB0byByZWN1cnNpdmVseSBnbyB0aHJvdWdoIHRoZSBkZXNjZW5kZW50cywgd2l0aCBhIGNhbGxiYWNrIGluIGhlcmUsIGFuZCBzZWUgaWYgdGhleSBtYXRjaCB0aGUgc2VhcmNoLlxyXG5cclxuICAgICAgICAvLyByZWN1cnNpdmUgaXRlcmF0aW9uIG9mIHRoZSBjb250cm9sKHMpXHJcblxyXG4gICAgICAgIHZhciByZWN1cnNpdmVfaXRlcmF0ZSA9IGZ1bmN0aW9uKGN0cmwsIGl0ZW1fY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgLy8gY2FsbGJhY2sgb24gYWxsIG9mIHRoZSBjaGlsZCBjb250cm9scywgYW5kIHRoZW4gaXRlcmF0ZSB0aG9zZS5cclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygncmVjdXJzaXZlX2l0ZXJhdGUnKTtcclxuICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSBjdHJsLmdldCgnY29udGVudCcpO1xyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdjb250ZW50JywgY29udGVudCk7XHJcblxyXG4gICAgICAgICAgICB2YXIgdF9jb250ZW50ID0gdG9mKGNvbnRlbnQpO1xyXG5cclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygndF9jb250ZW50JywgdF9jb250ZW50KTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0X2NvbnRlbnQgPT0gJ2NvbGxlY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29udGVudC5sZW5ndGgoKSA+IDApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnY29udGVudC5sZW5ndGgoKScsIGNvbnRlbnQubGVuZ3RoKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGl0ZXJhdGUgdGhyb3VnaCB0aG9zZSBjaGlsZCBub2RlcyBhcyB3ZWxsLlxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQuZWFjaChmdW5jdGlvbihpdGVtLCBpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2l0ZW0nLCBpdGVtKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbV9jYWxsYmFjayhpdGVtKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVjdXJzaXZlX2l0ZXJhdGUoaXRlbSwgaXRlbV9jYWxsYmFjayk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBhcnJfbWF0Y2hpbmcgPSBbXTtcclxuXHJcbiAgICAgICAgcmVjdXJzaXZlX2l0ZXJhdGUodGhpcywgZnVuY3Rpb24oaXRlbSkge1xyXG4gICAgICAgICAgICAvLyBzZWUgaWYgdGhlIGl0ZW0gbWF0Y2hlcyB0aGUgc2VhcmNoXHJcblxyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdjYiBpdGVtJywgaXRlbSk7XHJcbiAgICAgICAgICAgIHZhciBpdGVtX3R5cGUgPSBpdGVtLl9fdHlwZV9uYW1lO1xyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdpdGVtX3R5cGUnLCBpdGVtX3R5cGUpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGl0ZW1fdHlwZSA9PSBzZWFyY2gpIHtcclxuICAgICAgICAgICAgICAgIGFycl9tYXRjaGluZy5wdXNoKGl0ZW0pO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy9yZXR1cm4gY3RybF9wYXJlbnQuYW5jZXN0b3Ioc2VhcmNoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vY29uc29sZS5sb2coJ2Fycl9tYXRjaGluZycsIGFycl9tYXRjaGluZyk7XHJcbiAgICAgICAgcmV0dXJuIGFycl9tYXRjaGluZztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgICdhbmNlc3Rvcic6IGZ1bmN0aW9uKHNlYXJjaCkge1xyXG4gICAgICAgIC8vIGNvdWxkIG1heWJlIHdvcmsgd2hlbiBub3QgYWN0aXZhdGVkIHRvby4uLlxyXG4gICAgICAgIC8vIG5lZWQgdG8gZ2V0IHRoZSBhbmNlc3RvciBjb250cm9sIG1hdGNoaW5nIHRoZSBzZWFyY2ggKGluIHR5cGUpLlxyXG5cclxuICAgICAgICBpZiAodGhpcy5fcGFyZW50KSB7XHJcbiAgICAgICAgICAgIHZhciBjdHJsX3BhcmVudCA9IHRoaXMuX3BhcmVudC5fcGFyZW50O1xyXG4gICAgICAgICAgICAvLyB0aGUgX3BhcmVudCBpcyBhIENvbGxlY3Rpb24gd2l0aGluIHRoZSBwYXJlbnQgQ29udHJvbFxyXG5cclxuICAgICAgICAgICAgaWYgKCFjdHJsX3BhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2N0cmxfcGFyZW50JywgY3RybF9wYXJlbnQpO1xyXG4gICAgICAgICAgICAgICAgLy8gZG9lcyB0aGUgcGFyZW50IG1hdGNoIHRoZSB0eXBlP1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBwYXJlbnRfdHlwZSA9IGN0cmxfcGFyZW50Ll9fdHlwZV9uYW1lO1xyXG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygncGFyZW50X3R5cGUnLCBwYXJlbnRfdHlwZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudF90eXBlID09IHNlYXJjaCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjdHJsX3BhcmVudDtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN0cmxfcGFyZW50LmFuY2VzdG9yKHNlYXJjaCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgJ2NvbnRleHRfbWVudSc6IGZwKGZ1bmN0aW9uKGEsIHNpZykge1xyXG5cclxuICAgICAgICAvLyBXaGF0IHRvIGRvIGhlcmUgZGVwZW5kcyBvbiB0aGUgY29udHJvbCBsaWZlY3ljbGUgc3RhZ2UuXHJcbiAgICAgICAgLy8gIE9uIHRoZSBzZXJ2ZXJcclxuICAgICAgICAvLyAgIFdhbnQgaXQgdG8gYmUgc2VudCB0byB0aGUgY2xpZW50IHNvIHRoYXQgaXQgYXV0b21hdGljYWxseSBnZXRzIGFjdGl2YXRlZCB3aXRoIHRoYXQgY29udGV4dCBtZW51LlxyXG4gICAgICAgIC8vICAgIFdvdWxkIG5vdCBiZSBhYmxlIHRvIGNhbGwgY2FsbGJhY2tzIHRoYXQgZ2V0IGdpdmVuIHdoZW4gdGhlIGZ1bmN0aW9uIGdldHMgc2V0IHVwLlxyXG4gICAgICAgIC8vICAgIFdvdWxkIG5lZWQgdG8gaGF2ZSBVSSByZXNwb25zZXMgaGFuZGxlZCBvbiBhY3RpdmF0aW9uLCBidXQgYXQgbGVhc3QgdGhlIG1lbnUgaXRzZWxmIGNvdWxkIGJlIHNldCB1cCBhdCBhbiBlYXJsaWVyIHN0YWdlLlxyXG4gICAgICAgIC8vICBPbiB0aGUgY2xpZW50XHJcbiAgICAgICAgLy8gICBQcmUtYWN0aXZhdGlvblxyXG4gICAgICAgIC8vICAgID8/V29uJ3QgZG8gdGhhdCBmb3IgdGhlIG1vbWVudC4gQ291bGQgbWF5YmUgcmFpc2UgYW4gZXJyb3JcclxuICAgICAgICAvLyAgICBTZXQgcHJvcGVydGllcyBzbyB0aGF0IHdoZW4gaXQgZ2V0cyBhY3RpdmF0ZWQgaXQga25vd3MgdG8gYWN0aXZhdGUgaXQgd2l0aCB0aGUgY29udGV4dCBtZW51LlxyXG4gICAgICAgIC8vICAgUG9zdC9kdXJpbmcgYWN0aXZhdGlvblxyXG5cclxuXHJcblxyXG4gICAgICAgIC8vIFNvIGZhciwgdGhpcyBzZWVtcyB0byBiZSBmb3IgcG9zdC1hY3RpdmF0aW9uLlxyXG4gICAgICAgIC8vICBPbiB0aGUgc2VydmVyLCB3ZSB3YW50IGl0IHNvIHRoYXQgdGhlIHByb3BlcnRpZXMgZ2V0IHNlbnQgb3ZlciB0byB0aGUgY2xpZW50LlxyXG4gICAgICAgIC8vICAgSSB0aGluayB0aGF0IGNvdWxkIGRvIHdpdGggbW9yZSB3b3JrLlxyXG4gICAgICAgIC8vICAgTWFraW5nIGl0IHNvIHRoYXQgcHJvcGVydGllcyBpbiBnZW5lcmFsLCBhbmQgYmVoYXZpb3VycywgY2FuIGJlIHNlbnQgdG8gdGhlIGNsaWVudCBhbmQgYWN0aXZhdGVkIHRoZXJlLlxyXG5cclxuICAgICAgICAvLyBJdCBzZWVtcyBsaWtlIHNvbWUgbW9yZSBnZW5lcmFsaXphdGlvbiBpcyBuZWVkZWQgaW4gaG93IGRhdGEgZ2V0cyB0cmFuc2ZlcnJlZCB0byB0aGUgY2xpZW50P1xyXG4gICAgICAgIC8vIFRoZXJlIGFyZSB0aGUgZmllbGRzIHdoaWNoIGdldCBzZW50LCBhbmQgdGhlcmUgYXJlIGN0cmwtZmllbGRzXHJcbiAgICAgICAgLy8gIEZpZWxkcyBnZXQgc2V0LCBob3dldmVyIHRoZXkgZG9uJ3QgaW5mbHVlbmNlIGJlaGF2aW91cnMuXHJcblxyXG4gICAgICAgIC8vIE1lY2hhbmlzbSBmb3IgZnVuY3Rpb24gY2FsbHMgdXBvbiBhY3RpdmF0aW9uLlxyXG4gICAgICAgIC8vICBQb3NzaWJseSBiZWhhdmlvdXJzXHJcbiAgICAgICAgLy8gIG9yIGpzZ3VpLWFjdGl2YXRlPVwiY29udGV4dF9tZW51KHBhcmFtcylcIlxyXG4gICAgICAgIC8vICAgU28gYWN0dWFsbHkgaGF2aW5nIGZ1bmN0aW9uIGNhbGxzIHRoZXJlLlxyXG4gICAgICAgIC8vICAgIENhbGxpbmcgZnVuY3Rpb25zIG9uIHRoZSBjb250cm9scyB1cG9uIGFjdGl2YXRpb24sIGFzIHNwZWNpZmllZCBieSBwYXJhbWV0ZXJzIG9uIHRoZSBzZXJ2ZXIuXHJcblxyXG4gICAgICAgIC8vIEFsc28sIGJldHRlciBtZWNoYW5pc20gZm9yIHNldHRpbmcgZmllbGRzIGFuZCBjdHJsLWZpZWxkcy5cclxuICAgICAgICAvLyAgTmVlZCBhIGJpdCBvZiBiZWhpbmQgdGhlIHNjZW5lcyBwcm9jZXNzaW5nIHRvIG1ha2Ugc29tZXRoaW5nIHdvcmsgYmV0d2VlbiBib3RoIHRoZSBzZXJ2ZXIgYW4gdGhlIGNsaWVudHMuXHJcbiAgICAgICAgLy8gIFNldHRpbmcgZmllbGRzIGFuZCBiZWhhdmlvdXJzIG9uIHRoZSBzZXJ2ZXIgdGhhdCBkZXRlcm1pbmUgaG93IGl0IGdldHMgYWN0aXZhdGVkIG9uIHRoZSBjbGllbnQgbWFrZXMgc2Vuc2UuXHJcblxyXG4gICAgICAgIC8vIGpRdWVyeSAvIENTUyBsaWtlIHNlbGVjdG9ycyBmb3Igc2VsZWN0aW5nIGFuZCBmaW5kaW5nIGNvbnRyb2xzIHdpdGhpbiBlYWNoIG90aGVyIHdpbGwgYWxzbyBtYWtlIHNlbnNlLlxyXG4gICAgICAgIC8vICBTbyBmb3IgYWN0aXZhdGluZyBjb250cm9scyB3aXRoaW4gYW5vdGhlciBjb250cm9sLCBpdCB3aWxsIGJlIGZhc3QgdG8gZmluZCB0aGUgdmFyaW91cyBjb250cm9scyB0byBiZSBhY3RpdmF0ZWQuXHJcblxyXG5cclxuICAgICAgICAvLyBkYXRhLWpzZ3VpLWNhbGwtb24tYWN0aXZhdGVcclxuICAgICAgICAvLyBkYXRhLWpzZ3VpLWFjdGl2YXRlXHJcbiAgICAgICAgLy8gZGF0YS1qc2d1aS1jYWxsXHJcbiAgICAgICAgLy8gIEZ1bmN0aW9ucyBmb3IgaXQgdG8gY2FsbCBvbiB0aGUgY2xpZW50LlxyXG4gICAgICAgIC8vICAgSW50ZXJwcmV0cyB0aGUgZnVuY3Rpb25zLCBjYWxscyB0aGVtLlxyXG4gICAgICAgIC8vICAgU28gYSBjb250ZXh0IG1lbnUgdGhhdCdzIHNwZWNpZmllZCBvbiB0aGUgc2VydmVyIGNvdWxkIGJlIHNlbnQgYWxvbmcgdG8gdGhlIGNsaWVudC5cclxuXHJcbiAgICAgICAgLy8gQ29udHJvbCBoYXZpbmcgZXh0cmEgZnVuY3Rpb25hbGl0eSB0byBhZGQgYW5kIHJlbW92ZSB0aGUgdmFsdWVzIHRoYXQgd2lsbCBnZXQgc2VudCB0byB0aGUgY2xpZW50LlxyXG4gICAgICAgIC8vICBXaWxsIGhhdmUgdmFyaW91cyBtYXAgb2JqZWN0cyBvZiBkYXRhIHNlbnQgdG8gdGhlIGNsaWVudCAobWF5YmUgbGlzdC9hcnJheSBpbnN0ZWFkPylcclxuXHJcbiAgICAgICAgLy8gRGVhbGluZyB3aXRoIG1hcHMgb2YgZGF0YSB0byBiZSBzZW50IHRvIHRoZSBjbGllbnQuXHJcbiAgICAgICAgLy8gIE5lZWQgc29tZXRoaW5nIGZvciByZW5kZXJpbmcgdGhpcz9cclxuICAgICAgICAvLyAgSnVzdCB1c2UgdGhlIG5vcm1hbCBkb20gYXR0cmlidXRlcz9cclxuXHJcbiAgICAgICAgLy8gV2FudCB3YXlzIG9mIHJlZmVycmluZyB0byBKU09OIG9iamVjdHMgd2l0aGluIHRoZSBET00gYXR0cmlidXRlcy5cclxuICAgICAgICAvLyAgSXQgc291bmRzIGxpa2UgdGhlIGRhdGEgdHlwZSBhbmQgZmllbGQgc3lzdGVtcyBzaG91bGQgaGFuZGxlIHRoaXMgd2hlcmUgcG9zc2libGUuXHJcblxyXG4gICAgICAgIC8vLnNldCgnYWN0aXZlLmNvbnRleHRfbWVudScsIHsuLi59KVxyXG4gICAgICAgIC8vICBTbyBjaGFuZ2VzIHRvIHRoZSBhY3RpdmUgZmllbGQsIG9uIHRoZSBzZXJ2ZXIsIGNhdXNlIGNoYW5nZXMgdG8gZG9tLmF0dHJpYnV0ZXMuanNndWktYWN0aXZlXHJcblxyXG4gICAgICAgIC8vLmFjdGl2ZSh7J2NvbnRleHRfbWVudSc6IHsuLi59fSlcclxuXHJcblxyXG4gICAgICAgIHZhciBtZW51X2RlZjtcclxuICAgICAgICBpZiAoc2lnID09ICdbb10nIHx8IHNpZyA9PSAnW2FdJykge1xyXG4gICAgICAgICAgICBtZW51X2RlZiA9IGFbMF07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgQ29udGV4dF9NZW51ID0gQ29udGV4dF9NZW51IHx8IHJlcXVpcmUoJy4vY29udHJvbHMvYWR2YW5jZWQvY29udGV4dC1tZW51Jyk7XHJcblxyXG4gICAgICAgIHZhciBjb250ZXh0X21lbnU7XHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG5cclxuICAgICAgICAvLyBOZWVkIGl0IHNvIHRoYXQgdGhlIGNvbnRleHQgbWVudSBnZXRzIHJlbW92ZWQgd2hlbiBpdCBzaG91bGQuXHJcbiAgICAgICAgLy8gIEFueSBtb3VzZXVwIGV2ZW50IGNhdXNlcyBpdCB0byB2YW5pc2guXHJcblxyXG4gICAgICAgIHZhciBib2R5ID0gdGhpcy5fY29udGV4dC5ib2R5KCk7XHJcblxyXG4gICAgICAgIC8vdmFyIGN0cmxfaHRtbF9yb290ID0gdGhpcy5fY29udGV4dC5jdHJsX2RvY3VtZW50O1xyXG5cclxuICAgICAgICAvL2NvbnNvbGUubG9nKCdjdHJsX2h0bWxfcm9vdCcsIGN0cmxfaHRtbF9yb290KTtcclxuXHJcbiAgICAgICAgLy92YXIgYm9keSA9IGN0cmxfaHRtbF9yb290LmJvZHkoKTtcclxuXHJcbiAgICAgICAgdmFyIHNob3dfY29udGV4dF9tZW51ID0gZnAoZnVuY3Rpb24oYSwgc2lnKSB7XHJcblxyXG5cclxuICAgICAgICAgICAgdmFyIHBvcztcclxuXHJcblxyXG4gICAgICAgICAgICBpZiAoc2lnID09ICdbYV0nKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBBIHBvc2l0aW9uP1xyXG5cclxuICAgICAgICAgICAgICAgIHBvcyA9IGFbMF07XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdzaG93X2NvbnRleHRfbWVudSBwb3M6JywgcG9zKTtcclxuXHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3Nob3dfY29udGV4dF9tZW51Jyk7XHJcblxyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdDb250ZXh0X01lbnUnLCBDb250ZXh0X01lbnUpO1xyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdjb250ZXh0X21lbnUnLCBjb250ZXh0X21lbnUpO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFjb250ZXh0X21lbnUpIHtcclxuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2NyZWF0aW5nIG5ldyBjb250ZXh0IG1lbnUnKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdtZW51X2RlZicsIG1lbnVfZGVmKTtcclxuXHJcbiAgICAgICAgICAgICAgICBjb250ZXh0X21lbnUgPSBuZXcgQ29udGV4dF9NZW51KHtcclxuICAgICAgICAgICAgICAgICAgICAnY29udGV4dCc6IHRoYXQuX2NvbnRleHQsXHJcbiAgICAgICAgICAgICAgICAgICAgJ3ZhbHVlJzogbWVudV9kZWZcclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChwb3MpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0X21lbnUuc3R5bGUoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnbGVmdCc6IChwb3NbMF0gLSAxKSArICdweCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICd0b3AnOiAocG9zWzFdIC0gMSkgKyAncHgnXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0X21lbnUuc3R5bGUoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnbGVmdCc6ICcxMDBweCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICd0b3AnOiAnMTAwcHgnXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGNvbnRleHQgPSB0aGF0Ll9jb250ZXh0O1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChwb3MpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0X21lbnUuc3R5bGUoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnbGVmdCc6IChwb3NbMF0gLSAxKSArICdweCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICd0b3AnOiAocG9zWzFdIC0gMSkgKyAncHgnXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0X21lbnUuc3R5bGUoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnbGVmdCc6ICcxMDBweCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICd0b3AnOiAnMTAwcHgnXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcclxuXHJcbiAgICAgICAgICAgICAgICBib2R5LmFkZChjb250ZXh0X21lbnUpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3ByZSBhY3RpdmF0ZSBjb250ZXh0X21lbnUuXy5jb250ZW50Ll9hcnIubGVuZ3RoICcgKyBjb250ZXh0X21lbnUuXy5jb250ZW50Ll9hcnIubGVuZ3RoKTtcclxuXHJcbiAgICAgICAgICAgICAgICBjb250ZXh0X21lbnUuYWN0aXZhdGUoKTtcclxuXHJcbiAgICAgICAgICAgICAgICBjb250ZXh0X21lbnUub25lX21vdXNlZG93bl9hbnl3aGVyZShmdW5jdGlvbihlX21vdXNlZG93bikge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2VfbW91c2Vkb3duLndpdGhpbl90aGlzICcgKyBlX21vdXNlZG93bi53aXRoaW5fdGhpcyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghZV9tb3VzZWRvd24ud2l0aGluX3RoaXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dF9tZW51LnJlbW92ZSgpO1xyXG5cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1heWJlIG9wZW4gYSBuZXcgbGV2ZWwuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBbmQgbmVlZCB0byBjYWxsIHRoZSByZWxldmFudCBjb250ZXh0IG1lbnUgZnVuY3Rpb24uXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnZV9tb3VzZWRvd24nLCBlX21vdXNlZG93bik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZWxfdGFyZ2V0ID0gZV9tb3VzZWRvd24udGFyZ2V0O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHRhcmdldCBjb250cm9sIHdpbGwgaGF2ZSBhIGpzZ3VpIGlkIG5vdy5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gIHdlIHNob3VsZCBiZSBhYmxlIHRvIHRoZW4gZ28gdG8gaXRzIHBhcmVudCBhbmQgZ2V0IGl0cyBtZW51IG5vZGUuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29udGV4dCA9IHRoYXQuX2NvbnRleHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdjb250ZXh0JywgY29udGV4dCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0X2lkID0gZWxfdGFyZ2V0LmdldEF0dHJpYnV0ZSgnZGF0YS1qc2d1aS1pZCcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygndGFyZ2V0X2lkJywgdGFyZ2V0X2lkKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdHJsX3RhcmdldCA9IGNvbnRleHQubWFwX2NvbnRyb2xzW3RhcmdldF9pZF07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnY3RybF90YXJnZXQnLCBjdHJsX3RhcmdldCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3YW50IHRvIGJlIGFibGUgdG8gZ2V0IGFuIGFuY2VzdG9yIG9mIHR5cGUgbWVudS1ub2RlXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWVudV9ub2RlID0gY3RybF90YXJnZXQuYW5jZXN0b3IoJ21lbnVfbm9kZScpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnbWVudV9ub2RlJywgbWVudV9ub2RlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuZCByYWlzZSB0aGUgbWVudV9ub2RlIHNlbGVjdCBldmVudC5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lbnVfbm9kZS5yYWlzZSgnc2VsZWN0Jyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0X21lbnUucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIH0sIDApO1xyXG5cclxuICAgICAgICB9KTtcclxuXHJcblxyXG5cclxuICAgICAgICAvLyBSZXNwb25kIHRvIHJpZ2h0IGNsaWNrcyBvbmx5LlxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgdGhpcy5vbignY2xpY2snLCBmdW5jdGlvbihlX2NsaWNrKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdlX2NsaWNrJywgZV9jbGljayk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAqL1xyXG5cclxuICAgICAgICB0aGlzLm9uKCdjb250ZXh0bWVudScsIGZ1bmN0aW9uKGVfY29udGV4dG1lbnUpIHtcclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnZV9jb250ZXh0bWVudScsIGVfY29udGV4dG1lbnUpO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2VfY2xpY2snLCBlX2NsaWNrKTtcclxuICAgICAgICB9KVxyXG5cclxuICAgICAgICB0aGlzLm9uKCdtb3VzZWRvd24nLCBmdW5jdGlvbihlX21vdXNlZG93bikge1xyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdlX21vdXNlZG93bicsIGVfbW91c2Vkb3duKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBpbnRfYnV0dG9uID0gZV9tb3VzZWRvd24ud2hpY2g7XHJcblxyXG4gICAgICAgICAgICBpZiAoaW50X2J1dHRvbiA9PSAzKSB7XHJcbiAgICAgICAgICAgICAgICBlX21vdXNlZG93bi5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgd2luZG93LmV2ZW50LnJldHVyblZhbHVlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdGhpcy5vbignbW91c2V1cCcsIGZ1bmN0aW9uKGVfbW91c2V1cCkge1xyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdlX21vdXNldXAnLCBlX21vdXNldXApO1xyXG5cclxuICAgICAgICAgICAgdmFyIGludF9idXR0b24gPSBlX21vdXNldXAud2hpY2g7XHJcblxyXG4gICAgICAgICAgICBpZiAoaW50X2J1dHRvbiA9PSAzKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygncmlnaHQgYnV0dG9uJyk7XHJcbiAgICAgICAgICAgICAgICBlX21vdXNldXAucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgIHdpbmRvdy5ldmVudC5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgLy8gTmVlZCB0byB3b3JrIG91dCB0aGUgcG9zaXRpb24gb2YgdGhlIGNsaWNrLlxyXG4gICAgICAgICAgICAgICAgLy8gcGFnZVgsIHBhZ2VZXHJcbiAgICAgICAgICAgICAgICB2YXIgcG9zID0gW2VfbW91c2V1cC5wYWdlWCwgZV9tb3VzZXVwLnBhZ2VZXTtcclxuICAgICAgICAgICAgICAgIHNob3dfY29udGV4dF9tZW51KHBvcyk7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuXHJcblxyXG4gICAgfSksXHJcblxyXG5cclxuICAgIC8vIG1ha2UgZnVsbCBoZWlnaHQuXHJcbiAgICAvLyAgbWFrZXMgdGhlIGNvbnRyb2wgdGFrZSB0aGUgcmVzdCBvZiB0aGUgaGVpZ2h0IG9mIHRoZSB3aW5kb3cuXHJcblxyXG4gICAgLy8gRHJhZyBmdW5jdGlvbiBhcyB3ZWxsLi4uXHJcbiAgICAvLyAgQ291bGQgbWFrZSB0aGlzIGFjY2VwdCB0aGUgc2FtZSBwYXJhbXMgYXMgdGhlIGRyYWcgZnVuY3Rpb24sXHJcbiAgICAvLyAgIGJ1dCB0aGlzIHZlcnNpb24gd2lsbCBiZSBtb3JlIGZsZXhpYmxlIHdpdGggbW9yZSBtb2Rlcy5cclxuICAgIC8vIERyYWcgYW5kIGRyb3AgY291bGQgYWxzbyBiZSBzZXQgdXAgd2l0aCBzaW1wbGVyIHBhcmFtZXRlcnMgYW5kIGFjdHMgaW4gdGhlIGRlZmF1bHQgd2F5IHRoYXQgLmRyYWcgd291bGQgZG8uXHJcblxyXG4gICAgJ2RyYWdnYWJsZSc6IGZwKGZ1bmN0aW9uKGEsIHNpZykge1xyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICAvL2NvbnNvbGUubG9nKCdkcmFnZ2FibGUgc2lnJywgc2lnKTtcclxuXHJcbiAgICAgICAgLy9jb25zb2xlLnRyYWNlKCk7XHJcblxyXG4gICAgICAgIHZhciBvcHRpb25zID0ge30sIG1vZGUsIGRyYWdfc3RhcnRfZGlzdGFuY2UgPSA0O1xyXG5cclxuICAgICAgICAvLyBvcHRpb25zIGNvdWxkIGNvbnRhaW4gZXZlbnQgaGFuZGxlcnMuXHJcbiAgICAgICAgLy8gIE5vdCBzdXJlIGFib3V0IHRoZSBwdWJsaXNoIC8gc3Vic2NyaWJlIG1vZGVsLlxyXG4gICAgICAgIC8vICAgTWF5YmUgaXQgd291bGQgd29yayB3ZWxsLlxyXG5cclxuICAgICAgICAvLyBCdXQgYWxsb3dpbmcgZXZlbnQgaGFuZGxlcnMgYXMgc3BlY2lmaWVkIGluIHRoZSBvcHRpb25zIHdvdWxkIGJlIGdvb2QgYXMgd2VsbC5cclxuXHJcbiAgICAgICAgdmFyIGZuX21vdXNlZG93biwgZm5fZHJhZ3N0YXJ0LCBmbl9kcmFnbW92ZSwgZm5fZHJhZ2VuZDtcclxuICAgICAgICB2YXIgaGFuZGxlX21vdXNlZG93biwgaGFuZGxlX2RyYWdzdGFydCwgaGFuZGxlX2RyYWdtb3ZlICwgaGFuZGxlX2RyYWdlbmQ7XHJcblxyXG5cclxuICAgICAgICBpZiAoc2lnID09ICdbb10nKSB7XHJcbiAgICAgICAgICAgIG9wdGlvbnMgPSBhWzBdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gZm5fbW91c2Vkb3duLCBmbl9iZWdpbiwgZm5fbW92ZSwgZm5fZW5kXHJcbiAgICAgICAgaWYgKHNpZyA9PSAnW2YsZixmLGZdJykge1xyXG4gICAgICAgICAgICBoYW5kbGVfbW91c2Vkb3duID0gYVswXTtcclxuICAgICAgICAgICAgaGFuZGxlX2RyYWdzdGFydCA9IGFbMV07XHJcbiAgICAgICAgICAgIGhhbmRsZV9kcmFnbW92ZSA9IGFbMl07XHJcbiAgICAgICAgICAgIGhhbmRsZV9kcmFnZW5kID0gYVszXTtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICBpZiAob3B0aW9ucy5tb2RlKSBtb2RlID0gb3B0aW9ucy5tb2RlO1xyXG4gICAgICAgIC8vaWYgKG9wdGlvbnMuZm5fZHJhZ21vdmUpIGZuX2RyYWdtb3ZlID0gb3B0aW9ucy5mbl9kcmFnbW92ZTtcclxuICAgICAgICBpZiAob3B0aW9ucy5tb3ZlKSBoYW5kbGVfZHJhZ21vdmUgPSBvcHRpb25zLm1vdmU7XHJcbiAgICAgICAgLy9pZiAob3B0aW9ucy5mbl9kcmFnc3RhcnQpIGZuX2RyYWdzdGFydCA9IG9wdGlvbnMuZm5fZHJhZ3N0YXJ0O1xyXG4gICAgICAgIGlmIChvcHRpb25zLnN0YXJ0KSBoYW5kbGVfZHJhZ3N0YXJ0ID0gb3B0aW9ucy5zdGFydDtcclxuXHJcbiAgICAgICAgLy8gY291bGQgaGF2ZSBhICdub25lJyBtb2RlIHRoYXQgZG9lcyBub3QgaW1wbGVtZW50IGRyYWcgYmVoYXZpb3VyIGl0c2VsZiwgYnV0IGp1c3Qgc2hvd3MgdGhlIGV2ZW50cz9cclxuICAgICAgICAvLyAgb3IgSSB0aGluayAnZXZlbnRzJyBtb2RlIHdvdWxkIGJlIGEgYmV0dGVyIG5hbWUgYmVjYXVzZSBpdCdzIHNheWluZyB3aGF0IGl0IGlzLlxyXG4gICAgICAgIC8vICB3b3VsZCBiZSB1c2VmdWwgZm9yIG1vdmluZyBvYmplY3RzIGFyb3VuZCBhY2NvcmRpbmcgdG8gbW9yZSBzcGVjaWZpYyBydWxlcy5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuICAgICAgICBpZiAobW9kZSA9PSAnZ2hvc3QtY29weScpIHtcclxuICAgICAgICAgICAgLy8gRHJhZyBhIGdob3N0IGNvcHkgb2YgdGhlIG9yaWdpbmFsIGVsZW1lbnQuXHJcblxyXG4gICAgICAgICAgICAvLyBjYWxsIGEgY3JlYXRlX2dob3N0X2NvcHkgZnVuY3Rpb24/IEl0IHdvdWxkIG1ha2UgdGhlIGdob3N0IGNvcHkgYWJzb2x1dGVseSBwb3NpdGlvbmVkIGFuZCBhIGNoaWxkIG9mIHRoZSBib2R5LlxyXG4gICAgICAgICAgICAvLyAgY291bGQgYXV0b21hdGljYWxseSBjcmVhdGUgaXQgd2l0aCBhIHNtYWxsIG9mZnNldC5cclxuXHJcbiAgICAgICAgICAgIC8vICBOZWVkIHRvIGJlIGRyYWdnaW5nIHRoZSBnaG9zdCBjb3B5IGFyb3VuZCB0aHJvdWdob3V0IHRoZSBkcmFnIG9wZXJhdGlvbiBpbiB0aGlzIGNhc2UuXHJcblxyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnZ2hvc3QtY29weSBkcmFnJyk7XHJcblxyXG5cclxuXHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGJvZHkgPSB0aGF0Ll9jb250ZXh0LmJvZHkoKTtcclxuXHJcbiAgICAgICAgLy8gcmFpc2UgdGhlIGV2ZW50cyBleHRlcm5hbGx5LlxyXG5cclxuICAgICAgICB2YXIgaXNfZHJhZ2dpbmc7XHJcbiAgICAgICAgdmFyIHBvc19tb3VzZWRvd247XHJcblxyXG4gICAgICAgIHZhciBnaG9zdF9jbG9uZTtcclxuXHJcblxyXG5cclxuXHJcblxyXG4gICAgICAgIHZhciBmbl9tb3VzZW1vdmUgPSBmdW5jdGlvbihlX21vdXNlbW92ZSkge1xyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdlX21vdXNlbW92ZScsIGVfbW91c2Vtb3ZlKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBwb3MgPSBbZV9tb3VzZW1vdmUucGFnZVgsIGVfbW91c2Vtb3ZlLnBhZ2VZXTtcclxuXHJcbiAgICAgICAgICAgIHZhciBwb3Nfb2Zmc2V0ID0gW3Bvc1swXSAtIHBvc19tb3VzZWRvd25bMF0sIHBvc1sxXSAtIHBvc19tb3VzZWRvd25bMV1dO1xyXG5cclxuXHJcblxyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdkaXN0JywgZGlzdCk7XHJcblxyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdpc19kcmFnZ2luZyAnICsgaXNfZHJhZ2dpbmcpO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFpc19kcmFnZ2luZykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGRpc3QgPSBNYXRoLnJvdW5kKE1hdGguc3FydChwb3Nfb2Zmc2V0WzBdICogcG9zX29mZnNldFswXSArIHBvc19vZmZzZXRbMV0gKiBwb3Nfb2Zmc2V0WzFdKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGlzdCA+PSBkcmFnX3N0YXJ0X2Rpc3RhbmNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnc3RhcnRpbmcgZHJhZycpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlzX2RyYWdnaW5nID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaW4gZ2hvc3QgY29weSBtb2RlIGNyZWF0ZSB0aGUgZ2hvc3QgY29weVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAobW9kZSA9PSAnZ2hvc3QtY29weScpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ2hvc3RfY2xvbmUgPSB0aGF0LmFic29sdXRlX2dob3N0X2Nsb25lKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChoYW5kbGVfZHJhZ3N0YXJ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVfbW91c2Vtb3ZlLmNvbnRyb2wgPSB0aGF0O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlX2RyYWdzdGFydChlX21vdXNlbW92ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoaXNfZHJhZ2dpbmcpIHtcclxuICAgICAgICAgICAgICAgIC8vIHJhaXNlIHRoZSBkcmFnIGV2ZW50LlxyXG5cclxuICAgICAgICAgICAgICAgIC8vIGNvdWxkIGRvIHNvbWUgb2YgdGhlIGRyYWctZHJvcCBhY3Rpdml0eSBkZXBlbmRpbmcgb24gdGhlIGRyYWcgbW9kZS5cclxuICAgICAgICAgICAgICAgIC8vICBhbHNvIHdhbnQgdG8gcHJvdmlkZSBvdGhlciBob29rcyBmb3IgZnVuY3Rpb25hbGl0eS5cclxuXHJcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdmbl9kcmFnbW92ZScsIGZuX2RyYWdtb3ZlKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoaGFuZGxlX2RyYWdtb3ZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZV9tb3VzZW1vdmUuY29udHJvbCA9IHRoYXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlX2RyYWdtb3ZlKGVfbW91c2Vtb3ZlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcblxyXG5cclxuICAgICAgICAgICAgLy8gV2FudCB0aGUgb2Zmc2V0IGZyb20gdGhlIG1vdXNlZG93biBwb3NpdGlvbi5cclxuXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBmbl9tb3VzZXVwID0gZnVuY3Rpb24oZV9tb3VzZXVwKSB7XHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2VfbW91c2V1cCcsIGVfbW91c2V1cCk7XHJcblxyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdwcmUgc3dpdGNoIG9mZiBtb3VzZW1vdmUsIG1vdXNldXAnKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFNlZW1zIHRoZSBldmVudHMgYXJlIGJlaW5nIGFkZGVkIHRvbyBtYW55IHRpbWVzLlxyXG5cclxuICAgICAgICAgICAgYm9keS5vZmYoJ21vdXNlbW92ZScsIGZuX21vdXNlbW92ZSk7XHJcbiAgICAgICAgICAgIGJvZHkub2ZmKCdtb3VzZXVwJywgZm5fbW91c2V1cCk7XHJcblxyXG4gICAgICAgICAgICBib2R5LnJlbW92ZV9jbGFzcygnbm8tdGV4dC1zZWxlY3QnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMub24oJ21vdXNlZG93bicsIGZ1bmN0aW9uKGVfbW91c2Vkb3duKSB7XHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2VfbW91c2Vkb3duJywgZV9tb3VzZWRvd24pO1xyXG5cclxuICAgICAgICAgICAgcG9zX21vdXNlZG93biA9IFtlX21vdXNlZG93bi5wYWdlWCwgZV9tb3VzZWRvd24ucGFnZVldO1xyXG5cclxuICAgICAgICAgICAgLy8gcG9zaXRpb24gd2l0aGluIENvbnRyb2xcclxuICAgICAgICAgICAgLy8gcG9zaXRpb24gd2l0aGluIHdpbmRvd1xyXG5cclxuXHJcbiAgICAgICAgICAgIGJvZHkub24oJ21vdXNlbW92ZScsIGZuX21vdXNlbW92ZSk7XHJcbiAgICAgICAgICAgIGJvZHkub24oJ21vdXNldXAnLCBmbl9tb3VzZXVwKTtcclxuXHJcbiAgICAgICAgICAgIGJvZHkuYWRkX2NsYXNzKCduby10ZXh0LXNlbGVjdCcpO1xyXG4gICAgICAgICAgICBpc19kcmFnZ2luZyA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgaWYgKGhhbmRsZV9tb3VzZWRvd24pIHtcclxuICAgICAgICAgICAgICAgIGhhbmRsZV9tb3VzZWRvd24oZV9tb3VzZWRvd24pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH0pXHJcblxyXG5cclxuICAgIH0pLFxyXG5cclxuXHJcbiAgICAvLyBBcyB3ZWxsIGFzIHRoZSAnZHJhZ2dhYmxlJyBmdW5jdGlvbj9cclxuICAgIC8vICBDb3VsZCBrZWVwIHRoaXMsIGFuZCBoYXZlIGl0IGNhbGwgZHJhZ2dhYmxlP1xyXG4gICAgLy8gIERyYWdnYWJsZSBtYWtlcyBtb3JlIHNlbnNlLCBwZXJoYXBzIGRyYWcgY291bGQgYmUgYW4gYWxpYXMgZm9yIGRyYWdnYWJsZS5cclxuXHJcblxyXG4gICAgLypcclxuICAgICdkcmFnJzogZnVuY3Rpb24oZm5fbW91c2Vkb3duLCBmbl9iZWdpbiwgZm5fbW92ZSwgZm5fZW5kKSB7XHJcblxyXG4gICAgICAgIHZhciBzY3JlZW5fZG93bl94LCBzY3JlZW5fZG93bl95O1xyXG5cclxuICAgICAgICAvLyBXYW50IHdheXMgb2YgcmVzdHJpY3Rpbmcgb3IgY2FuY2VsbGluZyBhIGRyYWcuXHJcbiAgICAgICAgdmFyIGN0cmxfaHRtbF9yb290ID0gdGhpcy5fY29udGV4dC5jdHJsX2RvY3VtZW50O1xyXG5cclxuXHJcbiAgICAgICAgdGhpcy5hZGRfZXZlbnRfbGlzdGVuZXIoJ21vdXNlZG93bicsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnaG92ZXIgbW91c2VvdmVyJyk7XHJcblxyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdkcmFnIG1vdXNlZG93biAnLCBlKTtcclxuXHJcbiAgICAgICAgICAgIHNjcmVlbl9kb3duX3ggPSBlLnNjcmVlblg7XHJcbiAgICAgICAgICAgIHNjcmVlbl9kb3duX3kgPSBlLnNjcmVlblk7XHJcblxyXG4gICAgICAgICAgICAvL3ZhciBtb3ZlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB2YXIgZHJhZ19pbml0aWF0ZWQgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgIGZuX21vdXNlZG93bihlKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBmaXJzdCA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICB2YXIgaGFuZGxlX21vdmUgPSBmdW5jdGlvbihlKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ2hhbmRsZV9tb3ZlJyk7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHNjcmVlbl9tb3ZlX3ggPSBlLnNjcmVlblg7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2NyZWVuX21vdmVfeSA9IGUuc2NyZWVuWTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgc2NyZWVuX29mZnNldF94ID0gc2NyZWVuX21vdmVfeCAtIHNjcmVlbl9kb3duX3g7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2NyZWVuX29mZnNldF95ID0gc2NyZWVuX21vdmVfeSAtIHNjcmVlbl9kb3duX3k7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGZpcnN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3RybF9odG1sX3Jvb3QuYWRkX2NsYXNzKCdjdXJzb3ItZGVmYXVsdCcpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZpcnN0ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gU2NyZWVuIG1vdmVtZW50IG9mZnNldC5cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBBbnl3YXksIHdlIG5lZWQgdGhlIHBvc2l0aW9uIHdpdGhpbiB0aGUgZGl2IC8gZWxlbWVudCB3aGVyZSB0aGUgbW91c2Ugd2VudCBkb3duLlxyXG4gICAgICAgICAgICAgICAgLy8gIFdlIHVzZSB0aGF0IHRvIGNhbGN1bGF0ZSB0aGUgcG9zaXRpb24gdG8gbW92ZSB0aGUgY29udHJvbCB0bywgd2UgbmVlZCB0byB0YWtlIGFjY291bnQgb2YgdGhhdCBpbml0YWwgb2Zmc2V0LlxyXG5cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gY291bGQgZmluZCB0aGUgcG9zaXRpb24gb2YgdGhlIHNyY0VsZW1lbnQuXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gdGhhdCBtYXkgYmUgYmV0dGVyLlxyXG4gICAgICAgICAgICAgICAgLy8gIHRoZW4gd2UgdXNlIHRoZSBjbGllbnQgeCBhbmQgY2xpZW50IHkgcHJvcGVydGllcyB0byBkZXRlcm1pbmUgdGhlIG9mZnNldCBpbnRvIHRoZSBpdGVtIGNsaWNrZWQuXHJcblxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdzY3JlZW5fb2Zmc2V0X3gnLCBzY3JlZW5fb2Zmc2V0X3gsICdzY3JlZW5fb2Zmc2V0X3knLCBzY3JlZW5fb2Zmc2V0X3kpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIGJ1dCB3ZSBhbHJlYWR5IGhhdmUgYW4gb2Zmc2V0IHByb3BlcnR5IGZyb20gdGhlIGV2ZW50LlxyXG5cclxuICAgICAgICAgICAgICAgIC8vIG1heWJlIGNhbGwgb3VyIG5ldyBvbmUgYSBtb3ZlbWVudCBvZmZzZXQuXHJcblxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgZSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAnb2Zmc2V0WCc6IHNjcmVlbl9vZmZzZXRfeCxcclxuICAgICAgICAgICAgICAgICAgICAnb2Zmc2V0WSc6IHNjcmVlbl9vZmZzZXRfeSxcclxuICAgICAgICAgICAgICAgICAgICAnc2NyZWVuWCc6IHNjcmVlbl9tb3ZlX3gsXHJcbiAgICAgICAgICAgICAgICAgICAgJ3NjcmVlblknOiBzY3JlZW5fbW92ZV95LFxyXG4gICAgICAgICAgICAgICAgICAgICdjbGllbnRYJzogZS5jbGllbnRYLFxyXG4gICAgICAgICAgICAgICAgICAgICdjbGllbnRZJzogZS5jbGllbnRZLFxyXG4gICAgICAgICAgICAgICAgICAgICdwYWdlWCc6IGUucGFnZVgsXHJcbiAgICAgICAgICAgICAgICAgICAgJ3BhZ2VZJzogZS5wYWdlWVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmICghZHJhZ19pbml0aWF0ZWQpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9zZWUgaG93IGZhciBpdCBpcy4uLlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyB3YW50IHRvIHVzZSBhIGZ1bmN0aW9uIHRoYXQgY2FsY3VsYXRlcyB0aGUgbWFnbml0dWRlIG9mIHRoZSBkaXN0YW5jZS5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRicCA9IGpzZ3VpLmRpc3RhbmNlX2JldHdlZW5fcG9pbnRzKFtbMCwgMF0sIFtzY3JlZW5fb2Zmc2V0X3gsIHNjcmVlbl9vZmZzZXRfeV1dKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnZGJwICcgKyBkYnApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBkcmFnX2luaXRpYXRpb25fZGlzdGFuY2VcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRyYWdfaW5pdGlhdGlvbl9kaXN0YW5jZSA9IDE2O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkYnAgPj0gMTYpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZHJhZ19pbml0aWF0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHJsX2h0bWxfcm9vdC5hZGRfY2xhc3MoJ2RyYWdnaW5nJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY3RybF9odG1sX3Jvb3QuYWRkX2NsYXNzKCdjdXJzb3ItZGVmYXVsdCcpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZm5fYmVnaW4oZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNhbiBqdXN0IHVzZSB0aGUgbWFnbml0dWRlIG9mIHRoZSBvZmZzZXQuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gIGRicCB0YWtpbmcganVzdCAyIHZhbHVlcy4uLlxyXG5cclxuXHJcblxyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoZHJhZ19pbml0aWF0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBmbl9tb3ZlKGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBoYW5kbGVfbW91c2V1cCA9IGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgICAgIC8vZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgaGFuZGxlX21vdmUpO1xyXG4gICAgICAgICAgICAgICAgLy9kb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgaGFuZGxlX21vdXNldXApO1xyXG5cclxuICAgICAgICAgICAgICAgIGN0cmxfaHRtbF9yb290Lm9mZignbW91c2Vtb3ZlJywgaGFuZGxlX21vdmUpO1xyXG4gICAgICAgICAgICAgICAgY3RybF9odG1sX3Jvb3Qub2ZmKCdtb3VzZXVwJywgaGFuZGxlX21vdXNldXApO1xyXG5cclxuICAgICAgICAgICAgICAgIGN0cmxfaHRtbF9yb290LnJlbW92ZV9jbGFzcygnZHJhZ2dpbmcnKTtcclxuICAgICAgICAgICAgICAgIGN0cmxfaHRtbF9yb290LnJlbW92ZV9jbGFzcygnY3Vyc29yLWRlZmF1bHQnKTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgc2NyZWVuX21vdXNldXBfeCA9IGUuc2NyZWVuWDtcclxuICAgICAgICAgICAgICAgIHZhciBzY3JlZW5fbW91c2V1cF95ID0gZS5zY3JlZW5ZO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBzY3JlZW5fb2Zmc2V0X3ggPSBzY3JlZW5fbW91c2V1cF94IC0gc2NyZWVuX2Rvd25feDtcclxuICAgICAgICAgICAgICAgIHZhciBzY3JlZW5fb2Zmc2V0X3kgPSBzY3JlZW5fbW91c2V1cF95IC0gc2NyZWVuX2Rvd25feTtcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnc2NyZWVuX29mZnNldF94Jywgc2NyZWVuX29mZnNldF94LCAnc2NyZWVuX29mZnNldF95Jywgc2NyZWVuX29mZnNldF95KTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgZSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAnb2Zmc2V0WCc6IHNjcmVlbl9vZmZzZXRfeCxcclxuICAgICAgICAgICAgICAgICAgICAnb2Zmc2V0WSc6IHNjcmVlbl9vZmZzZXRfeVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZm5fZW5kKGUpO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY3RybF9odG1sX3Jvb3Qub24oJ21vdXNlbW92ZScsIGhhbmRsZV9tb3ZlKTtcclxuICAgICAgICAgICAgY3RybF9odG1sX3Jvb3Qub24oJ21vdXNldXAnLCBoYW5kbGVfbW91c2V1cCk7XHJcblxyXG4gICAgICAgICAgICAvL2RvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIGhhbmRsZV9tb3ZlLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIC8vZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIGhhbmRsZV9tb3VzZXVwLCBmYWxzZSk7XHJcblxyXG5cclxuICAgICAgICAgICAgLy9mbl9pbigpO1xyXG4gICAgICAgIH0pXHJcbiAgICB9LFxyXG4gICAgKi9cclxuXHJcbiAgICAnZHJhZ19oYW5kbGVfdG8nOiBmdW5jdGlvbihjdHJsKSB7XHJcbiAgICAgICAgLy8gQWxzbyBpbnZvbHZlZCB3aXRoIGRyYWcgYW5kIGRyb3AgYWN0aW9ucy5cclxuXHJcbiAgICAgICAgLy8gY291bGQgdXNlIHRoZSBsb3dlciBsZXZlbCBkcmFnKDMpIGZ1bmN0aW9uLlxyXG4gICAgICAgIC8vICB3b3VsZCBoYW5kbGUgaW5pdGlhbGl6YWluZyB0aGUgZHJhZywgc3RvcHBpbmcgaXQuXHJcblxyXG4gICAgICAgIC8vIGFub3RoZXIgcGllY2Ugb2YgY29kZSBkZWFscyB3aXRoIGRyYWdnaW5nIHNvbWV0aGluZyByZXByZXNlbnRpbmcgYSBjb3B5LCB3ZSBkb24ndCB3YW50IHRoYXQgaGVyZS5cclxuICAgICAgICAvLyAgd2FudCB0byBtb3ZlIHRoZSB3aW5kb3cuXHJcblxyXG4gICAgICAgIC8vIGFuZCBjYW4gZHJhZyBhbm90aGVyIGNvbnRyb2wuXHJcblxyXG4gICAgICAgIC8vIG1heWJlIHdhbnQgdG8gbWFrZSBhIGZldyBsb3dlciBsZXZlbCBkcmFnIGZ1bmN0aW9ucz9cclxuICAgICAgICAvL2NvbnNvbGUubG9nKCdkcmFnX2hhbmRsZV90bycpO1xyXG4gICAgICAgIHZhciBtb3VzZWRvd25fb2Zmc2V0X2Zyb21fY3RybF9sdDtcclxuXHJcbiAgICAgICAgdmFyIGN0cmxfZWwgPSBjdHJsLmdldCgnZG9tLmVsJyk7XHJcbiAgICAgICAgLy8gY291bGQgZ28gaW4gZW5oYW5jZWQuLi4uXHJcblxyXG4gICAgICAgIC8vdGhpcy5kcmFnKGZ1bmN0aW9uKGVfbW91c2Vkb3duKSB7XHJcbiAgICAgICAgdGhpcy5kcmFnZ2FibGUoZnVuY3Rpb24oZV9tb3VzZWRvd24pIHtcclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnZV9tb3VzZWRvd24nLCBlX21vdXNlZG93bik7XHJcblxyXG5cclxuICAgICAgICAgICAgLy8gVGhpcyB3aWxsIG5lZWQgdG8gYmUgcmV2aXNlZCAtIG1ha2luZyBhZGp1c3RtZW50IGZvciB3aGVuIGRyYWdnaW5nIGZyb20gYW4gYW5jaG9yZWQgcG9zaXRpb24uXHJcbiAgICAgICAgICAgIC8vICBTaG91bGQgbWFpbnRhaW4gc29tZSBpbmZvIGFib3V0IHRoZSBkcmFnIHNvIGl0IGtub3dzIGlmIGl0IHN0YXJ0cy9lbmRzIGFuY2hvcmVkIGFueXdoZXJlLlxyXG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gZV9tb3VzZWRvd24udGFyZ2V0O1xyXG5cclxuICAgICAgICAgICAgLy8gd2FudCB0byBnZXQgdGhlIHBvc2l0aW9uIHdpdGhpbiB0aGUgdGhpbmcgaXQncyBhIGhhbmRsZSB0bz9cclxuXHJcbiAgICAgICAgICAgIC8vIHdpbGwgbmVlZCB0byBkbyBhIGJpdCBvZiBwb3NpdGlvbiBjYWxjdWxhdGlvbiB0byBnZXQgaXQgdG8gd29yay5cclxuXHJcbiAgICAgICAgICAgIHZhciB0YXJnZXRQb3MgPSBmaW5kUG9zKHRhcmdldCk7XHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3RhcmdldFBvcyAnICsgc3RyaW5naWZ5KHRhcmdldFBvcykpO1xyXG5cclxuICAgICAgICAgICAgdmFyIGN0cmxfZWxfcG9zID0gZmluZFBvcyhjdHJsLmdldCgnZG9tLmVsJykpO1xyXG5cclxuICAgICAgICAgICAgLy8gYW5kIHVzZSB0aGUgY2xpZW50IHgsIGNsaWVudCB5XHJcblxyXG4gICAgICAgICAgICAvLyBvciBwYWdlIHggcGFnZSB5P1xyXG5cclxuICAgICAgICAgICAgdmFyIGVfcG9zX29uX3BhZ2UgPSBbZV9tb3VzZWRvd24ucGFnZVgsIGVfbW91c2Vkb3duLnBhZ2VZXTtcclxuXHJcbiAgICAgICAgICAgIC8vIHRoZW4gc3VidHJhY3QgdGhlIHZlY3RvcnMuXHJcblxyXG4gICAgICAgICAgICAvL3ZhciBvZmZzZXRfd2l0aGluX3RhcmdldCA9IGpzZ3VpLnZfc3VidHJhY3QoZV9wb3Nfb25fcGFnZSwgdGFyZ2V0UG9zKTtcclxuICAgICAgICAgICAgbW91c2Vkb3duX29mZnNldF9mcm9tX2N0cmxfbHQgPSBqc2d1aS52X3N1YnRyYWN0KGVfcG9zX29uX3BhZ2UsIGN0cmxfZWxfcG9zKTtcclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnbW91c2Vkb3duX29mZnNldF9mcm9tX2N0cmxfbHQgJyArIHN0cmluZ2lmeShtb3VzZWRvd25fb2Zmc2V0X2Zyb21fY3RybF9sdCkpO1xyXG5cclxuICAgICAgICAgICAgLy8gbm90IGJhZC4uLlxyXG5cclxuICAgICAgICAgICAgLy8gbm90aWZ5IHRoZSBwYWdlIGNvbnRleHQuXHJcbiAgICAgICAgICAgIC8vICBXaWxsIG5vdGlmeSB0aGUgcGFnZSBjb250ZXh0IHdoZW4gY29udHJvbCBnZXRzIG1vdmVkIHRvby5cclxuICAgICAgICAgICAgLy8gICBUaGUgcGFnZSBjb250ZXh0IGNvdWxkIGFycmFuZ2Ugb3RoZXIgdGhpbmdzLCBsaWtlIHRlbGwgYSBjb250cm9sIHdpdGggYSBkcm9wIHpvbmUgdG8gZ2V0IHJlYWR5P1xyXG4gICAgICAgICAgICAvLyAgICBPciB0aGF0IGNvbnRyb2wgcmVzcG9uZHMgdG8gdGhlIG1vdXNlb3ZlciBldmVudCBiZWNhdXNlIGl0IGlzIGEgZHJvcCB6b25lP1xyXG5cclxuICAgICAgICAgICAgLy8gVGhlIFBhZ2VfQ29udGV4dCBtYXkgZ2V0IHRvbGQgYWJvdXQgYSBmZXcgdGhpbmdzLCBidXQgb25seSB0aGVuIHNlbmQgb24gbWVzc2FnZXMgd2hlcmUgbmVjZXNzYXJ5LlxyXG5cclxuXHJcblxyXG5cclxuXHJcbiAgICAgICAgfSwgZnVuY3Rpb24oZV9iZWdpbikge1xyXG4gICAgICAgICAgICAvLyBhbHNvIHdhbnQgdGhlIHBvc2l0aW9uIG9mIG1vdXNlZG93bi5cclxuXHJcbiAgICAgICAgICAgIC8vIHdlIGNvdWxkIGdldCB0aGF0IHdpdGggYSBtb3VzZWRvd24gZXZlbnQuXHJcblxyXG5cclxuICAgICAgICAgICAgLy8gY291bGQgZ2V0IGEgbWVhc3VyZW1lbnQgb2YgdGhlIHNpemUgaGVpZ2h0LlxyXG4gICAgICAgICAgICAvLyAgYWxzbyBrbm93IGlmIGl0IGlzIGRvY2tlZCBvciBub3QuXHJcblxyXG4gICAgICAgICAgICB2YXIgY3RybFNpemUgPSBjdHJsLnNpemUoKTtcclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnY3RybFNpemUnLCBjdHJsU2l6ZSk7XHJcblxyXG4gICAgICAgICAgICB2YXIgYW5jaG9yZWRfdG8gPSBjdHJsLmdldCgnYW5jaG9yZWRfdG8nKTtcclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnYW5jaG9yZWRfdG8nLCBhbmNob3JlZF90byk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIWFuY2hvcmVkX3RvKSB7XHJcbiAgICAgICAgICAgICAgICAvL2N0cmwuc2V0KCd1bmFuY2hvcmVkX3NpemUnLCBjdHJsU2l6ZSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBuZWVkIHRvIHVuYW5jaG9yIGl0LlxyXG4gICAgICAgICAgICAgICAgY3RybC51bmFuY2hvcigpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgICAgICB2YXIgdW5hbmNob3JlZF9zaXplID0gY3RybC5nZXQoJ3VuYW5jaG9yZWRfc2l6ZScpO1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ3VuYW5jaG9yZWRfc2l6ZScsIHVuYW5jaG9yZWRfc2l6ZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgY3RybC5zaXplKHVuYW5jaG9yZWRfc2l6ZSk7XHJcbiAgICAgICAgICAgICAgICBjdHJsLnN0eWxlKHtcclxuICAgICAgICAgICAgICAgICAgICAncG9zaXRpb24nOiAnYWJzb2x1dGUnXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2RyYWcgaGFuZGxlIHRvIGRyYWcgYmVnaW4nKTtcclxuXHJcblxyXG4gICAgICAgICAgICAvL3Rocm93ICdzdG9wJztcclxuXHJcbiAgICAgICAgICAgIC8vIG5lZWQgdG8gbWFrZSBpdCBhYnNvbHV0ZWx5IHBvc2l0aW9uZWQsIHNpemUgaXQuXHJcblxyXG5cclxuXHJcbiAgICAgICAgfSwgZnVuY3Rpb24oZV9tb3ZlKSB7XHJcblxyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdtb3ZlIGV2ZW50Jyk7XHJcbiAgICAgICAgICAgIC8vIG5lZWQgdG8gcmVwb3NpdGlvbiB0aGUgY29udHJvbC5cclxuICAgICAgICAgICAgLy8gIHdpbGwgbWVhbiBhZGp1c3Rpbmcgc29tZSBpbmxpbmUgc3R5bGUuXHJcblxyXG4gICAgICAgICAgICAvLyBjb3VsZCBkbyB3aXRoIG1vcmUganNndWkgd29yayBvbiBkZWFsaW5nIHdpdGggc3R5bGVzLlxyXG4gICAgICAgICAgICAvLyAgYm90aCBjb252ZW50aW9uYWwgc3R5bGVzXHJcbiAgICAgICAgICAgIC8vICBhbmQgYSBzdHlsZSBhYnN0cmFjdGlvbi5cclxuXHJcbiAgICAgICAgICAgIC8vIHNldCB0aGUgc3R5bGUgb24gdGhlIGNvbnRyb2wuXHJcblxyXG4gICAgICAgICAgICAvLyBhbm90aGVyIHN0eWxlIGFic3RyYWN0aW9uIHN5c3RlbSB3b3VsZCBiZSBxdWl0ZSB1c2VmdWwsIG5vdCBjYWxsZWQgc3R5bGUuLi4uXHJcbiAgICAgICAgICAgIC8vIC5mb3JtPyBTZWVtcyBjb25mdXNpbmcgd2l0aCBodG1sIGZvci5cclxuICAgICAgICAgICAgLy8gLmFwcGVhcmFuY2UgLSB0b28gbG9uZ1xyXG4gICAgICAgICAgICAvLyAuZmxhaXI/XHJcblxyXG4gICAgICAgICAgICAvLyBvciBqdXN0IC5zdHlsZSwgYnV0IHRoZXNlIGFyZSBqc2d1aSBzdHlsZSBhYnN0cmFjdGlvbnMuXHJcbiAgICAgICAgICAgIC8vICBzbyB3ZSBjYW4gaGF2ZSBpdCBwdXQgaW4gdGhlIHJvdW5kZWQgZWRnZXMgd2l0aGluIGEgRElWIGluIElFNiwgYnV0IGl0IGRvZXMgY2hhbmdlIHRoZSBsYXlvdXQgaW4gZ2VuZXJhbC5cclxuXHJcbiAgICAgICAgICAgIC8vIHN0eWxlIHBvbHlmaWxsPyBzaGltP1xyXG5cclxuICAgICAgICAgICAgLy8gbWF5YmUgd2FudCB0byBzcGVjaWZ5IGNvcm5lcnMgaW4ganNndWkgLSB0aGF0IGlzIGEgc3R5bGUgYWJzdHJhY3Rpb24uXHJcblxyXG4gICAgICAgICAgICB2YXIgY2xpZW50WCA9IGVfbW92ZS5jbGllbnRYO1xyXG4gICAgICAgICAgICB2YXIgY2xpZW50WSA9IGVfbW92ZS5jbGllbnRZO1xyXG5cclxuICAgICAgICAgICAgLy92YXIgcGFnZVggPSBlX21vdmUucGFnZVg7XHJcbiAgICAgICAgICAgIC8vdmFyIHBhZ2VZID0gZV9tb3ZlLnBhZ2VZO1xyXG5cclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygncHJlIHNldCBjdHJsIHN0eWxlJyk7XHJcblxyXG4gICAgICAgICAgICAvLyB0aGUgc3R5bGUgd2l0aGluIHRoZSBkb20gYXR0cmlidXRlcz9cclxuXHJcbiAgICAgICAgICAgIC8vIEkgdGhpbmsgLmZvcm0gd291bGQgYmUgZ29vZCBpbnN0ZWFkIG9mIC5zdHlsZS5cclxuICAgICAgICAgICAgLy8gIC5mb3JtIHdvdWxkIGJlIGxpa2UgLnN0eWxlIGJ1dCB0aGUgc3R5bGUgYWJzdHJhY3Rpb24uXHJcblxyXG4gICAgICAgICAgICAvLyBQZXJoYXBzIGJlaW5nIGFibGUgdG8gYWNjZXNzIC5zdHlsZSBtYWtlcyBzZW5zZSBmb3IgY29udHJvbHMgdGhvdWdoLlxyXG5cclxuICAgICAgICAgICAgLy8gTmVlZCB0byBkZWFsIHByb3Blcmx5IHdpdGggb2Zmc2V0cy5cclxuXHJcbiAgICAgICAgICAgIC8vXHJcblxyXG4gICAgICAgICAgICAvLyB3aWR0aCBvZiB0aGUgY29udHJvbC5cclxuXHJcbiAgICAgICAgICAgIC8vIHdhbnQgY3RybC53aWR0aCgpIHRvIHByb2R1Y2UgdGhlIHJlc3VsdCwgYnV0IHRoYXQgd2lsbCBuZWVkIG1vcmUgd29yay5cclxuXHJcblxyXG5cclxuICAgICAgICAgICAgLy8gQWxzbyBuZWVkIHRvIGNsYW1wIGl0IHdpdGhpbiBwYWdlIGNvbnN0cmFpbnRzLlxyXG5cclxuICAgICAgICAgICAgdmFyIHdpbmRvd19zaXplID0gZ2V0X3dpbmRvd19zaXplKCk7XHJcblxyXG5cclxuICAgICAgICAgICAgdmFyIGN0cmxfcG9zID0ganNndWkudl9zdWJ0cmFjdChbY2xpZW50WCwgY2xpZW50WV0sIG1vdXNlZG93bl9vZmZzZXRfZnJvbV9jdHJsX2x0KTtcclxuXHJcbiAgICAgICAgICAgIC8vIEJ1dCB0aGVuIGFjdCBkaWZmZXJlbnRseSBpZiB3ZSBhcmUgZHJhZ2dpbmcgZnJvbSBhbiBhbmNob3JlZCBwb3NpdGlvbi5cclxuICAgICAgICAgICAgLy8gIFRoZSBtb3VzZWRvd24gb2Zmc2V0IHdpdGhpbiB0aGUgY29udHJvbCB3b24ndCBiZSBzbyByZWxldmFudCAtXHJcbiAgICAgICAgICAgIC8vICAgb3Igd29uJ3QgYmUgdGhlIG9ubHkgZmFjdG9yLlxyXG5cclxuICAgICAgICAgICAgLy8gVGFrZSBhY2NvdW50IG9mIHBvc2l0aW9uX2FkanVzdG1lbnRcclxuICAgICAgICAgICAgLy8gIG9yIG9mZnNldF9hZGp1c3RtZW50XHJcblxyXG4gICAgICAgICAgICB2YXIgb2Zmc2V0X2FkanVzdG1lbnQgPSBjdHJsLmdldCgnb2Zmc2V0X2FkanVzdG1lbnQnKTtcclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnb2Zmc2V0X2FkanVzdG1lbnQnLCBvZmZzZXRfYWRqdXN0bWVudCk7XHJcblxyXG4gICAgICAgICAgICBpZiAob2Zmc2V0X2FkanVzdG1lbnQpIHtcclxuICAgICAgICAgICAgICAgIC8vIHdhbnQgdG8gZmluZCBvdXQgd2hhdCB6b25lIGl0IGlzIGFuY2hvcmVkIGluLlxyXG5cclxuICAgICAgICAgICAgICAgIGN0cmxfcG9zID0ganNndWkudl9hZGQoY3RybF9wb3MsIG9mZnNldF9hZGp1c3RtZW50KTtcclxuXHJcbiAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgIHZhciB1bmFuY2hvcmVkX29mZnNldCA9IGN0cmwuZ2V0KCd1bmFuY2hvcmVkX29mZnNldCcpO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygndW5hbmNob3JlZF9vZmZzZXQnLCB1bmFuY2hvcmVkX29mZnNldCk7XHJcblxyXG4gICAgICAgICAgICBpZiAodW5hbmNob3JlZF9vZmZzZXQpIHtcclxuICAgICAgICAgICAgICAgIC8vIHdhbnQgdG8gZmluZCBvdXQgd2hhdCB6b25lIGl0IGlzIGFuY2hvcmVkIGluLlxyXG4gICAgICAgICAgICAgICAgdmFyIGFuY2hvcmVkX3RvID0gY3RybC5nZXQoJ2FuY2hvcmVkX3RvJyk7XHJcbiAgICAgICAgICAgICAgICB2YXIgem9uZSA9IGFuY2hvcmVkX3RvWzJdO1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCd6b25lJywgem9uZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHpvbmUgPT0gJ2xlZnQnIHx8IHpvbmUgPT0gJ3RvcCcgfHwgem9uZSA9PSAnYm90dG9tJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGN0cmxfcG9zID0ganNndWkudl9hZGQoY3RybF9wb3MsIFt1bmFuY2hvcmVkX29mZnNldFswXSwgMF0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICovXHJcblxyXG5cclxuICAgICAgICAgICAgaWYgKGN0cmxfcG9zWzBdIDwgMCkgY3RybF9wb3NbMF0gPSAwO1xyXG4gICAgICAgICAgICBpZiAoY3RybF9wb3NbMV0gPCAwKSBjdHJsX3Bvc1sxXSA9IDA7XHJcblxyXG4gICAgICAgICAgICAvLyBjbGFtcGluZyBpdCBzbyB0aGUgcmlnaHQgZG9lcyBub3QgZ28gb3V0c2lkZSB0aGUgc2NyZWVuIGlzIG1vcmUgZGlmZmljdWx0LlxyXG4gICAgICAgICAgICAvLyBtb3VzZWRvd25fb2Zmc2V0X2Zyb21fY3RybF9sdFxyXG5cclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyh3aW5kb3dfc2l6ZVswXSAtIG1vdXNlZG93bl9vZmZzZXRfZnJvbV9jdHJsX2x0WzBdKTtcclxuXHJcblxyXG4gICAgICAgICAgICB2YXIgb3cgPSBjdHJsX2VsLm9mZnNldFdpZHRoO1xyXG4gICAgICAgICAgICB2YXIgb2ggPSBjdHJsX2VsLm9mZnNldEhlaWdodDtcclxuXHJcblxyXG4gICAgICAgICAgICBpZiAoY3RybF9wb3NbMF0gPiB3aW5kb3dfc2l6ZVswXSAtIG93KSBjdHJsX3Bvc1swXSA9IHdpbmRvd19zaXplWzBdIC0gb3c7XHJcbiAgICAgICAgICAgIGlmIChjdHJsX3Bvc1sxXSA+IHdpbmRvd19zaXplWzFdIC0gb2gpIGN0cmxfcG9zWzFdID0gd2luZG93X3NpemVbMV0gLSBvaDtcclxuXHJcblxyXG5cclxuICAgICAgICAgICAgLy9jdHJsLnN0eWxlKHtcclxuICAgICAgICAgICAgLy8gICAgJ2xlZnQnOiBwYWdlWCArICdweCcsXHJcbiAgICAgICAgICAgIC8vICAgICd0b3AnOiBwYWdlWSArICdweCdcclxuICAgICAgICAgICAgLy99KTtcclxuXHJcbiAgICAgICAgICAgIHZhciBzdHlsZV92YWxzID0ge1xyXG4gICAgICAgICAgICAgICAgJ2xlZnQnOiBjdHJsX3Bvc1swXSArICdweCcsXHJcbiAgICAgICAgICAgICAgICAndG9wJzogY3RybF9wb3NbMV0gKyAncHgnXHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdzdHlsZV92YWxzJywgc3R5bGVfdmFscyk7XHJcblxyXG5cclxuICAgICAgICAgICAgY3RybC5zdHlsZShzdHlsZV92YWxzKTtcclxuXHJcblxyXG4gICAgICAgICAgICAvLyBJZiB0aGUgY3RybCBpcyBhbmNob3JlZCwgd2UgbmVlZCB0byB1bmFuY2hvciBpdC5cclxuXHJcblxyXG5cclxuICAgICAgICAgICAgLy8gYXMgd2VsbCBhcyB0aGF0LCB0ZWxsIHRoZSBjb250cm9sJ3MgY29udGV4dC5cclxuICAgICAgICAgICAgLy8gIFRoYXQgY291bGQgZG8gdGhpbmdzIGxpa2Ugc2NhbiBmb3IgaXQgYmVpbmcgaW4gYW4gb3V0c2lkZSBib3JkZXIuXHJcblxyXG4gICAgICAgICAgICBjdHJsLl9jb250ZXh0Lm1vdmVfZHJhZ19jdHJsKGVfbW92ZSwgY3RybCk7XHJcblxyXG4gICAgICAgIH0sIGZ1bmN0aW9uKGVfZW5kKSB7XHJcbiAgICAgICAgICAgIC8vIHRlbGwgdGhlIGNvbnRleHQgdGhhdCB0aGUgZHJhZyBoYXMgZW5kZWQuXHJcbiAgICAgICAgICAgIHZhciB1bzEgPSBjdHJsLmdldCgndW5hbmNob3JlZF9vZmZzZXQnKTtcclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygndW8xJywgdW8xKTtcclxuXHJcbiAgICAgICAgICAgIGN0cmwuX2NvbnRleHQuZW5kX2RyYWdfY3RybChlX2VuZCwgY3RybCk7XHJcblxyXG4gICAgICAgICAgICB2YXIgdW8yID0gY3RybC5nZXQoJ3VuYW5jaG9yZWRfb2Zmc2V0Jyk7XHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3VvMicsIHVvMik7XHJcblxyXG4gICAgICAgICAgICBpZiAodW8xICYmIHVvMikge1xyXG4gICAgICAgICAgICAgICAgY3RybC5zZXQoJ3VuYW5jaG9yZWRfb2Zmc2V0JywgbnVsbCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGN0cmwuc2V0KCdvZmZzZXRfYWRqdXN0bWVudCcsIG51bGwpO1xyXG5cclxuICAgICAgICAgICAgLy8gYW5kIGlmIGl0IGFscmVhZHkgaGFzIGFuIHVuYW5jaG9yZWRfb2Zmc2V0XHJcblxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgIH0sXHJcblxyXG5cclxuICAgIC8vIFBvc3NpYmx5IHB1dCB0aGlzIGJhY2s/XHJcbiAgICAvLyAgQnV0IG1heWJlIGRvbid0IHdhbnQgdG8gYmUgdGFsa2luZyBhYm91dCBjbGljayBvciB0b3VjaCB0b28gbXVjaCwgbWF5YmUgdGFsayBhYm91dCBwb2ludGVyIGFjdGlvbnMuXHJcbiAgICAvKlxyXG4gICAgJ2NsaWNrX3RvX3NlbGVjdCc6IGZ1bmN0aW9uKGN0cmwpIHtcclxuICAgICAgICBjdHJsID0gY3RybCB8fCB0aGlzO1xyXG5cclxuICAgICAgICB0aGlzLmNsaWNrKGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgLy8gaXMgY29udHJvbCBoZWxkIGRvd24/XHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2UnLCBlKTtcclxuICAgICAgICAgICAgdmFyIGN0cmxfa2V5ID0gZS5jdHJsS2V5O1xyXG4gICAgICAgICAgICBpZiAoY3RybF9rZXkpIHtcclxuICAgICAgICAgICAgICAgIGN0cmwuYWN0aW9uX3NlbGVjdF90b2dnbGUoKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGN0cmwuYWN0aW9uX3NlbGVjdF9vbmx5KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcbiAgICAqL1xyXG5cclxuICAgICdyZXNpemVfaGFuZGxlX3RvJzogZnVuY3Rpb24oY3RybCwgaGFuZGxlX3Bvc2l0aW9uKSB7XHJcbiAgICAgICAgLy8gVGhlIGNvbnRyb2wgbmVlZHMgdG8gYmUgZHJhZ2dhYmxlIG5vcm1hbGx5P1xyXG4gICAgICAgIC8vICBBbmQgdGhlbiBmcm9tIHRoZSBwb3NpdGlvbnMgb2Ygd2hlcmUgaXQgaXMgYWRqdXN0IHRoZSBzaXplIG9mIHdoYXQgaXQncyBhIHJlc2l6ZSBoYW5kbGUgdG8/XHJcblxyXG4gICAgICAgIGNvbnNvbGUubG9nKCdyZXNpemVfaGFuZGxlX3RvJyk7XHJcblxyXG4gICAgICAgIGlmIChoYW5kbGVfcG9zaXRpb24gPT0gJ3JpZ2h0LWJvdHRvbScpIHtcclxuICAgICAgICAgICAgdmFyIGZuX21vdmUgPSBmdW5jdGlvbihlX21vdmUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdlX21vdmUnLCBlX21vdmUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBmbl91cCA9IGZ1bmN0aW9uKGVfdXApIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGVfdXApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgZG9jID0gY3RybC5fY29udGV4dC5jdHJsX2RvY3VtZW50O1xyXG5cclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ2N0cmwuX2NvbnRleHQnLCBjdHJsLl9jb250ZXh0KTtcclxuXHJcbiAgICAgICAgICAgIC8vdmFyIGJvZHkgPSBkb2MuZ2V0KCdjb250ZW50JykuZ2V0KDEpO1xyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdib2R5JywgYm9keSk7XHJcblxyXG4gICAgICAgICAgICAvLyBUaGUgY29udGV4dCBzaG91bGQgaGF2ZSBhY2Nlc3MgdG8gdGhlIGNvbnRyb2xfZG9jdW1lbnQuXHJcbiAgICAgICAgICAgIC8vdGhyb3cgJ3N0b3AnO1xyXG5cclxuICAgICAgICAgICAgLy8gTmVlZCB0byBzdG9yZSB0aGUgaW5pdGFsIHBvc2l0aW9ucyB0byB3b3JrIG91dCBkaWZmZXJlbmNlcyBiZXR3ZWVuIHRoZW0uXHJcblxyXG4gICAgICAgICAgICAvLyBwYWdlWCBhbmQgUGFnZVkgYXJlIHJlbGlhYmxlIGFjY3Jvc3MgYnJvd3NlcnMuXHJcbiAgICAgICAgICAgIC8vICBjYW4gYmUgdXNlZCB0byB3b3JrIG91dCBtb3ZlbWVudCB2ZWN0b3IuXHJcblxyXG4gICAgICAgICAgICAvLyBNYXliZSB3ZSB1c2UgdGhlIG9yaWdpbmFsIG1lYXN1cmVkIHBvc2l0aW9uIG9mIHRoZSB3aW5kb3cgdG8gd29yayBvdXQgdGhlIG5ldyBzaXplLCBhbG9uZyB3aXRoIHRoZSBtb3ZlbWVudCB2ZWN0b3IuXHJcblxyXG5cclxuXHJcblxyXG4gICAgICAgICAgICB2YXIgZm5fbW92ZSA9IGZ1bmN0aW9uKGVfbW92ZSkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ2VfbW92ZScsIGVfbW92ZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBmbl91cCA9IGZ1bmN0aW9uKGVfdXApIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdlX3VwJywgZV91cCk7XHJcblxyXG4gICAgICAgICAgICAgICAgZG9jLm9mZignbW91c2Vtb3ZlJywgZm5fbW92ZSk7XHJcbiAgICAgICAgICAgICAgICBkb2Mub2ZmKCdtb3VzZXVwJywgZm5fdXApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjdHJsLm9uKCdtb3VzZWRvd24nLCBmdW5jdGlvbihlX21vdXNlZG93bikge1xyXG5cclxuXHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnZV9tb3VzZWRvd24nLCBlX21vdXNlZG93bik7XHJcblxyXG5cclxuICAgICAgICAgICAgICAgIGRvYy5vbignbW91c2Vtb3ZlJywgZm5fbW92ZSk7XHJcbiAgICAgICAgICAgICAgICBkb2Mub24oJ21vdXNldXAnLCBmbl91cCk7XHJcbiAgICAgICAgICAgIH0pXHJcblxyXG5cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgJ3NlbGVjdGFibGUnOiBmdW5jdGlvbihjdHJsKSB7XHJcblxyXG4gICAgICAgIC8vY29uc29sZS5sb2coJ3NlbGVjdGFibGUgY3RybCcsIGN0cmwpO1xyXG4gICAgICAgIC8vICBDYW4gY2xpY2sgb24gdGhpcywgc2VsZWN0IHNvbWV0aGluZyBlbHNlLlxyXG5cclxuICAgICAgICAvLyBpZiB0aGlzIGlzIG9uIHRoZSBzZXJ2ZXIsIHdhbnQgdG8gbWFyayB0aGlzIHNvIHRoYXQgaXQgZ2V0cyBhY3RpdmF0ZWQgYXMgc2VsZWN0YWJsZSBvbiB0aGUgY2xpZW50LlxyXG4gICAgICAgIC8vICBwZXJoYXBzIHdyaXRlIG1vcmUgb2YgYW4gYWJzdHJhY3Rpb24gZm9yIGNvZGUgc2NvcGUgc2hpZnRpbmcuXHJcblxyXG4gICAgICAgIC8vIGNvdWxkIHVzZSBqc2d1aSBmbGFncz9cclxuICAgICAgICAvLyAgbmVlZCB0byB3b3JrIG9uIHRoZSBhY3RpdmF0aW9uIHN0YWdlIHRvIHJlYWQgZGF0YSBvdXQgb2YgdGhlIGRvbSBub2RlLlxyXG5cclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgY3RybCA9IGN0cmwgfHwgdGhpcztcclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgLy8gc2V0IHRoZSBqc2d1aSBmaWVsZFxyXG5cclxuICAgICAgICAgICAgLy8gU2hvdWxkIHVzZSBhIGRpZmZlcmVudCB2ZXJzaW9uIG9mIGpzZ3VpIGRhdGEgZmllbGRzLlxyXG4gICAgICAgICAgICAvLyBzdWNoIGFzIF9fZmllbGRzXHJcbiAgICAgICAgICAgIC8vIGp1c3QgX2ZpZWxkc1xyXG5cclxuICAgICAgICAgICAgLy8gIHdoZW4gdGhlIGNvbnRyb2wgcmVuZGVycyB0aGUgZG9tIGF0dHJpYnV0ZXMsIGl0IHRyZWF0cyB0aGF0IGFzIGEgc3BlY2lhbCBjYXNlLlxyXG4gICAgICAgICAgICAvLyAgaXQgYWxyZWFkeSBoYXMgYSBmZXcgc3BlY2lhbCBjYXNlcywgZWcgc3R5bGUsIGpzZ3VpX2N0cmxfZmllbGRzXHJcblxyXG4gICAgICAgICAgICAvKlxyXG5cclxuICAgICAgICAgICAgdmFyIGpzZiA9IHRoYXQuZ2V0KCdkb20uYXR0cmlidXRlcy5kYXRhLWpzZ3VpLWZpZWxkcycpO1xyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdqc2YnLCBqc2YpO1xyXG5cclxuXHJcblxyXG4gICAgICAgICAgICBpZiAoanNmKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdGhyb3cgJ3ByZS1leGlzdGluZyBqc2d1aSBmaWVsZHMsIG55aSdcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciBvYmogPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgJ2lzX3NlbGVjdGFibGUnOiB0cnVlXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICB0aGF0LnNldCgnZG9tLmF0dHJpYnV0ZXMuZGF0YS1qc2d1aS1maWVsZHMnLCBKU09OLnN0cmluZ2lmeShvYmopLnJlcGxhY2UoL1wiL2csIFwiW0RCTF9RVF1cIikucmVwbGFjZSgvJy9nLCBcIltTTkdfUVRdXCIpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLy5yZXBsYWNlKC9cIi9nLCBcIltEQkxfUVRdXCIpLnJlcGxhY2UoLycvZywgXCJbU05HX1FUXVwiKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoYXQuX2ZpZWxkcyA9IHRoYXQuX2ZpZWxkcyB8fCB7fTtcclxuICAgICAgICAgICAgdGhhdC5fZmllbGRzWydpc19zZWxlY3RhYmxlJ10gPSB0cnVlO1xyXG5cclxuXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gbm90IG1ha2luZyBzb21ldGhpbmcgc2VsZWN0YWJsZT9cclxuICAgICAgICAgICAgLy8gIFRoaXMgc2VlbXMgdG8gYmUgZ2V0dGluZyBjYWxsZWQgd2hlbiBpdCBzaG91bGQgbm90LlxyXG5cclxuXHJcblxyXG5cclxuICAgICAgICAgICAgdGhhdC5jbGljayhmdW5jdGlvbihlKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gT3IgaXMgdGhlIGNsaWNrIGV2ZW50IGJlaW5nIGJ1YmJsZWQ/XHJcblxyXG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygndGhhdCBjbGljaywgdGhhdDonLCB0aGF0KTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBpcyBjb250cm9sIGhlbGQgZG93bj9cclxuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2UnLCBlKTtcclxuICAgICAgICAgICAgICAgIHZhciBjdHJsX2tleSA9IGUuY3RybEtleTtcclxuICAgICAgICAgICAgICAgIHZhciBtZXRhX2tleSA9IGUubWV0YUtleTtcclxuXHJcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdtZXRhS2V5ICcgKyBlLm1ldGFLZXkpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChjdHJsX2tleSB8fCBtZXRhX2tleSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGN0cmwuYWN0aW9uX3NlbGVjdF90b2dnbGUoKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3RybC5hY3Rpb25fc2VsZWN0X29ubHkoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuICAgIH0sXHJcblxyXG5cclxuICAgICdhY3Rpb25fc2VsZWN0X29ubHknOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAvLyBuZWVkcyB0byBzZWUgd2hhdCBpcyB3aXRoaW4gdGhlIHNlbGVjdGlvbl9zY29wZS5cclxuICAgICAgICAvLyB0aGlzIGlzIGEgc2VsZWN0aW9uIHNjb3BlLCBvciBpdCByZWZlcnMgdG8gYSBjb250cm9sIHdpdGggdGhhdCBzZXQgdG8gdHJ1ZSB0aGF0IGlzIGFuIGFuY2VzdG9yLlxyXG4gICAgICAgIC8vICBpdCBjb3VsZCBmaW5kIHN1Y2ggYSBjb250cm9sLlxyXG4gICAgICAgIC8vIG5vdCB0b3RhbGx5IHN1cmUgaWYgdGhlIGFuY2VzdG9yIHJlcXVpcmVtZW50IGlzIG5lY2Vzc2FyeSwgaXQgbWF5IG1ha2Ugc2Vuc2UgYW5kIGJlIGJlc3QgdGhvdWdoLlxyXG4gICAgICAgIC8vY29uc29sZS5sb2coJ2FjdGlvbl9zZWxlY3QgJyk7XHJcbiAgICAgICAgLy8gSSB0aGluayBhIFNlbGVjdGlvbl9TY29wZSBvYmplY3QgbWF5IG1ha2Ugc2Vuc2UgdG8gaG9sZCB0aGUgZGF0YS5cclxuXHJcbiAgICAgICAgLy8gdGhpcy5zZWxlY3Rpb25fc2NvcGUuc2VsZWN0X29ubHkodGhpcyk7XHJcblxyXG4gICAgICAgIC8vdGhpcy5nZXQoJ3NlbGVjdGlvbl9zY29wZScpLnNlbGVjdF9vbmx5KHRoaXMpO1xyXG5cclxuICAgICAgICB2YXIgc3MgPSB0aGlzLmZpbmRfc2VsZWN0aW9uX3Njb3BlKCk7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ3NzJywgc3MpO1xyXG4gICAgICAgIC8vIFRoZSBzZWxlY3Rpb24gc2NvcGUgc2hvdWxzIGJlIGEgU2VsZWN0aW9uX1Njb3BlIG9iamVjdC5cclxuXHJcbiAgICAgICAgLy8gIEkgdGhpbmsgdGhhdCBpdCB3b3VsZCBtYWtlIHVzZSBvZiB0aGUgQisgdHJlZSB3aGVyZSBuZWVkZWQuXHJcbiAgICAgICAgLy8gTmVlZCBhbGdvcml0aG1pY2FsbHkgZmFzdCBvcGVyYXRpb25zIHRvOlxyXG4gICAgICAgIC8vIFNlbGVjdCBvciBkZXNlbGVjdCBhbiBvYmplY3RcclxuICAgICAgICAvLyBHZXQgYWxsIG9iamVjdHMgdGhhdCBhcmUgc2VsZWN0ZWQgaW4gdGhlIG9yZGVyIGluIHdoaWNoIHRoZXkgYXJlIGxpc3RlZCBpbiBhbm90aGVyIGNvbnRyb2wuXHJcbiAgICAgICAgLy8gIFRob3VnaCBjYW4gZ2V0IGFsbCBvYmplY3RzIHRoYXQgYXJlIHNlbGVjdGVkIHF1aWNrbHksIHRoZW4gcXVpY2tseSBnZXQgdGhlaXIgaW5kZXhlcy5cclxuICAgICAgICAvLyAgRG8gdGhhdCB3aXRob3V0IGdvaW5nIHRocm91Z2ggd2hvbGUgc2VsZWN0aW9uLlxyXG5cclxuICAgICAgICAvL2NvbnNvbGUubG9nKCd0aGlzICcsIHRoaXMpO1xyXG5cclxuICAgICAgICAvLyBpcyB0aGVyZSBhIHNlbGVjdGlvbiBzY29wZT9cclxuICAgICAgICAvLyAgV2FudCB0byBoYXZlIHNlbGVjdGlvbiBzY29wZWQgc2V0IHVwIG9uIHRoZSBzZXJ2ZXIgT0suXHJcbiAgICAgICAgLy8gIFdvdWxkIG1lYW4gc2VsZWN0aW9uIHNjb3BlcyBuZWVkIHRvIGJlIGNyZWF0ZWQgdXBvbiBhY3RpdmF0aW9uLlxyXG4gICAgICAgIC8vICAgUGVyaGFwcyBhbnkgY29udHJvbCB0aGF0IGhhcyBpdHMgc2VsZWN0aW9uIHNjb3BlIHNldCBzaG91bGQgYWxzbyBzZW5kIGEgc2VsZWN0aW9uIHNjb3BlIGlkIHRvIHRoZSBjbGllbnQuXHJcblxyXG4gICAgICAgIHNzLnNlbGVjdF9vbmx5KHRoaXMpO1xyXG4gICAgICAgIC8vdGhpcy5maW5kX3NlbGVjdGlvbl9zY29wZSgpLnNlbGVjdF9vbmx5KHRoaXMpO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgJ2FjdGlvbl9zZWxlY3RfdG9nZ2xlJzogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy5maW5kX3NlbGVjdGlvbl9zY29wZSgpLnNlbGVjdF90b2dnbGUodGhpcyk7XHJcbiAgICB9LFxyXG5cclxuXHJcbiAgICAvLyBTbyBJIHRoaW5rIHRoZSByZXNvdXJjZS1wb29sIHdpbGwgaGF2ZSBhIHNlbGVjdGlvbiBzY29wZS5cclxuICAgICdmaW5kX3NlbGVjdGlvbl9zY29wZSc6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdmaW5kX3NlbGVjdGlvbl9zY29wZScpO1xyXG5cclxuICAgICAgICB2YXIgcmVzID0gdGhpcy5nZXQoJ3NlbGVjdGlvbl9zY29wZScpO1xyXG4gICAgICAgIGlmIChyZXMpIHJldHVybiByZXM7XHJcblxyXG4gICAgICAgIC8vIGxvb2sgYXQgdGhlIGFuY2VzdG9yLi4uXHJcblxyXG4gICAgICAgIC8vdmFyIHBhcmVudCA9IHRoaXMuZ2V0KCdwYXJlbnQnKTtcclxuICAgICAgICAvLyB3YW50IGFuIGVhc3kgd2F5IHRvIGdldCB0aGUgcGFyZW50IGNvbnRyb2wuXHJcblxyXG4gICAgICAgIC8vIC5wYXJlbnQgZm9yIGEgY29udHJvbCBzaG91bGQgZG8gdGhpcyBJIHRoaW5rLlxyXG5cclxuICAgICAgICB2YXIgcGFyZW50X2NvbnRyb2xfY29sbGVjdGlvbiA9IHRoaXMucGFyZW50KCk7XHJcbiAgICAgICAgLy8gTm90IGdldHRpbmcgdGhlIHBhcmVudCBjb250cm9scy5cclxuXHJcblxyXG4gICAgICAgIGNvbnNvbGUubG9nKCdwYXJlbnRfY29udHJvbF9jb2xsZWN0aW9uJywgcGFyZW50X2NvbnRyb2xfY29sbGVjdGlvbik7XHJcblxyXG4gICAgICAgIC8vIEluIGFjdGl2YXRpb24sIGl0IGxvb2tzIGxpa2Ugd2UgbmVlZCB0byBob29rIHVwIHRoZSBwYXJlbnQgY29udHJvbHMuXHJcblxyXG5cclxuXHJcbiAgICAgICAgaWYgKHBhcmVudF9jb250cm9sX2NvbGxlY3Rpb24pIHtcclxuICAgICAgICAgICAgdmFyIHBhcmVudF9jb250cm9sID0gcGFyZW50X2NvbnRyb2xfY29sbGVjdGlvbi5wYXJlbnQoKTtcclxuXHJcbiAgICAgICAgICAgIC8vdmFyIHBhcmVudCA9IHRoaXMucGFyZW50KCkucGFyZW50KCk7XHJcblxyXG5cclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygncGFyZW50X2NvbnRyb2wgJyArIHRvZihwYXJlbnRfY29udHJvbCkpO1xyXG5cclxuXHJcbiAgICAgICAgICAgIGlmIChwYXJlbnRfY29udHJvbCkgcmV0dXJuIHBhcmVudF9jb250cm9sLmZpbmRfc2VsZWN0aW9uX3Njb3BlKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuXHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvLyBOaWNlLCB0aGlzIHdvcmtzLiBOb3QgdGhhdCBlZmZpY2llbnRseSB5ZXQuXHJcblxyXG4gICAgJ21ha2VfZnVsbF9oZWlnaHQnOiBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgZWwgPSB0aGlzLmdldCgnZG9tLmVsJyk7XHJcbiAgICAgICAgdmFyIHZpZXdwb3J0SGVpZ2h0ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodDtcclxuXHJcblxyXG4gICAgICAgIHZhciByZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICAgICAgY29uc29sZS5sb2cocmVjdC50b3AsIHJlY3QucmlnaHQsIHJlY3QuYm90dG9tLCByZWN0LmxlZnQpO1xyXG5cclxuICAgICAgICB2YXIgaCA9IHZpZXdwb3J0SGVpZ2h0IC0gcmVjdC50b3A7XHJcblxyXG4gICAgICAgIHRoaXMuc3R5bGUoJ2hlaWdodCcsIGggKyAncHgnLCB0cnVlKTtcclxuICAgIH0sXHJcbiAgICAnZ3JpZF85JzogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHJlcyA9IHRoaXMuZ2V0KCdncmlkXzknKTtcclxuICAgICAgICBpZiAocmVzKSByZXR1cm4gcmVzO1xyXG5cclxuICAgICAgICByZXMgPSBuZXcgR3JpZF85KHtcclxuICAgICAgICAgICAgJ2NvbnRleHQnOiB0aGlzLl9jb250ZXh0XHJcbiAgICAgICAgfSlcclxuICAgICAgICAvL3Jlcy5fX3R5cGVfbmFtZSA9ICdjb250cm9sJztcclxuICAgICAgICByZXMuc2V0KCdkb20uYXR0cmlidXRlcy5kYXRhLWpzZ3VpLXR5cGUnLCAnY29udHJvbCcpO1xyXG4gICAgICAgIC8vIG5lZWQgdG8gc2F5IGl0J3MgYSBjb250cm9sIHRvby4uLlxyXG5cclxuICAgICAgICB2YXIgcmVzX2lkID0gcmVzLl9pZCgpO1xyXG5cclxuICAgICAgICByZXMuc2V0KCdkb20uYXR0cmlidXRlcy5kYXRhLWpzZ3VpLWlkJywgcmVzX2lkKTtcclxuXHJcbiAgICAgICAgdGhpcy5fY29udGV4dC5tYXBfY29udHJvbHNbcmVzX2lkXSA9IHJlcztcclxuXHJcbiAgICAgICAgLy9yZXMuc2V0KCcnKVxyXG5cclxuICAgICAgICAvLyB0cmFuc3BsYW50IHRoZSBjb250ZW50LlxyXG5cclxuXHJcbiAgICAgICAgdmFyIGVsID0gdGhpcy5nZXQoJ2RvbS5lbCcpO1xyXG4gICAgICAgIC8vIHJlbW92ZSBhbGwgY2hpbGQgbm9kZXM/Pz9cclxuXHJcbiAgICAgICAgLy8gY2FuIGp1c3QgaW5zZXJ0IHRoZSByZW5kZXJlZCBncmlkOVxyXG4gICAgICAgIC8vY29uc29sZS5sb2coJ3ByZSByZXMgYWxsX2h0bWxfcmVuZGVyJylcclxuICAgICAgICB2YXIgaHRtbF9ncmlkXzkgPSByZXMuYWxsX2h0bWxfcmVuZGVyKCk7XHJcbiAgICAgICAgdmFyIG5lbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG5cclxuICAgICAgICAvL2NvbnNvbGUubG9nKCdodG1sX2dyaWRfOSAnICsgaHRtbF9ncmlkXzkpO1xyXG5cclxuICAgICAgICBuZWwuaW5uZXJIVE1MID0gaHRtbF9ncmlkXzk7XHJcblxyXG4gICAgICAgIHZhciBlbF9ncmlkXzkgPSBuZWwuY2hpbGROb2Rlc1swXTtcclxuXHJcbiAgICAgICAgLy9jb25zb2xlLmxvZygnZWxfZ3JpZF85ICcgKyBlbF9ncmlkXzkpO1xyXG5cclxuICAgICAgICAvL2NvbnNvbGUubG9nKCdlbF9ncmlkXzkuY2hpbGROb2Rlcy5sZW5ndGggJyArIGVsX2dyaWRfOS5jaGlsZE5vZGVzLmxlbmd0aCApO1xyXG5cclxuXHJcblxyXG4gICAgICAgIGVsLmluc2VydEJlZm9yZShlbF9ncmlkXzksIGVsLmNoaWxkTm9kZXNbMF0pO1xyXG5cclxuICAgICAgICB3aGlsZSAoZWwuY2hpbGROb2Rlc1sxXSkge1xyXG4gICAgICAgICAgICBlbF9ncmlkXzkuY2hpbGROb2Rlc1sxXS5jaGlsZE5vZGVzWzFdLmFwcGVuZENoaWxkKGVsLmNoaWxkTm9kZXNbMV0pO1xyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIHJlcy5zZXQoJ2RvbS5lbCcsIGVsX2dyaWRfOSk7XHJcblxyXG4gICAgICAgIHJlcy5hY3RpdmF0ZV9yZWN1cnNpdmUoKTtcclxuICAgICAgICAvLyBjYW4ndCBkbyBpdCBxdWl0ZSBsaWtlIHRoYXQuXHJcbiAgICAgICAgLy8gIG1heWJlIGNoYW5nZSBmb3IgY29weWluZyBiZXR3ZWVuIGNvbGxlY3Rpb25zLlxyXG4gICAgICAgIC8vICBzZXR0aW5nIGEgY29sbGVjdGlvbiwgd2l0aCBhIGNvbGxlY3Rpb24uXHJcbiAgICAgICAgLy8gICBzaG91bGQgY3JlYXRlIGEgbmV3IGNvcHk/XHJcbiAgICAgICAgLy8gICAgb3IgcmVmZXJlbmNlIGl0Li4uXHJcbiAgICAgICAgLy8gICByZWZlcmVuY2UgaXMgYmV0dGVyIGlmIGl0IHdvcmtzLlxyXG5cclxuXHJcbiAgICAgICAgLy8gZ2V0IGNvbnRlbnQgc2hvdWxkIGdldCBhIGNvbGxlY3Rpb24uLi5cclxuICAgICAgICAvLyAgYnV0IG5lZWQgdG8gd29yayBvbiB0aGUgRGF0YV9PYmplY3QncyBzZXQgZm9yIHdoZW4gaXQgaXMgZGVhbGluZyB3aXRoIGEgY29sbGVjdGlvbi5cclxuXHJcblxyXG4gICAgICAgIHZhciBjdXJyZW50X2NvbnRlbnQgPSB0aGlzLmdldCgnY29udGVudCcpO1xyXG5cclxuICAgICAgICAvL2NvbnNvbGUubG9nKCcxKSBjdXJyZW50X2NvbnRlbnQubGVuZ3RoKCkgJyArIGN1cnJlbnRfY29udGVudC5sZW5ndGgoKSk7XHJcbiAgICAgICAgLy90aHJvdyAnc3RvcCc7XHJcblxyXG4gICAgICAgIC8vIG5lZWQgdG8gY29weSBpdCBzb21laG93Li4uLlxyXG5cclxuICAgICAgICB2YXIgcmVzX21pZGRsZSA9IHJlcy5nZXQoJ2NvbnRlbnQnKS5nZXQoMSkuZ2V0KCdjb250ZW50JykuZ2V0KDEpO1xyXG4gICAgICAgIC8vY29uc29sZS5sb2coJ3Jlc19taWRkbGUgJyArIHJlc19taWRkbGUpO1xyXG5cclxuXHJcblxyXG5cclxuICAgICAgICByZXNfbWlkZGxlLnNldCgnY29udGVudCcsIGN1cnJlbnRfY29udGVudCk7XHJcblxyXG4gICAgICAgIC8vY29uc29sZS5sb2coJzEpIHJlcyBjb250ZW50IC5sZW5ndGgoKSAnICsgcmVzLmdldCgnY29udGVudCcpLmxlbmd0aCgpKTtcclxuICAgICAgICAvL2NvbnNvbGUubG9nKCcxKSByZXNfbWlkZGxlIGNvbnRlbnQgLmxlbmd0aCgpICcgKyByZXNfbWlkZGxlLmdldCgnY29udGVudCcpLmxlbmd0aCgpKTtcclxuXHJcblxyXG4gICAgICAgIHRoaXMuZ2V0KCdjb250ZW50JykuY2xlYXIoKTtcclxuICAgICAgICB0aGlzLmdldCgnY29udGVudCcpLmFkZChyZXMpO1xyXG5cclxuXHJcbiAgICAgICAgdGhpcy5zZXQoJ2dyaWRfOScsIHJlcyk7XHJcblxyXG4gICAgICAgIC8vdmFyIGN1cnJlbnRfY29udGVudCA9IHRoaXMuZ2V0KCdjb250ZW50Jyk7XHJcblxyXG4gICAgICAgIC8vY29uc29sZS5sb2coJzIpIGN1cnJlbnRfY29udGVudC5sZW5ndGgoKSAnICsgY3VycmVudF9jb250ZW50Lmxlbmd0aCgpKTtcclxuXHJcbiAgICAgICAgLy8gcmVjdXJzaXZlIGFjdGl2YXRlLi4uXHJcbiAgICAgICAgLy8gIG5lZWRzIHRvIGFjdGl2YXRlIGZyb20gaW5zaWRlIHRvIG91dHNpZGUuXHJcblxyXG4gICAgICAgIC8vIFdoZW4gc29tZXRoaW5nIGdldHMgYW5jaG9yZWQgaW50byBhIHBvc2l0aW9uIGluIHRoZSBHcmlkXzksIHRoZSBHcmlkXzkgbmVlZHMgdG8gaGFuZGxlIGl0LlxyXG5cclxuXHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuXHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvLyBJcyBnZXR0aW5nIGEgYml0IHZlcmJvc2UuXHJcbiAgICAvLyAgU29tZSB0aGluZ3MgY291bGQgYmUgZXhwcmVzc2VkIG1vcmUgZWZmaWNpZW50bHkuXHJcbiAgICAvLyAgSG93ZXZlciwgcmlnaHQgbm93IGRvbid0IHdhbnQgdG8gY3JlYXRlIG92ZXJhbGwgYWJzdHJhY3Rpb24gZm9yIHRoaXMuXHJcblxyXG4gICAgLy8gVGhlcmUgd2lsbCBiZSBncmlkXzkgYW5kIGEgZmV3IG90aGVyIGxheW91dHMgdGhhdCBhcmUgZmFpcmx5IGludHJpbnNpYyB0byB0aGUgc3lzdGVtLlxyXG5cclxuXHJcblxyXG5cclxuICAgICdlbnN1cmVfZG9ja19wbGFjZWhvbGRlcic6IGZ1bmN0aW9uKHBvcykge1xyXG4gICAgICAgIC8vY29uc29sZS5sb2coJ2VuaCBjdHJsIGVuc3VyZV9kb2NrX3BsYWNlaG9sZGVyIHBvcyAnICsgcG9zKTtcclxuXHJcbiAgICAgICAgLy8gYW5kIHRoZW4gd2Uga2VlcCB0cmFjayBvZiB0aGUgZG9jayBwbGFjZWhvbGRlci5cclxuXHJcbiAgICAgICAgLy8gd291bGQgbGlrZWx5IGJlIGVhc2llciB0byBnZXQgYSBzdHJpbmcgYnkgZGVmYXVsdD9cclxuICAgICAgICAvLyAgb3IgZWFzaWx5IGdldCB0aGUgdmFsdWUuXHJcblxyXG4gICAgICAgIC8vIGEgdmFsIGZ1bmN0aW9uIHRoYXQgZ2V0cyB0aGUgdmFsdWUgb2YgaXQsIGlmIGl0IGhhcyBhIHZhbHVlIGZ1bmN0aW9uLlxyXG5cclxuXHJcblxyXG4gICAgICAgIC8vdmFsKGRvY2tfcGxhY2Vob2xkZXJfcG9zKVxyXG5cclxuXHJcbiAgICAgICAgLy8gdXNlIHRoZSBncmlkXzkncyBkb2NrIHBsYWNlaG9sZGVyIHBvc2l0aW9uP1xyXG5cclxuXHJcbiAgICAgICAgLy9jb25zb2xlLmxvZygnZG9ja19wbGFjZWhvbGRlcl9wb3MgJyArIHN0cmluZ2lmeShkb2NrX3BsYWNlaG9sZGVyX3BvcykpO1xyXG4gICAgICAgIC8vY29uc29sZS5sb2coJ3RvZiBkb2NrX3BsYWNlaG9sZGVyX3BvcyAnICsgdG9mKGRvY2tfcGxhY2Vob2xkZXJfcG9zKSk7XHJcbiAgICAgICAgdmFyIGdyaWRfOSA9IHRoaXMuZ2V0KCdncmlkXzknKTtcclxuICAgICAgICB2YXIgZzllbCA9IGdyaWRfOS5nZXQoJ2RvbS5lbCcpO1xyXG4gICAgICAgIGlmIChncmlkXzkpIHtcclxuICAgICAgICAgICAgdmFyIGRvY2tfcGxhY2Vob2xkZXJfcG9zID0gZ3JpZF85LmdldCgnZG9ja19wbGFjZWhvbGRlcl9wb3MnKTtcclxuXHJcbiAgICAgICAgICAgIHZhciB0X3N0cmlwZSA9IGdyaWRfOS5nZXQoJ2NvbnRlbnQnKS5nZXQoMCk7XHJcbiAgICAgICAgICAgIHZhciBtX3N0cmlwZSA9IGdyaWRfOS5nZXQoJ2NvbnRlbnQnKS5nZXQoMSk7XHJcbiAgICAgICAgICAgIHZhciBjZWxsXzQgPSBtX3N0cmlwZS5nZXQoJ2NvbnRlbnQnKS5nZXQoMSk7XHJcbiAgICAgICAgICAgIHZhciBjZWxsNF9lbCA9IGNlbGxfNC5nZXQoJ2RvbS5lbCcpO1xyXG5cclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnZG9ja19wbGFjZWhvbGRlcl9wb3MgJyArIGRvY2tfcGxhY2Vob2xkZXJfcG9zKTtcclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnZG9ja19wbGFjZWhvbGRlcl9wb3MgJyArIHRvZihkb2NrX3BsYWNlaG9sZGVyX3BvcykpO1xyXG4gICAgICAgICAgICAvL3Rocm93ICdzdG9wJztcclxuICAgICAgICAgICAgaWYgKGRvY2tfcGxhY2Vob2xkZXJfcG9zKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgcG9zIHdlIGhhdmUgaXMgZGlmZmVyZW50LlxyXG4gICAgICAgICAgICAgICAgdmFyIGRwcF92YWw7XHJcbiAgICAgICAgICAgICAgICBpZiAoZG9ja19wbGFjZWhvbGRlcl9wb3MudmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBkcHBfdmFsID0gZG9ja19wbGFjZWhvbGRlcl9wb3MudmFsdWUoKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZHBwX3ZhbCA9IGRvY2tfcGxhY2Vob2xkZXJfcG9zO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vZHBwX3ZhbCA9IGRvY2tfcGxhY2Vob2xkZXJfcG9zLnZhbHVlKCk7XHJcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdkcHBfdmFsICcgKyBkcHBfdmFsKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIXBvcykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBpdCBmcm9tIHdoZXJldmVyIGl0IGlzLlxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkcHBfdmFsID09ICdsZWZ0Jykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBuZWVkIHRvIHNldCBzb21lIHN0eWxlcywgc28gdGhhdCBoX21pZGRsZSBkb2VzIG5vdCB0YWtlIHRoZSBmdWxsIHdpZHRoLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgcmVkdWNlIGl0cyB3aWR0aCBzbyB0aGF0IHRoZSBwbGFjZWhvbGRlciBjYW4gYmUgYWNjb21tb2RhdGVkLlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZ3JpZF85LmNsb3NlX3BsYWNlaG9sZGVyKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvKlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGc5dyA9IGc5ZWwub2Zmc2V0V2lkdGg7XHJcblxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBnOWMgPSBncmlkXzkuZ2V0KCdjb250ZW50Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2c5YycsIGc5Yy5sZW5ndGgoKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdtX3N0cmlwZScsIG1fc3RyaXBlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjZWxsXzMgPSBtX3N0cmlwZS5nZXQoJ2NvbnRlbnQnKS5nZXQoMCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBuZWVkIHRvIG1lYXN1cmUgYW5kIHNocmluayB0aGUgY2VudHJhbCBjZWxsLlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy92YXIgdyA9IGNlbGw0X2VsLm9mZnNldFdpZHRoO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygndyAnICsgdyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvciByZW1vdmUgdGhhdCBzdHlsZSBkZWNsYXJhdGlvbj9cclxuICAgICAgICAgICAgICAgICAgICAgICAgY2VsbF80LnN0eWxlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vJ3dpZHRoJzogbnVsbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3dpZHRoJzogJzEwMCUnXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcblxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2NlbGxfMycsIGNlbGxfMyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxfMy5yZW1vdmVfY2xhc3MoJ2RvY2stcGxhY2Vob2xkZXInKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXQoJ2RvY2tfcGxhY2Vob2xkZXJfcG9zJywgZmFsc2UpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkcHBfdmFsID09ICd0b3AnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vdmFyIGc5YyA9IGdyaWRfOS5nZXQoJ2NvbnRlbnQnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnZzljJywgZzljLmxlbmd0aCgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy92YXIgbV9zdHJpcGUgPSBncmlkXzkuZ2V0KCdjb250ZW50JykuZ2V0KDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdtX3N0cmlwZScsIG1fc3RyaXBlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyaWRfOS5jbG9zZV9wbGFjZWhvbGRlcigpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNlbGxfMSA9IHRfc3RyaXBlLmdldCgnY29udGVudCcpLmdldCgxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnY2VsbF8zJywgY2VsbF8zKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2VsbF8xLnJlbW92ZV9jbGFzcygnZG9jay1wbGFjZWhvbGRlcicpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldCgnZG9ja19wbGFjZWhvbGRlcl9wb3MnLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRwcF92YWwgPT0gJ3JpZ2h0Jykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBncmlkXzkuY2xvc2VfcGxhY2Vob2xkZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNlbGxfNSA9IGdyaWRfOS5nZXQoJ2NvbnRlbnQnKS5nZXQoMSkuZ2V0KCdjb250ZW50JykuZ2V0KDIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdjZWxsXzMnLCBjZWxsXzMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjZWxsXzUucmVtb3ZlX2NsYXNzKCdkb2NrLXBsYWNlaG9sZGVyJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0KCdkb2NrX3BsYWNlaG9sZGVyX3BvcycsIGZhbHNlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxfNC5zdHlsZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyd3aWR0aCc6IG51bGxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICd3aWR0aCc6ICcxMDAlJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRwcF92YWwgPT0gJ2JvdHRvbScpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ3JpZF85LmNsb3NlX3BsYWNlaG9sZGVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBib3R0b20gN1xyXG4gICAgICAgICAgICAgICAgICAgIC8vICBsaWtlIHdpdGggb3RoZXJzLCB0aGUgY2VudHJhbCBkaXYgd2lsbCBuZWVkIHRvIGJlIG1hZGUgYSBiaXQgc21hbGxlci5cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vdGhyb3cgJ3N0b3AnO1xyXG5cclxuXHJcblxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gcHV0IHRoZSBwbGFjZWhvbGRlciBpbiB0aGUgcG9zaXRpb24uLi5cclxuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3BvcyAnICsgcG9zKTtcclxuICAgICAgICAgICAgICAgIC8vdGhyb3cgJ3N0b3AnO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFwb3MpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyB0ZWxsIHRoZSBncmlkOSB0byByZW1vdmUgd2hpY2hldmVyIGNsYXNzIGluZGljYXRlcyBpdHMgdGhlIHBsYWNlaG9sZGVyLlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL3Rocm93ICdzdG9wJztcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHBvcyA9PSAnbGVmdCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAvL3ZhciBnOWMgPSBncmlkXzkuZ2V0KCdjb250ZW50Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnZzljJywgZzljLmxlbmd0aCgpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZ3JpZF85Lm9wZW5fcGxhY2Vob2xkZXIoJ2xlZnQnKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLypcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN3ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoO1xyXG4gICAgICAgICAgICAgICAgICAgIGdyaWRfOS5zdHlsZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICd3aWR0aCc6IGN3ICsgJ3B4J1xyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcblxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnbV9zdHJpcGUnLCBtX3N0cmlwZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNlbGxfMyA9IG1fc3RyaXBlLmdldCgnY29udGVudCcpLmdldCgwKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy92YXIgY2VsbF80ID0gbV9zdHJpcGUuZ2V0KCdjb250ZW50JykuZ2V0KDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjZWxsM19lbCA9IGNlbGxfMy5nZXQoJ2RvbS5lbCcpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vdmFyIGNlbGw0X2VsID0gY2VsbF80LmdldCgnZG9tLmVsJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGM0dyA9IGNlbGw0X2VsLm9mZnNldFdpZHRoO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCcqIGM0dyAnICsgYzR3KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy90aHJvdyAnc3RvcCc7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnY2VsbF8zJywgY2VsbF8zKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBlbnN1cmUgY2xhc3M/XHJcbiAgICAgICAgICAgICAgICAgICAgY2VsbF8zLmFkZF9jbGFzcygnZG9jay1wbGFjZWhvbGRlcicpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgYzN3ID0gY2VsbDNfZWwub2Zmc2V0V2lkdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG53ID0gYzR3IC0gYzN3O1xyXG4gICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ253ICcgKyBudyk7XHJcblxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY2VsbF80LnN0eWxlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ3dpZHRoJzogKG53KSArICdweCdcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJyogYzN3ICcgKyBjM3cpO1xyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXQoJ2RvY2tfcGxhY2Vob2xkZXJfcG9zJywgJ2xlZnQnKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChwb3MgPT0gJ3RvcCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAvL3ZhciBnOWMgPSBncmlkXzkuZ2V0KCdjb250ZW50Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnZzljJywgZzljLmxlbmd0aCgpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbV9zdHJpcGUgPSBncmlkXzkuZ2V0KCdjb250ZW50JykuZ2V0KDApO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ21fc3RyaXBlJywgbV9zdHJpcGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjZWxsXzEgPSBtX3N0cmlwZS5nZXQoJ2NvbnRlbnQnKS5nZXQoMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnY2VsbF8zJywgY2VsbF8zKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBlbnN1cmUgY2xhc3M/XHJcbiAgICAgICAgICAgICAgICAgICAgY2VsbF8xLmFkZF9jbGFzcygnZG9jay1wbGFjZWhvbGRlcicpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0KCdkb2NrX3BsYWNlaG9sZGVyX3BvcycsICd0b3AnKTtcclxuICAgICAgICAgICAgICAgICAgICAqL1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBncmlkXzkub3Blbl9wbGFjZWhvbGRlcigndG9wJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAocG9zID09ICdyaWdodCcpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZ3JpZF85Lm9wZW5fcGxhY2Vob2xkZXIoJ3JpZ2h0Jyk7XHJcblxyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvL2dyaWRfOS5vcGVuX3BsYWNlaG9sZGVyKCdib3R0b20nKTtcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHBvcyA9PSAnYm90dG9tJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGdyaWRfOS5vcGVuX3BsYWNlaG9sZGVyKCdib3R0b20nKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgJ3VuYW5jaG9yJzogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIGFuY2hvcmVkX3RvID0gdGhpcy5nZXQoJ2FuY2hvcmVkX3RvJyk7XHJcbiAgICAgICAgYW5jaG9yZWRfdG9bMF0udW5hbmNob3JfY3RybCh0aGlzKTtcclxuXHJcbiAgICB9XHJcblxyXG59KVxyXG5cclxudmFyIEdyaWRfOSA9IGpzZ3VpLkNvbnRyb2wuZXh0ZW5kKHtcclxuICAgICdpbml0JzogZnVuY3Rpb24oc3BlYykge1xyXG4gICAgICAgIHRoaXMuX3N1cGVyKHNwZWMpO1xyXG5cclxuICAgICAgICAvLyBjb21wb3NpdGlvbi4uLlxyXG4gICAgICAgIC8vICBuZWVkIHRvIGNyZWF0ZSAzIHN0cmlwZXM6IHRvcCwgdl9taWRkbGUsIGJvdHRvbVxyXG4gICAgICAgIC8vICAgdGhlbiB3aXRoaW4gZWFjaCBvZiB0aGVtIHdlIGhhdmUgbGVmdCwgaF9taWRkbGUsIHJpZ2h0XHJcblxyXG4gICAgICAgIC8vIGluIGFuIGFycmF5LiBUaGUgY2VudGVyIGlzIG51bWJlciA0LlxyXG5cclxuICAgICAgICAvLyAwIDEgMlxyXG4gICAgICAgIC8vIDMgNCA1XHJcbiAgICAgICAgLy8gNiA3IDhcclxuICAgICAgICB0aGlzLl9fdHlwZV9uYW1lID09ICdncmlkXzknO1xyXG5cclxuICAgICAgICB0aGlzLnNldCgnZG9tLmF0dHJpYnV0ZXMuY2xhc3MnLCAnZ3JpZF85Jyk7XHJcbiAgICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLl9jb250ZXh0O1xyXG5cclxuICAgICAgICAvLyBpZiBiZWluZyBnaXZlbiB0aGUgZWxlbWVudCB3aGVuIGl0IGlzIGNvbnN0cnVjdGVkLi4uXHJcblxyXG4gICAgICAgIC8vIHB1dHRpbmcgdGhpcyBpbnRvIGFub3RoZXIgY29udHJvbC5cclxuICAgICAgICAvLyAgd2UgbmVlZCB0byByZS1yZW5kZXIgdGhlIGNvbnRyb2wgZnVsbHksIEkgdGhpbmsuXHJcblxyXG4gICAgICAgIC8vIElzIHRoZXJlIGEgYmV0dGVyIHdheSB0byBwdXQgdGhpcyBpbnRvIGFuIGV4aXN0aW5nIGRvY3VtZW50P1xyXG5cclxuICAgICAgICAvLyBSZW5kZXIgdGhlIEhUTUwgb2YgaXQgYW5kIGV2ZXJ5dGhpbmcgaW5zaWRlIGl0Li4uXHJcbiAgICAgICAgLy8gIFdvdWxkIG5lZWQgdG8gcmVhY3RpdmF0ZSAvIHJlYXR0YWNoIGV2ZW50cy5cclxuICAgICAgICAvLyAgIE1lbW9yeSBsZWFrP1xyXG5cclxuICAgICAgICAvLyBjb3VsZCBtYXliZSBhY3RpdmF0ZSB0byBtYWtlIGFjY2VzcyB0byBzdWJjb250cm9scyBtb3JlIGNvbnZlbmllbnQ/XHJcblxyXG5cclxuXHJcbiAgICAgICAgLy8gd2UgY2FuIGRldGFjaCBhbmQgcmVhdHRhY2guXHJcbiAgICAgICAgLy8gIGNvdWxkIGhhdmUgYSBzcGVjaWZpYyBtZWNoYW5pc20gZm9yIHB1dHRpbmcgdGhpcyBpbi5cclxuXHJcbiAgICAgICAgLy8gY29tcG9zZSBpdHMgaHRtbFxyXG4gICAgICAgIC8vIHJlbmRlciBjcmVhdGUgdGhlIGVsZW1lbnQuXHJcbiAgICAgICAgLy8gIHJlbW92ZSB0aGUgZXhpc3RpbmcgZWxlbWVudFxyXG4gICAgICAgIC8vIHB1dCB0aGUgZ3JpZDkgZWxlbWVudCBpbiAob3IgaXMgaXQgc2ltcGx5IDkgZWxlbWVudHM/KSBncmlkXzkgY291bGQgdGFrZSBhbiBvdXRlciBkaXYsIHRob3VnaCB3ZSBjb3VsZCBwb3NzaWJseSByZW1vdmUgdGhhdC5cclxuICAgICAgICAvLyAgdGhlbiBwdXQgdGhlIGVsZW1lbnQgd2l0aGluIHBvc2l0aW9uIDQgb2YgdGhlIGdyaWQ5LlxyXG5cclxuICAgICAgICB2YXIgYXJyX3ZfbmFtZXMgPSBbJ3RvcCcsICd2LW1pZGRsZScsICdib3R0b20nXTtcclxuICAgICAgICB2YXIgYXJyX2hfbmFtZXMgPSBbJ2xlZnQnLCAnaC1taWRkbGUnLCAncmlnaHQnXTtcclxuXHJcbiAgICAgICAgaWYgKCFzcGVjLmVsKSB7XHJcbiAgICAgICAgICAgIHZhciBjID0gMDtcclxuICAgICAgICAgICAgdmFyIGFycl9jdHJscyA9IG5ldyBBcnJheSg5KTtcclxuICAgICAgICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCAzOyB5KyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBzdHJpcGUgPSBuZXcganNndWkuQ29udHJvbCh7XHJcbiAgICAgICAgICAgICAgICAgICAgJ2NvbnRleHQnOiBjb250ZXh0XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgc3RyaXBlLnNldCgnZG9tLmF0dHJpYnV0ZXMuY2xhc3MnLCBhcnJfdl9uYW1lc1t5XSk7XHJcbiAgICAgICAgICAgICAgICAvLyBjb3VsZCBoYXZlIHRoZSBwYWdlIGNvbnRleHQgc2VlIHdoYXQgdGhlIGZyZWUgaWRzIGFyZSwgYW5kIHRoZW4gdXNlIHRoZW0uXHJcbiAgICAgICAgICAgICAgICAvLyAgd291bGQgc2V0IHRoZSBjb3VudGVyIGZvciBlYWNoIG9mIHRoZW0gYmFzZWQgb24gd2hhdCBoYXMgYmVlbiBmb3VuZC5cclxuXHJcbiAgICAgICAgICAgICAgICBzdHJpcGUuc2V0KCdkb20uYXR0cmlidXRlcy5kYXRhLWpzZ3VpLXR5cGUnLCBzdHJpcGUuX190eXBlX25hbWUpO1xyXG5cclxuXHJcbiAgICAgICAgICAgICAgICBzdHJpcGUuc2V0KCdkb20uYXR0cmlidXRlcy5kYXRhLWpzZ3VpLWlkJywgc3RyaXBlLl9pZCgpKTtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLmFkZChzdHJpcGUpO1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnRleHQubWFwX2NvbnRyb2xzW3N0cmlwZS5faWQoKV0gPSBzdHJpcGU7XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCAzOyB4KyspIHtcclxuICAgICAgICAgICAgICAgICAgICBhcnJfY3RybHNbY10gPSBuZXcganNndWkuQ29udHJvbCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdjb250ZXh0JzogY29udGV4dFxyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgYXJyX2N0cmxzW2NdLnNldCgnZG9tLmF0dHJpYnV0ZXMuY2xhc3MnLCBhcnJfaF9uYW1lc1t4XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYXJyX2N0cmxzW2NdLnNldCgnZG9tLmF0dHJpYnV0ZXMuZGF0YS1qc2d1aS1pZCcsIGFycl9jdHJsc1tjXS5faWQoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYXJyX2N0cmxzW2NdLnNldCgnZG9tLmF0dHJpYnV0ZXMuZGF0YS1qc2d1aS10eXBlJywgYXJyX2N0cmxzW2NdLl9fdHlwZV9uYW1lKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgc3RyaXBlLmFkZChhcnJfY3RybHNbY10pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0Lm1hcF9jb250cm9sc1thcnJfY3RybHNbY10uX2lkKCldID0gYXJyX2N0cmxzW2NdO1xyXG4gICAgICAgICAgICAgICAgICAgIGMrKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKHRoaXMuZ2V0KCdjb250ZW50JykubGVuZ3RoKCkpO1xyXG4gICAgICAgICAgICAvL3Rocm93ICdzdG9wJztcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgJ3VuYW5jaG9yX2N0cmwnOiBmdW5jdGlvbihjdHJsKSB7XHJcbiAgICAgICAgdmFyIGFuY2hvcmVkX3RvID0gY3RybC5nZXQoJ2FuY2hvcmVkX3RvJyk7XHJcbiAgICAgICAgdmFyIHpvbmUgPSBhbmNob3JlZF90b1syXTtcclxuICAgICAgICBjb25zb2xlLmxvZygndW5hbmNob3JfY3RybCB6b25lICcgKyB6b25lKTtcclxuICAgICAgICBjdHJsLnJlbW92ZV9jbGFzcygnYW5jaG9yZWQnKTtcclxuXHJcbiAgICAgICAgdmFyIHVuYW5jaG9yZWRfb2Zmc2V0ID0gY3RybC5nZXQoJ3VuYW5jaG9yZWRfb2Zmc2V0Jyk7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ3VuYW5jaG9yZWRfb2Zmc2V0JywgdW5hbmNob3JlZF9vZmZzZXQpO1xyXG5cclxuICAgICAgICAvLyBCdXQgd2hlbiB1bmFuY2hvcmluZyBpcyBkb25lIGFzIHBhcnQgb2YgYSBkcmFnLi4uXHJcbiAgICAgICAgLy8gIG5lZWQgdG8gcmVjYWxjdWxhdGUgdGhlIGRyYWcgb2Zmc2V0LlxyXG5cclxuICAgICAgICAvL2N0cmwub2Zmc2V0KHVuYW5jaG9yZWRfb2Zmc2V0KTtcclxuICAgICAgICBpZiAodW5hbmNob3JlZF9vZmZzZXQpIHtcclxuICAgICAgICAgICAgaWYgKHpvbmUgIT09ICdyaWdodCcpIHtcclxuICAgICAgICAgICAgICAgIGN0cmwuc2V0KCdvZmZzZXRfYWRqdXN0bWVudCcsIFt1bmFuY2hvcmVkX29mZnNldFswXSwgMF0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICB2YXIgdF9zdHJpcGUgPSB0aGlzLmdldCgnY29udGVudCcpLmdldCgwKTtcclxuICAgICAgICB2YXIgbV9zdHJpcGUgPSB0aGlzLmdldCgnY29udGVudCcpLmdldCgxKTtcclxuICAgICAgICB2YXIgY2VsbF80ID0gbV9zdHJpcGUuZ2V0KCdjb250ZW50JykuZ2V0KDEpO1xyXG4gICAgICAgIHZhciBjZWxsNF9lbCA9IGNlbGxfNC5nZXQoJ2RvbS5lbCcpO1xyXG5cclxuICAgICAgICBpZiAoem9uZSA9PSAnbGVmdCcpIHtcclxuICAgICAgICAgICAgdmFyIGNlbGxfMyA9IG1fc3RyaXBlLmdldCgnY29udGVudCcpLmdldCgwKTtcclxuXHJcbiAgICAgICAgICAgIC8vdmFyIGNlbGxfNCA9IG1fc3RyaXBlLmdldCgnY29udGVudCcpLmdldCgxKTtcclxuICAgICAgICAgICAgdmFyIGNlbGwzX2VsID0gY2VsbF8zLmdldCgnZG9tLmVsJyk7XHJcblxyXG4gICAgICAgICAgICBjZWxsXzMucmVtb3ZlX2NsYXNzKCdvcGVuJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoem9uZSA9PSAncmlnaHQnKSB7XHJcbiAgICAgICAgICAgIC8vdmFyIGM0dyA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aDtcclxuICAgICAgICAgICAgdmFyIGNlbGxfNSA9IHRoaXMuZ2V0KCdjb250ZW50JykuZ2V0KDEpLmdldCgnY29udGVudCcpLmdldCgyKTtcclxuICAgICAgICAgICAgY2VsbF81LnJlbW92ZV9jbGFzcygnZG9jay1wbGFjZWhvbGRlcicpO1xyXG5cclxuICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgdGhpcy5zZXQoJ29wZW4nLCAncmlnaHQnKTtcclxuICAgICAgICAgICAgdmFyIGNlbGw1X2VsID0gY2VsbF81LmdldCgnZG9tLmVsJyk7XHJcbiAgICAgICAgICAgIHZhciBjNXcgPSBjZWxsNV9lbC5vZmZzZXRXaWR0aDtcclxuICAgICAgICAgICAgdmFyIG53ID0gYzR3IC0gYzV3O1xyXG4gICAgICAgICAgICBjZWxsXzQuc3R5bGUoe1xyXG4gICAgICAgICAgICAgICAgJ3dpZHRoJzogKG53KSArICdweCdcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgKi9cclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICBhbmNob3JlZF90b1swXS5jbG9zZV9wbGFjZWhvbGRlcih6b25lKTtcclxuXHJcblxyXG5cclxuICAgICAgICBjdHJsLnNldCgnYW5jaG9yZWRfdG8nLCBudWxsKTtcclxuICAgICAgICBjdHJsLnNldCgndW5hbmNob3JlZF9vZmZzZXQnLCBudWxsKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgICdhbmNob3JfY3RybCc6IGZ1bmN0aW9uKGN0cmwsIHpvbmUpIHtcclxuICAgICAgICAvLyBuZWVkIHRvIGZpbmQgdGhlIHJpZ2h0IG5lc3RlZCBzdWJjb250cm9sXHJcblxyXG4gICAgICAgIHZhciB4LCB5LCBmb3VuZDtcclxuICAgICAgICBpZiAoem9uZSA9PSAnbGVmdCcpIHtcclxuICAgICAgICAgICAgeCA9IDA7IHkgPSAxO1xyXG4gICAgICAgICAgICBmb3VuZCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh6b25lID09ICd0b3AnKSB7XHJcbiAgICAgICAgICAgIHggPSAxOyB5ID0gMDtcclxuICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoem9uZSA9PSAncmlnaHQnKSB7XHJcbiAgICAgICAgICAgIHggPSAyOyB5ID0gMTtcclxuICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoem9uZSA9PSAnYm90dG9tJykge1xyXG4gICAgICAgICAgICB4ID0gMTsgeSA9IDI7XHJcbiAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciB0X3N0cmlwZSA9IHRoaXMuZ2V0KCdjb250ZW50JykuZ2V0KDApO1xyXG4gICAgICAgIHZhciBtX3N0cmlwZSA9IHRoaXMuZ2V0KCdjb250ZW50JykuZ2V0KDEpO1xyXG4gICAgICAgIHZhciBjZWxsXzQgPSBtX3N0cmlwZS5nZXQoJ2NvbnRlbnQnKS5nZXQoMSk7XHJcbiAgICAgICAgdmFyIGNlbGw0X2VsID0gY2VsbF80LmdldCgnZG9tLmVsJyk7XHJcblxyXG4gICAgICAgIGlmIChmb3VuZCkge1xyXG4gICAgICAgICAgICB2YXIgZ3JpZF9zZWN0aW9uID0gdGhpcy5nZXQoJ2NvbnRlbnQnKS5nZXQoeSkuZ2V0KCdjb250ZW50JykuZ2V0KHgpO1xyXG5cclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnZ3JpZF9zZWN0aW9uICcsIGdyaWRfc2VjdGlvbik7XHJcblxyXG4gICAgICAgICAgICAvLyBuZWVkIGEgd2F5IG9mIGluc2VydGluZyBhIGNvbnRyb2wuXHJcbiAgICAgICAgICAgIC8vICBBZGRpbmcgdG8gdGhlIGNvbnRlbnQsIGFuZCBoYXZpbmcgdGhlIGNvbnRyb2wgcmVhY3QgdG8gdGhpcyBhbmQgdXBkYXRlIHRoZSBET00/XHJcblxyXG4gICAgICAgICAgICAvLyBtYXkgaGF2ZSBjdHJsLmFwcGVuZChjdHJsKVxyXG4gICAgICAgICAgICAvLyAgd2hpY2ggYWRkcyBpdCB0byB0aGUgY29udGVudCAoYW5kIHVwZGF0ZXMgdGhlIERPTSlcclxuICAgICAgICAgICAgLy8gY291bGQgYWxzbyBoYXZlIGFuIGFjdGl2YXRlZCBjb250cm9sIGxpc3RlbiBvdXQgZm9yIGNvbnRlbnQgY2hhbmdlcy5cclxuICAgICAgICAgICAgLy8gIHNvIHdoZW4gc29tZXRoaW5nIGdldHMgYWRkZWQgaW4gdGhlIGNvbnRlbnQsIGl0IGdldHMgYXBwZW5kZWQgaW4gdGhlIERPTSB0b28uXHJcbiAgICAgICAgICAgIC8vICAgSSB0aGluayB0aGF0IG1ha2VzIHNlbnNlIGluIHRlcm1zIG9mIGNvbnZlbmllbmNlLlxyXG5cclxuICAgICAgICAgICAgLy8gV2lsbCBtZWFuIG1ha2luZyB0aGF0IGxlZnQgYmFyIGJpZ2dlciBzbyB0aGF0IGl0IGZpdHMgdGhlIGZsZXhpIGJvYXJkLlxyXG4gICAgICAgICAgICAvLyBhbHNvIG5lZWQgdG8gYWRkIHRoZSBjbGFzcyAnb3Blbicgb3Igc29tZXRoaW5nIHRvIHNob3cgdGhhdCB0aGUgZ3JpZCBzZWN0aW9uIGlzIG9wZW4uXHJcblxyXG4gICAgICAgICAgICAvLyBvcGVuIGEgcGFydCBvZiB0aGUgZ3JpZCBzZWN0aW9uLi4uXHJcbiAgICAgICAgICAgIC8vICBiZXN0IHRvIGdldCB0aGUgZ3JpZF85IHRvIGRvIHRoaXMuXHJcbiAgICAgICAgICAgIC8vICBhbHNvIHdvdWxkIGJlIGdvb2QgdG8gZ2V0IHRoZSBncmlkXzkgdG8gc2hvdyBwbGFjZWhvbGRlcnMgdXNpbmcgaXRzIG93biBtZXRob2RzLlxyXG5cclxuXHJcblxyXG5cclxuICAgICAgICAgICAgLy8gQW5kIHRoaXMgd2lsbCBjaGFuZ2UgdGhlIGZvcm1hdHRpbmcgb2YgdGhlIGdyaWRfOVxyXG4gICAgICAgICAgICAvLyAgRG9uJ3Qgd2FudCB0aGF0IHNlY3Rpb24gdG8gYXBwZWFyIGFuZCBkaXNzaXBlYXIuXHJcbiAgICAgICAgICAgIC8vICBEb24ndCBzaG93IGl0IGFzIGEgcGxhY2Vob2xkZXIgd2hlbiBzb21ldGhpbmcgaXMgdGhlcmUuLi5cclxuXHJcbiAgICAgICAgICAgIC8vIE5lZWQgdG8gb3BlbiBhIHNlY3Rpb24gb2YgdGhlIEdyaWRfOSAvIHJlcG9zaXRpb24gdGhpbmdzLlxyXG4gICAgICAgICAgICAvLyAgTGlrZSB3aGVuIHRoZSBwbGFjZWhvbGRlciBpcyBzaG93bi5cclxuXHJcbiAgICAgICAgICAgIC8vIFdlIHdhbnQgdG8gYWN0dWFsbHkgb3BlbiB0aGF0IHNlY3Rpb24gb2YgdGhlIGdyaWRfOS5cclxuICAgICAgICAgICAgdmFyIHVuYW5jaG9yZWRfb2Zmc2V0ID0gY3RybC5vZmZzZXQoKTtcclxuICAgICAgICAgICAgY3RybC5zZXQoJ3VuYW5jaG9yZWRfb2Zmc2V0JywgdW5hbmNob3JlZF9vZmZzZXQpO1xyXG5cclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygndW5hbmNob3JlZF9vZmZzZXQnLCB1bmFuY2hvcmVkX29mZnNldCk7XHJcblxyXG4gICAgICAgICAgICBjdHJsLmFkZF9jbGFzcygnYW5jaG9yZWQnKTtcclxuXHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJycpO1xyXG4gICAgICAgICAgICBncmlkX3NlY3Rpb24uYWRkKGN0cmwpO1xyXG5cclxuICAgICAgICAgICAgY3RybC5zZXQoJ2FuY2hvcmVkX3RvJywgW3RoaXMsIGdyaWRfc2VjdGlvbiwgem9uZV0pO1xyXG4gICAgICAgICAgICB2YXIgdW5hbmNob3JlZF9zaXplID0gY3RybC5zaXplKCk7XHJcbiAgICAgICAgICAgIGN0cmwuc2V0KCd1bmFuY2hvcmVkX3NpemUnLCB1bmFuY2hvcmVkX3NpemUpO1xyXG4gICAgICAgICAgICAvLyBUaGlzIGlzIGJhc2ljYWxseSB3b3JraW5nIG5vdyFcclxuICAgICAgICAgICAgLy8gIEhhdmUgYXV0b21hdGljIERPTSBhcHBlbmQgb2YgYWRkZWQgY29udGVudC5cclxuICAgICAgICAgICAgLy8gICBOZWVkIHRvIGdldCB0aGF0IHdvcmtpbmcgcHJvcGVybHkgYW5kIHRlc3RlZCBpbiBhbGwgY2FzZXMgdGhvdWdoLlxyXG5cclxuICAgICAgICAgICAgaWYgKHpvbmUgPT0gJ2xlZnQnKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyAoJ2xlZnQgem9uZScpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGN3ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdHlsZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgJ3dpZHRoJzogY3cgKyAncHgnXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnbV9zdHJpcGUnLCBtX3N0cmlwZSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgY2VsbF8zID0gbV9zdHJpcGUuZ2V0KCdjb250ZW50JykuZ2V0KDApO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vdmFyIGNlbGxfNCA9IG1fc3RyaXBlLmdldCgnY29udGVudCcpLmdldCgxKTtcclxuICAgICAgICAgICAgICAgIHZhciBjZWxsM19lbCA9IGNlbGxfMy5nZXQoJ2RvbS5lbCcpO1xyXG4gICAgICAgICAgICAgICAgLy92YXIgY2VsbDRfZWwgPSBjZWxsXzQuZ2V0KCdkb20uZWwnKTtcclxuICAgICAgICAgICAgICAgIHZhciBjNHcgPSBjZWxsNF9lbC5vZmZzZXRXaWR0aDtcclxuICAgICAgICAgICAgICAgIGNlbGxfMy5hZGRfY2xhc3MoJ29wZW4nKTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgYzN3ID0gY2VsbDNfZWwub2Zmc2V0V2lkdGg7XHJcbiAgICAgICAgICAgICAgICB2YXIgbncgPSBjNHcgLSBjM3c7XHJcbiAgICAgICAgICAgICAgICBjZWxsXzQuc3R5bGUoe1xyXG4gICAgICAgICAgICAgICAgICAgICd3aWR0aCc6IChudykgKyAncHgnXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoem9uZSA9PSAncmlnaHQnKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYzR3ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoO1xyXG4gICAgICAgICAgICAgICAgdmFyIGNlbGxfNSA9IHRoaXMuZ2V0KCdjb250ZW50JykuZ2V0KDEpLmdldCgnY29udGVudCcpLmdldCgyKTtcclxuICAgICAgICAgICAgICAgIGNlbGxfNS5hZGRfY2xhc3MoJ2RvY2stcGxhY2Vob2xkZXInKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0KCdvcGVuJywgJ3JpZ2h0Jyk7XHJcbiAgICAgICAgICAgICAgICB2YXIgY2VsbDVfZWwgPSBjZWxsXzUuZ2V0KCdkb20uZWwnKTtcclxuICAgICAgICAgICAgICAgIHZhciBjNXcgPSBjZWxsNV9lbC5vZmZzZXRXaWR0aDtcclxuICAgICAgICAgICAgICAgIHZhciBudyA9IGM0dyAtIGM1dztcclxuICAgICAgICAgICAgICAgIGNlbGxfNC5zdHlsZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgJ3dpZHRoJzogKG53KSArICdweCdcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICh6b25lID09ICdib3R0b20nKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYyA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgY2VsbF83ID0gdGhpcy5nZXQoJ2NvbnRlbnQnKS5nZXQoMikuZ2V0KCdjb250ZW50JykuZ2V0KDEpO1xyXG4gICAgICAgICAgICAgICAgY2VsbF83LmFkZF9jbGFzcygnb3BlbicpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXQoJ2RvY2tfcGxhY2Vob2xkZXJfcG9zJywgJ2JvdHRvbScpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGNlbGw3X2VsID0gY2VsbF83LmdldCgnZG9tLmVsJyk7XHJcbiAgICAgICAgICAgICAgICB2YXIgYzdoID0gY2VsbDdfZWwub2Zmc2V0SGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnYzdoICcgKyBjN2gpO1xyXG4gICAgICAgICAgICAgICAgdmFyIG5oID0gYyAtIGM3aDtcclxuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ25oICcgKyBuaCk7XHJcbiAgICAgICAgICAgICAgICBtX3N0cmlwZS5zdHlsZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgJ2hlaWdodCc6IChuaCkgKyAncHgnXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vZ3JpZF9zZWN0aW9uLmFuY2hvcl9jdHJsKGN0cmwpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG4gICAgJ29wZW5fcGxhY2Vob2xkZXInOiBmdW5jdGlvbih6b25lKSB7XHJcbiAgICAgICAgLy9jb25zb2xlLmxvZygnZ3JpZF85IG9wZW5fcGxhY2Vob2xkZXIgJyArIHpvbmUpO1xyXG5cclxuICAgICAgICB2YXIgdF9zdHJpcGUgPSB0aGlzLmdldCgnY29udGVudCcpLmdldCgwKTtcclxuICAgICAgICB2YXIgbV9zdHJpcGUgPSB0aGlzLmdldCgnY29udGVudCcpLmdldCgxKTtcclxuICAgICAgICB2YXIgY2VsbF80ID0gbV9zdHJpcGUuZ2V0KCdjb250ZW50JykuZ2V0KDEpO1xyXG4gICAgICAgIHZhciBjZWxsNF9lbCA9IGNlbGxfNC5nZXQoJ2RvbS5lbCcpO1xyXG5cclxuICAgICAgICBpZiAoem9uZSA9PSAnbGVmdCcpIHtcclxuICAgICAgICAgICAgdmFyIGN3ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoO1xyXG4gICAgICAgICAgICB0aGlzLnN0eWxlKHtcclxuICAgICAgICAgICAgICAgICd3aWR0aCc6IGN3ICsgJ3B4J1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdtX3N0cmlwZScsIG1fc3RyaXBlKTtcclxuICAgICAgICAgICAgdmFyIGNlbGxfMyA9IG1fc3RyaXBlLmdldCgnY29udGVudCcpLmdldCgwKTtcclxuXHJcbiAgICAgICAgICAgIC8vdmFyIGNlbGxfNCA9IG1fc3RyaXBlLmdldCgnY29udGVudCcpLmdldCgxKTtcclxuICAgICAgICAgICAgdmFyIGNlbGwzX2VsID0gY2VsbF8zLmdldCgnZG9tLmVsJyk7XHJcbiAgICAgICAgICAgIC8vdmFyIGNlbGw0X2VsID0gY2VsbF80LmdldCgnZG9tLmVsJyk7XHJcbiAgICAgICAgICAgIHZhciBjNHcgPSBjZWxsNF9lbC5vZmZzZXRXaWR0aDtcclxuICAgICAgICAgICAgY2VsbF8zLmFkZF9jbGFzcygnZG9jay1wbGFjZWhvbGRlcicpO1xyXG5cclxuICAgICAgICAgICAgdmFyIGMzdyA9IGNlbGwzX2VsLm9mZnNldFdpZHRoO1xyXG4gICAgICAgICAgICB2YXIgbncgPSBjNHcgLSBjM3c7XHJcbiAgICAgICAgICAgIGNlbGxfNC5zdHlsZSh7XHJcbiAgICAgICAgICAgICAgICAnd2lkdGgnOiAobncpICsgJ3B4J1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICB0aGlzLnNldCgnZG9ja19wbGFjZWhvbGRlcl9wb3MnLCAnbGVmdCcpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHpvbmUgPT0gJ3RvcCcpIHtcclxuICAgICAgICAgICAgLy92YXIgbV9zdHJpcGUgPSBncmlkXzkuZ2V0KCdjb250ZW50JykuZ2V0KDApO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ21fc3RyaXBlJywgbV9zdHJpcGUpO1xyXG4gICAgICAgICAgICB2YXIgY2VsbF8xID0gdF9zdHJpcGUuZ2V0KCdjb250ZW50JykuZ2V0KDEpO1xyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdjZWxsXzMnLCBjZWxsXzMpO1xyXG4gICAgICAgICAgICAvLyBlbnN1cmUgY2xhc3M/XHJcbiAgICAgICAgICAgIGNlbGxfMS5hZGRfY2xhc3MoJ2RvY2stcGxhY2Vob2xkZXInKTtcclxuICAgICAgICAgICAgdGhpcy5zZXQoJ2RvY2tfcGxhY2Vob2xkZXJfcG9zJywgJ3RvcCcpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHpvbmUgPT0gJ3JpZ2h0Jykge1xyXG4gICAgICAgICAgICB2YXIgYzR3ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoO1xyXG4gICAgICAgICAgICB2YXIgY2VsbF81ID0gdGhpcy5nZXQoJ2NvbnRlbnQnKS5nZXQoMSkuZ2V0KCdjb250ZW50JykuZ2V0KDIpO1xyXG4gICAgICAgICAgICBjZWxsXzUuYWRkX2NsYXNzKCdkb2NrLXBsYWNlaG9sZGVyJyk7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0KCdkb2NrX3BsYWNlaG9sZGVyX3BvcycsICdyaWdodCcpO1xyXG5cclxuICAgICAgICAgICAgLy92YXIgYzR3ID0gY2VsbDRfZWwub2Zmc2V0V2lkdGg7XHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2M0dyAnICsgYzR3KTtcclxuICAgICAgICAgICAgLy9jZWxsXzUuYWRkX2NsYXNzKCdkb2NrLXBsYWNlaG9sZGVyJyk7XHJcbiAgICAgICAgICAgIHZhciBjZWxsNV9lbCA9IGNlbGxfNS5nZXQoJ2RvbS5lbCcpO1xyXG4gICAgICAgICAgICAvLyB1c2UgdGhlIGZ1bGwgcGFnZSB3aWR0aC5cclxuXHJcbiAgICAgICAgICAgIHZhciBjNXcgPSBjZWxsNV9lbC5vZmZzZXRXaWR0aDtcclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnYzV3ICcgKyBjNXcpO1xyXG4gICAgICAgICAgICB2YXIgbncgPSBjNHcgLSBjNXc7XHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ253ICcgKyBudyk7XHJcbiAgICAgICAgICAgIGNlbGxfNC5zdHlsZSh7XHJcbiAgICAgICAgICAgICAgICAnd2lkdGgnOiAobncpICsgJ3B4J1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHpvbmUgPT0gJ2JvdHRvbScpIHtcclxuICAgICAgICAgICAgdmFyIGMgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0O1xyXG4gICAgICAgICAgICB2YXIgY2VsbF83ID0gdGhpcy5nZXQoJ2NvbnRlbnQnKS5nZXQoMikuZ2V0KCdjb250ZW50JykuZ2V0KDEpO1xyXG4gICAgICAgICAgICBjZWxsXzcuYWRkX2NsYXNzKCdkb2NrLXBsYWNlaG9sZGVyJyk7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0KCdkb2NrX3BsYWNlaG9sZGVyX3BvcycsICdib3R0b20nKTtcclxuXHJcblxyXG4gICAgICAgICAgICAvL3ZhciBjNHcgPSBjZWxsNF9lbC5vZmZzZXRXaWR0aDtcclxuXHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2M0dyAnICsgYzR3KTtcclxuICAgICAgICAgICAgLy9jZWxsXzUuYWRkX2NsYXNzKCdkb2NrLXBsYWNlaG9sZGVyJyk7XHJcblxyXG4gICAgICAgICAgICB2YXIgY2VsbDdfZWwgPSBjZWxsXzcuZ2V0KCdkb20uZWwnKTtcclxuXHJcblxyXG4gICAgICAgICAgICAvLyB1c2UgdGhlIGZ1bGwgcGFnZSB3aWR0aC5cclxuXHJcblxyXG4gICAgICAgICAgICAvL3ZhciBjNGggPSBjZWxsNF9lbC5vZmZzZXRIZWlnaHQ7XHJcbiAgICAgICAgICAgIC8vIGdldCB0aGUgb2Zmc2V0IGhlaWdodCBvZiB0aGUgbWlkZGxlIHN0cmlwZSwgdGhhdCdzIHRoZSBvbmUgd2hvJ3MgaGVpZ2h0IHdlIHNob3VsZCBjaGFuZ2UuXHJcblxyXG5cclxuXHJcblxyXG4gICAgICAgICAgICB2YXIgYzdoID0gY2VsbDdfZWwub2Zmc2V0SGVpZ2h0O1xyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdjN2ggJyArIGM3aCk7XHJcbiAgICAgICAgICAgIHZhciBuaCA9IGMgLSBjN2g7XHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ25oICcgKyBuaCk7XHJcbiAgICAgICAgICAgIG1fc3RyaXBlLnN0eWxlKHtcclxuICAgICAgICAgICAgICAgICdoZWlnaHQnOiAobmgpICsgJ3B4J1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG4gICAgJ2Nsb3NlX3BsYWNlaG9sZGVyJzogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIGRwcG9zID0gdGhpcy5nZXQoJ2RvY2tfcGxhY2Vob2xkZXJfcG9zJyk7XHJcbiAgICAgICAgaWYgKGRwcG9zICYmIGRwcG9zLnZhbHVlKSBkcHBvcyA9IGRwcG9zLnZhbHVlKCk7XHJcblxyXG4gICAgICAgIHZhciB0X3N0cmlwZSA9IHRoaXMuZ2V0KCdjb250ZW50JykuZ2V0KDApO1xyXG5cclxuICAgICAgICB2YXIgbV9zdHJpcGUgPSB0aGlzLmdldCgnY29udGVudCcpLmdldCgxKTtcclxuICAgICAgICB2YXIgY2VsbF80ID0gbV9zdHJpcGUuZ2V0KCdjb250ZW50JykuZ2V0KDEpO1xyXG5cclxuICAgICAgICBpZiAoZHBwb3MgPT0gJ2xlZnQnKSB7XHJcbiAgICAgICAgICAgIHZhciBlbCA9IHRoaXMuZ2V0KCdkb20uZWwnKTtcclxuICAgICAgICAgICAgdmFyIGc5dyA9IGVsLm9mZnNldFdpZHRoO1xyXG5cclxuICAgICAgICAgICAgdmFyIGc5YyA9IHRoaXMuZ2V0KCdjb250ZW50Jyk7XHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2c5YycsIGc5Yy5sZW5ndGgoKSk7XHJcblxyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdtX3N0cmlwZScsIG1fc3RyaXBlKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBjZWxsXzMgPSBtX3N0cmlwZS5nZXQoJ2NvbnRlbnQnKS5nZXQoMCk7XHJcblxyXG4gICAgICAgICAgICAvLyBuZWVkIHRvIG1lYXN1cmUgYW5kIHNocmluayB0aGUgY2VudHJhbCBjZWxsLlxyXG5cclxuICAgICAgICAgICAgLy92YXIgdyA9IGNlbGw0X2VsLm9mZnNldFdpZHRoO1xyXG5cclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygndyAnICsgdyk7XHJcblxyXG4gICAgICAgICAgICAvLyBvciByZW1vdmUgdGhhdCBzdHlsZSBkZWNsYXJhdGlvbj9cclxuICAgICAgICAgICAgY2VsbF80LnN0eWxlKHtcclxuICAgICAgICAgICAgICAgIC8vJ3dpZHRoJzogbnVsbFxyXG4gICAgICAgICAgICAgICAgJ3dpZHRoJzogJzEwMCUnXHJcbiAgICAgICAgICAgIH0pXHJcblxyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdjZWxsXzMnLCBjZWxsXzMpO1xyXG4gICAgICAgICAgICBjZWxsXzMucmVtb3ZlX2NsYXNzKCdkb2NrLXBsYWNlaG9sZGVyJyk7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0KCdkb2NrX3BsYWNlaG9sZGVyX3BvcycsIGZhbHNlKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoZHBwb3MgPT0gJ3RvcCcpIHtcclxuICAgICAgICAgICAgdmFyIGNlbGxfMSA9IHRfc3RyaXBlLmdldCgnY29udGVudCcpLmdldCgxKTtcclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnY2VsbF8zJywgY2VsbF8zKTtcclxuICAgICAgICAgICAgY2VsbF8xLnJlbW92ZV9jbGFzcygnZG9jay1wbGFjZWhvbGRlcicpO1xyXG4gICAgICAgICAgICB0aGlzLnNldCgnZG9ja19wbGFjZWhvbGRlcl9wb3MnLCBmYWxzZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoZHBwb3MgPT0gJ3JpZ2h0Jykge1xyXG4gICAgICAgICAgICB2YXIgY2VsbF81ID0gdGhpcy5nZXQoJ2NvbnRlbnQnKS5nZXQoMSkuZ2V0KCdjb250ZW50JykuZ2V0KDIpO1xyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdjZWxsXzMnLCBjZWxsXzMpO1xyXG4gICAgICAgICAgICBjZWxsXzUucmVtb3ZlX2NsYXNzKCdkb2NrLXBsYWNlaG9sZGVyJyk7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0KCdkb2NrX3BsYWNlaG9sZGVyX3BvcycsIGZhbHNlKTtcclxuICAgICAgICAgICAgY2VsbF80LnN0eWxlKHtcclxuICAgICAgICAgICAgICAgIC8vJ3dpZHRoJzogbnVsbFxyXG4gICAgICAgICAgICAgICAgJ3dpZHRoJzogJzEwMCUnXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoZHBwb3MgPT0gJ2JvdHRvbScpIHtcclxuICAgICAgICAgICAgdmFyIGNlbGxfNyA9IHRoaXMuZ2V0KCdjb250ZW50JykuZ2V0KDIpLmdldCgnY29udGVudCcpLmdldCgxKTtcclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnY2VsbF8zJywgY2VsbF8zKTtcclxuICAgICAgICAgICAgY2VsbF83LnJlbW92ZV9jbGFzcygnZG9jay1wbGFjZWhvbGRlcicpO1xyXG4gICAgICAgICAgICB0aGlzLnNldCgnZG9ja19wbGFjZWhvbGRlcl9wb3MnLCBmYWxzZSk7XHJcblxyXG4gICAgICAgICAgICBtX3N0cmlwZS5zdHlsZSh7XHJcbiAgICAgICAgICAgICAgICAnaGVpZ2h0JzogJzEwMCUnXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICB2YXIgZzl3ID0gZzllbC5vZmZzZXRXaWR0aDtcclxuXHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGc5YyA9IGdyaWRfOS5nZXQoJ2NvbnRlbnQnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnZzljJywgZzljLmxlbmd0aCgpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ21fc3RyaXBlJywgbV9zdHJpcGUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNlbGxfMyA9IG1fc3RyaXBlLmdldCgnY29udGVudCcpLmdldCgwKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5lZWQgdG8gbWVhc3VyZSBhbmQgc2hyaW5rIHRoZSBjZW50cmFsIGNlbGwuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3ZhciB3ID0gY2VsbDRfZWwub2Zmc2V0V2lkdGg7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCd3ICcgKyB3KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9yIHJlbW92ZSB0aGF0IHN0eWxlIGRlY2xhcmF0aW9uP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjZWxsXzQuc3R5bGUoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8nd2lkdGgnOiBudWxsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnd2lkdGgnOiAnMTAwJSdcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuXHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnY2VsbF8zJywgY2VsbF8zKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2VsbF8zLnJlbW92ZV9jbGFzcygnZG9jay1wbGFjZWhvbGRlcicpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldCgnZG9ja19wbGFjZWhvbGRlcl9wb3MnLCBmYWxzZSk7XHJcbiAgICAgICAgKi9cclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8gdGhlIGdyaWRfOSBhbHNvIG5lZWRzIHRvIGJlIGFjdGl2YXRlZC5cclxuICAgIC8vICB0aGUgY29udHJvbHMgd2l0aGluIGl0IG5lZWQgYXR0YWNobWVudHMgdG8gdGhlaXIgZWxlbWVudHMuXHJcbiAgICAvLyAgbWF5YmUgZ3JpZF85IGRvZXMgbm90IG5lZWQgbW9yZSBjb2RlIGluIGl0c2VsZi4uLiBqdXN0IG5lZWRzIGFjdGl2YXRlIHRvIGJlIGNhbGxlZCB3aGVuIGl0J3MgaW4gdGhlIERPTS5cclxuXHJcblxyXG5cclxufSk7XHJcbi8vanNndWkuQ29udHJvbCA9IENvbnRyb2w7XHJcblxyXG5cclxuXHJcblxyXG4vLyBTZWxlY3Rpb24gc2NvcGUuLi5cclxuLy8gIENhbiBzZWxlY3QgdGhlIHdob2xlIHRoaW5nLCBjYW4gc2VsZWN0IHBhcnRzIG9mIGl0LlxyXG5cclxuLy8gRG9uJ3Qgd2FudCB0b28gbXVjaCBjb2RlIHRvIGRvIHdpdGggc2VsZWN0aW9uIGluIHRoZSBVSSBjb250cm9sIGl0c2VsZi5cclxuXHJcblxyXG5cclxuLy8gU3BhY2Ugc2F2aW5nIG1lYXN1cmVzP1xyXG4vLyAgRGVjbGFyaW5nIGEgYnVjaCBvZiBzdWJjb250cm9scyB3aXRoIHByb3BlcnRpZXM/XHJcbi8vICBEb2luZyBzbyBhcyBYTUw/IEFzIEpTT04/XHJcblxyXG5cclxuLy8gTW92YWJsZVxyXG4vLyBSZXNpemFibGVcclxuLy8gUm90YXRhYmxlXHJcbi8vIERlbGV0YWJsZVxyXG4vLyBFZGl0YWJsZVxyXG4vLyBSZW9yZGVyYWJsZVxyXG4vLyBDcmVhdGFibGVcclxuXHJcbi8vIEFjdGlvbmFibGVcclxuLy8gIChhY3Rpb25hYmxlIGJlaGF2aW91cnMpXHJcblxyXG4vLyBUaGV5IHdpbGwgdmFyeSBxdWl0ZSBhIGxvdCBhbmQgcHJvYmFibHkgY2FuJ3QgYWxsIGZpdCBpbnRvIG9uZSB3YXkgb2YgZG9pbmcgdGhpbmdzLlxyXG5cclxuLy8gV2FudCBhIHZlcnkgZWFzeSB3YXkgdG8gc2V0IHRoZXNlIHVwLlxyXG5cclxuLy8gVXNpbmcgZ3JvdXBzIHRvby5cclxuXHJcbi8vIEJlaGF2aW91cnMgc2VlbSBsaWtlIGEgZ29vZCB3YXkgb2YgZXhwcmVzc2luZyBhY3Rpb24tcmVhY3Rpb24uXHJcbi8vXHJcblxyXG5cclxudmFyIHJlY3Vyc2l2ZV9kb21faXRlcmF0ZSA9IGZ1bmN0aW9uIChlbCwgY2FsbGJhY2spIHtcclxuICAgIC8vY29uc29sZS5sb2coJ3JlY3Vyc2l2ZV9kb21faXRlcmF0ZScpO1xyXG4gICAgY2FsbGJhY2soZWwpO1xyXG5cclxuICAgIC8vY29uc29sZS5sb2coJ3RvZihlbC5jaGlsZE5vZGVzKSAnICsgdG9mKGVsLmNoaWxkTm9kZXMpKTtcclxuXHJcbiAgICAvL2VhY2goZWwuY2hpbGROb2RlcywgZnVuY3Rpb24oaSwgdikge1xyXG4gICAgLy9cdGNvbnNvbGUubG9nKCd2ICcgKyB2KTtcclxuICAgIC8vfSk7XHJcblxyXG4gICAgLy9jb25zb2xlLmxvZygnZWwuY2hpbGROb2Rlcy5sZW5ndGggJyArIGVsLmNoaWxkTm9kZXMubGVuZ3RoKTtcclxuICAgIHZhciBjbnMgPSBlbC5jaGlsZE5vZGVzO1xyXG4gICAgLy9jb25zb2xlLmxvZygnZWwnLCBlbCk7XHJcbiAgICAvL2NvbnNvbGUubG9nKCdjbnMubGVuZ3RoJywgY25zLmxlbmd0aCk7XHJcbiAgICBmb3IgKHZhciBjID0gMCwgbCA9IGNucy5sZW5ndGg7IGMgPCBsOyBjKyspIHtcclxuICAgICAgICByZWN1cnNpdmVfZG9tX2l0ZXJhdGUoY25zW2NdLCBjYWxsYmFjayk7XHJcbiAgICB9XHJcbn1cclxuXHJcbnZhciByZWN1cnNpdmVfZG9tX2l0ZXJhdGVfZGVwdGggPSBmdW5jdGlvbiAoZWwsIGNhbGxiYWNrKSB7XHJcbiAgICAvL2NvbnNvbGUubG9nKCdyZWN1cnNpdmVfZG9tX2l0ZXJhdGUnKTtcclxuXHJcblxyXG4gICAgLy9jb25zb2xlLmxvZygndG9mKGVsLmNoaWxkTm9kZXMpICcgKyB0b2YoZWwuY2hpbGROb2RlcykpO1xyXG5cclxuICAgIC8vZWFjaChlbC5jaGlsZE5vZGVzLCBmdW5jdGlvbihpLCB2KSB7XHJcbiAgICAvLyAgY29uc29sZS5sb2coJ3YgJyArIHYpO1xyXG4gICAgLy99KTtcclxuXHJcbiAgICAvL2NvbnNvbGUubG9nKCdlbC5jaGlsZE5vZGVzLmxlbmd0aCAnICsgZWwuY2hpbGROb2Rlcy5sZW5ndGgpO1xyXG4gICAgdmFyIGNucyA9IGVsLmNoaWxkTm9kZXM7XHJcbiAgICBmb3IgKHZhciBjID0gMCwgbCA9IGNucy5sZW5ndGg7IGMgPCBsOyBjKyspIHtcclxuICAgICAgICByZWN1cnNpdmVfZG9tX2l0ZXJhdGVfZGVwdGgoY25zW2NdLCBjYWxsYmFjayk7XHJcbiAgICB9XHJcbiAgICBjYWxsYmFjayhlbCk7XHJcbn1cclxuXHJcblxyXG4vLyBXYW50IHRoZSBkb2N1bWVudCBub2RlIHRvIGJlIGxpbmtlZCB3aXRoIHRoZSBjb250ZXh0IHdoZW4gYWN0aXZhdGVkIChhdXRvbWF0aWNhbGx5KVxyXG5cclxuLy8gV2UgZmluZCB0aGUgaHRtbCBlbGVtZW50IGNvbnRyb2wuIFRoYXQgaXMgdGhlIG9uZSB0aGF0IGdldHMgc2V0IHRvIGJlIHRoZSBjb250ZXh0J3MgY3RybF9kb2N1bWVudC5cclxuXHJcblxyXG5cclxuXHJcbnZhciBhY3RpdmF0ZSA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcclxuICAgIC8vIFRoZSBjb250ZXh0IHNob3VsZCBhbHJlYWR5IGhhdmUgdGhlIG1hcCBvZiBjb250cm9scy5cclxuXHJcbiAgICAvLyBOb3Qgc28gc3VyZSB3ZSBjYW4gaGF2ZSB0aGUgY2xpZW50IHBhZ2UgY29udGV4dCBoZXJlIC0gZG9lcyBpdCB1c2UgcmVzb3VyY2VzP1xyXG5cclxuICAgIC8vZW5zdXJlX0NvbnRleHRfTWVudV9sb2FkZWQoZnVuY3Rpb24oX0NvbnRleHRfTWVudSkge1xyXG4gICAgICAgIC8vQ29udGV4dF9NZW51ID0gX0NvbnRleHRfTWVudTtcclxuICAgICAgICBpZiAoIWNvbnRleHQpIHtcclxuICAgICAgICAgICAgdGhyb3cgJ2pzZ3VpLWh0bWwtZW5oIGFjdGl2YXRlKGNvbnRleHQpIC0gbmVlZCB0byBzdXBwbHkgY29udGV4dCBwYXJhbWV0ZXIuJztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy9jb250ZXh0ID0gY29udGV4dCB8fCBuZXcgUGFnZV9Db250ZXh0KCk7XHJcbiAgICAgICAgLy9jb25zb2xlLmxvZygnanNndWktaHRtbC1lbmggYWN0aXZhdGUgY29udGV4dCcsIGNvbnRleHQpO1xyXG5cclxuICAgICAgICB2YXIgbWFwX2pzZ3VpX2VscyA9IHt9O1xyXG4gICAgICAgIHZhciBtYXBfanNndWlfdHlwZXMgPSB7fTtcclxuICAgICAgICAvL2NvbnNvbGUubG9nKCdhY3RpdmF0ZSAtIGJlZ2lubmluZyBtYXBwaW5nJyk7XHJcbiAgICAgICAgLy8gQ291bGQgcHV0IHRvZ2V0aGVyIHRoZSBhcnJheSBvZiBjb250cm9scyBpbiBvcmRlciBmb3VuZC5cclxuXHJcbiAgICAgICAgdmFyIGFycl9jb250cm9scyA9IFtdO1xyXG4gICAgICAgIC8vIGVsZW1lbnQgcmVnaXN0cmF0aW9uXHJcbiAgICAgICAgLy8gUmVjdXJzaXZlIGl0ZXJhdGlvbiB3aGVyZSB0aGUgaW5uZXJtb3N0IGdldCBjYWxsZWQgZmlyc3QuLi4uXHJcbiAgICAgICAgLy8gIFdvdWxkIGJlIHVzZWZ1bCBoZXJlLlxyXG4gICAgICAgIC8vIGNvdW50aW5nIHVwIHRoZSB0eXBlZCBpZCBudW1iZXJzLlxyXG5cclxuICAgICAgICB2YXIgbWF4X3R5cGVkX2lkcyA9IHt9O1xyXG5cclxuICAgICAgICB2YXIgaWRfYmVmb3JlX18gPSBmdW5jdGlvbihpZCkge1xyXG4gICAgICAgICAgICB2YXIgcG9zMSA9IGlkLmxhc3RJbmRleE9mKCdfJyk7XHJcbiAgICAgICAgICAgIHZhciByZXMgPSBpZC5zdWJzdHIoMCwgcG9zMSk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgbnVtX2FmdGVyID0gZnVuY3Rpb24oaWQpIHtcclxuICAgICAgICAgICAgLy92YXIgcG9zMSA9IGlkLmxhc3RJbmRleE9mKCdfJyk7XHJcbiAgICAgICAgICAgIC8vdmFyIHJlcyA9IHBhcnNlSW50KGlkLnN1YnN0cihwb3MxICsgMSksIDEwKTtcclxuICAgICAgICAgICAgLy9yZXR1cm4gcmVzO1xyXG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQoaWQuc3Vic3RyKGlkLmxhc3RJbmRleE9mKCdfJykgKyAxKSwgMTApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmVjdXJzaXZlX2RvbV9pdGVyYXRlKGRvY3VtZW50LCBmdW5jdGlvbihlbCkge1xyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCcyKSBlbC50YWdOYW1lICcgKyBlbC50YWdOYW1lKTtcclxuICAgICAgICAgICAgdmFyIG50ID0gZWwubm9kZVR5cGU7XHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ250ICcgKyBudCk7XHJcblxyXG4gICAgICAgICAgICAvLyBTbyBmb3IgdGhlICdIVE1MJyB0YWcgbmFtZS4uLlxyXG4gICAgICAgICAgICAvLyAgV2Ugc2hvdWxkIG1ha2UgYSBjb250cm9sIGZvciB0aGUgSFRNTCBkb2N1bWVudCAtIG9yIGl0IHNob3VsZCBnZXQgYWN0aXZhdGVkLlxyXG5cclxuXHJcblxyXG4gICAgICAgICAgICBpZiAobnQgPT0gMSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGpzZ3VpX2lkID0gZWwuZ2V0QXR0cmlidXRlKCdkYXRhLWpzZ3VpLWlkJyk7XHJcbiAgICAgICAgICAgICAgICAvLyBHaXZlIHRoZSBIVE1MIGRvY3VtZW50IGFuIElEP1xyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdqc2d1aV9pZCAnICsganNndWlfaWQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGpzZ3VpX2lkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGliID0gaWRfYmVmb3JlX18oanNndWlfaWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBudW0gPSAgbnVtX2FmdGVyKGpzZ3VpX2lkKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIW1heF90eXBlZF9pZHNbaWJdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heF90eXBlZF9pZHNbaWJdID0gbnVtO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChudW0gPiBtYXhfdHlwZWRfaWRzW2liXSkgbWF4X3R5cGVkX2lkc1tpYl0gPSBudW07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBtYXBfanNndWlfZWxzW2pzZ3VpX2lkXSA9IGVsO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBqc2d1aV90eXBlID0gZWwuZ2V0QXR0cmlidXRlKCdkYXRhLWpzZ3VpLXR5cGUnKTtcclxuICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdqc2d1aV90eXBlICcgKyBqc2d1aV90eXBlKTtcclxuICAgICAgICAgICAgICAgICAgICBtYXBfanNndWlfdHlwZXNbanNndWlfaWRdID0ganNndWlfdHlwZTtcclxuICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdqc2d1aV90eXBlICcgKyBqc2d1aV90eXBlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNvbnRleHQuc2V0X21heF9pZHMobWF4X3R5cGVkX2lkcyk7XHJcbiAgICAgICAgLy9jb25zb2xlLmxvZygnbWF4X3R5cGVkX2lkcyAnICsgc3RyaW5naWZ5KG1heF90eXBlZF9pZHMpKTtcclxuICAgICAgICAvL3Rocm93ICdzdG9wJztcclxuICAgICAgICAvL2NvbnNvbGUubG9nKCdhY3RpdmF0ZSAtIGZpbmlzaGVkIG1hcHBpbmcnKTtcclxuXHJcbiAgICAgICAgLy8gVGhlbiBhY3RpdmF0ZVxyXG4gICAgICAgIC8vICAoYnV0IGFuIGFjdGl2YXRpb24gd2hlcmUgaXQgZG9lcyBub3QgeWV0IGtub3cgdGhlIHJlZmVyZW5jZXMgdG8gdmFyaW91cyBuZWNlc3Nhcnkgb3RoZXIgY29udHJvbHMpXHJcbiAgICAgICAgLy8gIFRoaXMgaXMgYWJvdXQgY3JlYXRpbmcgdGhlIGNvbnRyb2xzLCB3aXRoaW4gdGhlIHBhZ2VfY29udGV4dC5cclxuXHJcbiAgICAgICAgLy8gaWYgdGhlIGNvbnRyb2wgZG9lcyBub3QgaGF2ZSBpdHMgb3duIHJlY3Vyc2l2ZSBhY3RpdmF0aW9uLi4uXHJcbiAgICAgICAgLy8gIERvIHRoZSBjb250cm9sIGNyZWF0aW9uLCB0aGVuIHRoZXJlIHNob3VsZCBiZSB2YXJpb3VzIHByb3BlcnRpZXMgYW5kIGJlaGF2aW91cnMgdGhhdCBnZXQgc2V0LlxyXG5cclxuICAgICAgICAvLyBjcmVhdGUgdGhlIGNvbnRyb2xzLlxyXG4gICAgICAgIC8vY29uc29sZS5sb2coJ21hcF9qc2d1aV90eXBlcyAnICsgc3RyaW5naWZ5KG1hcF9qc2d1aV90eXBlcykpO1xyXG4gICAgICAgIC8vY29uc29sZS5sb2coJ21hcF9qc2d1aV9lbHMgJyArIHN0cmluZ2lmeShtYXBfanNndWlfZWxzKSk7XHJcblxyXG4gICAgICAgIC8vY29uc29sZS5sb2coJ21hcF9jb250cm9sc19ieV90eXBlICcgKyBzdHJpbmdpZnkobWFwX2NvbnRyb2xzX2J5X3R5cGUpKTtcclxuICAgICAgICAvL3Rocm93ICdzdG9wJztcclxuXHJcbiAgICAgICAgLy9jb25zb2xlLmxvZygnY29udGV4dC5tYXBfY29udHJvbHMnLCBjb250ZXh0Lm1hcF9jb250cm9scyk7XHJcbiAgICAgICAgLy9jb25zb2xlLmxvZygnbWFwX2pzZ3VpX3R5cGVzJywgbWFwX2pzZ3VpX3R5cGVzKTtcclxuXHJcbiAgICAgICAgdmFyIG1hcF9jb250cm9scyA9IGNvbnRleHQubWFwX2NvbnRyb2xzO1xyXG4gICAgICAgIC8vIENvbnRyb2wgY29uc3RydWN0aW9uIGFuZCByZWdpc3RyYXRpb25cclxuICAgICAgICBlYWNoKG1hcF9qc2d1aV9lbHMsIGZ1bmN0aW9uKGVsLCBqc2d1aV9pZCkge1xyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdqc2d1aV9pZCAnICsganNndWlfaWQpO1xyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCczKSBlbC50YWdOYW1lICcgKyBlbC50YWdOYW1lKTtcclxuICAgICAgICAgICAgdmFyIGxfdGFnX25hbWUgPSBlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICAgIGlmIChqc2d1aV9pZCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBtYXBfanNndWlfdHlwZXNbanNndWlfaWRdO1xyXG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygndHlwZSAnICsgdHlwZSk7XHJcbiAgICAgICAgICAgICAgICAvL3ZhciBjc3RyID0ganNndWkuY29uc3RydWN0b3JfZnJvbV90eXBlKHR5cGUpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vdmFyIGNzdHIgPSBqc2d1aS5jb25zdHJ1Y3Rvcl9mcm9tX3R5cGUodHlwZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnY3N0ciAnICsgY3N0cik7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gdXNlIHRoZSBjb250ZXh0J3MgbWFwX0NvbnRyb2xzXHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIENzdHIgPSBjb250ZXh0Lm1hcF9Db250cm9sc1t0eXBlXTtcclxuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ0NzdHIgJyArIENzdHIucHJvdG90eXBlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyB0aGVuIHdlIGNhbiBjb25zdHJ1Y3QgdGhlIGNvbnRyb2wsIGFuZCBwdXQgaXQgd2l0aGluIHRoZSBtYXAuXHJcbiAgICAgICAgICAgICAgICAvLyAgQSBsYXRlciBzdGFnZSBvZiBhY3RpdmF0aW9uIHdpbGwgcmVjcmVhdGUgdGhlIHJlbGF0aW9uc2hpcHMgYmV0d2VlbiB0aGUgY29udHJvbHMuXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gT0ssIGJ1dCBoYXZlIHdlIGdvdCB2YXJpYWJsZXMgdG8gaW5pdGlhbGl6ZSB0aGUgY29udHJvbHMgd2l0aD9cclxuICAgICAgICAgICAgICAgIC8vICBJdCB3b3VsZCBtYXliZSBiZSBtb3N0IGVmZmljaWVudCB0byB0YWtlIGRlbGl2ZXJ5IG9mIHRoZW0gYXMgb25lIG9iamVjdC5cclxuICAgICAgICAgICAgICAgIC8vICAgV2l0aCBqdXN0IHRoZSBjb250cm9sIHR5cGVzIGFuZCB0aGUgZGF0YSBjb250YWluZWQgaW4gdGhlbSB3ZSBjYW4gZG8gYSBsb3Qgb2YgcmVjb25zdHJ1Y3Rpb24gb2YgdGhlIGFjdHVhbCBjb250cm9scy5cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBXaXRoIHRoZSBvYmplY3Qgdmlld2VyLCB3ZSBjYW4gZXZlbiByZWNvbnN0cnVjdCB0aGUgaW5pdGlhbCBvYmplY3QgZnJvbSB0aGUgcmVuZGVyZWQgdmlldy5cclxuICAgICAgICAgICAgICAgIC8vICBOb3Qgc3VyZSBxdWl0ZSBob3cgbXVjaCBwb2ludCB0aGVyZSBpcyBpbiBkb2luZyB0aGF0LiBNYXkgd29yayBvdXQgbW9zdCBlZmZpY2llbnQgYmVjYXVzZSAxc3QgdmlldyBpcyBwcmVyZW5kZXJlZCBhbmRcclxuICAgICAgICAgICAgICAgIC8vICBpdCBkb2VzIG5vdCBuZWVkIHRvIHNlbmQgdGhlIGRhdGEgdHdpY2UuXHJcbiAgICAgICAgICAgICAgICAvLyBFZyBjYW4gaG9vayB1cCB0aGUga2V5ICh2aWV3ZXIpLCB0aGUgdmFsdWUgKHZpZXdlcikgYW5kIHRoZSBjb21tYS5cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBmb3IgdGhlIGRvY3VtZW50IGVsZW1lbnQgd2Ugc3BlY2lmaWNhbGx5IGFkZCB0aGUgY29udHJvbCB0byB0aGUgY29udGV4dC5cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBBbHNvIHdhbnQgdG8gcmVhZCBmaWVsZHMgb3V0IGZvciB1c2UgaW4gaW5pdGlhbGl6YXRpb24uXHJcbiAgICAgICAgICAgICAgICAvLyAgTm90IHRoZSBjdHJsX2ZpZWxkcyAoZm9yIHRoZSBtb21lbnQpXHJcbiAgICAgICAgICAgICAgICAvLyAgSnVzdCB0aGUgZGF0YS1qc2d1aS1maWVsZHMuXHJcbiAgICAgICAgICAgICAgICAvLyAgIEhvd2V2ZXIsIGl0J3MgbGlrZWx5IHRoZXkgY291bGQgYmUgdXNlZCBpbiB0aGUgaW5pdGlhbGl6YXRpb24uXHJcbiAgICAgICAgICAgICAgICAvLyAgICBBbmQgbWVyZ2VkIHdpdGggdGhlIHNwZWMuXHJcblxyXG5cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKENzdHIpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY3RybCA9IG5ldyBDc3RyKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ2NvbnRleHQnOiBjb250ZXh0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAnX2lkJzoganNndWlfaWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdlbCc6IGVsXHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICBtYXBfY29udHJvbHNbanNndWlfaWRdID0gY3RybDtcclxuICAgICAgICAgICAgICAgICAgICBhcnJfY29udHJvbHMucHVzaChjdHJsKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnZWwudGFnTmFtZScsIGVsLnRhZ05hbWUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAobF90YWdfbmFtZSA9PT0gJ2h0bWwnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2VsIGlzIGRvY3VtZW50IHJvb3QgZWwnKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBodG1sIGVsZW1lbnQgcmVwcmVzZW50cyB0aGUgcm9vdCBvZiBhIGRvY3VtZW50LlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3Rocm93ICcyKSBzdG9wJztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuY3RybF9kb2N1bWVudCA9IGN0cmw7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnTWlzc2luZyBjb250ZXh0Lm1hcF9Db250cm9scyBmb3IgdHlwZSAnICsgdHlwZSArICcsIHVzaW5nIGdlbmVyaWMgQ29udHJvbCcpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjdHJsID0gbmV3IENvbnRyb2woe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnY29udGV4dCc6IGNvbnRleHQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdfaWQnOiBqc2d1aV9pZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ2VsJzogZWxcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIG1hcF9jb250cm9sc1tqc2d1aV9pZF0gPSBjdHJsO1xyXG4gICAgICAgICAgICAgICAgICAgIGFycl9jb250cm9scy5wdXNoKGN0cmwpO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnanNndWlfaWQgJyArIGpzZ3VpX2lkKTtcclxuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2N0cmwuX2lkKCkgJyArIGN0cmwuX2lkKCkpO1xyXG5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBnZXQgdGhlIGNvbnN0cnVjdG9yIGZyb20gdGhlIGlkP1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vY29uc29sZS5sb2coJ2Fycl9jb250cm9scyAnICsgc3RyaW5naWZ5KGFycl9jb250cm9scykpO1xyXG4gICAgICAgIC8vIGRlcHRoLWZpcnN0IGFjdGl2YXRpb24/XHJcbiAgICAgICAgLy8gIEJ1dCBjb25uZWN0aW5nIHVwIHRoZSBhY3RpdmF0ZWQgc3ViY29udHJvbHMgd2l0aCB0aGUgY29udHJvbCBnZXR0aW5nIGFjdGl2YXRlZD9cclxuICAgICAgICAvLyAgIFRoZXkgY291bGQgYmUgdGhlIGNvbnRlbnQuXHJcblxyXG4gICAgICAgIC8vY29uc29sZS5sb2coJ3ByZSByZWN1cnNpdmVfZG9tX2l0ZXJhdGVfZGVwdGgnKTtcclxuICAgICAgICByZWN1cnNpdmVfZG9tX2l0ZXJhdGVfZGVwdGgoZG9jdW1lbnQsIGZ1bmN0aW9uKGVsKSB7XHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2VsICcgKyBlbCk7XHJcbiAgICAgICAgICAgIHZhciBudCA9IGVsLm5vZGVUeXBlO1xyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdudCAnICsgbnQpO1xyXG4gICAgICAgICAgICBpZiAobnQgPT0gMSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGpzZ3VpX2lkID0gZWwuZ2V0QXR0cmlidXRlKCdkYXRhLWpzZ3VpLWlkJyk7XHJcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCcqIGpzZ3VpX2lkICcgKyBqc2d1aV9pZCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoanNndWlfaWQpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN0cmwgPSBtYXBfY29udHJvbHNbanNndWlfaWRdO1xyXG4gICAgICAgICAgICAgICAgICAgIGN0cmwuX19hY3RpdmF0aW5nID09IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygndG9mIGN0cmwgJyArIHRvZihjdHJsKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY3RybC5hY3RpdmF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGN0cmwuX19hY3RpdmF0aW5nID09IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2pzZ3VpX3R5cGUgJyArIGpzZ3VpX3R5cGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vIEltYWdlIHVwbG9hZGVyIHNlZW1zIG5vdCB0byBiZSBhY3RpdmF0aW5nIHByb3Blcmx5Li4uXHJcblxyXG4gICAgLy99KVxyXG5cclxuICAgIC8vICBjb25zdHJ1Y3RvcnMuXHJcblxyXG4gICAgLy8gc2hvdWxkIGFjdGl2YXRlIHdpdGggdGhlIGNvbnRleHQuXHJcblxyXG5cclxuXHJcbiAgICAvL2NvbnNvbGUubG9nKCdkb25lIGFjdGl2YXRlIHJkaScpO1xyXG5cclxuICAgIC8qXHJcblxyXG4gICAgZWFjaChhcnJfY29udHJvbHMsIGZ1bmN0aW9uKGksIGN0cmwpIHtcclxuICAgICAgICAvLyBDYWxsIGFjdGl2YXRlIG9uIHRoZSBjb250cm9sLi4uXHJcbiAgICAgICAgLy8gIHVzdWFsbHkgaXQncyBnb2luZyB0byBzZXQgdXAgdGhlIGNvbnRlbnRzLlxyXG5cclxuXHJcbiAgICAgICAgLy8gYWN0aXZhdGVfY29udGVudHMgYWN0aXZhdGVfY29udHJvbF9jb250ZW50c1xyXG5cclxuICAgICAgICBjdHJsLmFjdGl2YXRlKCk7XHJcbiAgICAgICAgLy8gQWN0aXZhdGUgZnJvbSBib3R0b20gdXBcclxuICAgICAgICAvLyAgTW9zdCBpbndhcmRzLCB1cHdhcmRzP1xyXG5cclxuICAgICAgICAvLyAgU28gaW5uZXIgY29udHJvbHMgYXJlIGFjdGl2ZSBieSB0aGUgdGltZSBpdCByZWFjaGVzIG91dHNpZGUuLi4uXHJcblxyXG5cclxuXHJcbiAgICB9KTtcclxuICAgICovXHJcblxyXG4gICAgLy8gVGhlbiBhbm90aGVyIHJlYyBkb20gaXQuXHJcbiAgICAvLyAgV2hlbiBhY3RpdmF0aW5nIHZhcmlvdXMgY29udHJvbHMsIHdlJ2xsIGJlIGxvb2tpbmcgZm9yIHNwZWNpZmljIHN1YmNvbnRyb2xzIHRvIGdldCBhIHJlZmVyZW5jZSB0by5cclxuICAgIC8vICBEb24ndCB3YW50IHRvIHdyYXAgdGhlIGVsZW1lbnRzIGxpa2Ugd2l0aCBqUXVlcnkuXHJcblxyXG4gICAgLy8gdGhlbiB3ZW4gbmVlZCB0byBmaW5kIHRoZSBjb25zdHJ1Y3RvciBmb3IgdmFyaW91cyBjb250cm9scy5cclxuICAgIC8vICBwb3NzaWJseSBkbyBpdCBmb3IgYWxsIGNvbnRyb2xzLlxyXG4gICAgLy8gIGZvciB0ZXh0IHNwYW5zLCB3ZSByZWFkIGl0IGFuZCBhc3NpZ24gdGhlIHByb3Blcml0ZXMuXHJcblxyXG4gICAgLy8gVGhpbmsgd2Ugc2hvdWxkIGFjdGl2YXRlIGV2ZXJ5dGhpbmcuXHJcbiAgICAvLyAgQ3JlYXRlIHRoZSBjb250cm9sc1xyXG4gICAgLy8gIEdpdmUgdGhlbSByZWZlcmVuY2VzIHRvIHRoZSBwYWdlIGNvbnRleHRcclxuXHJcbiAgICAvLyBUaGVuIGdpdmUgdGhlIGNvbnRyb2xzIHJlZmVyZW5jZXMgdG8gZWFjaCBvdGhlci5cclxuICAgIC8vICBTb21lIG9mIHRoZSBjb250cm9scyB3aWxsIGJlIGZpZWxkcyBvZiBvdGhlciBjb250cm9scy5cclxuICAgIC8vICBXZSBjYW4gbWFrZSBzdXJlIHRoZXNlIGdldCBzZW50IGZyb20gdGhlIHNlcnZlciBzbyB0aGV5IGNhbiBiZSBhY3RpdmF0ZWQgb24gdGhlIGNsaWVudC5cclxuICAgIC8vICAgQ291bGQgbWF5YmUgaGF2ZSAncmVsYXRpb25zaGlwcycgd2hlcmUgdmFyaW91cyBvdGhlciBjb250cm9scyBhcmUgZ2l2ZW4gYnkganNndWktaWQgdGhhdCBkbyBzb21ldGhpbmcgb24gYSBjb250cm9sLlxyXG4gICAgLy8gICBUaGV5IGFyZSByZWFsbHkgY29udHJvbCBmaWVsZHMuXHJcblxyXG4gICAgLy8gU28gYW4gb2JqZWN0IGVkaXRvciBtYXkgaGF2ZSB0aGUgb3BlbiBhbmQgY2xvc2UgY29udHJvbCBmaWVsZHMuXHJcblxyXG59XHJcblxyXG52YXIgY29yZV9leHRlbnNpb24gPSBzdHJfYXJyX21hcGlmeShmdW5jdGlvbiAodGFnTmFtZSkge1xyXG4gICAganNndWlbdGFnTmFtZV0gPSBDb250cm9sLmV4dGVuZCh7XHJcbiAgICAgICAgJ2luaXQnOiBmdW5jdGlvbiAoc3BlYykge1xyXG4gICAgICAgICAgICAvL3NwZWMudGFnTmFtZSA9IHRhZ05hbWU7XHJcblxyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdjb3JlIGV4dGVuc2lvbiB0YWdOYW1lICcgKyB0YWdOYW1lKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuX3N1cGVyKHNwZWMpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5nZXQoJ2RvbScpLnNldCgndGFnTmFtZScsIHRhZ05hbWUpO1xyXG4gICAgICAgICAgICAvLyBkb20udGFnTmFtZT9cclxuXHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBqc2d1aVt0YWdOYW1lXS5wcm90b3R5cGUuX3RhZ19uYW1lID0gdGFnTmFtZTtcclxuICAgIG1hcF9Db250cm9sc1t0YWdOYW1lXSA9IGpzZ3VpW3RhZ05hbWVdO1xyXG59KTtcclxuXHJcbnZhciBjb3JlX2V4dGVuc2lvbl9ub19jbG9zaW5nX3RhZyA9IHN0cl9hcnJfbWFwaWZ5KGZ1bmN0aW9uICh0YWdOYW1lKSB7XHJcbiAgICBqc2d1aVt0YWdOYW1lXSA9IENvbnRyb2wuZXh0ZW5kKHtcclxuICAgICAgICAnaW5pdCc6IGZ1bmN0aW9uIChzcGVjKSB7XHJcbiAgICAgICAgICAgIC8vc3BlYy50YWdOYW1lID0gdGFnTmFtZTtcclxuXHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2NvcmUgZXh0ZW5zaW9uIHRhZ05hbWUgJyArIHRhZ05hbWUpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5fc3VwZXIoc3BlYyk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmdldCgnZG9tJykuc2V0KCd0YWdOYW1lJywgdGFnTmFtZSk7XHJcbiAgICAgICAgICAgIHRoaXMuZ2V0KCdkb20nKS5zZXQoJ25vQ2xvc2luZ1RhZycsIHRydWUpO1xyXG4gICAgICAgICAgICAvLyBkb20udGFnTmFtZT9cclxuXHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBqc2d1aVt0YWdOYW1lXS5wcm90b3R5cGUuX3RhZ19uYW1lID0gdGFnTmFtZTtcclxuICAgIG1hcF9Db250cm9sc1t0YWdOYW1lXSA9IGpzZ3VpW3RhZ05hbWVdO1xyXG59KTtcclxuXHJcblxyXG5cclxuXHJcbmNvcmVfZXh0ZW5zaW9uKCdodG1sIGhlYWQgdGl0bGUgYm9keSBkaXYgc3BhbiBoMSBoMiBoMyBoNCBoNSBsYWJlbCBwIGEgc2NyaXB0IGJ1dHRvbiBmb3JtIGltZyB1bCBsaSBhdWRpbyB2aWRlbycpO1xyXG5jb3JlX2V4dGVuc2lvbl9ub19jbG9zaW5nX3RhZygnbGluayBpbnB1dCcpO1xyXG4vLyBsaW5rIHRhZyBuZWVkcyB0byBoYXZlIG5vIGNsb3NpbmcgdGFnLlxyXG4vLyAgY29yZV9leHRlbnNpb25fbm9fY2xvc2luZ190YWdcclxuXHJcblxyXG4vLyB0aGUganNndWkuc2NyaXB0IG9iamVjdCBuZWVkcyBtb3JlIGZpZWxkcy5cclxuLy8gIHRoZSBqc2d1aSBkYXRhIHN5c3RlbSBoYXMgYmVjb21lIG1vcmUgcmVzdHJpY3RpdmUsIGluIHRoYXQgZmllbGRzIC8gYXR0cmlidXRlcyBuZWVkIHRvIGJlIHNwZWNpZmllZC5cclxuXHJcbi8vIGRvbS5hdHRyaWJ1dGVzLnR5cGUgYmVpbmcgcGFydCBvZiBzY3JpcHQuXHJcblxyXG4vLyBqc2d1aS5zY3JpcHQuZmllbGRzKCkuYWRkKCdkb20uYXR0cmlidXRlcy50eXBlJylcclxuXHJcbi8vICBJdCBtYXkgYmUgbmljZSB0byBoYXZlIHRoaXMgbW9yZSBmbGV4aWJsZSBhZ2Fpbi5cclxuXHJcbi8vIGJ1dCB3aXRoIGxhYmVsIHdlIHdhbnQgYSBiaXQgbW9yZS4uLlxyXG5cclxuanNndWkuTGFiZWwgPSBDb250cm9sLmV4dGVuZCh7XHJcbiAgICAvLyBhIGZpZWxkIGZvciAnZm9yJ1xyXG4gICAgJ2ZpZWxkcyc6IFtcclxuICAgICAgICBbJ2ZvcicsICdjb250cm9sJ11cclxuICAgICAgICAvLyBuZWVkcyB0byBiZSBhYmxlIHRvIGRlYWwgd2l0aCBmaWVsZHMgb2YgdGhlIHR5cGUgJ2NvbnRyb2wnLlxyXG5cclxuXHJcbiAgICBdLFxyXG5cclxuICAgICdpbml0JzogZnVuY3Rpb24gKHNwZWMpIHtcclxuICAgICAgICAvLyBmb3IgcHJvcGVydHksIGFuZCBpdCdzIHRhZ05hbWUgZ2V0cyBzZXQgdG9vLlxyXG4gICAgICAgIHRoaXMuX3N1cGVyKHNwZWMpO1xyXG4gICAgICAgIHRoaXMuc2V0KCdkb20udGFnTmFtZScsICdsYWJlbCcpO1xyXG5cclxuXHJcbiAgICAgICAgLy9jb25zb2xlLmxvZyhzcGVjLmZvcik7XHJcbiAgICAgICAgLy90aHJvdyBzdG9wO1xyXG4gICAgICAgIC8vIGNvbnRlbnQgcmF0aGVyIHRoYW4gdGV4dC5cclxuICAgIH0sXHJcbiAgICAnYmVmb3JlUmVuZGVyRG9tQXR0cmlidXRlcyc6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvL3RoaXMuc2V0KCdkb20ubmFtZScpXHJcblxyXG4gICAgICAgIC8vdmFyIGRvbSA9IHRoaXMuZ2V0KCdkb20nKTtcclxuICAgICAgICAvL2NvbnNvbGUubG9nKCcnKTtcclxuXHJcbiAgICAgICAgLy9jb25zb2xlLmxvZygnJyk7XHJcbiAgICAgICAgLy92YXIgZG9tX2F0dHJpYnV0ZXMgPSB0aGlzLmdldCgnZG9tLmF0dHJpYnV0ZXMnKTtcclxuXHJcbiAgICAgICAgLy9jb25zb2xlLmxvZygnZG9tICcgKyBzdHJpbmdpZnkoZG9tKSk7XHJcbiAgICAgICAgLy9jb25zb2xlLmxvZygnZG9tX2F0dHJpYnV0ZXMgJyArIGRvbV9hdHRyaWJ1dGVzKTtcclxuXHJcbiAgICAgICAgLy90aHJvdyAnc3RvcCc7XHJcblxyXG5cclxuICAgICAgICAvL2NvbnNvbGUubG9nKCdkb21BdHRyaWJ1dGVzICcgKyBzdHJpbmdpZnkoZG9tQXR0cmlidXRlcykpO1xyXG4gICAgICAgIC8vaWYgKHRoaXMuKVxyXG4gICAgICAgIC8vY29uc29sZS5sb2coJ3RoaXMuXyAnICsgc3RyaW5naWZ5KHRoaXMuXykpO1xyXG4gICAgICAgIHZhciBfZm9yID0gdGhpcy5nZXQoJ2ZvcicpO1xyXG5cclxuXHJcblxyXG4gICAgICAgIC8vY29uc29sZS5sb2coJ3RvZihfZm9yKSAnICsgdG9mKF9mb3IpKTtcclxuICAgICAgICAvL3Rocm93ICdzdG9wJztcclxuXHJcbiAgICAgICAgaWYgKHRvZihfZm9yKSA9PSAnY29udHJvbCcpIHtcclxuICAgICAgICAgICAgLy8gd2UgdXNlIHRoYXQgY29udHJvbCdzIF9pZCgpIGFzIHRociBmb3IgaW4gdGhlIGRvbSBhdHRyaWJ1dGVzLlxyXG4gICAgICAgICAgICB2YXIgZG9tQXR0cmlidXRlcyA9IHRoaXMuZ2V0KCdkb20uYXR0cmlidXRlcycpO1xyXG4gICAgICAgICAgICBkb21BdHRyaWJ1dGVzLnNldCgnZm9yJywgX2Zvci5faWQoKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL2NvbnNvbGUubG9nKCdfZm9yICcgKyBzdHJpbmdpZnkoX2ZvcikpO1xyXG4gICAgICAgIC8vdGhyb3cgJ3N0b3AnO1xyXG4gICAgICAgIC8qXHJcbiAgICAgICAgdmFyIGdyb3VwTmFtZSA9IHRoaXMuZ2V0KCdncm91cF9uYW1lJykuZ2V0KCk7XHJcbiAgICAgICAgdmFyIGNoZWNrZWQgPSB0aGlzLmdldCgnY2hlY2tlZCcpLmdldCgpO1xyXG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0KCd2YWx1ZScpLmdldCgpO1xyXG4gICAgICAgIC8vY29uc29sZS5sb2coJ2NoZWNrZWQgJyArIHN0cmluZ2lmeShjaGVja2VkKSk7XHJcbiAgICAgICAgLy90aHJvdyAnc3RvcCc7XHJcbiAgICAgICAgaWYgKGdyb3VwTmFtZSkge1xyXG4gICAgICAgICAgICBkb21BdHRyaWJ1dGVzLnNldCgnbmFtZScsIGdyb3VwTmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjaGVja2VkKSB7XHJcbiAgICAgICAgICAgIGRvbUF0dHJpYnV0ZXMuc2V0KCdjaGVja2VkJywgY2hlY2tlZC50b1N0cmluZygpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzX2RlZmluZWQodmFsdWUpKSB7XHJcbiAgICAgICAgICAgIGRvbUF0dHJpYnV0ZXMuc2V0KCd2YWx1ZScsIHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgKi9cclxuICAgIH1cclxufSk7XHJcblxyXG52YXIgSFRNTF9Eb2N1bWVudCA9IGpzZ3VpLmh0bWwuZXh0ZW5kKHtcclxuICAgIC8vIG5vIHRhZyB0byByZW5kZXIuLi5cclxuICAgIC8vICBidXQgaGFzIGR0ZC5cclxuXHJcbiAgICAncmVuZGVyX2R0ZCc6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gJzwhRE9DVFlQRSBodG1sIFBVQkxJQyBcIi0vL1czQy8vRFREIFhIVE1MIDEuMS8vRU5cIiBcImh0dHA6Ly93d3cudzMub3JnL1RSL3hodG1sMTEvRFREL3hodG1sMTEuZHRkXCI+XFxuJztcclxuICAgIH1cclxuXHJcblxyXG59KTtcclxuXHJcbnZhciBCbGFua19IVE1MX0RvY3VtZW50ID0gSFRNTF9Eb2N1bWVudC5leHRlbmQoe1xyXG4gICAgJ2luaXQnOiBmdW5jdGlvbiAoc3BlYykge1xyXG4gICAgICAgIHRoaXMuX3N1cGVyKHNwZWMpO1xyXG5cclxuICAgICAgICB2YXIgY29udGV4dCA9IHRoaXMuX2NvbnRleHQ7XHJcbiAgICAgICAgLy9jb25zb2xlLmxvZygnY29udGV4dCAnICsgY29udGV4dCk7XHJcblxyXG4gICAgICAgIGlmICghc3BlYy5lbCkge1xyXG4gICAgICAgICAgICB2YXIgaGVhZCA9IG5ldyBqc2d1aS5oZWFkKHtcclxuICAgICAgICAgICAgICAgICdjb250ZXh0JzogY29udGV4dFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy5nZXQoJ2NvbnRlbnQnKS5hZGQoaGVhZCk7XHJcblxyXG4gICAgICAgICAgICB2YXIgdGl0bGUgPSBuZXcganNndWkudGl0bGUoe1xyXG4gICAgICAgICAgICAgICAgJ2NvbnRleHQnOiBjb250ZXh0XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBoZWFkLmdldCgnY29udGVudCcpLmFkZCh0aXRsZSk7XHJcblxyXG4gICAgICAgICAgICB2YXIgYm9keSA9IG5ldyBqc2d1aS5ib2R5KHtcclxuICAgICAgICAgICAgICAgICdjb250ZXh0JzogY29udGV4dFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy5nZXQoJ2NvbnRlbnQnKS5hZGQoYm9keSk7XHJcblxyXG4gICAgICAgICAgICAvLyBhbmQgaGF2ZSAuaGVhZCwgLnRpdGxlLCAuYm9keT9cclxuXHJcbiAgICAgICAgICAgIC8vIHVzZWZ1bCBzaG9ydGN1dHM/XHJcbiAgICAgICAgICAgIHRoaXMuc2V0KCdoZWFkJywgaGVhZCk7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0KCd0aXRsZScsIHRpdGxlKTtcclxuICAgICAgICAgICAgdGhpcy5zZXQoJ2JvZHknLCBib2R5KTtcclxuXHJcbiAgICAgICAgICAgIC8vdGhpcy5oZWFkID0gaGVhZDtcclxuICAgICAgICAgICAgLy90aGlzLnRpdGxlID0gdGl0bGU7XHJcbiAgICAgICAgICAgIC8vdGhpcy5ib2R5ID0gYm9keTtcclxuXHJcbiAgICAgICAgICAgIC8vIE1heWJlIGNvbm5lY3RpbmcgY29udHJvbCBmaWVsZHM/XHJcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdF9maWVsZHMoWydoZWFkJywgJ2JvZHknLCAndGl0bGUnXSk7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcblxyXG4gICAgICAgIC8vY29uc29sZS5sb2coJ2NvbnRlbnQgJyArIHN0cmluZ2lmeSh0aGlzLmdldCgnY29udGVudCcpKSk7XHJcblxyXG4gICAgICAgIC8vdGhyb3cgJ3N0b3AnO1xyXG5cclxuICAgICAgICAvL2NvbnNvbGUubG9nKCcnKTtcclxuICAgICAgICAvL2NvbnNvbGUubG9nKCdlbmQgaW5pdCBCbGFua19IVE1MX0RvY3VtZW50IHRoaXMuXyAnICsgc3RyaW5naWZ5KHRoaXMuXykpO1xyXG4gICAgfSxcclxuICAgICdib2R5JzogZnAoZnVuY3Rpb24oYSwgc2lnKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ2JvZHkgc2lnJywgc2lnKTtcclxuICAgICAgICBpZiAoc2lnID09J1tdJykge1xyXG4gICAgICAgICAgICAvLyBmaW5kIHRoZSBib2R5IGNvbnRyb2wuXHJcblxyXG4gICAgICAgICAgICB2YXIgY29udGVudCA9IHRoaXMuZ2V0KCdjb250ZW50Jyk7XHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2NvbnRlbnQnLCBjb250ZW50KTtcclxuICAgICAgICAgICAgdmFyIGJvZHkgPSBjb250ZW50LmdldCgxKTtcclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnYm9keScsIGJvZHkpO1xyXG4gICAgICAgICAgICAvL3Rocm93ICdzdG9wJztcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBib2R5O1xyXG4gICAgICAgIH1cclxuICAgIH0pXHJcbn0pO1xyXG5cclxuLy8gV2FudCBhIGJvZHkgZnVuY3Rpb24gaW4gb3RoZXIgbm9kZXMsIGF2YWlsYWJsZSB0aHJvdWdob3V0IHRoZSBkb2N1bWVudD9cclxuXHJcblxyXG5cclxudmFyIENsaWVudF9IVE1MX0RvY3VtZW50ID0gQmxhbmtfSFRNTF9Eb2N1bWVudC5leHRlbmQoe1xyXG4gICAgJ2luaXQnOiBmdW5jdGlvbiAoc3BlYykge1xyXG4gICAgICAgIHRoaXMuX3N1cGVyKHNwZWMpO1xyXG5cclxuICAgICAgICAvL3NwZWMuY29udGV4dC5jdHJsX2RvY3VtZW50ID0gdGhpcztcclxuICAgICAgICB0aGlzLmFjdGl2ZSgpO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgJ2luY2x1ZGVfanMnOiBmdW5jdGlvbih1cmwpIHtcclxuICAgICAgICB2YXIgaGVhZCA9IHRoaXMuZ2V0KCdoZWFkJyk7XHJcbiAgICAgICAgLy8gY3JlYXRlIGpzZ3VpLnNjcmlwdFxyXG5cclxuICAgICAgICB2YXIgc2NyaXB0ID0gbmV3IGpzZ3VpLnNjcmlwdCh7XHJcbiAgICAgICAgICAgIC8vPHNjcmlwdCB0eXBlPVwidGV4dC9KYXZhU2NyaXB0XCIgc3JjPVwiYWJjLmpzXCI+PC9zY3JpcHQ+XHJcbiAgICAgICAgICAgICdjb250ZXh0JzogdGhpcy5fY29udGV4dFxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLy8gPHNjcmlwdCBkYXRhLW1haW49XCJzY3JpcHRzL21haW5cIiBzcmM9XCJzY3JpcHRzL3JlcXVpcmUuanNcIj48L3NjcmlwdD5cclxuICAgICAgICB2YXIgZG9tID0gc2NyaXB0LmdldCgnZG9tJyk7XHJcbiAgICAgICAgLy9jb25zb2xlLmxvZygnKiBkb20gJyArIHN0cmluZ2lmeShkb20pKTtcclxuXHJcbiAgICAgICAgLy92YXIgZG9tQXR0cmlidXRlcyA9IHNjcmlwdC5nZXQoJ2RvbS5hdHRyaWJ1dGVzJyk7XHJcbiAgICAgICAgdmFyIGRvbUF0dHJpYnV0ZXMgPSBkb20uZ2V0KCdhdHRyaWJ1dGVzJyk7XHJcbiAgICAgICAgLy9jb25zb2xlLmxvZygnZG9tQXR0cmlidXRlcyAnICsgZG9tQXR0cmlidXRlcyk7XHJcblxyXG4gICAgICAgIGRvbUF0dHJpYnV0ZXMuc2V0KCd0eXBlJywgJ3RleHQvamF2YXNjcmlwdCcpO1xyXG4gICAgICAgIC8vZG9tQXR0cmlidXRlcy5zZXQoJ3NyYycsICcvanMvcmVxdWlyZS5qcycpO1xyXG4gICAgICAgIGRvbUF0dHJpYnV0ZXMuc2V0KCdzcmMnLCB1cmwpO1xyXG4gICAgICAgIGhlYWQuY29udGVudCgpLmFkZChzY3JpcHQpO1xyXG4gICAgfSxcclxuXHJcbiAgICAnaW5jbHVkZV9jc3MnOiBmdW5jdGlvbih1cmwpIHtcclxuICAgICAgICB2YXIgaGVhZCA9IHRoaXMuZ2V0KCdoZWFkJyk7XHJcbiAgICAgICAgLy8gY3JlYXRlIGpzZ3VpLnNjcmlwdFxyXG5cclxuICAgICAgICAvLyA8bGluayByZWw9XCJzdHlsZXNoZWV0XCIgdHlwZT1cInRleHQvY3NzXCIgaHJlZj1cInRoZW1lLmNzc1wiPlxyXG5cclxuICAgICAgICB2YXIgbGluayA9IG5ldyBqc2d1aS5saW5rKHtcclxuICAgICAgICAgICAgLy88c2NyaXB0IHR5cGU9XCJ0ZXh0L0phdmFTY3JpcHRcIiBzcmM9XCJhYmMuanNcIj48L3NjcmlwdD5cclxuICAgICAgICAgICAgJ2NvbnRleHQnOiB0aGlzLl9jb250ZXh0XHJcbiAgICAgICAgfSlcclxuICAgICAgICAvLyA8c2NyaXB0IGRhdGEtbWFpbj1cInNjcmlwdHMvbWFpblwiIHNyYz1cInNjcmlwdHMvcmVxdWlyZS5qc1wiPjwvc2NyaXB0PlxyXG4gICAgICAgIHZhciBkb20gPSBsaW5rLmdldCgnZG9tJyk7XHJcbiAgICAgICAgLy9jb25zb2xlLmxvZygnKiBkb20gJyArIHN0cmluZ2lmeShkb20pKTtcclxuXHJcbiAgICAgICAgLy92YXIgZG9tQXR0cmlidXRlcyA9IHNjcmlwdC5nZXQoJ2RvbS5hdHRyaWJ1dGVzJyk7XHJcbiAgICAgICAgdmFyIGRvbUF0dHJpYnV0ZXMgPSBkb20uZ2V0KCdhdHRyaWJ1dGVzJyk7XHJcbiAgICAgICAgLy9jb25zb2xlLmxvZygnZG9tQXR0cmlidXRlcyAnICsgZG9tQXR0cmlidXRlcyk7XHJcblxyXG4gICAgICAgIGRvbUF0dHJpYnV0ZXMuc2V0KCdyZWwnLCAnc3R5bGVzaGVldCcpO1xyXG4gICAgICAgIGRvbUF0dHJpYnV0ZXMuc2V0KCd0eXBlJywgJ3RleHQvY3NzJyk7XHJcbiAgICAgICAgLy9kb21BdHRyaWJ1dGVzLnNldCgnc3JjJywgJy9qcy9yZXF1aXJlLmpzJyk7XHJcbiAgICAgICAgZG9tQXR0cmlidXRlcy5zZXQoJ2hyZWYnLCB1cmwpO1xyXG4gICAgICAgIGhlYWQuY29udGVudCgpLmFkZChsaW5rKTtcclxuICAgIH0sXHJcblxyXG5cclxuICAgICdpbmNsdWRlX2pzZ3VpX2NsaWVudCc6IGZ1bmN0aW9uKGpzX2ZpbGVfcmVxdWlyZV9kYXRhX21haW4pIHtcclxuXHJcbiAgICAgICAgLy8gQ291bGQgYWRkIHRoZSBkZWZhdWx0IGNsaWVudCBmaWxlLlxyXG5cclxuICAgICAgICAvLyBPciBhIHNwZWNpZmljIGNsaWVudCBmaWxlIHdpdGggYSBjb250cm9sIHRoYXQgYWxzbyBoYXMgY2xpZW50LXNpZGUgY29kZS5cclxuICAgICAgICAvLyAgVGhlIGNsaWVudC1zaWRlIGNvZGUgd29uJ3QgZ2V0IHByb2Nlc3NlZCBvbiB0aGUgc2VydmVyLlxyXG4gICAgICAgIC8vICBUaGVyZSB3aWxsIGJlIGEgc3BlY2lmaWMgcGxhY2Ugd2hlcmUgY2xpZW50IHNpZGUgY29kZSBnZXRzIGNhbGxlZCB1cG9uIGFjdGl2YXRpb24uXHJcblxyXG4gICAgICAgIC8vIGNvdWxkIGluY2x1ZGUgYSBzcGVjaWZpYyBwYXJhbWV0ZXIgZm9yIGpzX2ZpbGVfcmVxdWlyZV9kYXRhX21haW5cclxuXHJcbiAgICAgICAganNfZmlsZV9yZXF1aXJlX2RhdGFfbWFpbiA9IGpzX2ZpbGVfcmVxdWlyZV9kYXRhX21haW4gfHwgJy9qcy93ZWIvanNndWktaHRtbC1jbGllbnQnO1xyXG5cclxuICAgICAgICAvLyBOZWVkcyB0byBhZGQgdmFyaW91cyBzY3JpcHQgcmVmZXJlbmNlcyB0byB0aGUgYm9keS5cclxuICAgICAgICAvLyAgTWF5IGp1c3QgYmUgb25lIGNsaWVudC5qcyBmaWxlXHJcbiAgICAgICAgLy8gIFRoZW4gd2lsbCB3b3JrIG9uIGhhdmluZyBpdCBidWlsZCBxdWlja2x5XHJcbiAgICAgICAgLy8gIFRoZW4gd2lsbCB3b3JrIG9uIG1ha2luZyBpdCBzdGF5IGZhc3QgdG8gYnVpbGQgYW5kIGJlIHNtYWxsZXIuXHJcblxyXG4gICAgICAgIC8vIGluY2x1ZGUgdGhlIHNjcmlwdCBpbiB0aGUgYm9keT9cclxuICAgICAgICAvLyAgaXMgdGhlcmUgYSB3YXkgdG8ga2VlcCBpdCBhdCB0aGUgZW5kIG9mIHRoZSBib2R5P1xyXG4gICAgICAgIC8vICBjb3VsZCBwdXQgaXQgaW4gdGhlIGhlYWQgZm9yIHRoZSBtb21lbnQuXHJcblxyXG4gICAgICAgIHZhciBoZWFkID0gdGhpcy5nZXQoJ2hlYWQnKTtcclxuICAgICAgICAvLyBjcmVhdGUganNndWkuc2NyaXB0XHJcblxyXG4gICAgICAgIHZhciBzY3JpcHQgPSBuZXcganNndWkuc2NyaXB0KHtcclxuICAgICAgICAgICAgLy88c2NyaXB0IHR5cGU9XCJ0ZXh0L0phdmFTY3JpcHRcIiBzcmM9XCJhYmMuanNcIj48L3NjcmlwdD5cclxuICAgICAgICAgICAgJ2NvbnRleHQnOiB0aGlzLl9jb250ZXh0XHJcbiAgICAgICAgfSlcclxuICAgICAgICAvLyA8c2NyaXB0IGRhdGEtbWFpbj1cInNjcmlwdHMvbWFpblwiIHNyYz1cInNjcmlwdHMvcmVxdWlyZS5qc1wiPjwvc2NyaXB0PlxyXG5cclxuICAgICAgICAvL3ZhciBkb20gPSBzY3JpcHQuZ2V0KCdkb20nKTtcclxuICAgICAgICAvL2NvbnNvbGUubG9nKCcqIGRvbSAnICsgc3RyaW5naWZ5KGRvbSkpO1xyXG5cclxuICAgICAgICAvL3ZhciBkb21BdHRyaWJ1dGVzID0gc2NyaXB0LmdldCgnZG9tLmF0dHJpYnV0ZXMnKTtcclxuICAgICAgICAvL3ZhciBkb21BdHRyaWJ1dGVzID0gZG9tLmdldCgnYXR0cmlidXRlcycpO1xyXG4gICAgICAgIHZhciBkb21BdHRyaWJ1dGVzID0gc2NyaXB0LmdldCgnZG9tLmF0dHJpYnV0ZXMnKTtcclxuXHJcbiAgICAgICAgLy9jb25zb2xlLmxvZygnZG9tQXR0cmlidXRlcyAnICsgZG9tQXR0cmlidXRlcyk7XHJcblxyXG5cclxuXHJcbiAgICAgICAgLy9kb21BdHRyaWJ1dGVzLnNldCgndHlwZScsICd0ZXh0L2phdmFzY3JpcHQnKTtcclxuICAgICAgICAvL2RvbUF0dHJpYnV0ZXMuc2V0KCdzcmMnLCAnL2pzL3JlcXVpcmUuanMnKTtcclxuICAgICAgICAvL2RvbUF0dHJpYnV0ZXMuc2V0KCdkYXRhLW1haW4nLCBqc19maWxlX3JlcXVpcmVfZGF0YV9tYWluKTtcclxuICAgICAgICBkb21BdHRyaWJ1dGVzLnNldCh7XHJcbiAgICAgICAgICAgICd0eXBlJzogJ3RleHQvamF2YXNjcmlwdCcsXHJcbiAgICAgICAgICAgICdzcmMnOiAnL2pzL3dlYi9yZXF1aXJlLmpzJyxcclxuICAgICAgICAgICAgJ2RhdGEtbWFpbic6IGpzX2ZpbGVfcmVxdWlyZV9kYXRhX21haW5cclxuICAgICAgICB9KTtcclxuXHJcblxyXG4gICAgICAgIC8vc2NyaXB0LnNldCgnZG9tLmF0dHJpYnV0ZXMudHlwZScsICd0ZXh0L2phdmFzY3JpcHQnKTtcclxuICAgICAgICAvL3NjcmlwdC5zZXQoJ2RvbS5hdHRyaWJ1dGVzLnNyYycsICdqcy9qc2d1aS1jbGllbnQuanMnKTtcclxuICAgICAgICAvL3NjcmlwdC5zZXQoJ2RvbS5hdHRyaWJ1dGVzLnNyYycsICdqcy9yZXF1aXJlLmpzJyk7XHJcbiAgICAgICAgLy9zY3JpcHQuc2V0KCdkb20uYXR0cmlidXRlcy5kYXRhLW1haW4nLCAnanMvanNndWktY2xpZW50LmpzJyk7XHJcbiAgICAgICAgLy9zY3JpcHQuc2V0KCdkb20uYXR0cmlidXRlcy5kYXRhLW1haW4nLCBqc19maWxlX3JlcXVpcmVfZGF0YV9tYWluKTtcclxuXHJcblxyXG4gICAgICAgIGhlYWQuYWRkKHNjcmlwdCk7XHJcbiAgICAgICAgLy90aHJvdyAnc3RvcCc7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAnaW5jbHVkZV9qc2d1aV9yZXNvdXJjZV9jbGllbnQnOiBmdW5jdGlvbihwYXRoKSB7XHJcblxyXG4gICAgICAgIC8vIENvdWxkIGFkZCB0aGUgZGVmYXVsdCBjbGllbnQgZmlsZS5cclxuXHJcbiAgICAgICAgLy8gT3IgYSBzcGVjaWZpYyBjbGllbnQgZmlsZSB3aXRoIGEgY29udHJvbCB0aGF0IGFsc28gaGFzIGNsaWVudC1zaWRlIGNvZGUuXHJcbiAgICAgICAgLy8gIFRoZSBjbGllbnQtc2lkZSBjb2RlIHdvbid0IGdldCBwcm9jZXNzZWQgb24gdGhlIHNlcnZlci5cclxuICAgICAgICAvLyAgVGhlcmUgd2lsbCBiZSBhIHNwZWNpZmljIHBsYWNlIHdoZXJlIGNsaWVudCBzaWRlIGNvZGUgZ2V0cyBjYWxsZWQgdXBvbiBhY3RpdmF0aW9uLlxyXG5cclxuICAgICAgICAvLyBjb3VsZCBpbmNsdWRlIGEgc3BlY2lmaWMgcGFyYW1ldGVyIGZvciBqc19maWxlX3JlcXVpcmVfZGF0YV9tYWluXHJcblxyXG4gICAgICAgIHZhciBqc19maWxlX3JlcXVpcmVfZGF0YV9tYWluID0gcGF0aCB8fCAnL2pzL3dlYi9qc2d1aS1odG1sLXJlc291cmNlLWNsaWVudCc7XHJcbiAgICAgICAgdGhpcy5pbmNsdWRlX2pzZ3VpX2NsaWVudChqc19maWxlX3JlcXVpcmVfZGF0YV9tYWluKTtcclxuXHJcbiAgICB9LFxyXG4gICAgJ2luY2x1ZGVfY2xpZW50X2Nzcyc6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBoZWFkID0gdGhpcy5nZXQoJ2hlYWQnKTtcclxuICAgICAgICB2YXIgbGluayA9IG5ldyBqc2d1aS5saW5rKHtcclxuICAgICAgICAgICAgLy88c2NyaXB0IHR5cGU9XCJ0ZXh0L0phdmFTY3JpcHRcIiBzcmM9XCJhYmMuanNcIj48L3NjcmlwdD5cclxuICAgICAgICAgICAgJ2NvbnRleHQnOiB0aGlzLl9jb250ZXh0XHJcblxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vdmFyIGxkYSA9IGxpbmsuZ2V0KCdkb20uYXR0cmlidXRlcycpO1xyXG4gICAgICAgIC8vdmFyIGRvbSA9IGxpbmsuZ2V0KCdkb20nKTtcclxuICAgICAgICAvL2NvbnNvbGUubG9nKCcqIGRvbSAnICsgc3RyaW5naWZ5KGRvbSkpO1xyXG5cclxuICAgICAgICAvL3ZhciBkb21BdHRyaWJ1dGVzID0gc2NyaXB0LmdldCgnZG9tLmF0dHJpYnV0ZXMnKTtcclxuICAgICAgICB2YXIgZG9tQXR0cmlidXRlcyA9IGxpbmsuZ2V0KCdkb20uYXR0cmlidXRlcycpO1xyXG5cclxuICAgICAgICBkb21BdHRyaWJ1dGVzLnNldCgncmVsJywgJ3N0eWxlc2hlZXQnKTtcclxuICAgICAgICBkb21BdHRyaWJ1dGVzLnNldCgndHlwZScsICd0ZXh0L2NzcycpO1xyXG4gICAgICAgIGRvbUF0dHJpYnV0ZXMuc2V0KCdocmVmJywgJy9jc3MvYmFzaWMuY3NzJyk7XHJcblxyXG4gICAgICAgIGhlYWQuY29udGVudCgpLmFkZChsaW5rKTtcclxuICAgICAgICAvLyA8bGluayByZWw9XCJzdHlsZXNoZWV0XCIgdHlwZT1cInRleHQvY3NzXCIgaHJlZj1cInRoZW1lLmNzc1wiPlxyXG4gICAgfVxyXG5cclxuICAgIC8vIGFsc28gbmVlZCB0byBpbmNsdWRlIGpzZ3VpIGNsaWVudCBjc3NcclxuXHJcblxyXG5cclxufSk7XHJcblxyXG5cclxuXHJcblxyXG4vLyBCZWhhdmlvdXJzLi4uXHJcbi8vICAoTWF5IGJlIGxpa2UgZmxhZ3M/KVxyXG4vLyAgU2VsZWN0YWJsZVxyXG4vLyAgRHJhZ2FibGVcclxuLy8gIERyb3AtWm9uZVxyXG5cclxuLy8gVGhlc2UgbmVlZCB0byBiZSBkb25lIGluIGEgd2F5IHRvIG1ha2UgY29udHJvbHMgdGFrZSBsZXNzIGNvZGUuXHJcblxyXG5cclxuXHJcbmpzZ3VpLmFjdGl2YXRlID0gYWN0aXZhdGU7XHJcbmpzZ3VpLnJlY3Vyc2l2ZV9kb21faXRlcmF0ZSA9IHJlY3Vyc2l2ZV9kb21faXRlcmF0ZTtcclxuanNndWkucmVjdXJzaXZlX2RvbV9pdGVyYXRlX2RlcHRoID0gcmVjdXJzaXZlX2RvbV9pdGVyYXRlX2RlcHRoO1xyXG5qc2d1aS5nZXRfd2luZG93X3NpemUgPSBnZXRfd2luZG93X3NpemU7XHJcbmpzZ3VpLkNsaWVudF9IVE1MX0RvY3VtZW50ID0gQ2xpZW50X0hUTUxfRG9jdW1lbnQ7XHJcbmpzZ3VpLmRlc2MgPSBkZXNjO1xyXG4vL2pzZ3VpLlNlbGVjdGlvbl9TY29wZSA9IFNlbGVjdGlvbl9TY29wZTtcclxuXHJcbi8vIEFuZCBhIFBhZ2VfQ29udHJvbCBhcyB3ZWxsLi4uXHJcblxyXG5cclxuXHJcblxyXG5cclxuanNndWkuaG92ZXJfY2xhc3MgPSBob3Zlcl9jbGFzcztcclxuanNndWkuZ3JvdXBfaG92ZXJfY2xhc3MgPSBncm91cF9ob3Zlcl9jbGFzcztcclxuXHJcbi8vcmV0dXJuIGpzZ3VpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBqc2d1aTtcclxuXHJcblx0Ly99XHJcbi8vKTtcclxuIiwiXHJcbi8qXHJcbmlmICh0eXBlb2YgZGVmaW5lICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICB2YXIgZGVmaW5lID0gcmVxdWlyZSgnYW1kZWZpbmUnKShtb2R1bGUpO1xyXG59XHJcblxyXG5cclxuZGVmaW5lKFtcIi4vanNndWktaHRtbC1jb3JlXCJdLFxyXG5cdGZ1bmN0aW9uKGpzZ3VpKSB7XHJcblx0ICAgICovXHJcblxyXG52YXIganNndWkgPSByZXF1aXJlKCcuL2pzZ3VpLWh0bWwtY29yZScpO1xyXG5cclxudmFyIHN0cmluZ2lmeSA9IGpzZ3VpLnN0cmluZ2lmeSwgZWFjaCA9IGpzZ3VpLmVhYywgdG9mID0ganNndWkudG9mLCBpc19kZWZpbmVkID0ganNndWkuaXNfZGVmaW5lZDtcclxudmFyIENvbnRyb2wgPSBqc2d1aS5Db250cm9sLCBDbGFzcyA9IGpzZ3VpLkNsYXNzO1xyXG5cclxudmFyIGZwID0ganNndWkuZnA7XHJcbnZhciBncm91cCA9IGpzZ3VpLmdyb3VwO1xyXG5cclxudmFyIGdldF93aW5kb3dfc2l6ZSA9IGpzZ3VpLmdldF93aW5kb3dfc2l6ZTtcclxuXHJcblxyXG4vLyB0aGlzIGlzIHRoZSBlbmhhbmNlZCBIVE1MIG1vZHVsZS5cclxuXHJcbnZhciBQYWdlX0NvbnRleHQgPSBqc2d1aS5FdmVudGVkX0NsYXNzLmV4dGVuZCh7XHJcbiAgICAnaW5pdCc6IGZ1bmN0aW9uIChzcGVjKSB7XHJcbiAgICAgICAgc3BlYyA9IHNwZWMgfHwge307XHJcbiAgICAgICAgaWYgKHNwZWMuYnJvd3Nlcl9pbmZvKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYnJvd3Nlcl9pbmZvID0gc3BlYy5icm93c2VyX2luZm87XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgaWYgKHNwZWMucmVzb3VyY2VfcG9vbCkge1xyXG4gICAgICAgICAgICB0aGlzLnJlc291cmNlX3Bvb2wgPSBzcGVjLnJlc291cmNlX3Bvb2w7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKlxyXG4gICAgICAgIHRoaXMuaXRlbUluZGV4ID0gZnVuY3Rpb24ob2JqLCBpdGVtKSB7XHJcbiAgICAgICAgICAgIHZhciBjID0gLTE7XHJcbiAgICAgICAgICAgICQuZWFjaChvYmosIGZ1bmN0aW9uKGksIG4pIHtcclxuICAgICAgICAgICAgICAgIGlmIChuID09PSBvYmopIGMgPSBpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIGM7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAqL1xyXG5cclxuICAgICAgICB0aGlzLmdldF92ZWN0b3JfbWV0aG9kb2xvZ3kgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmJyb3dzZXJfaW5mby5pZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICd2bWwnO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICdzdmcnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICB2YXIgcWlkcyA9IFtdLFxyXG4gICAgICAgICAgICBpUWlkID0gMSxcclxuICAgICAgICAgICAgcWlkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlcyA9ICdxaWRfJyArIGlRaWQ7XHJcbiAgICAgICAgICAgICAgICBpUWlkKys7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgICAgICAgICB9LCB0eXBlZElkcyA9IHt9LCBpVHlwZWRJZHMgPSB7fSwgdHlwZWRfaWQgPSBmdW5jdGlvbiAoc3RyX3R5cGUpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaVR5cGVkSWRzW3N0cl90eXBlXSA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBpVHlwZWRJZHNbc3RyX3R5cGVdID0gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciByZXMgPSBpVHlwZWRJZHNbc3RyX3R5cGVdO1xyXG4gICAgICAgICAgICAgICAgaVR5cGVkSWRzW3N0cl90eXBlXSA9IGlUeXBlZElkc1tzdHJfdHlwZV0gKyAxO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB0aGlzLnFpZCA9IHFpZDtcclxuICAgICAgICAqL1xyXG5cclxuXHJcbiAgICAgICAgLy8gQ29waWVkIGZyb20gU2VydmVyLlBhZ2VfQ29udGV4dFxyXG5cclxuICAgICAgICB2YXIgbWFwX25ld19pZHMgPSB7fTtcclxuICAgICAgICAvLyBhbmQgaGF2ZSB0aGUgb2JqZWN0cyByZWdpc3RlcmVkIHdpdGhpbiB0aGUgY29udGV4dCB0b28uXHJcblxyXG4gICAgICAgIHZhciBtYXBfb2JqZWN0cyA9IHt9O1xyXG5cclxuICAgICAgICB2YXIgX2dldF9uZXdfdHlwZWRfb2JqZWN0X2lkID0gZnVuY3Rpb24odHlwZV9uYW1lKSB7XHJcbiAgICAgICAgICAgIGlmICghaXNfZGVmaW5lZChtYXBfbmV3X2lkc1t0eXBlX25hbWVdKSkge1xyXG4gICAgICAgICAgICAgICAgbWFwX25ld19pZHNbdHlwZV9uYW1lXSA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy9pZiAoIWlzX2RlZmluZWQobWFwX25ld19pZHNbdHlwZV9uYW1lXSkge1xyXG4gICAgICAgICAgICAvLyAgbWFwX25ld19pZHNbdHlwZV9uYW1lXSA9IDA7XHJcbiAgICAgICAgICAgIC8vfVxyXG4gICAgICAgICAgICB2YXIgcmVzID0gdHlwZV9uYW1lICsgJ18nICsgbWFwX25ld19pZHNbdHlwZV9uYW1lXTtcclxuICAgICAgICAgICAgbWFwX25ld19pZHNbdHlwZV9uYW1lXSsrO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5uZXdfaWQgPSBfZ2V0X25ld190eXBlZF9vYmplY3RfaWQ7XHJcblxyXG4gICAgICAgIHRoaXMuc2V0X21heF9pZHMgPSBmdW5jdGlvbihtYXBfbWF4X2lkcykge1xyXG4gICAgICAgICAgICBlYWNoKG1hcF9tYXhfaWRzLCBmdW5jdGlvbihpLCB2KSB7XHJcbiAgICAgICAgICAgICAgICBtYXBfbmV3X2lkc1tpXSA9IHYgKyAxO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIC8qIHRlSWRzID0ge30sIGl0ZUlkcyA9IHt9LCB0eXBlZF9lbmhhbmNlbWVudF9pZCA9IGZ1bmN0aW9uKHN0cl90eXBlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzdHJfdHlwZSArICdfJyArIHR5cGVkX2VuaGFuY2VtZW50X2ludChzdHJfdHlwZSk7XHJcbiAgICAgICAgfTsgKi9cclxuXHJcbiAgICAgICAgLy90aGlzLnRlSWRzID0gdGVJZHM7XHJcbiAgICAgICAgLy90aGlzLmN0cmxzX2J5X2lkID0ge307XHJcbiAgICAgICAgLy90aGlzLmNsX2FicyA9IHt9OyAvLyBhYnN0cmFjdCBjb250cm9scyBmb3IgdGhlIGNsaWVudFxyXG5cclxuICAgICAgICAvLyB0eXBlZCBlbmhhbmNlbWVudHMgbWF5IGJlIHJldGlyZWQuIE5vdCBhY3RpdmVseSB1c2luZyB0aGVtIGxhdGUgSnVseSAyMDExIGJ1dCB0aGV5IGNvdWxkIHRoZXkgYmUgd2l0aGluIHRoZSBsb3dlciBsZXZlbCB3b3JraW5ncz9cclxuICAgICAgICAvKlxyXG4gICAgICAgIHZhciB0eXBlZF9lbmhhbmNlbWVudF9pbnQgPSBmdW5jdGlvbihzdHJfdHlwZSkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGl0ZUlkc1tzdHJfdHlwZV0gPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgICAgICBpdGVJZHNbc3RyX3R5cGVdID0gMDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnJyk7XHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJyoqIHN0cl90eXBlICcgKyBzdHJfdHlwZSk7XHJcblxyXG4gICAgICAgICAgICB2YXIgcmVzID0gaXRlSWRzW3N0cl90eXBlXTtcclxuICAgICAgICAgICAgaXRlSWRzW3N0cl90eXBlXSA9IGl0ZUlkc1tzdHJfdHlwZV0gKyAxO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHRoaXMuX2FkdmFuY2VfdHlwZV9pZCA9IGZ1bmN0aW9uKHN0cl90eXBlLCBxdWFudGl0eSkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHF1YW50aXR5ID09ICd1bmRlZmluZWQnKSBxdWFudGl0eSA9IDE7XHJcbiAgICAgICAgICAgIGl0ZUlkc1tzdHJfdHlwZV0gPSBpdGVJZHNbc3RyX3R5cGVdIHx8IDA7XHJcbiAgICAgICAgICAgIGl0ZUlkc1tzdHJfdHlwZV0gPSBpdGVJZHNbc3RyX3R5cGVdICsgcXVhbnRpdHk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAqL1xyXG4gICAgICAgIC8qXHJcbiAgICAgICAgdGhpcy5lbnN1cmVfY3RybF9pZCA9IGZ1bmN0aW9uKGN0cmwpIHtcclxuICAgICAgICAgICAgY3RybC5fID0gY3RybC5fIHx8IHt9O1xyXG5cclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnZW5zdXJlX2N0cmxfaWQgY3RybC5fICcgKyBzdHJpbmdpZnkoY3RybC5fKSk7XHJcblxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGN0cmwuXy5pZCA9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAgICAgLy8gY3RybC5fLmNsYXNzX25hbWVcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGlkID0gdHlwZWRfZW5oYW5jZW1lbnRfaWQoY3RybC5fLnR5cGVfbmFtZSk7XHJcbiAgICAgICAgICAgICAgICBjdHJsLl8uaWQgPSBpZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gY3RybC5fLmlkO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gbWF5IGJlIHJldGlyZWQuLi4gY291bGQgYmUgYmVoYXZpb3VycyAvIHN1cmZhY2VzIGluIHNwZWNzLlxyXG4gICAgICAgIHRoaXMuYXBwbHlfZW5oYW5jZW1lbnRfaWRfc3BlYyA9IGZ1bmN0aW9uKHNwZWMsIGN0cmwpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIHNwZWNpZmljYWxseSB3aGF0IGRvZXMgdGhpcyBkbz9cclxuXHJcbiAgICAgICAgICAgIC8vIFRoZSBjb250cm9sIHdpbGwgaGF2ZSBhbm90aGVyIERPTSBhdHRyaWJ1dGUgc2V0XHJcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgb25seSBmb3Igd2hlbiBjb21wb3NpbmcgYW4gZW5oYW5jZWQgY29udHJvbCBvbiB0aGUgc2VydmVyP1xyXG4gICAgICAgICAgICAvLyBqc2d1aV9lX2lkXHJcblxyXG4gICAgICAgICAgICBzcGVjLmRvbSA9IHNwZWMuZG9tIHx8IHt9O1xyXG4gICAgICAgICAgICBzcGVjLmRvbS5hdHRyaWJ1dGVzID0gc3BlYy5kb20uYXR0cmlidXRlcyB8fCB7fTtcclxuICAgICAgICAgICAgdmFyIHROYW1lID0gY3RybC50eXBlTmFtZSB8fCAnbWlzYyc7XHJcbiAgICAgICAgICAgIHZhciB0ZWkgPSB0eXBlZF9lbmhhbmNlbWVudF9pbnQodE5hbWUpO1xyXG4gICAgICAgICAgICBzcGVjLmRvbS5hdHRyaWJ1dGVzWydqc2d1aV9lX2lkJ10gPSBTdHJpbmcodGVpKTtcclxuICAgICAgICAgICAgcmV0dXJuIFt0TmFtZSwgdGVpXTtcclxuICAgICAgICB9O1xyXG4gICAgICAgICovXHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgdGhpcy5nZXRfc3BlYyA9IGZ1bmN0aW9uIChzcGVjKSB7XHJcbiAgICAgICAgICAgIHNwZWMgPSBzcGVjIHx8IHt9O1xyXG4gICAgICAgICAgICBzcGVjLnBhZ2VfY29udGV4dCA9IHRoaXM7XHJcbiAgICAgICAgICAgIHJldHVybiBzcGVjO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgKi9cclxuXHJcbiAgICAgICAgLy8gR2l2ZSBpdCB0aGUgYWJzdHJhY3QgY29tcG9uZW50IHRvIG1ha2U/XHJcbiAgICAgICAgLy8gIFNvIHRoZSBhYnN0cmFjdCBjb25zdHJ1Y3RvciBnZXRzIGNhbGxlZCwgYW5kIHRoZW4gdGhlIGFic3RyYWN0IGluc3RhbmNlIGdvZXMgaW50byB0aGUgbWFrZSBmdW5jdGlvbi5cclxuXHJcbiAgICAgICAgLy8gY29udGV4dGlmeSAtIGNvbnRleHRpZmllcyBhIHJlY2VudGx5IG1hZGUgaXRlbS5cclxuXHJcbiAgICAgICAgLy90aGlzLm1ha2UgPSBmdW5jdGlvbigpXHJcblxyXG4gICAgICAgIHZhciBtYXBfQ29udHJvbHMgPSB0aGlzLm1hcF9Db250cm9scyA9IHt9O1xyXG4gICAgICAgIC8vICB0aGV5IGFyZSBjb25zdHJ1Y3RvcnNcclxuXHJcbiAgICAgICAgdmFyIG1hcF9jb250cm9scyA9IHRoaXMubWFwX2NvbnRyb2xzID0ge307XHJcblxyXG4gICAgICAgIG1hcF9Db250cm9sc1snY29udHJvbCddID0gQ29udHJvbDtcclxuXHJcbiAgICB9LFxyXG4gICAgJ21ha2UnOiBmdW5jdGlvbihhYnN0cmFjdF9vYmplY3QpIHtcclxuICAgICAgICBpZiAoYWJzdHJhY3Rfb2JqZWN0Ll9hYnN0cmFjdCkge1xyXG4gICAgICAgICAgICAvL3ZhciByZXMgPSBuZXdcclxuICAgICAgICAgICAgLy8gd2UgbmVlZCB0aGUgY29uc3RydWN0b3IgZnVuY3Rpb24uXHJcblxyXG4gICAgICAgICAgICB2YXIgY29uc3RydWN0b3IgPSBhYnN0cmFjdF9vYmplY3QuY29uc3RydWN0b3I7XHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2NvbnN0cnVjdG9yICcgKyBjb25zdHJ1Y3Rvcik7XHJcblxyXG5cclxuICAgICAgICAgICAgLy90aHJvdyAnc3RvcCc7XHJcblxyXG4gICAgICAgICAgICB2YXIgYW9zID0gYWJzdHJhY3Rfb2JqZWN0Ll9zcGVjO1xyXG5cclxuICAgICAgICAgICAgLy8gY291bGQgdXNlICdkZWxldGU/J1xyXG4gICAgICAgICAgICBhb3MuYWJzdHJhY3QgPSBudWxsO1xyXG4gICAgICAgICAgICBhb3MuY29udGV4dCA9IHRoaXM7XHJcblxyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdhYnN0cmFjdF9vYmplY3QuX3NwZWMgJyArIHN0cmluZ2lmeShhYnN0cmFjdF9vYmplY3QuX3NwZWMpKTtcclxuICAgICAgICAgICAgLy8gTm90IHN1cmUgaXQgaXMgY3JlYXRpbmcgdGhlIHJpZ2h0IGNvbnN0cnVjdG9yLlxyXG5cclxuXHJcbiAgICAgICAgICAgIHZhciByZXMgPSBuZXcgY29uc3RydWN0b3IoYWJzdHJhY3Rfb2JqZWN0Ll9zcGVjKTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlcztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJvdyAnT2JqZWN0IG11c3QgYmUgYWJzdHJhY3QsIGhhdmluZyAuX2Fic3RyYWN0ID09IHRydWUnXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgICd1cGRhdGVfQ29udHJvbHMnOiBmcChmdW5jdGlvbihhLCBzaWcpIHtcclxuICAgICAgICAvL2NvbnNvbGUubG9nKCd1cGRhdGVfQ29udHJvbHMgc2lnICcgKyBzaWcpO1xyXG4gICAgICAgIGlmIChzaWcgPT0gJ1tvXScpIHtcclxuICAgICAgICAgICAgLy8gYSBtYXAgb2Yga2V5cyBhbmQgY29uc3RydWN0b3JzIHZhbHVlcy5cclxuICAgICAgICAgICAgdmFyIG8gPSBhWzBdO1xyXG4gICAgICAgICAgICB2YXIgbWFwX0NvbnRyb2xzID0gdGhpcy5tYXBfQ29udHJvbHM7XHJcbiAgICAgICAgICAgIGVhY2gobywgZnVuY3Rpb24obmFtZSwgQ29uc3RydWN0b3IpIHtcclxuICAgICAgICAgICAgICAgIG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCduYW1lICcgKyBuYW1lKTtcclxuICAgICAgICAgICAgICAgIG1hcF9Db250cm9sc1tuYW1lXSA9IENvbnN0cnVjdG9yO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzaWcgPT0gJ1tzLGZdJykge1xyXG4gICAgICAgICAgICB2YXIgbmFtZSA9IGFbMF07XHJcbiAgICAgICAgICAgIHZhciBDb25zdHJ1Y3RvciA9IGFbMV07XHJcbiAgICAgICAgICAgIG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ25hbWUgJyArIG5hbWUpO1xyXG4gICAgICAgICAgICB0aGlzLm1hcF9Db250cm9sc1tuYW1lXSA9IENvbnN0cnVjdG9yO1xyXG4gICAgICAgIH1cclxuICAgIH0pLFxyXG5cclxuICAgICdyZWdpc3Rlcl9jb250cm9sJzogZnVuY3Rpb24oY29udHJvbCkge1xyXG4gICAgICAgIC8vIFB1dCBpdCBpbnRvIHRoZSBtYXAgb2YgSURzXHJcblxyXG4gICAgICAgIC8vY29uc29sZS5sb2coJ3JlZ2lzdGVyX2NvbnRyb2wnKTtcclxuXHJcbiAgICAgICAgLy8gTm90IHN1cmUgaG93IHVzZWZ1bCByZWdpc3RyYXRpb24gb2YgYWxsIGNvbnRyb2xzIHdpbGwgYmUuXHJcbiAgICAgICAgLy8gIFByb2JhYmx5IHdvdWxkIG5vdCBiZSBhIHByb2JsZW0sIGp1c3QgaXQgd2lsbCB0YWtlIG1lbW9yeSBhbmQgQ1BVIGN5Y2xlcy5cclxuXHJcblxyXG4gICAgICAgIHZhciBpZCA9IGNvbnRyb2wuX2lkKCk7XHJcbiAgICAgICAgLy9jb25zb2xlLmxvZygnaWQnLCBpZCk7XHJcblxyXG4gICAgICAgIHRoaXMubWFwX2NvbnRyb2xzW2lkXSA9IGNvbnRyb2w7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAnZmlyc3RfY3RybF9tYXRjaGluZ190eXBlJzogZnVuY3Rpb24odHlwZV9uYW1lKSB7XHJcbiAgICAgIC8vIFdhbnQgdG8gaXRlcmF0ZSB0aHJvdWdoIHRoZSBjb250cm9scy5cclxuICAgICAgdmFyIHJlcztcclxuICAgICAgZWFjaCh0aGlzLm1hcF9jb250cm9scywgZnVuY3Rpb24oY3RybCwgY3RybF9pZCwgZm5fc3RvcCkge1xyXG4gICAgICAgIC8vY29uc29sZS5sb2coJ2ZuX3N0b3AnLCBmbl9zdG9wKTtcclxuXHJcbiAgICAgICAgLy9jb25zb2xlLmxvZygnY3RybCcsIGN0cmwpO1xyXG4gICAgICAgIC8vY29uc29sZS5sb2coJ2N0cmwuX190eXBlX25hbWUnLCBjdHJsLl9fdHlwZV9uYW1lKTtcclxuXHJcbiAgICAgICAgaWYgKGN0cmwuX190eXBlX25hbWUgPT09IHR5cGVfbmFtZSkge1xyXG4gICAgICAgICAgLy9jb25zb2xlLmxvZygnaGF2ZSBtYXRjaCcpO1xyXG4gICAgICAgICAgZm5fc3RvcCgpO1xyXG4gICAgICAgICAgcmVzID0gY3RybDtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgICByZXR1cm4gcmVzO1xyXG5cclxuXHJcbiAgICB9LFxyXG5cclxuXHJcblxyXG4gICAgLy8nc2V0X21heF9pZHMnOiBmdW5jdGlvbihtYXBfbWF4X2lkcykge1xyXG5cclxuICAgIC8vfSxcclxuXHJcbiAgICAvLyBiZWdpbl9kcmFnP1xyXG5cclxuICAgIC8vIGNhbiB0aGlzIGJlIHBsdW1iZWQgaW50byB0aGUgcmVjZW50bHkgY3JlYXRlZCBldmVudHM/XHJcbiAgICAvLyAgd2UgdGVsbCBpdCB0aGF0IHRoZSBkcmFnIGlzIHN0YXJ0aW5nLlxyXG5cclxuICAgIC8vIFdhbnQgdG8gdGVsbCB0aGUgcGFnZSBjb250ZXh0IGFib3V0IGJlZ2lubmluZyBkaWZmZXJlbnQgdHlwZXMgb2YgZHJhZ3M/XHJcblxyXG4gICAgLy8gV2FudCB0aGUgcGFnZSBjb250ZXh0IHRvIGJlIG5vdGlmaWVkIHdoZW5ldmVyIGEgZHJhZyBiZWdpbnMuXHJcbiAgICAvLyAgSWYgdGhlcmUgaXMgYSBzZWxlY3Rpb24gc2NvcGUgdGhlbiBpdCdzIGRyYWdnaW5nIHRob3NlIGl0ZW1zLlxyXG5cclxuICAgIC8vIE90aGVyd2lzZSBpdCBjb3VsZCBiZSBkcmFnZ2luZyBhIGNvbnRyb2wuXHJcbiAgICAvLyAgV2FudCB0aGUgY29udHJvbCBkcmFnZ2luZyB0byBjYWxsIGV2ZW50cyBoZXJlLCBzbyB0aGUgUGFnZV9Db250ZXh0IGtub3dzIHdoZXJlIGNvbnRyb2xzIGFyZSBiZWluZyBkcmFnZ2VkIGZyb20gLyB0by5cclxuXHJcblxyXG5cclxuXHJcbiAgICAvLyBUaGlzIGlzIGN1cnJlbnRseSBhYm91dCBiZWdpbm5pbmcgYSBkcmFnIHdpdGggYSBzZWxlY3Rpb24gc2NvcGUsIGJ1dCB3ZSBtYXkganVzdCB3YW50IHRvIGJlIGRyYWdnaW5nIGEgc2luZ2xlIGNvbnRyb2xcclxuICAgIC8vICBvciBjb250cm9scyBub3QgdG8gZG8gd2l0aCBhIHNlbGVjdGlvbl9zY29wZS5cclxuXHJcbiAgICAvLyBJbiB0aGUgY2FzZSBvZiB0aGVyZSBiZWluZyBhIHNlbGVjdGlvbiBzY29wZSwgd2Ugd2FudCB0byBkcmFnIGFyb3VuZCBzb21ldGhpbmcgdGhhdCByZXByZXNlbnRzIHRoZSBzZWxlY3Rpb24uXHJcblxyXG4gICAgLy8gV2l0aCBkaXJlY3QgZHJhZywgb3IgZHJhZ2dpbmcgYSBoYW5kbGUsIHdlIGRvbid0IGhhdmUgdGhpcyBjb3B5IG9mIHRoZSBzZWxlY3Rpb24gc2NvcGUuXHJcblxyXG4gICAgLy8gZHJhZ19zZWxlY3Rpb25fc2NvcGVfc2hhbGxvd19jb3B5XHJcblxyXG4gICAgLy8gTWF5IHdhbnQgdG8gcmVmYWN0cm9yIHRoaW5ncyB0byBoYXZlIG1vcmUgYmVoYXZpb3VycyBhbmQgZHJhZyBhYnN0cmFjdGlvbnMuXHJcbiAgICAvLyAgSG93ZXZlciwgd29ya2luZyBtb3JlIG9uIHRoZSBzdHlsZSBwcm9wZXJ0aWVzIGZpcnN0IG1ha2VzIG1vcmUgc2Vuc2UuXHJcblxyXG4gICAgLy8gSSdsbCBkbyBzb21lIG1vcmUgd2l0aG91dCBtYWpvciBmdXJ0aGVyIGFic3RyYWN0aW9ucy5cclxuICAgIC8vXHJcblxyXG4gICAgLy8gRGVmaW5pbmcgdGhlIHJlcG9zaXRpb25pbmcuLi5cclxuICAgIC8vICBjb3VsZCBoYXZlIHRoYXQgZXh0bmVkYWJsZS5cclxuXHJcbiAgICAvLyB0aGVuIHdlIGhhdmUgdGhlIGRyYWdnaW5nIG9mIGEgY29udHJvbC5cclxuICAgIC8vICBNb3ZlcyB0aGUgY29udHJvbCwgZG9lcyBub3QgbGVhdmUgYSBwbGFjZWhvbGRlci5cclxuXHJcbiAgICAvLyBOZWVkIHRvIGJlIG5vdGlmaWVkIG9mIGl0P1xyXG4gICAgLy8gIENvbnRyb2wgbWF5IGJlIGRvY2thYmxlLlxyXG5cclxuICAgIC8vIChub3RpZnkpXHJcbiAgICAnYmVnaW5fZHJhZ19jdHJsJzogZnVuY3Rpb24oZV9iZWdpbiwgY3RybCkge1xyXG4gICAgICAgIC8vIFRob3VnaCB0aGUgY3RybCBzaG91bGQgcHJvYmFibHkgZ28gaW4gdGhlIGV2ZW50IG9iamVjdCAtIG1heWJlIG5lZWQgdG8gZm9ybWFsaXNlIGFuIEFQSS5cclxuXHJcbiAgICAgICAgLy8gRGlmZmVyZW50IHR5cGVzIG9mIGRyYWcgY291bGQgYmUgbWFkZSBtb2R1bGFyIHRvIG1ha2UgYnVpbGRzIHNtYWxsZXIuXHJcbiAgICAgICAgLy8gIEZvciB0aGUgbW9tZW50IG5lZWQgdG8gYWRkIGZ1bmN0aW9uYWxpdHkgdGhlbiB3b3JrIG9uIGJ1aWxkIHNpemUgbGF0ZXIuXHJcblxyXG5cclxuXHJcblxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLy8gTWFrZSB0aGlzIGFuIEV2ZW50ZWRfQ2xhc3M/XHJcblxyXG4gICAgLypcclxuXHJcbiAgICAncmFpc2UnOiBmdW5jdGlvbihldmVudF9uYW1lKSB7XHJcbiAgICAgICAgLy8gbmVlZCB0byBhY2Nlc3MgdGhlIG9iamVjdCdzIGJvdW5kIGV2ZW50cy5cclxuXHJcbiAgICAgICAgLy90aGlzLl9fYm91bmRfZXZlbnRzID0gdGhpcy5fX2JvdW5kX2V2ZW50cyB8fCB7fTtcclxuXHJcbiAgICAgICAgLy8gYnV0IHdoaWNoIGNvbnRleHQ/XHJcblxyXG4gICAgICAgIC8vICB0aGUgY29udGV4dCBvZiB0aGUgZXZlbnQgcmFpc2VyP1xyXG5cclxuICAgICAgICB2YXIgYSA9IGFyZ3VtZW50cztcclxuICAgICAgICB2YXIgYTIgPSBbXTtcclxuICAgICAgICBpZiAoYS5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGMgPSAxOyBjIDwgYS5sZW5ndGg7IGMrKykge1xyXG4gICAgICAgICAgICAgICAgYTIucHVzaChhW2NdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuX19ib3VuZF9ldmVudHMpIHtcclxuICAgICAgICAgICAgdmFyIGNvcnJlc3BvbmRpbmdfZXZlbnRzID0gdGhpcy5fX2JvdW5kX2V2ZW50c1tldmVudF9uYW1lXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgYyA9IDAsIGwgPSBjb3JyZXNwb25kaW5nX2V2ZW50cy5sZW5ndGg7IGMgPCBsOyBjKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChhMi5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29ycmVzcG9uZGluZ19ldmVudHNbY10uYXBwbHkodGhpcywgYTIpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjb3JyZXNwb25kaW5nX2V2ZW50c1tjXS5hcHBseSh0aGlzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvLyBsaXN0ZW4gZnVuY3Rpb24gYXMgd2VsbC5cclxuICAgIC8vICB0byBsaXN0ZW4gZm9yIGFuIGV2ZW50LCBpdCdzIGxpa2UgYWRkX2V2ZW50X2hhbmRsZXIuXHJcblxyXG4gICAgLy8gbWF5IGNoYW5nZSB0aGF0IHRvIGxpc3Rlbi5cclxuXHJcbiAgICAnbGlzdGVuJzogZnVuY3Rpb24oZXZlbnRfbmFtZSwgaGFuZGxlcikge1xyXG4gICAgICAgIHRoaXMuX19ib3VuZF9ldmVudHMgPSB0aGlzLl9fYm91bmRfZXZlbnRzIHx8IHt9O1xyXG4gICAgICAgIHRoaXMuX19ib3VuZF9ldmVudHNbZXZlbnRfbmFtZV0gPSB0aGlzLl9fYm91bmRfZXZlbnRzW2V2ZW50X25hbWVdIHx8IFtdO1xyXG4gICAgICAgIHRoaXMuX19ib3VuZF9ldmVudHNbZXZlbnRfbmFtZV0ucHVzaChoYW5kbGVyKTtcclxuICAgIH0sXHJcblxyXG4gICAgKi9cclxuXHJcblxyXG4gICAgJ21vdmVfZHJhZ19jdHJsJzogZnVuY3Rpb24oZV9tb3ZlLCBjdHJsKSB7XHJcbiAgICAgICAgLy8gVGhvdWdoIHRoZSBjdHJsIHNob3VsZCBwcm9iYWJseSBnbyBpbiB0aGUgZXZlbnQgb2JqZWN0IC0gbWF5YmUgbmVlZCB0byBmb3JtYWxpc2UgYW4gQVBJLlxyXG5cclxuICAgICAgICAvLyBEaWZmZXJlbnQgdHlwZXMgb2YgZHJhZyBjb3VsZCBiZSBtYWRlIG1vZHVsYXIgdG8gbWFrZSBidWlsZHMgc21hbGxlci5cclxuICAgICAgICAvLyAgRm9yIHRoZSBtb21lbnQgbmVlZCB0byBhZGQgZnVuY3Rpb25hbGl0eSB0aGVuIHdvcmsgb24gYnVpbGQgc2l6ZSBsYXRlci5cclxuXHJcbiAgICAgICAgLy9jb25zb2xlLmxvZygnbW92ZV9kcmFnX2N0cmwgJywgZV9tb3ZlKTtcclxuXHJcbiAgICAgICAgLy8gbWF5YmUgdGlmeSB1cCB0aGUgcGFyYW1zIHNvIHRoZXJlIGlzIGEgbW92ZV9vZmZzZXQgdmFsdWUuXHJcbiAgICAgICAgLy8gIHBlcmhhcHMgd2UgZG9udCBuZWVkIGl0IGFuZCBpdCBtYWtlcyB1bm5lY2Vzc2FyeSBjYWxjdWxhdGlvbi5cclxuXHJcbiAgICAgICAgLy8gYW55d2F5LCB1c2UgdGhlIGNsaWVudHggYW5kIGNsaWVudCB5XHJcblxyXG4gICAgICAgIC8vIHNob3VsZCBtYXliZSBtZWFzdXJlIHRoZSBjbGllbnQgYXJlYT9cclxuICAgICAgICAvLyAgb3IgZG8gdGhhdCBvbmNlIGFuZCBkbyBpdCBhZ2FpbiBvbiByZXNpemU/XHJcblxyXG4gICAgICAgIC8vIFNob3VsZCBiZSBhYmxlIHRvIGdldCB0aGUgY2xpZW50IHNpemUgZnJvbSB0aGUgUGFnZV9Db250ZXh0LlxyXG4gICAgICAgIC8vICBQYWdlX0NvbnRleHQgaXMgdHVybmluZyBvdXQgdG8gYmUgdmVyeSB2ZXJzaXRpbGUgb24gdGhlIGNsaWVudCB0b28sIG5pY2UgdGhhdCBpdCdzIGdvdCBzaW1pbGFyaXRpZXMgb24gdGhlIHNlcnZlclxyXG4gICAgICAgIC8vICBidXQgdXNlZCB2ZXJ5IGRpZmZlcmVudGx5LlxyXG5cclxuXHJcbiAgICAgICAgLy8gZmluZCBvdXQgd2hlcmUgd2UgYXJlIHdpdGhpbiB0aGUgY2xpZW50IHdpbmRvdy5cclxuXHJcbiAgICAgICAgLy8gZ2V0X3dpbmRvd19zaXplXHJcblxyXG5cclxuXHJcbiAgICAgICAgdmFyIHdpbmRvd19zaXplID0gZ2V0X3dpbmRvd19zaXplKCk7XHJcblxyXG5cclxuXHJcbiAgICAgICAgLy9jb25zb2xlLmxvZygnV2luZG93IHdpZHRoID0gJyArIHdpblcpO1xyXG4gICAgICAgIC8vY29uc29sZS5sb2coJ1dpbmRvdyBoZWlnaHQgPSAnICsgd2luSCk7XHJcblxyXG4gICAgICAgIC8vIGZpbmQgaG93IGNsb3NlIHRoZSBjbGllbnRYIC8gY2xpZW50WSBpcyB0byB0aGUgc2lkZXNcclxuXHJcbiAgICAgICAgLy8gY291bGQgZXZlbiBoYXZlIHR3byBkaWZmZXJlbnQgZGlzdGFuY2VzIC8gcmFuZ2VzIGZvclxyXG4gICAgICAgIC8vICAxKSBhbmNob3IgdG8gcG9zaXRpb25cclxuICAgICAgICAvLyAgMikgYW5jaG9yIHRvIHBvaXNpdGlvbiBhbmQgaGlkZSwgb25seSBzaG93aW5nIHdpdGggbW91c2VvdmVyIG9mIHNtYWxsIHJlZ2lvbi5cclxuXHJcbiAgICAgICAgLy8gZmluZCBob3cgY2xvc2UgdG8gZWRnZXMuLi5cclxuXHJcbiAgICAgICAgdmFyIGZyb21fbGVmdCwgZnJvbV90b3AsIGZyb21fcmlnaHQsIGZyb21fYm90dG9tO1xyXG5cclxuXHJcblxyXG4gICAgICAgIHZhciBjbGllbnRYID0gZV9tb3ZlLmNsaWVudFg7XHJcbiAgICAgICAgdmFyIGNsaWVudFkgPSBlX21vdmUuY2xpZW50WTtcclxuXHJcbiAgICAgICAgLy8gc2VlIGlmIGl0J3MgYXQgdGhlIHRvcCBvciBib3R0b20uLi5cclxuICAgICAgICAvLyAgd291bGQgYmUgbmljZSB0byBoYXZlIGRpZmZlcmVudCBkaXN0YW5jZXMsIHNvIGhhbGZ3YXkgdG8gdGhlIG1hcmdpbiBhbmNob3JzIGl0IGluIGEgd2F5IHRoYXQgaXQgaGlkZXMgaXRzZWxmLlxyXG5cclxuXHJcblxyXG4gICAgICAgIHZhciBtYXJnaW4gPSA2NDtcclxuXHJcbiAgICAgICAgdmFyIGlzX2xlZnQgPSBjbGllbnRYIDw9IG1hcmdpbjtcclxuICAgICAgICB2YXIgaXNfdG9wID0gY2xpZW50WSA8PSBtYXJnaW47XHJcblxyXG4gICAgICAgIHZhciBpc19yaWdodCA9IGNsaWVudFggPj0gd2luZG93X3NpemVbMF0gLSBtYXJnaW47XHJcbiAgICAgICAgdmFyIGlzX2JvdHRvbSA9IGNsaWVudFkgPj0gd2luZG93X3NpemVbMV0gLSBtYXJnaW47XHJcblxyXG4gICAgICAgIC8vIG5lZWQgbW9yZSBnZW5lcmljIGV2ZW50IGJpbmRpbmcgZm9yIG9iamVjdHMuXHJcblxyXG4gICAgICAgIC8vIGxpc3RlblxyXG4gICAgICAgIC8vIHJhaXNlXHJcblxyXG5cclxuXHJcblxyXG4gICAgICAgIC8vIHRoZW4gZm9yIHRoZSBjb21iaW5hdGlvbnMuLi5cclxuICAgICAgICAvL2NvbnNvbGUubG9nKCdpc190b3AgJyArIGlzX3RvcCk7XHJcbiAgICAgICAgaWYgKGlzX3RvcCkge1xyXG4gICAgICAgICAgICAvLyByYWlzZSB0aGUgZXZlbnQuLi5cclxuXHJcbiAgICAgICAgICAgIC8vIHRoZW4gc29tZSB0aGluZ3Mgd2lsbCBsaXN0ZW4gZm9yIGl0LlxyXG4gICAgICAgICAgICB0aGlzLnJhaXNlKCdkcmFnLWN0cmwtdG9wJyk7XHJcblxyXG4gICAgICAgIH0gZWxzZSBpZiAoaXNfYm90dG9tKSB7XHJcbiAgICAgICAgICAgIC8vIHJhaXNlIHRoZSBldmVudC4uLlxyXG5cclxuICAgICAgICAgICAgLy8gdGhlbiBzb21lIHRoaW5ncyB3aWxsIGxpc3RlbiBmb3IgaXQuXHJcbiAgICAgICAgICAgIHRoaXMucmFpc2UoJ2RyYWctY3RybC1ib3R0b20nKTtcclxuXHJcbiAgICAgICAgfSBlbHNlIGlmIChpc19sZWZ0KSB7XHJcbiAgICAgICAgICAgIC8vIHJhaXNlIHRoZSBldmVudC4uLlxyXG5cclxuICAgICAgICAgICAgLy8gdGhlbiBzb21lIHRoaW5ncyB3aWxsIGxpc3RlbiBmb3IgaXQuXHJcbiAgICAgICAgICAgIHRoaXMucmFpc2UoJ2RyYWctY3RybC1sZWZ0Jyk7XHJcblxyXG4gICAgICAgIH0gZWxzZSBpZiAoaXNfcmlnaHQpIHtcclxuICAgICAgICAgICAgLy8gcmFpc2UgdGhlIGV2ZW50Li4uXHJcblxyXG4gICAgICAgICAgICAvLyB0aGVuIHNvbWUgdGhpbmdzIHdpbGwgbGlzdGVuIGZvciBpdC5cclxuICAgICAgICAgICAgdGhpcy5yYWlzZSgnZHJhZy1jdHJsLXJpZ2h0Jyk7XHJcblxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMucmFpc2UoJ2RyYWctY3RybC1uby16b25lJyk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAnZW5kX2RyYWdfY3RybCc6IGZ1bmN0aW9uKGVfZW5kLCBjdHJsKSB7XHJcbiAgICAgICAgLy8gcmFpc2UgdGhlIGV2ZW50Li4uXHJcbiAgICAgICAgdGhpcy5yYWlzZSgnZHJhZy1jdHJsLWVuZCcsIGVfZW5kLCBjdHJsKTtcclxuXHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAnZHJvcF9jdHJsJzogZnVuY3Rpb24oY3RybCwgem9uZSkge1xyXG4gICAgICAgIC8vY29uc29sZS5sb2coJ3BhZ2UgY29udGV4dCBkcm9wIGNvbnRyb2wgY3RybCAnICsgY3RybCk7XHJcbiAgICAgICAgLy9jb25zb2xlLmxvZygnem9uZSAnICsgem9uZSk7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmZ1bGxfd2luZG93KSB7XHJcbiAgICAgICAgICAgIC8vIGFuY2hvciB0aGUgY29udHJvbCBpbiB0aGF0IHpvbmUuXHJcblxyXG4gICAgICAgICAgICB0aGlzLmFuY2hvcihjdHJsLCB6b25lKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEJhc2ljYWxseSB3ZSBuZWVkIHRvIGFuY2hvciBvbmUgY29udHJvbCBpbnNpZGUgYW5vdGhlci5cclxuICAgICAgICAgICAgLy8gIFRoZSBhbmNob3Igem9uZSB3aWxsIGJlIGEgcGFydCBvZiB0aGUgZ3JpZF85IChvciBvdGhlciBtZWNoYW5pc20pXHJcblxyXG5cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgICdhbmNob3InOiBmdW5jdGlvbihjdHJsLCB6b25lKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ3BhZ2UgY29udGV4dCBhbmNob3IgJyk7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmZ1bGxfd2luZG93KSB7XHJcbiAgICAgICAgICAgIHZhciBmdyA9IHRoaXMuZnVsbF93aW5kb3c7XHJcblxyXG4gICAgICAgICAgICAvLyBhbmQgdGhlbiBkb2VzIHRoZSBmdWxsIHdpbmRvdyBjb250cm9sIGhhdmUgYSBncmlkXzk/XHJcblxyXG4gICAgICAgICAgICB2YXIgZzkgPSBmdy5nZXQoJ2dyaWRfOScpO1xyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdnOSAnICsgZzkpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGc5KSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVGhlbiB0aGUgY29udHJvbCB3aWxsIGtub3cgaXRzIGFuY2hvcmVkLlxyXG4gICAgICAgICAgICAgICAgLy8gIERyYWdnaW5nIHRoYXQgY29udHJvbCB3aWxsIHVuYW5jaG9yIGl0LlxyXG5cclxuICAgICAgICAgICAgICAgIC8vIGFuY2hvciB0aGUgY29udHJvbCB0byBhIHBvc2l0aW9uIHdpdGhpbiB0aGF0IGc5LlxyXG4gICAgICAgICAgICAgICAgLy8gIEJhc2ljYWxseSBqdXN0IHB1dCB0aGUgY29udHJvbCBpbiBwbGFjZS5cclxuICAgICAgICAgICAgICAgIC8vICBDb3VsZCBkbyBjdHJsLmFuY2hvcihnOSwgem9uZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gR2VuZXJhbGx5IHdvbid0IGJlIGFuY2hvcmluZyBnOXMgdG8gb3RoZXIgdGhpbmdzLCBidXQgZG9uJ3Qgd2FudCB0byBpbXBseSB0aGF0IGluIHRoZSBmbiBuYW1lLlxyXG4gICAgICAgICAgICAgICAgLy8gIGc5LmFuY2hvcl9jdHJsKClcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBtYXkgaGF2ZSBjdHJsLmFuY2hvcl9jdHJsLCBhbmQgYW5jaG9yaW5nIGlzIGJhc2ljYWxseSBwdXR0aW5nIGluc2lkZSwgYnV0IGl0IHNldHMgaXQgYXMgYmVpbmdcclxuICAgICAgICAgICAgICAgIC8vICAnYW5jaG9yZWQnLlxyXG5cclxuICAgICAgICAgICAgICAgIGc5LmFuY2hvcl9jdHJsKGN0cmwsIHpvbmUpO1xyXG5cclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBmd3RuID0gZncuX190eXBlX25hbWU7XHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2Z3dG4gJyArIGZ3dG4pO1xyXG5cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8vIEVuZGluZyBhIGNvbnRyb2wgZHJhZy5cclxuICAgIC8vICBJZiB3ZSBhcmUgdG8gZG9jayB0aGUgY29udHJvbCBzb21ld2hlcmUsIHdlIGhhdmUgc29tZSBkb2NraW5nIGNvZGUgdGhhdCBkb2VzIHRoaXMgdGhhdCBjYW4gYmUgY2FsbGVkIHNlcGFyYXRlbHkgZnJvbSB0aGVcclxuICAgIC8vICBldmVudC5cclxuXHJcblxyXG4gICAgLy8gbW9yZSB0aGFuIG5vdGlmeSwgdGhpcyBkb2VzIHNvbWUgVUkgdG9vLlxyXG4gICAgJ2JlZ2luX2RyYWdfc2VsZWN0aW9uX3Njb3BlJzogZnVuY3Rpb24oZV9iZWdpbiwgc2VsZWN0aW9uX3Njb3BlKSB7XHJcblxyXG4gICAgICAgIC8vIGRyYWcgYmVnaW4gZXZlbnQsIHRoZW4gd2hhdCB3ZSBhcmUgZHJhZ2dpbmcuXHJcbiAgICAgICAgLy8gIHdlIGNvdWxkIGJlIGRyYWdnaW5nIGEgc2VsZWN0aW9uIHNjb3BlXHJcbiAgICAgICAgLy8gIGp1c3QgYSBzaW5nbGUgY29udHJvbFxyXG4gICAgICAgIC8vICBhIGNvcHkgb2YgYSBjb250cm9sLlxyXG5cclxuICAgICAgICAvLyBnb2luZyBmb3Igc29tZSBzcGVjaWZpYyBuYW1lcyB0byBiZWdpbiB3aXRoIG1heSBoZWxwLlxyXG5cclxuICAgICAgICAvLyByZW5hbWUgdGhpcyBiZWdpbl9zZWxlY3Rpb25fc2NvcGVfZHJhZ1xyXG5cclxuXHJcblxyXG5cclxuXHJcbiAgICAgICAgLy8gZGlmZmVyZW50IGRyYWcgbW9kZXMuLi5cclxuXHJcbiAgICAgICAgLy8gIGRyYWctc2hhbGxvdy1jb3B5XHJcbiAgICAgICAgLy8gIGRyYWctY3RybFxyXG5cclxuICAgICAgICAvLyBkcmFnLXNoYWxsb3ctY29weS1iZWdpblxyXG5cclxuICAgICAgICAvLyBJIHRoaW5rIGF3YXJlbmVzcyBvZiB0aGUgZHJhZyBtb2RlIHdpbGwgaGVscC5cclxuXHJcbiAgICAgICAgLy8gVGhlIHNlbGVjdGlvbiBzY29wZSBtYXkgbm90IGJlIHJlbGV2YW50IHdoZW4gZHJhZ2dpbmcgYSB3aW5kb3cuXHJcbiAgICAgICAgLy8gIEhvd2V2ZXIsIHdlIGNvdWxkIGNvdW50IG9uZSBpdGVtIGFzIGJlaW5nIHNlbGVjdGVkIGluIHRoZSBkcmFnP1xyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbiAgICAgICAgY29uc29sZS5sb2coJ3BhZ2UgY29udGV4dCBkcmFnIHNlbGVjdGlvbl9zY29wZSAnICsgc2VsZWN0aW9uX3Njb3BlKTtcclxuXHJcbiAgICAgICAgdmFyIG1hcF9zZWxlY3RlZF9jb250cm9scyA9IHNlbGVjdGlvbl9zY29wZS5tYXBfc2VsZWN0ZWRfY29udHJvbHM7XHJcbiAgICAgICAgLy9jb25zb2xlLmxvZygnbWFwX3NlbGVjdGVkX2NvbnRyb2xzICcgKyBzdHJpbmdpZnkobWFwX3NlbGVjdGVkX2NvbnRyb2xzKSk7XHJcblxyXG4gICAgICAgIC8vIHRydWUga2V5cy4uLlxyXG5cclxuICAgICAgICB2YXIgYXJyX3NlbGVjdGVkID0ganNndWkudHJ1ZV92YWxzKG1hcF9zZWxlY3RlZF9jb250cm9scyk7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ2Fycl9zZWxlY3RlZC5sZW5ndGggJyArIGFycl9zZWxlY3RlZC5sZW5ndGgpO1xyXG5cclxuICAgICAgICAvLyBtYWtlIHNoYWxsb3cgY29waWVzIG9mIHRoZXNlIHNlbGVjdGVkIGNvbnRyb2xzLlxyXG5cclxuICAgICAgICB2YXIgc2hhbGxvd19jb3BpZXNfc2VsZWN0ZWQgPSBqc2d1aS5zaGFsbG93X2NvcHkoYXJyX3NlbGVjdGVkKTtcclxuXHJcblxyXG4gICAgICAgIHRoaXMuZHJhZ19zZWxlY3RlZCA9IGFycl9zZWxlY3RlZDtcclxuXHJcbiAgICAgICAgdmFyIGN0cmxfYWJzID0gdGhpcy5tYWtlKENvbnRyb2woe1xyXG5cclxuICAgICAgICB9KSk7XHJcblxyXG4gICAgICAgIGN0cmxfYWJzLmFkZChzaGFsbG93X2NvcGllc19zZWxlY3RlZCk7XHJcblxyXG4gICAgICAgIHZhciBzY3JlZW5YID0gZV9iZWdpbi5zY3JlZW5YO1xyXG5cclxuICAgICAgICAvL2NvbnNvbGUubG9nKCdzY3JlZW5YICcgKyBzY3JlZW5YKTtcclxuICAgICAgICB2YXIgc2NyZWVuWSA9IGVfYmVnaW4uc2NyZWVuWTtcclxuXHJcbiAgICAgICAgdmFyIGNsaWVudFggPSBlX2JlZ2luLmNsaWVudFg7XHJcbiAgICAgICAgdmFyIGNsaWVudFkgPSBlX2JlZ2luLmNsaWVudFk7XHJcblxyXG5cclxuICAgICAgICAvL2N0cmxfYWJzLnNldCgnZG9tLmF0dHJpYnV0ZXMuc3R5bGUucG9zaXRpb24nLCAnYWJzb2x1dGUnKTtcclxuICAgICAgICAvL2N0cmxfYWJzLnNldCgnZG9tLmF0dHJpYnV0ZXMuc3R5bGUuaGVpZ2h0JywgJzIwMHB4Jyk7XHJcbiAgICAgICAgLy9jdHJsX2Ficy5zZXQoJ2RvbS5hdHRyaWJ1dGVzLnN0eWxlLndpZHRoJywgJzMyMHB4Jyk7XHJcbiAgICAgICAgLy9jdHJsX2Ficy5zZXQoJ2RvbS5hdHRyaWJ1dGVzLnN0eWxlLmJhY2tncm91bmQtY29sb3InLCAnI0FCQ0RFRicpO1xyXG5cclxuICAgICAgICAvLyBDb3VsZCBzZXQgaXRzIGNsYXNzIG9yIGhhdmUgYmV0dGVyIHdheSBvZiBkb2luZyBhbiBpbmxpbmUgc3R5bGUuXHJcblxyXG4gICAgICAgIGN0cmxfYWJzLnNldCgnZG9tLmF0dHJpYnV0ZXMuc3R5bGUnLCAncG9zaXRpb246IGFic29sdXRlOyBsZWZ0OiAnICsgY2xpZW50WCArICdweDsgdG9wOicgKyBjbGllbnRZICsgJ3B4OyBoZWlnaHQ6IDIwMHB4OyB3aWR0aDogMzIwcHg7IGJhY2tncm91bmQtY29sb3I6ICNFRUVFRUUnKTtcclxuICAgICAgICB2YXIgaHRtbCA9IGN0cmxfYWJzLmFsbF9odG1sX3JlbmRlcigpO1xyXG5cclxuICAgICAgICB2YXIgZWxfY3RyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgZWxfY3RyLmlubmVySFRNTCA9IGh0bWw7XHJcblxyXG4gICAgICAgIHZhciBlbF9hYnMgPSBlbF9jdHIuY2hpbGROb2Rlc1swXTtcclxuXHJcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChlbF9hYnMpO1xyXG5cclxuICAgICAgICBjdHJsX2Ficy5zZXQoJ2VsJywgZWxfYWJzKTtcclxuXHJcbiAgICAgICAgLy8gd2l0aGluIHRoZSBjb250ZXh0LCB3ZSBjYW4gbWFrZSBuZXcgY29udHJvbHMgYW5kIHB1dCB0aGVtIGluIHRoZSBkb2N1bWVudC5cclxuICAgICAgICAvLyBhbiBhYnNvbHV0ZWx5IHBvc2l0aW9uZWQgZGl2LlxyXG5cclxuICAgICAgICB0aGlzLmN0cmxfYWJzID0gY3RybF9hYnM7XHJcblxyXG5cclxuICAgICAgICAvL3Rocm93ICdzdG9wJztcclxuICAgIH0sXHJcblxyXG5cclxuXHJcbiAgICAnbW92ZV9kcmFnX3NlbGVjdGlvbl9zY29wZSc6IGZ1bmN0aW9uKGVfbW92ZSkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdwYWdlIGNvbnRleHQgbW92ZV9kcmFnX3NlbGVjdGlvbl9zY29wZScpO1xyXG5cclxuICAgICAgICAvLyBEb24ndCB3YW50IHRoaXMgdG8gYmUgdGhlIGNhc2Ugd2l0aCBhbGwgZHJhZyBtb3Zlcy4uLlxyXG4gICAgICAgIC8vICBXZSBtYXkgYmUgbW92aW5nIHRoZSBhY3R1YWwgaXRlbS5cclxuXHJcblxyXG5cclxuXHJcbiAgICAgICAgdmFyIGNsaWVudFggPSBlX21vdmUuY2xpZW50WDtcclxuICAgICAgICB2YXIgY2xpZW50WSA9IGVfbW92ZS5jbGllbnRZO1xyXG5cclxuICAgICAgICAvLyBkZWZpbml0ZWx5IHdvdWxkIGJlIHVzZWZ1bCB0byBoYXZlIHRoZSBhYnN0cmFjdGlvbiB0aGF0IGNvdmVycyBpbmRpdmlkdWFsIHN0eWxlIHByb3BlcnRpZXMuXHJcbiAgICAgICAgdmFyIHN0eWxlID0gJ3Bvc2l0aW9uOiBhYnNvbHV0ZTsgbGVmdDogJyArIGNsaWVudFggKyAncHg7IHRvcDonICsgY2xpZW50WSArICdweDsgaGVpZ2h0OiAyMDBweDsgd2lkdGg6IDMyMHB4OyBiYWNrZ3JvdW5kLWNvbG9yOiAjRUVFRUVFJ1xyXG4gICAgICAgIC8vY29uc29sZS5sb2coJ3N0eWxlICcgKyBzdHlsZSk7XHJcbiAgICAgICAgdmFyIGVsID0gdGhpcy5jdHJsX2Ficy5nZXQoJ2VsJyk7XHJcbiAgICAgICAgLy9jb25zb2xlLmxvZygnZWwgJyArIGVsKTtcclxuICAgICAgICBlbC5zdHlsZS5jc3NUZXh0ID0gc3R5bGU7XHJcblxyXG5cclxuICAgIH0sXHJcbiAgICAnZW5kX2RyYWdfc2VsZWN0aW9uX3Njb3BlJzogZnVuY3Rpb24oZV9lbmQpIHtcclxuICAgICAgICBpZiAodGhpcy5jdHJsX2Ficykge1xyXG4gICAgICAgICAgICB0aGlzLmN0cmxfYWJzLnJlbW92ZSgpO1xyXG4gICAgICAgICAgICB0aGlzLmN0cmxfYWJzID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgICdlbnN1cmVfZG9ja19wbGFjZWhvbGRlcic6IGZ1bmN0aW9uKHBvcykge1xyXG4gICAgICAgIC8vY29uc29sZS5sb2coJ1BhZ2UgQ29udGV4dCBlbnN1cmVfZG9ja19wbGFjZWhvbGRlciAnICsgcG9zKTtcclxuXHJcbiAgICAgICAgdmFyIGZ3ID0gdGhpcy5mdWxsX3dpbmRvdztcclxuXHJcbiAgICAgICAgaWYgKGZ3KSB7XHJcbiAgICAgICAgICAgIGZ3LmVuc3VyZV9kb2NrX3BsYWNlaG9sZGVyKHBvcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFBhZ2VfQ29udGV4dDtcclxuXHRcdC8vcmV0dXJuIFBhZ2VfQ29udGV4dDtcclxuXHQvL31cclxuLy8pO1xyXG4iLCIvLyBvYmplY3Qgdmlld2VyXG5cbi8qXG5pZiAodHlwZW9mIGRlZmluZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBkZWZpbmUgPSByZXF1aXJlKCdhbWRlZmluZScpKG1vZHVsZSk7XG59XG4qL1xuXG5cbi8vIE5lZWQgdG8gc29ydCBvdXQgaG93IHRoZSBkZXBlbmRlbmNpZXMgbGluay5cblxuXG4vLyBEb2VzIGh0bWwgcmVxdWlyZSByZXNvdXJjZT9cbi8vIGh0bWwtZW5oIHJlcXVpcmUgcmVzb3VyY2U/XG5cbi8vIFJlc291cmNlIHNob3VsZCBiZSBhIHBhcnQgb2YgdGhlIGh0bWwgY2xpZW50LCBidXQgbm90IHRoZSBodG1sIHN5c3RlbSBpbiBnZW5lcmFsLlxuXG4vL3Rocm93ICdzdG9wJztcblxuLy8gTWF5IGJlIGEgY2lyY3VsYXIgcmVmZXJlbmNlIGhlcmUuXG4vLyAgV2l0aGluIG9uZSBvZiB0aGUgbW9kdWxlcyB0aGF0IGdldHMgbG9hZGVkLlxuXG5cbi8vIG5vdCBzbyBzdXJlIHRoaXMgbmVlZHMgdG8gaW5jbHVzZSB0aGUgcGFnZSBjb250ZXh0LlxuXG52YXIganNndWkgPSByZXF1aXJlKCcuL2pzZ3VpLWh0bWwtZW5oJyk7XG5cbi8vY29uc29sZS5sb2coJ2pzZ3VpJywganNndWkpO1xuLy90aHJvdyAnc3RvcDInO1xudmFyIFBhZ2VfQ29udGV4dCA9IHJlcXVpcmUoJy4vanNndWktaHRtbC1wYWdlLWNvbnRleHQnKTtcblxuLy8gTm90IHVzaW5nIHRoZSBvbGQgUGFnZV9Db250cm9sIGF0IHRoZSBtb21lbnQuXG4vLyAgSXQgc2VlbXMgYXMgaWYgdGhlIGRvY2tpbmcgYmVoYXZpb3VyIHdvdWxkIGJldHRlciBiZSBtYWRlIHNvbWUga2luZCBvZiBhZGRpbiAvIG1peGluLlxuXG5cblxuLy92YXIgUGFnZV9Db250cm9sID0gcmVxdWlyZSgnLi9jb250cm9scy9wYWdlL3BhZ2UtY29udHJvbCcpO1xuXG5cbi8vZGVmaW5lKFtcIi4vanNndWktaHRtbC1lbmhcIiwgXCIuL2pzZ3VpLWh0bWwtcGFnZS1jb250ZXh0XCIsIFwiLi9jb250cm9scy9wYWdlL3BhZ2UtY29udHJvbFwiXSxcblx0Ly9mdW5jdGlvbihqc2d1aSwgUGFnZV9Db250ZXh0LCBQYWdlX0NvbnRyb2wpIHtcblx0XHRcbnZhciBzdHJpbmdpZnkgPSBqc2d1aS5zdHJpbmdpZnksIGVhY2ggPSBqc2d1aS5lYWNoLCB0b2YgPSBqc2d1aS50b2YsIGlzX2RlZmluZWQgPSBqc2d1aS5pc19kZWZpbmVkO1xudmFyIENvbnRyb2wgPSBqc2d1aS5Db250cm9sO1xuXG52YXIgZnAgPSBqc2d1aS5mcDtcbnZhciBncm91cCA9IGpzZ3VpLmdyb3VwO1xuXG4vLyBDbGllbnQtc2lkZSByZXNvdXJjZSBwb29sLi4uXG4vLyAgVGhhdCB3b3VsZCBiZSB2ZXJ5IHVzZWZ1bCBmb3IgYWNjZXNzaW5nIHJlc291cmNlcyBvbiB0aGUgc2VydmVyLlxuLy8gICBXb3VsZCBoYXZlIHRoZSBzZXJ2ZXIncyBVUkwsIGFuZCBhIG1hcCAobWF5YmUpIG9mIHdoYXQgcmVzb3VyY2VzIGFyZSBvbiB0aGUgc2VydmVyLlxuXG4vLyBUaGlzIHdvdWxkIGJlIHNvbWUga2luZCBvZiByZXF1ZXN0IGJyb2tlci5cbi8vICBJdCBtYXkgYXNrIHRoZSBzZXJ2ZXIgd2hhdCByZXNvdXJjZXMgYXJlIG9uIGl0LCBidXQgdGhlIHNlcnZlciBjb3VsZCBzZW5kIHRoaXMgaW5mbyAobWF5YmUganVzdCBiYXNpYyBpbmZvKVxuLy8gIGFsb25nIHdoZW4gdGhlIGNsaWVudC1zaWRlIHJlc291cmNlIHBvb2wgaXMgc3RhcnRlZCB1cC5cblxuLy8gRGVsaXZlciB0aGF0IHRvIGpzZ3VpLWh0bWwtY2xpZW50P1xuXG5cbi8vY29uc29sZS5sb2coJ1BhZ2VfQ29udGV4dCcsIFBhZ2VfQ29udGV4dCk7XG4vL3Rocm93ICdzdG9wJztcbi8vdGhyb3cgJ3N0b3AnO1xuXG5qc2d1aS5QYWdlX0NvbnRleHQgPSBQYWdlX0NvbnRleHQ7XG4vL2pzZ3VpLlBhZ2VfQ29udHJvbCA9IFBhZ2VfQ29udHJvbDtcbi8vIHRoaXMgaXMgdGhlIGVuaGFuY2VkIEhUTUwgbW9kdWxlLlxuXG5cbi8vcmV0dXJuIGpzZ3VpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGpzZ3VpO1xuXHQvL31cbi8vKTsiLCIvKipcclxuICogQ3JlYXRlZCBieSBKYW1lcyBvbiAwNy8wMi8yMDE1LlxyXG4gKi9cclxuXHJcbnZhciBqc2d1aSA9IHJlcXVpcmUoJy4vanNndWktaHRtbC1jb3JlJyk7XHJcbnZhciBlYWNoID0ganNndWkuZWFjO1xyXG52YXIgdG9mID0ganNndWkudG9mO1xyXG5cclxudmFyIFNlbGVjdGlvbl9TY29wZSA9IGpzZ3VpLkRhdGFfT2JqZWN0LmV4dGVuZCh7XHJcbi8vdmFyIFNlbGVjdGlvbl9TY29wZSA9IGpzZ3VpLkNsYXNzLmV4dGVuZCh7XHJcbiAgICAnaW5pdCc6IGZ1bmN0aW9uKHNwZWMpIHtcclxuICAgICAgICAvLyBBIHNlbGVjdGlvbiBzY29wZSBiZWxvbmdzIHRvIGEgY29udGV4dFxyXG4gICAgICAgIC8vICBzaG91bGQgZG9cclxuICAgICAgICAvLyBoYXMgaXRzIGNvbnRyb2wuXHJcbiAgICAgICAgLy8gdmFyaW91cyBjb250cm9scyBwb2ludCB0byBpdC5cclxuICAgICAgICAvLyBoYXMgdmFyaW91cyBtZXRob2RzIHRvIGRvIHdpdGggc2VsZWN0aW5nIGFuZCBzZWxlY3Rpbmcgb2JqZWN0c1xyXG5cclxuXHJcbiAgICAgICAgLy8gQ291bGQgcHJvYmFibHkgZG8gdGhlc2UgYXMgZmllbGRzLlxyXG5cclxuICAgICAgICAvLyBTZWxlY3Rpb24gc2NvcGUgc2hvdWxkIGFsc28ga2VlcCB0cmFjayBvZiBpdHMgY29udGV4dCBhbmQgaXRzIGlkLlxyXG4gICAgICAgIGlmIChzcGVjLmNvbnRleHQpIHRoaXMuY29udGV4dCA9IHNwZWMuY29udGV4dDtcclxuICAgICAgICBpZiAodHlwZW9mIHNwZWMuaWQgIT09ICd1bmRlZmluZWQnKSB0aGlzLmlzID0gc3BlYy5pZDtcclxuXHJcblxyXG4gICAgICAgIGlmIChzcGVjLmNvbnRyb2wpIHRoaXMuY29udHJvbCA9IHNwZWMuY29udHJvbDtcclxuICAgICAgICAvLyBOZWVkcyB0byBiZSBhIGxpc3QgLyBtYXAgb2YgYWxsIGNvbnRyb2xzIHRoYXQgYXJlIHNlbGVjdGVkLlxyXG4gICAgICAgIC8vIG1hcCBvZiBzZWxlY3RlZCBjb250cm9scyBieSBpZD9cclxuICAgICAgICAvLyAgYWxzbyBuZWVkIHRvIGJlIGFibGUgdG8gZ28gdGhyb3VnaCB0aGUgbGlzdCBvZiBjb250cm9scy5cclxuICAgICAgICB0aGlzLm1hcF9zZWxlY3RlZF9jb250cm9scyA9IHt9O1xyXG4gICAgICAgIC8vIHNldCB0aGUgaXRlbXMgYnkgdGhlaXIgaWQgdG8gcG9pbnQgdG8gdGhlIGNvbnRyb2wuXHJcbiAgICAgICAgLy8gIHRoZSBjb250cm9sIHdpbGwga25vdyBpdHMgaW5kZXggd2l0aGluIGl0cyBwYXJlbnQsIGNhbiBsb29rIHVwIG1vcmUgaW5mbyB0aGVyZS5cclxuICAgIH0sXHJcbiAgICAnc2VsZWN0X29ubHknOiBmdW5jdGlvbihjdHJsKSB7XHJcbiAgICAgICAgLy9jb25zb2xlLmxvZygnU2VsZWN0aW9uX1Njb3BlIHNlbGVjdF9vbmx5ICcgKyBjdHJsLl9pZCgpKTtcclxuXHJcbiAgICAgICAgLy8gcmVtb3ZlIHRoZSBzZWxlY3RlZCBjbGFzcyBmcm9tIGFsbCB0aGF0IGFyZSBjdXJyZW50bHkgc2VsZWN0ZWQgKGV4Y2VwdCB0aGUgdGFyZ2V0IGN0cmwpLlxyXG4gICAgICAgIC8vY29uc29sZS5sb2coJ3RoaXMubWFwX3NlbGVjdGVkX2NvbnRyb2xzICcsIHRoaXMubWFwX3NlbGVjdGVkX2NvbnRyb2xzKTtcclxuXHJcblxyXG4gICAgICAgIC8vIEFuZCBuZWVkIHRvIHRyaWdnZXIgZGVzZWxlY3Qgd2hlcmUgYXBwcm9wcmlhdGUuXHJcblxyXG4gICAgICAgIC8vIEJ1dCBub3QgaWYgdGhlIGNvbnRyb2wgd2FzIHByZXZpb3VzbHkgc2VsZWN0ZWQuXHJcbiAgICAgICAgdmFyIGN1cnJlbnRseV9zZWxlY3RlZDtcclxuICAgICAgICB2YXIgY291bnRfZGVzZWxlY3RlZCA9IDA7XHJcblxyXG4gICAgICAgIHZhciBzZWxlY3RlZDtcclxuICAgICAgICBlYWNoKHRoaXMubWFwX3NlbGVjdGVkX2NvbnRyb2xzLCBmdW5jdGlvbih2LCBpKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAodiAmJiB2ICE9PSBjdHJsKSB7XHJcbiAgICAgICAgICAgICAgICBzZWxlY3RlZCA9IHYuZ2V0KCdzZWxlY3RlZCcpLnZhbHVlKCk7XHJcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdzZWxlY3RlZCcsIHNlbGVjdGVkKTtcclxuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3RvZiBzZWxlY3RlZCcsIHRvZihzZWxlY3RlZCkpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChzZWxlY3RlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHYuc2V0KCdzZWxlY3RlZCcsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICB2LnJlbW92ZV9jbGFzcygnc2VsZWN0ZWQnKTtcclxuICAgICAgICAgICAgICAgICAgICB2LnRyaWdnZXIoJ2Rlc2VsZWN0Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgY291bnRfZGVzZWxlY3RlZCsrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3Nob3VsZCBoYXZlIGRlc2VsY3RlZCAnICsgdi5faWQoKSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodiA9PT0gY3RybCkge1xyXG4gICAgICAgICAgICAgIGN1cnJlbnRseV9zZWxlY3RlZCA9IHYuZ2V0KCdzZWxlY3RlZCcpLnZhbHVlKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHRoaXMubWFwX3NlbGVjdGVkX2NvbnRyb2xzID0ge307XHJcblxyXG4gICAgICAgIHRoaXMubWFwX3NlbGVjdGVkX2NvbnRyb2xzW2N0cmwuX2lkKCldID0gY3RybDtcclxuXHJcbiAgICAgICAgLy8gYW5kIHRoZW4gdGVsbCB0aGUgY29udHJvbCB0aGF0IGl0J3Mgc2VsZWN0ZWQuXHJcblxyXG4gICAgICAgIC8vIGNvdWxkIHBvc3NpYmx5IHNldCBhIENTUyBmbGFnLlxyXG5cclxuICAgICAgICBpZiAoIWN1cnJlbnRseV9zZWxlY3RlZCkge1xyXG4gICAgICAgICAgY3RybC5zZXQoJ3NlbGVjdGVkJywgdHJ1ZSk7XHJcbiAgICAgICAgICBjdHJsLnRyaWdnZXIoJ3NlbGVjdCcpO1xyXG5cclxuICAgICAgICAgIGN0cmwuYWRkX2NsYXNzKCdzZWxlY3RlZCcpO1xyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIGlmIChjb3VudF9kZXNlbGVjdGVkID4gMCAmISBjdXJyZW50bHlfc2VsZWN0ZWQpIHtcclxuICAgICAgICAgIHRoaXMudHJpZ2dlcignY2hhbmdlJyk7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcblxyXG5cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8vIGRlc2VsZWN0IGNvbnRyb2xzIGludGVybmFsIHRvIGEgY29udHJvbC5cclxuXHJcbiAgICAvLyBXaGVuIHNlbGVjdGluZyBhIGNvbnRyb2wsIHdlIHdhbnQgdG8gbWFrZSBpdCBzbyB0aGF0IGNvbnRyb2xzIGluc2lkZSBpdCwgaW4gdGhlIHNhbWUgc2VsZWN0aW9uIGNvbnRleHQgYXJlIG5vdCBzZWxlY3RlZC5cclxuICAgIC8vICBUaGUgU2VsZWN0aW9uIFNjb3BlIGRvZXMgYSBmYWlyIGJpdCBvZiB0aGUgbWFuYWdlbWVudCBvZiB0aGUgc2VsZWN0aW9ucy5cclxuXHJcbiAgICAnZGVzZWxlY3RfY3RybF9jb250ZW50JzogZnVuY3Rpb24oY3RybCkge1xyXG4gICAgICAgIHZhciBjcyA9IGN0cmwuZ2V0KCdzZWxlY3Rpb25fc2NvcGUnKTtcclxuICAgICAgICB2YXIgbXNjID0gdGhpcy5tYXBfc2VsZWN0ZWRfY29udHJvbHM7XHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgIGN0cmwuZ2V0KCdjb250ZW50JykuZWFjaChmdW5jdGlvbihpLCB2KSB7XHJcbiAgICAgICAgICAgIHZhciB0diA9IHRvZih2KTtcclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygndHYgJyArIHR2KTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0diA9PSAnY29udHJvbCcpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBUcmlnZ2VyICdkZXNlbGVjdCcgZXZlbnRzIHdoZW4gc2VsZWN0aW9uIGNoYW5nZXMgdG8gbmVnaXRpdmVcclxuXHJcbiAgICAgICAgICAgICAgICB2LnJlbW92ZV9jbGFzcygnc2VsZWN0ZWQnKTtcclxuICAgICAgICAgICAgICAgIHYuc2V0KCdzZWxlY3RlZCcsIGZhbHNlKTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgaWQgPSB2Ll9pZCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG1zY1tpZF0pIG1zY1tpZF0gPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGF0LmRlc2VsZWN0X2N0cmxfY29udGVudCh2KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLy9jb25zb2xlLmxvZygnbXNjICcsIG1zYyk7XHJcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdjaGFuZ2UnKTtcclxuICAgICAgICAvL3Rocm93ICdzdG9wJztcclxuICAgIH0sXHJcblxyXG5cclxuXHJcbiAgICAnc2VsZWN0X3RvZ2dsZSc6IGZ1bmN0aW9uKGN0cmwpIHtcclxuICAgICAgICAvL2NvbnNvbGUubG9nKCcnKTtcclxuICAgICAgICAvL2NvbnNvbGUubG9nKCdzZWxlY3RfdG9nZ2xlJyk7XHJcbiAgICAgICAgdmFyIHNlbCA9IGN0cmwuZ2V0KCdzZWxlY3RlZCcpLnZhbHVlKCk7XHJcbiAgICAgICAgLy9jb25zb2xlLmxvZygndG9mKHNlbCkgJyArIHRvZihzZWwpKTtcclxuXHJcbiAgICAgICAgdmFyIG1zYyA9IHRoaXMubWFwX3NlbGVjdGVkX2NvbnRyb2xzO1xyXG4gICAgICAgIHZhciBpZCA9IGN0cmwuX2lkKCk7XHJcbiAgICAgICAgaWYgKCFzZWwpIHtcclxuXHJcblxyXG4gICAgICAgICAgICB2YXIgc2VsX2FuYyA9IGN0cmwuZmluZF9zZWxlY3RlZF9hbmNlc3Rvcl9pbl9zY29wZSgpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHNlbF9hbmMpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCcxKSBub3Qgc2VsZWN0aW5nIGJlY2F1c2UgYSBzZWxlY3RlZCBhbmNlc3RvciBpbiB0aGUgc2VsZWN0aW9uIHNjb3BlIGhhcyBiZWVuIGZvdW5kLicpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuXHJcbiAgICAgICAgICAgICAgICBjdHJsLnNldCgnc2VsZWN0ZWQnLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIC8vIENoZWNrIGZvciBhIHNlbGVjdGVkIGFuY2VzdG9yIGNvbnRyb2wgaW4gdGhlIHNjb3BlLlxyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuZGVzZWxlY3RfY3RybF9jb250ZW50KGN0cmwpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vICBjYW4gdHJ5IGFuIGl0ZXJhdGVfYW5jZXN0b3JzIGZ1bmN0aW9uLlxyXG5cclxuICAgICAgICAgICAgICAgIC8vICBpdGVyYXRlX2FuY2VzdG9yc19pbl9zZWxlY3Rpb25fc2NvcGVcclxuICAgICAgICAgICAgICAgIC8vICAgbG9va2luZyBmb3Igc2VsZWN0ZWQgYW5jZXN0b3IuXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gZmluZF9zZWxlY3RlZF9hbmNlc3Rvcl9pbl9zY29wZVxyXG5cclxuICAgICAgICAgICAgICAgIGN0cmwuYWRkX2NsYXNzKCdzZWxlY3RlZCcpO1xyXG4gICAgICAgICAgICAgICAgbXNjW2lkXSA9IGN0cmw7XHJcbiAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciB0c2VsID0gdG9mKHNlbCk7XHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3RzZWwgJyArICh0c2VsKSlcclxuICAgICAgICAgICAgaWYgKHRzZWwgPT0gJ2RhdGFfdmFsdWUnKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdmFsID0gc2VsLmdldCgpO1xyXG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygndmFsICcgKyB2YWwpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGN0cmwucmVtb3ZlX2NsYXNzKCdzZWxlY3RlZCcpO1xyXG4gICAgICAgICAgICAgICAgICAgIGN0cmwuc2V0KCdzZWxlY3RlZCcsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICBtc2NbaWRdID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzZWxfYW5jID0gY3RybC5maW5kX3NlbGVjdGVkX2FuY2VzdG9yX2luX3Njb3BlKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxfYW5jKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCcyKSBub3Qgc2VsZWN0aW5nIGJlY2F1c2UgYSBzZWxlY3RlZCBhbmNlc3RvciBpbiB0aGUgc2VsZWN0aW9uIHNjb3BlIGhhcyBiZWVuIGZvdW5kLicpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwuc2V0KCdzZWxlY3RlZCcsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBmb3IgYSBzZWxlY3RlZCBhbmNlc3RvciBjb250cm9sIGluIHRoZSBzY29wZS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZXNlbGVjdF9jdHJsX2NvbnRlbnQoY3RybCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICBjYW4gdHJ5IGFuIGl0ZXJhdGVfYW5jZXN0b3JzIGZ1bmN0aW9uLlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gIGl0ZXJhdGVfYW5jZXN0b3JzX2luX3NlbGVjdGlvbl9zY29wZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgIGxvb2tpbmcgZm9yIHNlbGVjdGVkIGFuY2VzdG9yLlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZmluZF9zZWxlY3RlZF9hbmNlc3Rvcl9pbl9zY29wZVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5hZGRfY2xhc3MoJ3NlbGVjdGVkJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1zY1tpZF0gPSBjdHJsO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRzZWwgPT0gJ2Jvb2xlYW4nKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHNlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGN0cmwucmVtb3ZlX2NsYXNzKCdzZWxlY3RlZCcpO1xyXG4gICAgICAgICAgICAgICAgICAgIGN0cmwuc2V0KCdzZWxlY3RlZCcsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICBtc2NbaWRdID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzZWxfYW5jID0gY3RybC5maW5kX3NlbGVjdGVkX2FuY2VzdG9yX2luX3Njb3BlKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxfYW5jKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCcyKSBub3Qgc2VsZWN0aW5nIGJlY2F1c2UgYSBzZWxlY3RlZCBhbmNlc3RvciBpbiB0aGUgc2VsZWN0aW9uIHNjb3BlIGhhcyBiZWVuIGZvdW5kLicpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVzZWxlY3RfY3RybF9jb250ZW50KGN0cmwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHJsLnNldCgnc2VsZWN0ZWQnLCB0cnVlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGZvciBhIHNlbGVjdGVkIGFuY2VzdG9yIGNvbnRyb2wgaW4gdGhlIHNjb3BlLlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gIGNhbiB0cnkgYW4gaXRlcmF0ZV9hbmNlc3RvcnMgZnVuY3Rpb24uXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgaXRlcmF0ZV9hbmNlc3RvcnNfaW5fc2VsZWN0aW9uX3Njb3BlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgbG9va2luZyBmb3Igc2VsZWN0ZWQgYW5jZXN0b3IuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmaW5kX3NlbGVjdGVkX2FuY2VzdG9yX2luX3Njb3BlXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHJsLmFkZF9jbGFzcygnc2VsZWN0ZWQnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbXNjW2lkXSA9IGN0cmw7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnRyaWdnZXIoJ2NoYW5nZScpO1xyXG4gICAgICAgIC8vdGhyb3cgJ3N0b3AnO1xyXG5cclxuICAgIH1cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNlbGVjdGlvbl9TY29wZTtcclxuIl19
